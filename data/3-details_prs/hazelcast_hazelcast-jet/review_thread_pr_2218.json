{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5NTE5NzU5", "number": 2218, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNzo0OTowN1rOD37lWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOTo1MjoxNVrOD3-Qtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTc0NDkxOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/json/JsonUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNzo0OTowN1rOGOdu8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNzoyNjo1OFrOGQdbhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgyMDQwMA==", "bodyText": "This is problematic, because it will re-parse the JSON string every time you fetch one key-value pair from it. Now that I have used Jackson jr a bit too, I think that we don't actually need these methods (I mean all methods that return primitives, arrays, lists, sub-maps), it's would be enough to keep the one that returns the full map. Sorry for having lead you in the wrong direction initially.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2218#discussion_r417820400", "createdAt": "2020-04-30T07:49:07Z", "author": {"login": "jbartok"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/json/JsonUtil.java", "diffHunk": "@@ -28,14 +32,67 @@ private JsonUtil() {\n     /**\n      * Converts a JSON string to a object of given type.\n      */\n-    public static <T> T map(Class<T> type, String jsonString) {\n+    public static <T> T parse(Class<T> type, String jsonString) {\n         return uncheckCall(() -> JSON.std.beanFrom(type, jsonString));\n     }\n \n+    /**\n+     * Converts a JSON string to a {@link Map}.\n+     */\n+    public static Map<String, Object> parse(String jsonString) {\n+        return uncheckCall(() -> JSON.std.with(Feature.READ_ONLY).mapFrom(jsonString));\n+    }\n+\n+    /**\n+     * Extracts a string value from given JSON string.\n+     */\n+    public static String getString(String jsonString, String key) {\n+        return (String) parse(jsonString).get(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b2759ec3c4be6242e52671363399c96c98deef2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwMTg2Ng==", "bodyText": "yes you are right but if a user wants only a single field from a json string these may come handy, saves you a lot of boilerplate code and type casting. Maybe we should mention that each call will parse the json again.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2218#discussion_r419901866", "createdAt": "2020-05-05T07:01:57Z", "author": {"login": "gurbuzali"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/json/JsonUtil.java", "diffHunk": "@@ -28,14 +32,67 @@ private JsonUtil() {\n     /**\n      * Converts a JSON string to a object of given type.\n      */\n-    public static <T> T map(Class<T> type, String jsonString) {\n+    public static <T> T parse(Class<T> type, String jsonString) {\n         return uncheckCall(() -> JSON.std.beanFrom(type, jsonString));\n     }\n \n+    /**\n+     * Converts a JSON string to a {@link Map}.\n+     */\n+    public static Map<String, Object> parse(String jsonString) {\n+        return uncheckCall(() -> JSON.std.with(Feature.READ_ONLY).mapFrom(jsonString));\n+    }\n+\n+    /**\n+     * Extracts a string value from given JSON string.\n+     */\n+    public static String getString(String jsonString, String key) {\n+        return (String) parse(jsonString).get(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgyMDQwMA=="}, "originalCommit": {"oid": "7b2759ec3c4be6242e52671363399c96c98deef2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkxMjU4Mg==", "bodyText": "Makes sense.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2218#discussion_r419912582", "createdAt": "2020-05-05T07:26:58Z", "author": {"login": "jbartok"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/json/JsonUtil.java", "diffHunk": "@@ -28,14 +32,67 @@ private JsonUtil() {\n     /**\n      * Converts a JSON string to a object of given type.\n      */\n-    public static <T> T map(Class<T> type, String jsonString) {\n+    public static <T> T parse(Class<T> type, String jsonString) {\n         return uncheckCall(() -> JSON.std.beanFrom(type, jsonString));\n     }\n \n+    /**\n+     * Converts a JSON string to a {@link Map}.\n+     */\n+    public static Map<String, Object> parse(String jsonString) {\n+        return uncheckCall(() -> JSON.std.with(Feature.READ_ONLY).mapFrom(jsonString));\n+    }\n+\n+    /**\n+     * Extracts a string value from given JSON string.\n+     */\n+    public static String getString(String jsonString, String key) {\n+        return (String) parse(jsonString).get(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgyMDQwMA=="}, "originalCommit": {"oid": "7b2759ec3c4be6242e52671363399c96c98deef2"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTc2NDI4OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/json/JsonUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNzo1NDo1MVrOGOd7Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNzo1NDo1MVrOGOd7Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgyMzUxOA==", "bodyText": "One problem I've come across when using Jackson jr is that I needed annotation support for renaming fields (for example had first_name in JSON and wanted a mapping class field name like firstName so I needed to use @JsonProperty to translate it). To use annotation support I had to use a JSON like JSON.builder().register(JacksonAnnotationExtension.std).build() as opposed to JSON.std to do the mapping. I would not be able to do the same thing with the methods provided by this utility class, as it stands right now.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2218#discussion_r417823518", "createdAt": "2020-04-30T07:54:51Z", "author": {"login": "jbartok"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/json/JsonUtil.java", "diffHunk": "@@ -28,14 +32,67 @@ private JsonUtil() {\n     /**\n      * Converts a JSON string to a object of given type.\n      */\n-    public static <T> T map(Class<T> type, String jsonString) {\n+    public static <T> T parse(Class<T> type, String jsonString) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b2759ec3c4be6242e52671363399c96c98deef2"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDE3ODI3OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/FileSourceBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOTo1MDo0NFrOGOiBpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOTo1MDo0NFrOGOiBpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg5MDcyNw==", "bodyText": "Maybe a JSON manipulation should be inside the JsonUtil class and Jackson jr not be exposed anywhere else?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2218#discussion_r417890727", "createdAt": "2020-04-30T09:50:44Z", "author": {"login": "jbartok"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/FileSourceBuilder.java", "diffHunk": "@@ -161,6 +168,31 @@ public FileSourceBuilder charset(@Nonnull Charset charset) {\n                 SourceProcessors.readFilesP(directory, glob, sharedFileSystem, readFileFn));\n     }\n \n+    /**\n+     * Builds a JSON file {@link BatchSource} with supplied components. The\n+     * source expects a stream of JSON objects as the content of the file.\n+     <p>\n+     * The source does not save any state to snapshot. If the job is restarted,\n+     * it will re-emit all entries.\n+     * <p>\n+     * Any {@code IOException} will cause the job to fail. The files must not\n+     * change while being read; if they do, the behavior is unspecified.\n+     * <p>\n+     * The default local parallelism for this processor is 2 (or 1 if just 1\n+     * CPU is available).\n+     *\n+     */\n+    public <T> BatchSource<T> buildJson(@Nonnull Class<T> type) {\n+        String charsetName = charset.name();\n+        return build(path -> {\n+            InputStreamReader reader = new InputStreamReader(new FileInputStream(path.toFile()), charsetName);\n+            ValueIterator<T> valueIterator = JSON.std.beanSequenceFrom(type, reader);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b86ada6a0c88660cebe4724c19dc97ec979490"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDE4MzU4OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/impl/connector/ReadFilesPTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOTo1MjoxNVrOGOiE7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOTo1MjoxNVrOGOiE7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg5MTU2Ng==", "bodyText": "Maybe use Jackson jr annotation support to get rid of all those getters & setters?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2218#discussion_r417891566", "createdAt": "2020-04-30T09:52:15Z", "author": {"login": "jbartok"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/impl/connector/ReadFilesPTest.java", "diffHunk": "@@ -121,10 +148,78 @@ private Pipeline buildDag(String glob) {\n         return p;\n     }\n \n-    private void finishDirectory(File ... files) {\n+    private Pipeline pipelineJson() {\n+        Pipeline p = Pipeline.create();\n+        p.readFrom(Sources.filesBuilder(directory.getPath())\n+                          .buildJson(TestPerson.class))\n+         .writeTo(Sinks.list(listJson));\n+\n+        return p;\n+    }\n+\n+    private void finishDirectory(File... files) {\n         for (File file : files) {\n             assertTrue(file.delete());\n         }\n         assertTrue(directory.delete());\n     }\n+\n+    public static class TestPerson implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55b86ada6a0c88660cebe4724c19dc97ec979490"}, "originalPosition": 118}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4693, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}