{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5ODEwMjc4", "number": 2654, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzozMzoyOFrOE4KaWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyNjo1OFrOFJtoSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzI2Mjk2OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzozMzoyOFrOHx67gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzozMzoyOFrOHx67gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEwNzc3OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Command(description = \"Starts the SQL console\")\n          \n          \n            \n                @Command(description = \"Starts the SQL shell [BETA]\")", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r522107778", "createdAt": "2020-11-12T13:33:28Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -179,6 +186,57 @@ public void run() {\n         // top-level command, do nothing\n     }\n \n+    @Command(description = \"Starts the SQL console\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d7b141cd0801a048c966b438d42e25f198fb9d"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MjA4MjU2OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNTozOTozMFrOH9hBRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNTozOTozMFrOH9hBRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2NjE4Mg==", "bodyText": "We can use ForkJoinPool.commonPool() here.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r534266182", "createdAt": "2020-12-02T15:39:30Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +766,311 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            final int[] roundBracketsBalance = new int[2];\n+            final int[] squareBracketsBalance = new int[2];\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                // once we reach the cursor, set the\n+                // position of the selected index\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        checkBracketBalance(roundBracketsBalance, currentChar, '(', ')');\n+                        checkBracketBalance(squareBracketsBalance, currentChar, '[', ']');\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            if (squareBracketsBalance[0] != 0 || squareBracketsBalance[1] != 0) {\n+                throw new EOFError(-1, cursor, \"Square brackets balance fails\");\n+            }\n+\n+            if (roundBracketsBalance[0] != 0 || roundBracketsBalance[1] != 0) {\n+                throw new EOFError(-1, cursor, \"Round brackets balance fails\");\n+            }\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private void checkBracketBalance(int[] balance, char actual,\n+                                         char openBracket, char closeBracket) {\n+            if (actual == openBracket) {\n+                balance[0]++;\n+            } else if (actual == closeBracket) {\n+                if (balance[0] > 0) {\n+                    balance[0]--;\n+                } else {\n+                    // closed bracket without open\n+                    balance[1]++;\n+                }\n+            }\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 15;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+\n+        ExecutorService executor\n+                = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0044eb3e054f3444abd44c0cb6a72d096a6843c3"}, "originalPosition": 428}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjc2OTk2OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMToyMDoxMVrOIJU7kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowMzo0NlrOIJ8PZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1MTAyNw==", "bodyText": "it might be nice if these commands worked without the ;. I think it's common elsewhere.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546651027", "createdAt": "2020-12-21T11:20:11Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 603}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTA3Ng==", "bodyText": "I allowed special commands to run without semicolon", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547295076", "createdAt": "2020-12-22T14:03:46Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1MTAyNw=="}, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 603}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjc5NzcwOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMToyOTo0M1rOIJVLrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzoxNjozNFrOIKkccQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1NTE1MQ==", "bodyText": "The line is 106 characters long, which exceeds the traditional size for small terminals of 80 chars. At least it should not be indented.\nTo my taste it's also a bit splashy, something more meek like this would suffice:\n$ ./jet sql\nConnected to Hazelcast Jet 4.4 at 127.0.0.1:5007 (+1 more)\nType 'help' for instructions\nsql>\n\nThe version 4.4 is the cluster version, not client's. The IP is the IP of the 1st member, the +1 more indicates the cluster size (2 in this case).\nThe prompt can be just sql>. If we happen to connect to an imdg cluster, jet commands would not work.\nThe need to use ; and the Ctrl+C will be in the help, many people can figure them out i think.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546655151", "createdAt": "2020-12-21T11:29:43Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")\n+                .append(\"\\n\\t\\t\\t\\t Press Ctrl+C to cancel streaming queries\\n\\n\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 604}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NzEzNA==", "bodyText": "I literally converted it to what you want. But when this console is connected to an imdg cluster, It should show \"Connected to Hazelcast IMDG 4.1\" kind of prompt but I have not done it yet.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547297134", "createdAt": "2020-12-22T14:07:52Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")\n+                .append(\"\\n\\t\\t\\t\\t Press Ctrl+C to cancel streaming queries\\n\\n\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1NTE1MQ=="}, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 604}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzc3MzY4Ng==", "bodyText": "I am actually unsure if a JetClientInstance can connect to an IMDG cluster. Please check that.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547773686", "createdAt": "2020-12-23T07:56:14Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")\n+                .append(\"\\n\\t\\t\\t\\t Press Ctrl+C to cancel streaming queries\\n\\n\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1NTE1MQ=="}, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 604}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk1Mzc3Nw==", "bodyText": "It can connect to an IMDG cluster. ./jet -v sql --targets dev@localhost:5701(dev -> default cluster name for IMDG) this command can be used to connect IMDG cluster running on localhost:5701. In the starting prompt, the sql console indicate which type of cluster (Jet or IMDG) the client connected to. I will also update the docs link in the help command to show the imdg documentation in case the client is connected to imdg.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547953777", "createdAt": "2020-12-23T13:16:34Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")\n+                .append(\"\\n\\t\\t\\t\\t Press Ctrl+C to cancel streaming queries\\n\\n\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1NTE1MQ=="}, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 604}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjgyMTM1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMTozODowNFrOIJVZVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowNzo1OVrOIJ8Xqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1ODY0NQ==", "bodyText": "What about just OK?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546658645", "createdAt": "2020-12-21T11:38:04Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NzE5NA==", "bodyText": "Changed it to OK", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547297194", "createdAt": "2020-12-22T14:07:59Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1ODY0NQ=="}, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 496}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjgyNDQxOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMTozOTowMlrOIJVbBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowODoyOFrOIJ8YzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1OTA3OA==", "bodyText": "We have newline here, but not before an error. I lean towards not having it here.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546659078", "createdAt": "2020-12-21T11:39:02Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 489}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NzQ4NQ==", "bodyText": "Removed it", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547297485", "createdAt": "2020-12-22T14:08:28Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1OTA3OA=="}, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 489}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjgzMDU3OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMTo0MToyNlrOIJVepw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDowOTowMVrOIJ8Z7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY2MDAwNw==", "bodyText": "The behavior of Ctrl+C, when a query isn't running, is surprising to me: it just exits the terminal. It would be better to just cancel the not-yet-submitted query, I often use that in a linux terminal.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546660007", "createdAt": "2020-12-21T11:41:26Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")\n+                .append(\"\\n\\t\\t\\t\\t Press Ctrl+C to cancel streaming queries\\n\\n\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 604}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5Nzc3Mg==", "bodyText": "Changed its behavior to cancel not yet submitted query.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547297772", "createdAt": "2020-12-22T14:09:01Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")\n+                .append(\"\\n\\t\\t\\t\\t Press Ctrl+C to cancel streaming queries\\n\\n\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY2MDAwNw=="}, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 604}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzMwMzI0OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxNjo0NVrOIJZuOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxNjo0NVrOIJZuOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcyOTUzMA==", "bodyText": "We could be a bit more smart here: 5 for boolean, 4 for tinyint, 6 for smallint, 12 for int, 20 for bigint, 8 for time, 10 for date, 19 for timestamp, 25 for timestamp_with_tz, 4 for null, real/double i can't tell from the top of my head and 20 for the rest (varchar, object).\nThis is how we print decimals currently (see price column):\nJET SQL> SELECT * FROM latest_trades;\n+--------------------+--------------------+--------------------+--------------------+\n|       __key        |       ticker       |       price        |       amount       |\n+--------------------+--------------------+--------------------+--------------------+\n|        ABCD        |        ABCD        |5.500000000000000...|         10         |\n|        EFGH        |        EFGH        |14.00000000000000...|         20         |\n+--------------------+--------------------+--------------------+--------------------+", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546729530", "createdAt": "2020-12-21T14:16:45Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 475}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzMwNjkzOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxNzozOFrOIJZwTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzozNjo0NlrOIKk9OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjczMDA2Mg==", "bodyText": "We can use the unicode ellipsis, which is a single character: \u2026. Works fine on windows ;)", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546730062", "createdAt": "2020-12-21T14:17:38Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 597}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk2MjE2OQ==", "bodyText": "Applied this change", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547962169", "createdAt": "2020-12-23T13:36:46Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjczMDA2Mg=="}, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 597}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzcwNDg0OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNjowMzoyMVrOIJdXzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMzozNzoxNFrOIKk9_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4OTMyNw==", "bodyText": "When you submit this command, it executes it, even though it doesn't end with ;:\n/**/\n\nSeems that after a multi-line comment it's treated as an end of command.\nAlso this:\n--;", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546789327", "createdAt": "2020-12-21T16:03:21Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk2MjM2NQ==", "bodyText": "I solved these issues.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547962365", "createdAt": "2020-12-23T13:37:14Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4OTMyNw=="}, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 315}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzcxOTUwOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNjowNzoxNlrOIJdgiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDoxMTozOVrOIJ8e3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MTU2MQ==", "bodyText": "The @see should not be here", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546791561", "createdAt": "2020-12-21T16:07:16Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5OTAzNg==", "bodyText": "Removed it", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547299036", "createdAt": "2020-12-22T14:11:39Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MTU2MQ=="}, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzcyNDg1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNjowODo0OVrOIJdj3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDoxMToyOVrOIJ8egQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MjQxNA==", "bodyText": "# is not one line comment in sql. It's probably a feature of sqline.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546792414", "createdAt": "2020-12-21T16:08:49Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 403}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5ODk0NQ==", "bodyText": "Removed it. Also, I replaced isOneLineComment()and isMultilineComment() methods with one liners.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547298945", "createdAt": "2020-12-22T14:11:29Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MjQxNA=="}, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 403}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzczMDYzOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNjoxMDoyN1rOIJdnXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNjoxMDoyN1rOIJdnXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MzMxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // From one side there is an assumption that multi-line comment\n          \n          \n            \n                                // is completed, from the other side nextNonCommentedChar\n          \n          \n            \n                                // On one hand there is an assumption that multi-line comment\n          \n          \n            \n                                // is completed, on the other hand nextNonCommentedChar", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546793310", "createdAt": "2020-12-21T16:10:27Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 412}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNzc2MTM4OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNjoxOTowNFrOIJd53g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDo0NjowOVrOIJ9nhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5ODA0Ng==", "bodyText": "I think the toffset and ooffset are swapped here, it should have been:\n.regionMatches(i, line, 0, oneLineCommentString.length()))\n\nBut using startsWith will be much more readable IMO:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (i <= buffer.length() - oneLineCommentString.length()\n          \n          \n            \n                                            && oneLineCommentString\n          \n          \n            \n                                            .regionMatches(0, line, i, oneLineCommentString.length())) {\n          \n          \n            \n                                    if (line.substring(i).startsWith(oneLineCommentString)) {\n          \n      \n    \n    \n  \n\nSame for regionMatches above.\nThere also seems to be duplicate code in isOneLineComment below.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546798046", "createdAt": "2020-12-21T16:19:04Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 422}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNzYzOA==", "bodyText": "I removed the inconsistent regionMatches usages and followed a single style as line.regionMatches(...)", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r547317638", "createdAt": "2020-12-22T14:46:09Z", "author": {"login": "ufukyilmaz"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5ODA0Ng=="}, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 422}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NTczNjY4OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjoxNToyOFrOIL85BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjoxNToyOFrOIL85BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwMjg4NA==", "bodyText": "The condition can be simplified:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (command.length() > 0 && command.lastIndexOf(\";\") == (command.length() - 1)) {\n          \n          \n            \n                            if (command.length() > 0 && command.charAt(command.length() - 1) == ';') {\n          \n      \n    \n    \n  \n\nBut the issue is that this condition breaks the ; handling in MultilineParser. This command failse (note there's no ; at the end):\nsql> select ';' from foo\nThere are non-whitespace characters after the semicolon.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r549402884", "createdAt": "2020-12-28T16:15:28Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -179,6 +212,104 @@ public void run() {\n         // top-level command, do nothing\n     }\n \n+    @Command(description = \"Starts the SQL shell [BETA]\")\n+    public void sql(@Mixin(name = \"verbosity\") Verbosity verbosity,\n+                    @Mixin(name = \"targets\") TargetsMixin targets\n+    ) {\n+        runWithJet(targets, verbosity, true, jet -> {\n+            LineReader reader = LineReaderBuilder.builder().parser(new MultilineParser())\n+                    .variable(LineReader.SECONDARY_PROMPT_PATTERN, new AttributedStringBuilder()\n+                            .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR)).append(\"%M%P > \").toAnsi())\n+                    .variable(LineReader.INDENTATION, 2)\n+                    .option(LineReader.Option.DISABLE_EVENT_EXPANSION, true)\n+                    .appName(\"hazelcast-jet-sql\")\n+                    .build();\n+\n+            AtomicReference<SqlResult> activeSqlResult = new AtomicReference<>();\n+            reader.getTerminal().handle(Signal.INT, signal -> {\n+                SqlResult r = activeSqlResult.get();\n+                if (r != null) {\n+                    r.close();\n+                }\n+            });\n+\n+            PrintWriter writer = reader.getTerminal().writer();\n+            writer.println(sqlStartingPrompt(jet));\n+            writer.flush();\n+\n+            for (; ; ) {\n+                String command;\n+                try {\n+                    command = reader.readLine(new AttributedStringBuilder()\n+                            .style(AttributedStyle.DEFAULT.foreground(SECONDARY_COLOR))\n+                            .append(\"sql> \").toAnsi()).trim();\n+                } catch (EndOfFileException | IOError e) {\n+                    // Ctrl+D, and kill signals result in exit\n+                    writer.println(SQLCliConstants.EXIT_PROMPT);\n+                    writer.flush();\n+                    break;\n+                } catch (UserInterruptException e) {\n+                    // Ctrl+C cancels the not-yet-submitted query\n+                    continue;\n+                }\n+\n+                command = command.trim();\n+                if (command.length() > 0 && command.lastIndexOf(\";\") == (command.length() - 1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74aaaec71da6258874386ce6ac07fe600a1e5613"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NzI4MTY0OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyMjo1OFrOIMJvKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyMjo1OFrOIMJvKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzM1NQ==", "bodyText": "Method seems incomplete. For example DECIMAL_FORMAT_LENGTH is unused, we use TIMESTAMP_WITH_TIME_ZONE_FORMAT_LENGTH for DECIMAL. Also at some types we ignore the header length. Maybe we could create determineColumnWidth that would do max(min(header.length(), MAX_HEADER_LENGTH), typeLength).", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r549613355", "createdAt": "2020-12-29T08:22:58Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +847,421 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is adapted from\n+     * <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonWhitespaceData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastSemicolonIdx = -1;\n+            for (int i = 0; i < line.length(); i++) {\n+                // If a one line comment, a multiline comment or a quote is not started before,\n+                // check if the character we're on is a quote character\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonWhitespaceData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 &&\n+                            line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                        // Enter the multiline comment block\n+                        multiLineCommentStart = i;\n+                        containsNonWhitespaceData = true;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        // In a multiline comment block\n+                        if (i - multiLineCommentStart > 2 &&\n+                                line.regionMatches(i - 1, \"*/\", 0, \"*/\".length())) {\n+                            // End the multiline block\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 &&\n+                            line.regionMatches(i, \"--\", 0, \"--\".length())) {\n+                        // Enter the one line comment block\n+                        oneLineCommentStart = i;\n+                        containsNonWhitespaceData = true;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        // In a one line comment\n+                        if (currentChar == '\\n') {\n+                            // End the one line comment block\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        if (currentChar == ';') {\n+                            lastSemicolonIdx = i;\n+                        } else if (!Character.isWhitespace(currentChar)) {\n+                            containsNonWhitespaceData = true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (SQLCliConstants.COMMAND_SET.contains(line.trim().toLowerCase(Locale.US))) {\n+                return;\n+            }\n+            // These EOFError exceptions are captured in LineReader's\n+            // readLine() method and it points out that the command\n+            // being written to console is not finalized and command\n+            // won't be read\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (oneLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"One line comment\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            if (containsNonWhitespaceData &&\n+                    (lastSemicolonIdx == -1 || lastSemicolonIdx >= cursor)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+    }\n+\n+    private void executeSqlCmd(\n+            JetInstance jet,\n+            String command,\n+            Terminal terminal,\n+            AtomicReference<SqlResult> activeSqlResult\n+    ) {\n+        PrintWriter out = terminal.writer();\n+        try (SqlResult sqlResult = jet.getSql().execute(command)) {\n+            activeSqlResult.set(sqlResult);\n+\n+            // if it's a result with an update count, just print it\n+            if (sqlResult.updateCount() != -1) {\n+                String message = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"OK\")\n+                        .toAnsi();\n+                out.println(message);\n+                return;\n+            }\n+            SqlRowMetadata rowMetadata = sqlResult.getRowMetadata();\n+            int[] colWidths = determineColumnWidths(rowMetadata);\n+            Alignment[] alignments = determineAlignments(rowMetadata);\n+\n+            // this is a result with rows. Print the header and rows, watch for concurrent cancellation\n+            printMetadataInfo(rowMetadata, colWidths, alignments, out);\n+\n+            int rowCount = 0;\n+            for (SqlRow row : sqlResult) {\n+                rowCount++;\n+                printRow(row, colWidths, alignments, out);\n+            }\n+\n+            // bottom line after all the rows\n+            printSeparatorLine(sqlResult.getRowMetadata().getColumnCount(), colWidths, out);\n+\n+            String message = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(String.valueOf(rowCount))\n+                    .append(\" row(s) selected\")\n+                    .toAnsi();\n+            out.println(message);\n+        } catch (HazelcastSqlException e) {\n+            // the query failed to execute\n+            String errorPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(e.getMessage())\n+                    .toAnsi();\n+            out.println(errorPrompt);\n+        }\n+    }\n+\n+    private static int[] determineColumnWidths(SqlRowMetadata metadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e673b90f2166f0ef59dbb3780555c4e80d0b06ed"}, "originalPosition": 582}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1NzI5MDk4OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyNjo1OFrOIMJ0Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyNjo1OFrOIMJ0Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNDY2Mw==", "bodyText": "We should sanitize the colName the same way we sanitize values on line 1118 below. Or even more, replace every character below 32 with . or something.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r549614663", "createdAt": "2020-12-29T08:26:58Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +847,421 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is adapted from\n+     * <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonWhitespaceData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastSemicolonIdx = -1;\n+            for (int i = 0; i < line.length(); i++) {\n+                // If a one line comment, a multiline comment or a quote is not started before,\n+                // check if the character we're on is a quote character\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonWhitespaceData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 &&\n+                            line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                        // Enter the multiline comment block\n+                        multiLineCommentStart = i;\n+                        containsNonWhitespaceData = true;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        // In a multiline comment block\n+                        if (i - multiLineCommentStart > 2 &&\n+                                line.regionMatches(i - 1, \"*/\", 0, \"*/\".length())) {\n+                            // End the multiline block\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 &&\n+                            line.regionMatches(i, \"--\", 0, \"--\".length())) {\n+                        // Enter the one line comment block\n+                        oneLineCommentStart = i;\n+                        containsNonWhitespaceData = true;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        // In a one line comment\n+                        if (currentChar == '\\n') {\n+                            // End the one line comment block\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        if (currentChar == ';') {\n+                            lastSemicolonIdx = i;\n+                        } else if (!Character.isWhitespace(currentChar)) {\n+                            containsNonWhitespaceData = true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (SQLCliConstants.COMMAND_SET.contains(line.trim().toLowerCase(Locale.US))) {\n+                return;\n+            }\n+            // These EOFError exceptions are captured in LineReader's\n+            // readLine() method and it points out that the command\n+            // being written to console is not finalized and command\n+            // won't be read\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (oneLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"One line comment\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            if (containsNonWhitespaceData &&\n+                    (lastSemicolonIdx == -1 || lastSemicolonIdx >= cursor)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+    }\n+\n+    private void executeSqlCmd(\n+            JetInstance jet,\n+            String command,\n+            Terminal terminal,\n+            AtomicReference<SqlResult> activeSqlResult\n+    ) {\n+        PrintWriter out = terminal.writer();\n+        try (SqlResult sqlResult = jet.getSql().execute(command)) {\n+            activeSqlResult.set(sqlResult);\n+\n+            // if it's a result with an update count, just print it\n+            if (sqlResult.updateCount() != -1) {\n+                String message = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"OK\")\n+                        .toAnsi();\n+                out.println(message);\n+                return;\n+            }\n+            SqlRowMetadata rowMetadata = sqlResult.getRowMetadata();\n+            int[] colWidths = determineColumnWidths(rowMetadata);\n+            Alignment[] alignments = determineAlignments(rowMetadata);\n+\n+            // this is a result with rows. Print the header and rows, watch for concurrent cancellation\n+            printMetadataInfo(rowMetadata, colWidths, alignments, out);\n+\n+            int rowCount = 0;\n+            for (SqlRow row : sqlResult) {\n+                rowCount++;\n+                printRow(row, colWidths, alignments, out);\n+            }\n+\n+            // bottom line after all the rows\n+            printSeparatorLine(sqlResult.getRowMetadata().getColumnCount(), colWidths, out);\n+\n+            String message = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(String.valueOf(rowCount))\n+                    .append(\" row(s) selected\")\n+                    .toAnsi();\n+            out.println(message);\n+        } catch (HazelcastSqlException e) {\n+            // the query failed to execute\n+            String errorPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(e.getMessage())\n+                    .toAnsi();\n+            out.println(errorPrompt);\n+        }\n+    }\n+\n+    private static int[] determineColumnWidths(SqlRowMetadata metadata) {\n+        int colCount = metadata.getColumnCount();\n+        int[] colWidths = new int[colCount];\n+        for (int i = 0; i < colCount; i++) {\n+            SqlColumnMetadata colMetadata = metadata.getColumn(i);\n+            SqlColumnType type = colMetadata.getType();\n+            String colName = colMetadata.getName();\n+            switch (type) {\n+                case BOOLEAN:\n+                    colWidths[i] = Math.max(SQLCliConstants.BOOLEAN_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case DATE:\n+                    colWidths[i] = Math.max(SQLCliConstants.DATE_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case TIMESTAMP_WITH_TIME_ZONE:\n+                case DECIMAL:\n+                case REAL:\n+                case DOUBLE:\n+                    colWidths[i] = SQLCliConstants.TIMESTAMP_WITH_TIME_ZONE_FORMAT_LENGTH;\n+                    break;\n+                case INTEGER:\n+                    colWidths[i] = Math.max(SQLCliConstants.INTEGER_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case NULL:\n+                case TINYINT:\n+                    colWidths[i] = Math.max(SQLCliConstants.TINYINT_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case SMALLINT:\n+                    colWidths[i] = Math.max(SQLCliConstants.SMALLINT_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case TIMESTAMP:\n+                    colWidths[i] = Math.max(SQLCliConstants.TIMESTAMP_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case BIGINT:\n+                case VARCHAR:\n+                case OBJECT:\n+                default:\n+                    colWidths[i] = SQLCliConstants.VARCHAR_FORMAT_LENGTH;\n+            }\n+        }\n+        return colWidths;\n+    }\n+\n+    private static Alignment[] determineAlignments(SqlRowMetadata metadata) {\n+        int colCount = metadata.getColumnCount();\n+        Alignment[] alignments = new Alignment[colCount];\n+        for (int i = 0; i < colCount; i++) {\n+            SqlColumnMetadata colMetadata = metadata.getColumn(i);\n+            SqlColumnType type = colMetadata.getType();\n+            String colName = colMetadata.getName();\n+            switch (type) {\n+                case BIGINT:\n+                case DECIMAL:\n+                case DOUBLE:\n+                case INTEGER:\n+                case REAL:\n+                case SMALLINT:\n+                case TINYINT:\n+                    alignments[i] = Alignment.RIGHT;\n+                    break;\n+                case BOOLEAN:\n+                case DATE:\n+                case NULL:\n+                case OBJECT:\n+                case TIMESTAMP:\n+                case VARCHAR:\n+                case TIMESTAMP_WITH_TIME_ZONE:\n+                default:\n+                    alignments[i] = Alignment.CENTER;\n+            }\n+        }\n+        return alignments;\n+    }\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int[] colWidths,\n+                                          Alignment[] alignments, PrintWriter out) {\n+        int colCount = metadata.getColumnCount();\n+        printSeparatorLine(colCount, colWidths, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colCount; i++) {\n+            String colName = metadata.getColumn(i).getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e673b90f2166f0ef59dbb3780555c4e80d0b06ed"}, "originalPosition": 670}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4451, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}