{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1OTc4ODU0", "number": 2750, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTowNjo0NVrOFD709A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTowNzowNFrOFD71Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjcwMjYwOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTowNjo0NVrOID0CPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTowNjo0NVrOID0CPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTE4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (remainder == 0) {\n          \n          \n            \n                                        return createConveyorArray(downstreamParallelism, queueCount, queueSize);\n          \n          \n            \n                                    } else if (upstreamParallelism - remainder == 0) { // downstreamParallelism > upstreamParallelism\n          \n          \n            \n                                        return createConveyorArray(downstreamParallelism, queueCount + 1, queueSize);\n          \n          \n            \n                                    } else {\n          \n          \n            \n                                        return Stream.concat(\n          \n          \n            \n                                                Arrays.stream(createConveyorArray(remainder, queueCount + 1, queueSize)),\n          \n          \n            \n                                                Arrays.stream(createConveyorArray(\n          \n          \n            \n                                                        downstreamParallelism - remainder, queueCount, queueSize\n          \n          \n            \n                                                ))).toArray((IntFunction<ConcurrentConveyor<Object>[]>) ConcurrentConveyor[]::new);\n          \n          \n            \n                                    }\n          \n          \n            \n                                    return Stream.concat(\n          \n          \n            \n                                            Arrays.stream(createConveyorArray(remainder, queueCount + 1, queueSize)),\n          \n          \n            \n                                            Arrays.stream(createConveyorArray(\n          \n          \n            \n                                                    downstreamParallelism - remainder, Math.max(1, queueCount), queueSize\n          \n          \n            \n                                            ))).toArray((IntFunction<ConcurrentConveyor<Object>[]>) ConcurrentConveyor[]::new);", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2750#discussion_r540869182", "createdAt": "2020-12-11T11:06:45Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java", "diffHunk": "@@ -472,13 +474,35 @@ private OutboundEdgeStream createOutboundEdgeStream(EdgeDef edge,\n                 throw new IllegalArgumentException(\"Isolated edges must be local: \" + edge);\n             }\n \n-            // there is only one producer per consumer for a one to many edge, so queueCount is always 1\n             ConcurrentConveyor<Object>[] localConveyors = localConveyorMap.computeIfAbsent(edge.edgeId(),\n-                    e -> createConveyorArray(downstreamParallelism, 1, queueSize));\n-            return IntStream.range(0, downstreamParallelism)\n-                            .filter(i -> i % upstreamParallelism == processorIndex)\n-                            .mapToObj(i -> new ConveyorCollector(localConveyors[i], 0, null))\n-                            .toArray(OutboundCollector[]::new);\n+                    e -> {\n+                        int queueCount = upstreamParallelism / downstreamParallelism;\n+                        int remainder = upstreamParallelism % downstreamParallelism;\n+                        if (remainder == 0) {\n+                            return createConveyorArray(downstreamParallelism, queueCount, queueSize);\n+                        } else if (upstreamParallelism - remainder == 0) { // downstreamParallelism > upstreamParallelism\n+                            return createConveyorArray(downstreamParallelism, queueCount + 1, queueSize);\n+                        } else {\n+                            return Stream.concat(\n+                                    Arrays.stream(createConveyorArray(remainder, queueCount + 1, queueSize)),\n+                                    Arrays.stream(createConveyorArray(\n+                                            downstreamParallelism - remainder, queueCount, queueSize\n+                                    ))).toArray((IntFunction<ConcurrentConveyor<Object>[]>) ConcurrentConveyor[]::new);\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4451ea055497f722b6acaba68907a43912ac1597"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjcwMzcxOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTowNzowNFrOID0C6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTowNzowNFrOID0C6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTM1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (downstreamParallelism >= upstreamParallelism) {\n          \n          \n            \n                            return IntStream.range(0, downstreamParallelism)\n          \n          \n            \n                                    .filter(i -> i % upstreamParallelism == processorIndex)\n          \n          \n            \n                                    .mapToObj(i -> new ConveyorCollector(localConveyors[i], 0, null))\n          \n          \n            \n                                    .toArray(OutboundCollector[]::new);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return IntStream.range(0, downstreamParallelism)\n          \n          \n            \n                                    .filter(i -> processorIndex % downstreamParallelism == i)\n          \n          \n            \n                                    .mapToObj(i -> new ConveyorCollector(localConveyors[i],\n          \n          \n            \n                                            processorIndex / downstreamParallelism, null))\n          \n          \n            \n                                    .toArray(OutboundCollector[]::new);\n          \n          \n            \n                        }\n          \n          \n            \n                            return IntStream.range(0, downstreamParallelism)\n          \n          \n            \n                                    .filter(i -> i % upstreamParallelism == processorIndex % downstreamParallelism)\n          \n          \n            \n                                    .mapToObj(i -> new ConveyorCollector(localConveyors[i], processorIndex / downstreamParallelism, null))\n          \n          \n            \n                                    .toArray(OutboundCollector[]::new);", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2750#discussion_r540869355", "createdAt": "2020-12-11T11:07:04Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java", "diffHunk": "@@ -472,13 +474,35 @@ private OutboundEdgeStream createOutboundEdgeStream(EdgeDef edge,\n                 throw new IllegalArgumentException(\"Isolated edges must be local: \" + edge);\n             }\n \n-            // there is only one producer per consumer for a one to many edge, so queueCount is always 1\n             ConcurrentConveyor<Object>[] localConveyors = localConveyorMap.computeIfAbsent(edge.edgeId(),\n-                    e -> createConveyorArray(downstreamParallelism, 1, queueSize));\n-            return IntStream.range(0, downstreamParallelism)\n-                            .filter(i -> i % upstreamParallelism == processorIndex)\n-                            .mapToObj(i -> new ConveyorCollector(localConveyors[i], 0, null))\n-                            .toArray(OutboundCollector[]::new);\n+                    e -> {\n+                        int queueCount = upstreamParallelism / downstreamParallelism;\n+                        int remainder = upstreamParallelism % downstreamParallelism;\n+                        if (remainder == 0) {\n+                            return createConveyorArray(downstreamParallelism, queueCount, queueSize);\n+                        } else if (upstreamParallelism - remainder == 0) { // downstreamParallelism > upstreamParallelism\n+                            return createConveyorArray(downstreamParallelism, queueCount + 1, queueSize);\n+                        } else {\n+                            return Stream.concat(\n+                                    Arrays.stream(createConveyorArray(remainder, queueCount + 1, queueSize)),\n+                                    Arrays.stream(createConveyorArray(\n+                                            downstreamParallelism - remainder, queueCount, queueSize\n+                                    ))).toArray((IntFunction<ConcurrentConveyor<Object>[]>) ConcurrentConveyor[]::new);\n+                        }\n+                    });\n+\n+            if (downstreamParallelism >= upstreamParallelism) {\n+                return IntStream.range(0, downstreamParallelism)\n+                        .filter(i -> i % upstreamParallelism == processorIndex)\n+                        .mapToObj(i -> new ConveyorCollector(localConveyors[i], 0, null))\n+                        .toArray(OutboundCollector[]::new);\n+            } else {\n+                return IntStream.range(0, downstreamParallelism)\n+                        .filter(i -> processorIndex % downstreamParallelism == i)\n+                        .mapToObj(i -> new ConveyorCollector(localConveyors[i],\n+                                processorIndex / downstreamParallelism, null))\n+                        .toArray(OutboundCollector[]::new);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4451ea055497f722b6acaba68907a43912ac1597"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4360, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}