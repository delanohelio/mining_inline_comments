{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NDEwNDU2", "number": 2286, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODozNjoyM1rOEDWVFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODo0NDo1NlrOEDWgXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTQ3MDI5OnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch/elasticsearch-5/src/main/java/com/hazelcast/jet/elastic/impl/ElasticSourcePMetaSupplier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODozNjoyM1rOGgUIXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDowNToxMlrOGkdCNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNzQzOQ==", "bodyText": "I see that we have this obtaining RestClient via reflection at processor too. Maybe we can have it as a static utility method, in ElasticCatClient for example.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r436537439", "createdAt": "2020-06-08T08:36:23Z", "author": {"login": "gurbuzali"}, "path": "extensions/elasticsearch/elasticsearch-5/src/main/java/com/hazelcast/jet/elastic/impl/ElasticSourcePMetaSupplier.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.elastic.impl;\n+\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.cluster.Member;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.core.ProcessorMetaSupplier;\n+import com.hazelcast.jet.core.ProcessorSupplier;\n+import com.hazelcast.jet.core.processor.Processors;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.annotation.Nonnull;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.nCopies;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toSet;\n+\n+public class ElasticSourcePMetaSupplier<T> implements ProcessorMetaSupplier {\n+\n+    private static final long serialVersionUID = 1L;\n+    private static final int DEFAULT_LOCAL_PARALLELISM = 2;\n+\n+    @Nonnull\n+    private final ElasticSourceConfiguration<T> configuration;\n+\n+    private transient Map<Address, List<Shard>> assignedShards;\n+    private transient Address ownerAddress;\n+\n+    public ElasticSourcePMetaSupplier(@Nonnull ElasticSourceConfiguration<T> configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public int preferredLocalParallelism() {\n+        if (configuration.isCoLocatedReadingEnabled() || configuration.isSlicingEnabled()) {\n+            return DEFAULT_LOCAL_PARALLELISM;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    @Override\n+    public void init(@Nonnull Context context) throws Exception {\n+        RestHighLevelClient client = configuration.clientFn().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350190c1070f15730bc00286ebacb52b59c1ec70"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg3NzYyMg==", "bodyText": "Done.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r440877622", "createdAt": "2020-06-16T14:05:12Z", "author": {"login": "frant-hartm"}, "path": "extensions/elasticsearch/elasticsearch-5/src/main/java/com/hazelcast/jet/elastic/impl/ElasticSourcePMetaSupplier.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.elastic.impl;\n+\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.cluster.Member;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.core.ProcessorMetaSupplier;\n+import com.hazelcast.jet.core.ProcessorSupplier;\n+import com.hazelcast.jet.core.processor.Processors;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.annotation.Nonnull;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.nCopies;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toSet;\n+\n+public class ElasticSourcePMetaSupplier<T> implements ProcessorMetaSupplier {\n+\n+    private static final long serialVersionUID = 1L;\n+    private static final int DEFAULT_LOCAL_PARALLELISM = 2;\n+\n+    @Nonnull\n+    private final ElasticSourceConfiguration<T> configuration;\n+\n+    private transient Map<Address, List<Shard>> assignedShards;\n+    private transient Address ownerAddress;\n+\n+    public ElasticSourcePMetaSupplier(@Nonnull ElasticSourceConfiguration<T> configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public int preferredLocalParallelism() {\n+        if (configuration.isCoLocatedReadingEnabled() || configuration.isSlicingEnabled()) {\n+            return DEFAULT_LOCAL_PARALLELISM;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    @Override\n+    public void init(@Nonnull Context context) throws Exception {\n+        RestHighLevelClient client = configuration.clientFn().get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNzQzOQ=="}, "originalCommit": {"oid": "350190c1070f15730bc00286ebacb52b59c1ec70"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTQ4NTYzOnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch/elasticsearch-5/src/test/java/com/hazelcast/jet/elastic/impl/ElasticSourcePTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODo0MDo0NlrOGgURzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDowODoyOFrOGkdLNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzOTg1Mg==", "bodyText": "why is this commented out ?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r436539852", "createdAt": "2020-06-08T08:40:46Z", "author": {"login": "gurbuzali"}, "path": "extensions/elasticsearch/elasticsearch-5/src/test/java/com/hazelcast/jet/elastic/impl/ElasticSourcePTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.elastic.impl;\n+\n+import com.hazelcast.jet.core.test.TestSupport;\n+import com.hazelcast.jet.elastic.impl.Shard.Prirep;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.SearchScrollRequest;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.slice.SliceBuilder;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.util.Lists.newArrayList;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+\n+public class ElasticSourcePTest {\n+\n+    public static final String HIT_SOURCE = \"{\\\"name\\\": \\\"Frantisek\\\"}\";\n+    public static final String HIT_SOURCE2 = \"{\\\"name\\\": \\\"Vladimir\\\"}\";\n+    public static final String SCROLL_ID = \"random-scroll-id\";\n+\n+    private static final String KEEP_ALIVE = \"42m\";\n+\n+    private ElasticSourceP<String> processor;\n+    private SerializableRestClient spyClient;\n+    private SearchResponse response;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        RestClientBuilder builderMock = mock(RestClientBuilder.class);\n+        RestClient restClientMock = mock(RestClient.class, RETURNS_DEEP_STUBS);\n+        when(builderMock.build()).thenReturn(restClientMock);\n+        SerializableRestClient client = new SerializableRestClient(builderMock);\n+        spyClient = SerializableRestClient.instanceHolder = spy(client);\n+        // Mocks returning mocks is not generally recommended, but the setup of empty SearchResponse is even uglier\n+        // See org.elasticsearch.action.search.SearchResponse#empty\n+        response = mock(SearchResponse.class);\n+        when(response.getScrollId()).thenReturn(SCROLL_ID);\n+        // client is a spy, need to to doReturn()\n+        doReturn(response).when(spyClient).search(any(SearchRequest.class), any());\n+    }\n+\n+    private TestSupport runProcessor() throws Exception {\n+        return runProcessor(emptyList(), false, false);\n+    }\n+\n+    private TestSupport runProcessorWithCoLocation(List<Shard> shards) throws Exception {\n+        return runProcessor(shards, false, true);\n+    }\n+\n+    private TestSupport runProcessor(List<Shard> shards,\n+                                     boolean slicing, boolean coLocatedReading)\n+            throws Exception {\n+\n+        RestHighLevelClient client = spyClient;\n+        ElasticSourceConfiguration<String> configuration = new ElasticSourceConfiguration<String>(\n+                () -> client,\n+                () -> new SearchRequest(\"*\"),\n+                SearchHit::getSourceAsString,\n+                slicing,\n+                coLocatedReading,\n+                KEEP_ALIVE\n+        );\n+\n+        // This constructor calls the client so it has to be called after specific mock setup in each test method\n+        // rather than in setUp()\n+        processor = new ElasticSourceP<>(configuration, shards);\n+\n+        return TestSupport.verifyProcessor(() -> processor)\n+                .disableSnapshots();\n+    }\n+\n+    @Test\n+    public void when_runProcessor_then_executeSearchRequestWithScroll() throws Exception {\n+        when(response.getHits()).thenReturn(new SearchHits(new SearchHit[]{}, 0, Float.NaN));\n+\n+        TestSupport support = runProcessor();\n+\n+        support.expectOutput(emptyList());\n+\n+        ArgumentCaptor<SearchRequest> captor = forClass(SearchRequest.class);\n+        verify(spyClient).search(captor.capture());\n+\n+        SearchRequest request = captor.getValue();\n+        assertThat(request.scroll().keepAlive().getStringRep()).isEqualTo(KEEP_ALIVE);\n+    }\n+\n+    @Test\n+    public void given_singleHit_when_runProcessor_then_produceSingleHit() throws Exception {\n+        SearchHit hit = new SearchHit(0, \"id-0\", new Text(\"ignored\"), emptyMap());\n+        hit.sourceRef(new BytesArray(HIT_SOURCE));\n+        when(response.getHits()).thenReturn(new SearchHits(new SearchHit[]{hit}, 1, Float.NaN));\n+\n+        SearchResponse response2 = mock(SearchResponse.class);\n+        when(response2.getHits()).thenReturn(new SearchHits(new SearchHit[]{}, 1, Float.NaN));\n+        doReturn(response2).when(spyClient).searchScroll(any());\n+\n+        TestSupport testSupport = runProcessor();\n+\n+        testSupport.expectOutput(newArrayList(HIT_SOURCE));\n+    }\n+\n+    @Test\n+    public void givenMultipleResults_when_runProcessor_then_useScrollIdInFollowupScrollRequest() throws Exception {\n+        SearchHit hit = new SearchHit(0, \"id-0\", new Text(\"ignored\"), emptyMap());\n+        hit.sourceRef(new BytesArray(HIT_SOURCE));\n+        when(response.getHits()).thenReturn(new SearchHits(new SearchHit[]{hit}, 3, Float.NaN));\n+\n+        SearchResponse response2 = mock(SearchResponse.class);\n+        SearchHit hit2 = new SearchHit(1, \"id-1\", new Text(\"ignored\"), emptyMap());\n+        hit2.sourceRef(new BytesArray(HIT_SOURCE2));\n+        when(response2.getHits()).thenReturn(new SearchHits(new SearchHit[]{hit2}, 3, Float.NaN));\n+\n+        SearchResponse response3 = mock(SearchResponse.class);\n+        when(response3.getHits()).thenReturn(new SearchHits(new SearchHit[]{}, 3, Float.NaN));\n+        doReturn(response2, response3).when(spyClient).searchScroll(any()); // client is a spy, need to to doReturn()..\n+\n+        TestSupport testSupport = runProcessor();\n+\n+        testSupport.expectOutput(newArrayList(HIT_SOURCE, HIT_SOURCE2));\n+\n+        ArgumentCaptor<SearchScrollRequest> captor = forClass(SearchScrollRequest.class);\n+\n+        verify(spyClient, times(2)).searchScroll(captor.capture());\n+        SearchScrollRequest request = captor.getValue();\n+        assertThat(request.scrollId()).isEqualTo(SCROLL_ID);\n+        assertThat(request.scroll().keepAlive().getStringRep()).isEqualTo(KEEP_ALIVE);\n+    }\n+\n+/*\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350190c1070f15730bc00286ebacb52b59c1ec70"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg3OTkyNA==", "bodyText": "Because the API is too different for this test to work in the way it was designed and I considered writing new test would not provide much benefit for v5.\nDeleted commented code.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r440879924", "createdAt": "2020-06-16T14:08:28Z", "author": {"login": "frant-hartm"}, "path": "extensions/elasticsearch/elasticsearch-5/src/test/java/com/hazelcast/jet/elastic/impl/ElasticSourcePTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.elastic.impl;\n+\n+import com.hazelcast.jet.core.test.TestSupport;\n+import com.hazelcast.jet.elastic.impl.Shard.Prirep;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.SearchScrollRequest;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.slice.SliceBuilder;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.util.Lists.newArrayList;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+\n+public class ElasticSourcePTest {\n+\n+    public static final String HIT_SOURCE = \"{\\\"name\\\": \\\"Frantisek\\\"}\";\n+    public static final String HIT_SOURCE2 = \"{\\\"name\\\": \\\"Vladimir\\\"}\";\n+    public static final String SCROLL_ID = \"random-scroll-id\";\n+\n+    private static final String KEEP_ALIVE = \"42m\";\n+\n+    private ElasticSourceP<String> processor;\n+    private SerializableRestClient spyClient;\n+    private SearchResponse response;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        RestClientBuilder builderMock = mock(RestClientBuilder.class);\n+        RestClient restClientMock = mock(RestClient.class, RETURNS_DEEP_STUBS);\n+        when(builderMock.build()).thenReturn(restClientMock);\n+        SerializableRestClient client = new SerializableRestClient(builderMock);\n+        spyClient = SerializableRestClient.instanceHolder = spy(client);\n+        // Mocks returning mocks is not generally recommended, but the setup of empty SearchResponse is even uglier\n+        // See org.elasticsearch.action.search.SearchResponse#empty\n+        response = mock(SearchResponse.class);\n+        when(response.getScrollId()).thenReturn(SCROLL_ID);\n+        // client is a spy, need to to doReturn()\n+        doReturn(response).when(spyClient).search(any(SearchRequest.class), any());\n+    }\n+\n+    private TestSupport runProcessor() throws Exception {\n+        return runProcessor(emptyList(), false, false);\n+    }\n+\n+    private TestSupport runProcessorWithCoLocation(List<Shard> shards) throws Exception {\n+        return runProcessor(shards, false, true);\n+    }\n+\n+    private TestSupport runProcessor(List<Shard> shards,\n+                                     boolean slicing, boolean coLocatedReading)\n+            throws Exception {\n+\n+        RestHighLevelClient client = spyClient;\n+        ElasticSourceConfiguration<String> configuration = new ElasticSourceConfiguration<String>(\n+                () -> client,\n+                () -> new SearchRequest(\"*\"),\n+                SearchHit::getSourceAsString,\n+                slicing,\n+                coLocatedReading,\n+                KEEP_ALIVE\n+        );\n+\n+        // This constructor calls the client so it has to be called after specific mock setup in each test method\n+        // rather than in setUp()\n+        processor = new ElasticSourceP<>(configuration, shards);\n+\n+        return TestSupport.verifyProcessor(() -> processor)\n+                .disableSnapshots();\n+    }\n+\n+    @Test\n+    public void when_runProcessor_then_executeSearchRequestWithScroll() throws Exception {\n+        when(response.getHits()).thenReturn(new SearchHits(new SearchHit[]{}, 0, Float.NaN));\n+\n+        TestSupport support = runProcessor();\n+\n+        support.expectOutput(emptyList());\n+\n+        ArgumentCaptor<SearchRequest> captor = forClass(SearchRequest.class);\n+        verify(spyClient).search(captor.capture());\n+\n+        SearchRequest request = captor.getValue();\n+        assertThat(request.scroll().keepAlive().getStringRep()).isEqualTo(KEEP_ALIVE);\n+    }\n+\n+    @Test\n+    public void given_singleHit_when_runProcessor_then_produceSingleHit() throws Exception {\n+        SearchHit hit = new SearchHit(0, \"id-0\", new Text(\"ignored\"), emptyMap());\n+        hit.sourceRef(new BytesArray(HIT_SOURCE));\n+        when(response.getHits()).thenReturn(new SearchHits(new SearchHit[]{hit}, 1, Float.NaN));\n+\n+        SearchResponse response2 = mock(SearchResponse.class);\n+        when(response2.getHits()).thenReturn(new SearchHits(new SearchHit[]{}, 1, Float.NaN));\n+        doReturn(response2).when(spyClient).searchScroll(any());\n+\n+        TestSupport testSupport = runProcessor();\n+\n+        testSupport.expectOutput(newArrayList(HIT_SOURCE));\n+    }\n+\n+    @Test\n+    public void givenMultipleResults_when_runProcessor_then_useScrollIdInFollowupScrollRequest() throws Exception {\n+        SearchHit hit = new SearchHit(0, \"id-0\", new Text(\"ignored\"), emptyMap());\n+        hit.sourceRef(new BytesArray(HIT_SOURCE));\n+        when(response.getHits()).thenReturn(new SearchHits(new SearchHit[]{hit}, 3, Float.NaN));\n+\n+        SearchResponse response2 = mock(SearchResponse.class);\n+        SearchHit hit2 = new SearchHit(1, \"id-1\", new Text(\"ignored\"), emptyMap());\n+        hit2.sourceRef(new BytesArray(HIT_SOURCE2));\n+        when(response2.getHits()).thenReturn(new SearchHits(new SearchHit[]{hit2}, 3, Float.NaN));\n+\n+        SearchResponse response3 = mock(SearchResponse.class);\n+        when(response3.getHits()).thenReturn(new SearchHits(new SearchHit[]{}, 3, Float.NaN));\n+        doReturn(response2, response3).when(spyClient).searchScroll(any()); // client is a spy, need to to doReturn()..\n+\n+        TestSupport testSupport = runProcessor();\n+\n+        testSupport.expectOutput(newArrayList(HIT_SOURCE, HIT_SOURCE2));\n+\n+        ArgumentCaptor<SearchScrollRequest> captor = forClass(SearchScrollRequest.class);\n+\n+        verify(spyClient, times(2)).searchScroll(captor.capture());\n+        SearchScrollRequest request = captor.getValue();\n+        assertThat(request.scrollId()).isEqualTo(SCROLL_ID);\n+        assertThat(request.scroll().keepAlive().getStringRep()).isEqualTo(KEEP_ALIVE);\n+    }\n+\n+/*\n+    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzOTg1Mg=="}, "originalCommit": {"oid": "350190c1070f15730bc00286ebacb52b59c1ec70"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTQ5OTE3OnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch/elasticsearch-5/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwODo0NDo1NlrOGgUakA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDowODo1OFrOGkdMlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0MjA5Ng==", "bodyText": "we have this dependency at parent pom already.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r436542096", "createdAt": "2020-06-08T08:44:56Z", "author": {"login": "gurbuzali"}, "path": "extensions/elasticsearch/elasticsearch-5/pom.xml", "diffHunk": "@@ -0,0 +1,128 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright 2020 Hazelcast Inc.\n+  ~\n+  ~ Licensed under the Hazelcast Community License (the \"License\");\n+  ~ you may not use this file except in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~ http://hazelcast.com/hazelcast-community-license\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing, software\n+  ~ distributed under the License is distributed on an \"AS IS\" BASIS,\n+  ~ WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+  ~ See the License for the specific language governing permissions and\n+  ~ limitations under the License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <packaging>jar</packaging>\n+    <name>hazelcast-jet-elasticsearch-5</name>\n+    <description>Elasticsearch 5 support for Hazelcast Jet</description>\n+    <url>http://www.hazelcast.com/</url>\n+\n+    <artifactId>hazelcast-jet-elasticsearch-5</artifactId>\n+\n+    <parent>\n+        <groupId>com.hazelcast.jet</groupId>\n+        <artifactId>hazelcast-jet-extensions</artifactId>\n+        <version>4.2-SNAPSHOT</version>\n+        <relativePath>../../pom.xml</relativePath>\n+    </parent>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-jar-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>test-jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <configuration>\n+                    <archive>\n+                        <manifestEntries>\n+                            <Automatic-Module-Name>com.hazelcast.jet.elastic</Automatic-Module-Name>\n+                        </manifestEntries>\n+                    </archive>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-assembly-plugin</artifactId>\n+                <version>${maven.assembly.plugin.version}</version>\n+                <executions>\n+                    <execution>\n+                        <id>distro-assembly</id>\n+                        <phase>package</phase>\n+                        <goals>\n+                            <goal>single</goal>\n+                        </goals>\n+                        <configuration>\n+                            <descriptorRefs>\n+                                <descriptorRef>jar-with-dependencies</descriptorRef>\n+                            </descriptorRefs>\n+                            <tarLongFileMode>posix</tarLongFileMode>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.elasticsearch.client</groupId>\n+            <artifactId>elasticsearch-rest-high-level-client</artifactId>\n+            <!--\n+            Supports Elastic server 5.6.0+\n+            This is the oldest version of the high level client.\n+            -->\n+            <version>5.6.16</version>\n+        </dependency>\n+\n+        <!-- TEST -->\n+        <dependency>\n+            <groupId>org.elasticsearch.client</groupId>\n+            <artifactId>transport</artifactId>\n+            <version>5.6.16</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "350190c1070f15730bc00286ebacb52b59c1ec70"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg4MDI3Nw==", "bodyText": "Removed.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r440880277", "createdAt": "2020-06-16T14:08:58Z", "author": {"login": "frant-hartm"}, "path": "extensions/elasticsearch/elasticsearch-5/pom.xml", "diffHunk": "@@ -0,0 +1,128 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+  ~ Copyright 2020 Hazelcast Inc.\n+  ~\n+  ~ Licensed under the Hazelcast Community License (the \"License\");\n+  ~ you may not use this file except in compliance with the License.\n+  ~ You may obtain a copy of the License at\n+  ~\n+  ~ http://hazelcast.com/hazelcast-community-license\n+  ~\n+  ~ Unless required by applicable law or agreed to in writing, software\n+  ~ distributed under the License is distributed on an \"AS IS\" BASIS,\n+  ~ WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+  ~ See the License for the specific language governing permissions and\n+  ~ limitations under the License.\n+  -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <packaging>jar</packaging>\n+    <name>hazelcast-jet-elasticsearch-5</name>\n+    <description>Elasticsearch 5 support for Hazelcast Jet</description>\n+    <url>http://www.hazelcast.com/</url>\n+\n+    <artifactId>hazelcast-jet-elasticsearch-5</artifactId>\n+\n+    <parent>\n+        <groupId>com.hazelcast.jet</groupId>\n+        <artifactId>hazelcast-jet-extensions</artifactId>\n+        <version>4.2-SNAPSHOT</version>\n+        <relativePath>../../pom.xml</relativePath>\n+    </parent>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-jar-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>test-jar</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+                <configuration>\n+                    <archive>\n+                        <manifestEntries>\n+                            <Automatic-Module-Name>com.hazelcast.jet.elastic</Automatic-Module-Name>\n+                        </manifestEntries>\n+                    </archive>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-assembly-plugin</artifactId>\n+                <version>${maven.assembly.plugin.version}</version>\n+                <executions>\n+                    <execution>\n+                        <id>distro-assembly</id>\n+                        <phase>package</phase>\n+                        <goals>\n+                            <goal>single</goal>\n+                        </goals>\n+                        <configuration>\n+                            <descriptorRefs>\n+                                <descriptorRef>jar-with-dependencies</descriptorRef>\n+                            </descriptorRefs>\n+                            <tarLongFileMode>posix</tarLongFileMode>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.elasticsearch.client</groupId>\n+            <artifactId>elasticsearch-rest-high-level-client</artifactId>\n+            <!--\n+            Supports Elastic server 5.6.0+\n+            This is the oldest version of the high level client.\n+            -->\n+            <version>5.6.16</version>\n+        </dependency>\n+\n+        <!-- TEST -->\n+        <dependency>\n+            <groupId>org.elasticsearch.client</groupId>\n+            <artifactId>transport</artifactId>\n+            <version>5.6.16</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU0MjA5Ng=="}, "originalCommit": {"oid": "350190c1070f15730bc00286ebacb52b59c1ec70"}, "originalPosition": 98}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4594, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}