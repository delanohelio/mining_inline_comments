{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2MTMyMDg1", "number": 2120, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwOTowODoxMFrODtA8iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo1MzoxOFrODtEmLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NTI4MDExOnYy", "diffSide": "RIGHT", "path": "site/docs/api/serialization.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwOTowODoxMFrOF-MQOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwOTowODoxMFrOF-MQOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc1Njc5NA==", "bodyText": "wouldn't it be better to mention this earlier in the document? It kind of contradicts the previous section which states all classes must be present on classpath. It must be made into a coherent overall story.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2120#discussion_r400756794", "createdAt": "2020-03-31T09:08:10Z", "author": {"login": "cangencer"}, "path": "site/docs/api/serialization.md", "diffHunk": "@@ -294,3 +294,28 @@ hazelcast:\n All the classes - data types, serializers & hooks - should be present\n on the server classpath, ideally in server's `lib` directory packaged as\n a jar file.\n+\n+### Job-level Serializers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c94c8f82b185c609c0754a96259092d2f511123"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NTg3NTM4OnYy", "diffSide": "RIGHT", "path": "site/docs/api/serialization.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo1MjoyNFrOF-SAhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo1MjoyNFrOF-SAhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MTA3OA==", "bodyText": "but it can still conflict with other global serializers, right?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2120#discussion_r400851078", "createdAt": "2020-03-31T11:52:24Z", "author": {"login": "cangencer"}, "path": "site/docs/api/serialization.md", "diffHunk": "@@ -216,44 +214,68 @@ not to mention very wasteful of memory usage.\n ### Writing Custom Serializers\n \n For best performance and simplest implementation we recommend using\n-[com.hazelcast.nio.serialization.StreamSerializer](https://docs.hazelcast.org/docs/4.0/javadoc/com/hazelcast/nio/serialization/StreamSerializer.html)\n-or\n-[com.hazelcast.nio.serialization.ByteArraySerializer](https://docs.hazelcast.org/docs/4.0/javadoc/com/hazelcast/nio/serialization/ByteArraySerializer.html).\n+[com.hazelcast.nio.serialization.StreamSerializer](https://docs.hazelcast.org/docs/4.0/javadoc/com/hazelcast/nio/serialization/StreamSerializer.html).\n \n Below you can find a sample implementation of `StreamSerializer` for\n-`Person` (mind the type id which should be unique across all serializers):\n+`Person`:\n \n ```java\n class PersonSerializer implements StreamSerializer<Person> {\n \n-        private static final int TYPE_ID = 1;\n-\n-        @Override\n-        public int getTypeId() {\n-            return TYPE_ID;\n-        }\n-\n-        @Override\n-        public void write(ObjectDataOutput out, Person person) throws IOException {\n-            out.writeUTF(person.firstName);\n-            out.writeUTF(person.lastName);\n-            out.writeInt(person.age);\n-            out.writeFloat(person.height);\n-        }\n-\n-        @Override\n-        public Person read(ObjectDataInput in) throws IOException {\n-            return new Person(in.readUTF(), in.readUTF(), in.readInt(), in.readFloat());\n-        }\n+    private static final int TYPE_ID = 1;\n+\n+    @Override\n+    public int getTypeId() {\n+        return TYPE_ID;\n+    }\n+\n+    @Override\n+    public void write(ObjectDataOutput out, Person person) throws IOException {\n+        out.writeUTF(person.firstName);\n+        out.writeUTF(person.lastName);\n+        out.writeInt(person.age);\n+        out.writeFloat(person.height);\n     }\n+\n+    @Override\n+    public Person read(ObjectDataInput in) throws IOException {\n+        return new Person(in.readUTF(), in.readUTF(), in.readInt(), in.readFloat());\n+    }\n+}\n ```\n \n-Then the serializer should be registered with Jet up front on cluster\n-startup. The best way to do is to create a `SerializerHook` which can\n-automatically be registered on startup:\n+#### Registering serializer for the job\n+\n+One way of registering a custom serializer is to do that on a job\n+level. Assuming both, value and serializer classes are already added to\n+the [classpath](submitting-jobs.md), you can simply:\n+\n+```java\n+new JobConfig()\n+    .registerSerializer(Person.class, PersonSerializer.class)\n+```\n+\n+Such serializer is scoped - the type id does not have to be globally", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "712e13ebe7ec4a8671a315b118838641366d47f4"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NTg3ODIwOnYy", "diffSide": "RIGHT", "path": "site/docs/api/serialization.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo1MzoxOFrOF-SCXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo1MzoxOFrOF-SCXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MTU0OA==", "bodyText": "we should mention this is required for supporting querying, projections and so on.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2120#discussion_r400851548", "createdAt": "2020-03-31T11:53:18Z", "author": {"login": "cangencer"}, "path": "site/docs/api/serialization.md", "diffHunk": "@@ -292,5 +314,8 @@ hazelcast:\n ```\n \n All the classes - data types, serializers & hooks - should be present\n-on the server classpath, ideally in server's `lib` directory packaged as\n-a jar file.\n+on the cluster classpath, ideally in server's `lib` directory packaged as\n+a jar file. Moreover, used type ids have to be unique across all\n+serializers.\n+Despite those limitations cluster level serializers offer\n+full support for IMDG [sources and sinks](sources-sinks.md).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "712e13ebe7ec4a8671a315b118838641366d47f4"}, "originalPosition": 124}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4776, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}