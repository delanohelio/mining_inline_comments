{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1NzE3Mzcy", "number": 2117, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNToxNjoxM1rODsuN3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNToxNjoxM1rODsuN3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MjIxMTQ5OnYy", "diffSide": "RIGHT", "path": "site/docs/architecture/fault-tolerance.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNToxNjoxM1rOF9uyww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNToxNjoxM1rOF9uyww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI3NDExNQ==", "bodyText": "a replayable source can..", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2117#discussion_r400274115", "createdAt": "2020-03-30T15:16:13Z", "author": {"login": "cangencer"}, "path": "site/docs/architecture/fault-tolerance.md", "diffHunk": "@@ -15,18 +15,54 @@ then seamlessly continue from that point.\n \n When you configure the processing guarantee for your job as\n _exactly-once_ or _at-least-once_, Hazelcast Jet uses the distributed\n-snapshotting feature to store all the internal computation state to an\n-`IMap`. However, this on its own isn't enough to provide the processing\n-guarantee because the snapshot must cover the entire pipeline, from\n-source to sink. Hazelcast Jet requires certain guarantees from the\n-systems used as sources and sinks in a fault-tolerant data pipeline.\n+snapshotting feature to store all the **internal** computation state to\n+an `IMap`. However, this on its own isn't enough to provide the\n+processing guarantee because the snapshot must cover the entire\n+pipeline, including the external changes performed by sources and sinks.\n+Hazelcast Jet requires certain guarantees from sources and sinks in a\n+fault-tolerant data pipeline.\n \n When the job is restarting after a node failure, Jet resets the whole\n-data pipeline to the state of the last snapshot. For the source this\n-means rewinding back to the point of snapshot, ready to replay the items\n-it already emitted in he previous (failed) job run. For the sink it's\n-usually enough to support idempotence: when Jet's sink connector asks it\n-to apply the same data again, it must simply stay in the same state.\n+data pipeline to the state of the last snapshot. More technically,\n+processors can save arbitrary data to the snapshot and Jet will present\n+that same data to the processors after a restart. Jet performs such\n+snapshots in regular intervals. Sources can cooperate with the job in\n+multiple ways:\n+\n+- **Replayable sources:** a replayable can seek to certain position and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e15cc133ac29eef2a041488460f6920bf82aceb"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4772, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}