{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NTQ3NTYw", "number": 2648, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjoxNTo0NFrOE3xfBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjoxOTo0MFrOFMMrXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTE3ODk0OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-sql/src/test/java/com/hazelcast/jet/sql/SqlJoinTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjoxNTo0NFrOHxUDGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwOTowODozN1rOHxxIIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3MDc0NQ==", "bodyText": "This query can be transformed to\nSELECT 1 FROM b AS b1 JOIN b AS b2 ON 1=1\nor to:\nSELECT 1 FROM b AS b1, b AS b2\nI'm surprised that cross join isn't handled by Calcite before we observe it...", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2648#discussion_r521470745", "createdAt": "2020-11-11T16:15:44Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-sql/src/test/java/com/hazelcast/jet/sql/SqlJoinTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql;\n+\n+import com.hazelcast.jet.sql.impl.connector.test.TestBatchSqlConnector;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+public class SqlJoinTest extends SqlTestSupport {\n+\n+    private static SqlService sqlService;\n+\n+    @BeforeClass\n+    public static void setUpClass() {\n+        initialize(2, null);\n+        sqlService = instance().getSql();\n+    }\n+\n+    @Test\n+    public void test_leftJoinFails() {\n+        TestBatchSqlConnector.create(sqlService, \"b\", 0);\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 LEFT JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"LEFT join not supported\");\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 LEFT OUTER JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"LEFT join not supported\");\n+    }\n+\n+    @Test\n+    public void test_rightJoinFails() {\n+        TestBatchSqlConnector.create(sqlService, \"b\", 0);\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 RIGHT JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"RIGHT join not supported\");\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 RIGHT OUTER JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"RIGHT join not supported\");\n+    }\n+\n+    @Test\n+    public void test_fullJoinFails() {\n+        TestBatchSqlConnector.create(sqlService, \"b\", 0);\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 FULL JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"FULL join not supported\");\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 FULL OUTER JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"FULL join not supported\");\n+    }\n+\n+    @Test\n+    public void test_crossJoinFails() {\n+        TestBatchSqlConnector.create(sqlService, \"b\", 0);\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 CROSS JOIN b AS b2\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d48180dd885d587c1ece17093bc8cd8ddba8294"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0NzE3MQ==", "bodyText": "Enabled CROSS JOINs", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2648#discussion_r521947171", "createdAt": "2020-11-12T09:08:37Z", "author": {"login": "gierlachg"}, "path": "hazelcast-jet-sql/src/test/java/com/hazelcast/jet/sql/SqlJoinTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql;\n+\n+import com.hazelcast.jet.sql.impl.connector.test.TestBatchSqlConnector;\n+import com.hazelcast.sql.SqlService;\n+import com.hazelcast.sql.impl.QueryException;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+public class SqlJoinTest extends SqlTestSupport {\n+\n+    private static SqlService sqlService;\n+\n+    @BeforeClass\n+    public static void setUpClass() {\n+        initialize(2, null);\n+        sqlService = instance().getSql();\n+    }\n+\n+    @Test\n+    public void test_leftJoinFails() {\n+        TestBatchSqlConnector.create(sqlService, \"b\", 0);\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 LEFT JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"LEFT join not supported\");\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 LEFT OUTER JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"LEFT join not supported\");\n+    }\n+\n+    @Test\n+    public void test_rightJoinFails() {\n+        TestBatchSqlConnector.create(sqlService, \"b\", 0);\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 RIGHT JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"RIGHT join not supported\");\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 RIGHT OUTER JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"RIGHT join not supported\");\n+    }\n+\n+    @Test\n+    public void test_fullJoinFails() {\n+        TestBatchSqlConnector.create(sqlService, \"b\", 0);\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 FULL JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"FULL join not supported\");\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 FULL OUTER JOIN b AS b2 ON b1.v = b2.v\"))\n+                .hasCauseInstanceOf(QueryException.class)\n+                .hasMessageContaining(\"FULL join not supported\");\n+    }\n+\n+    @Test\n+    public void test_crossJoinFails() {\n+        TestBatchSqlConnector.create(sqlService, \"b\", 0);\n+\n+        assertThatThrownBy(() -> sqlService.execute(\"SELECT 1 FROM b AS b1 CROSS JOIN b AS b2\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3MDc0NQ=="}, "originalCommit": {"oid": "2d48180dd885d587c1ece17093bc8cd8ddba8294"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTIwMTUyOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/JoinByPredicateProcessorFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjoyMTowMFrOHxUQ9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNzoxNjoyMVrOHygEQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NDI5NQ==", "bodyText": "Don't we need to do type conversion here? Imagine two maps:\nm1: IMap<Integer, Integer>\nm2: IMap<Integer, Long>\nSELECT *\nFROM m1\nJOIN m2 USING(this)\nthe predicate will compare Integer to Long, which is always false.\nMaybe calcite generates Project nodes to do the casting or maybe HZ Predicates handle it, i don't know. But I didn't see a test for that", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2648#discussion_r521474295", "createdAt": "2020-11-11T16:21:00Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/JoinByPredicateProcessorFactory.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.connector.map;\n+\n+import com.hazelcast.function.BiFunctionEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.function.SupplierEx;\n+import com.hazelcast.jet.Traverser;\n+import com.hazelcast.jet.Traversers;\n+import com.hazelcast.jet.core.Processor;\n+import com.hazelcast.jet.impl.processor.TransformP;\n+import com.hazelcast.jet.pipeline.ServiceFactory;\n+import com.hazelcast.jet.sql.impl.ExpressionUtil;\n+import com.hazelcast.jet.sql.impl.JoinInfo;\n+import com.hazelcast.jet.sql.impl.connector.keyvalue.KvRowProjector;\n+import com.hazelcast.jet.sql.impl.connector.map.JoinProcessors.JoinProcessorFactory;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.query.Predicate;\n+import com.hazelcast.query.PredicateBuilder;\n+import com.hazelcast.query.PredicateBuilder.EntryObject;\n+import com.hazelcast.query.Predicates;\n+import com.hazelcast.sql.impl.extract.QueryPath;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map.Entry;\n+\n+final class JoinByPredicateProcessorFactory implements JoinProcessorFactory {\n+\n+    static final JoinByPredicateProcessorFactory INSTANCE = new JoinByPredicateProcessorFactory();\n+\n+    private JoinByPredicateProcessorFactory() {\n+    }\n+\n+    @Override\n+    public Processor create(\n+            ServiceFactory<Object, IMap<Object, Object>> mapFactory,\n+            IMap<Object, Object> map,\n+            QueryPath[] rightPaths,\n+            SupplierEx<KvRowProjector> rightProjectorSupplier,\n+            JoinInfo joinInfo\n+    ) {\n+        return new TransformP<Object[], Object[]>(\n+                joinFn(map, rightPaths, rightProjectorSupplier.get(), joinInfo)\n+        ) {\n+            @Override\n+            public boolean isCooperative() {\n+                return false;\n+            }\n+        };\n+    }\n+\n+    private static FunctionEx<Object[], Traverser<Object[]>> joinFn(\n+            IMap<Object, Object> map,\n+            QueryPath[] rightPaths,\n+            KvRowProjector rightProjector,\n+            JoinInfo joinInfo\n+    ) {\n+        assert joinInfo.isEquiJoin();\n+\n+        int[] leftEquiJoinIndices = joinInfo.leftEquiJoinIndices();\n+        int[] rightEquiJoinIndices = joinInfo.rightEquiJoinIndices();\n+        BiFunctionEx<Object[], Object[], Object[]> joinFn = ExpressionUtil.joinFn(joinInfo.nonEquiCondition());\n+\n+        return left -> {\n+            Predicate<Object, Object> predicate = toPredicate(left, leftEquiJoinIndices, rightEquiJoinIndices, rightPaths);\n+            if (predicate == null) {\n+                return Traversers.empty();\n+            }\n+\n+            List<Object[]> rows = new ArrayList<>();\n+            for (Entry<Object, Object> entry : map.entrySet(predicate)) {\n+                Object[] right = rightProjector.project(entry);\n+                if (right == null) {\n+                    continue;\n+                }\n+\n+                Object[] joined = joinFn.apply(left, right);\n+                if (joined != null) {\n+                    rows.add(joined);\n+                }\n+            }\n+            return Traversers.traverseIterable(rows);\n+        };\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    private static Predicate<Object, Object> toPredicate(\n+            Object[] left,\n+            int[] leftEquiJoinIndices,\n+            int[] rightEquiJoinIndices,\n+            QueryPath[] rightPaths\n+    ) {\n+        PredicateBuilder builder = Predicates.newPredicateBuilder();\n+        EntryObject entryObject = builder.getEntryObject();\n+        for (int i = 0; i < leftEquiJoinIndices.length; i++) {\n+            Comparable leftValue = (Comparable) left[leftEquiJoinIndices[i]];\n+\n+            // might need a change when/if IS NOT DISTINCT FROM is supported\n+            if (leftValue == null) {\n+                return null;\n+            }\n+\n+            QueryPath rightPath = rightPaths[rightEquiJoinIndices[i]];\n+\n+            EntryObject object;\n+            if (rightPath.isKey()) {\n+                object = rightPath.isTop()\n+                        ? entryObject.key()\n+                        : entryObject.key().get(rightPath.getPath());\n+            } else {\n+                object = rightPath.isTop()\n+                        ? entryObject.get(rightPath.toString())\n+                        : entryObject.get(QueryPath.VALUE).get(rightPath.getPath());\n+            }\n+            if (i == 0) {\n+                object.equal(leftValue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d48180dd885d587c1ece17093bc8cd8ddba8294"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcxNjIyNw==", "bodyText": "If types don't match then a CAST is inserted by Calcite and it's not an equi-join.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2648#discussion_r522716227", "createdAt": "2020-11-13T07:16:21Z", "author": {"login": "gierlachg"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/JoinByPredicateProcessorFactory.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.connector.map;\n+\n+import com.hazelcast.function.BiFunctionEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.function.SupplierEx;\n+import com.hazelcast.jet.Traverser;\n+import com.hazelcast.jet.Traversers;\n+import com.hazelcast.jet.core.Processor;\n+import com.hazelcast.jet.impl.processor.TransformP;\n+import com.hazelcast.jet.pipeline.ServiceFactory;\n+import com.hazelcast.jet.sql.impl.ExpressionUtil;\n+import com.hazelcast.jet.sql.impl.JoinInfo;\n+import com.hazelcast.jet.sql.impl.connector.keyvalue.KvRowProjector;\n+import com.hazelcast.jet.sql.impl.connector.map.JoinProcessors.JoinProcessorFactory;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.query.Predicate;\n+import com.hazelcast.query.PredicateBuilder;\n+import com.hazelcast.query.PredicateBuilder.EntryObject;\n+import com.hazelcast.query.Predicates;\n+import com.hazelcast.sql.impl.extract.QueryPath;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map.Entry;\n+\n+final class JoinByPredicateProcessorFactory implements JoinProcessorFactory {\n+\n+    static final JoinByPredicateProcessorFactory INSTANCE = new JoinByPredicateProcessorFactory();\n+\n+    private JoinByPredicateProcessorFactory() {\n+    }\n+\n+    @Override\n+    public Processor create(\n+            ServiceFactory<Object, IMap<Object, Object>> mapFactory,\n+            IMap<Object, Object> map,\n+            QueryPath[] rightPaths,\n+            SupplierEx<KvRowProjector> rightProjectorSupplier,\n+            JoinInfo joinInfo\n+    ) {\n+        return new TransformP<Object[], Object[]>(\n+                joinFn(map, rightPaths, rightProjectorSupplier.get(), joinInfo)\n+        ) {\n+            @Override\n+            public boolean isCooperative() {\n+                return false;\n+            }\n+        };\n+    }\n+\n+    private static FunctionEx<Object[], Traverser<Object[]>> joinFn(\n+            IMap<Object, Object> map,\n+            QueryPath[] rightPaths,\n+            KvRowProjector rightProjector,\n+            JoinInfo joinInfo\n+    ) {\n+        assert joinInfo.isEquiJoin();\n+\n+        int[] leftEquiJoinIndices = joinInfo.leftEquiJoinIndices();\n+        int[] rightEquiJoinIndices = joinInfo.rightEquiJoinIndices();\n+        BiFunctionEx<Object[], Object[], Object[]> joinFn = ExpressionUtil.joinFn(joinInfo.nonEquiCondition());\n+\n+        return left -> {\n+            Predicate<Object, Object> predicate = toPredicate(left, leftEquiJoinIndices, rightEquiJoinIndices, rightPaths);\n+            if (predicate == null) {\n+                return Traversers.empty();\n+            }\n+\n+            List<Object[]> rows = new ArrayList<>();\n+            for (Entry<Object, Object> entry : map.entrySet(predicate)) {\n+                Object[] right = rightProjector.project(entry);\n+                if (right == null) {\n+                    continue;\n+                }\n+\n+                Object[] joined = joinFn.apply(left, right);\n+                if (joined != null) {\n+                    rows.add(joined);\n+                }\n+            }\n+            return Traversers.traverseIterable(rows);\n+        };\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    private static Predicate<Object, Object> toPredicate(\n+            Object[] left,\n+            int[] leftEquiJoinIndices,\n+            int[] rightEquiJoinIndices,\n+            QueryPath[] rightPaths\n+    ) {\n+        PredicateBuilder builder = Predicates.newPredicateBuilder();\n+        EntryObject entryObject = builder.getEntryObject();\n+        for (int i = 0; i < leftEquiJoinIndices.length; i++) {\n+            Comparable leftValue = (Comparable) left[leftEquiJoinIndices[i]];\n+\n+            // might need a change when/if IS NOT DISTINCT FROM is supported\n+            if (leftValue == null) {\n+                return null;\n+            }\n+\n+            QueryPath rightPath = rightPaths[rightEquiJoinIndices[i]];\n+\n+            EntryObject object;\n+            if (rightPath.isKey()) {\n+                object = rightPath.isTop()\n+                        ? entryObject.key()\n+                        : entryObject.key().get(rightPath.getPath());\n+            } else {\n+                object = rightPath.isTop()\n+                        ? entryObject.get(rightPath.toString())\n+                        : entryObject.get(QueryPath.VALUE).get(rightPath.getPath());\n+            }\n+            if (i == 0) {\n+                object.equal(leftValue);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NDI5NQ=="}, "originalCommit": {"oid": "2d48180dd885d587c1ece17093bc8cd8ddba8294"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDA3NTEzOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/IMapSqlConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjoyNDowMVrOHyC0Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjoyNDowMVrOHyC0Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzNjkzOA==", "bodyText": "We should somehow use a distributed-partitioned edge in this case. The map.get call can then be local.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2648#discussion_r522236938", "createdAt": "2020-11-12T16:24:01Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/IMapSqlConnector.java", "diffHunk": "@@ -122,6 +132,69 @@ public final Table createTable(\n         );\n     }\n \n+    @Override\n+    public boolean supportsNestedLoopReader() {\n+        return true;\n+    }\n+\n+    @Nonnull @Override\n+    public Vertex nestedLoopReader(\n+            @Nonnull DAG dag,\n+            @Nonnull Table table0,\n+            @Nullable Expression<Boolean> predicate,\n+            @Nonnull List<Expression<?>> projections,\n+            @Nonnull JetJoinInfo joinInfo\n+    ) {\n+        PartitionedMapTable table = (PartitionedMapTable) table0;\n+\n+        ProcessorSupplier pSupplier;\n+        String name = table.getMapName();\n+        List<TableField> fields = table.getFields();\n+        QueryPath[] paths = fields.stream().map(field -> ((MapTableField) field).getPath()).toArray(QueryPath[]::new);\n+        QueryDataType[] types = fields.stream().map(TableField::getType).toArray(QueryDataType[]::new);\n+        QueryTargetDescriptor keyDescriptor = table.getKeyDescriptor();\n+        QueryTargetDescriptor valueDescriptor = table.getValueDescriptor();\n+\n+        KvRowProjector.Supplier rightRowProjectorSupplier =\n+                KvRowProjector.supplier(paths, types, keyDescriptor, valueDescriptor, predicate, projections);\n+\n+        String desc;\n+        if (isEquiJoinByPrimitiveKey(joinInfo, fields)) {\n+            pSupplier = new JoinByPrimitiveKeyProcessorSupplier(joinInfo, name, rightRowProjectorSupplier);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "168583a337e4b46ea0f078150f365f7a7bf67958"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Nzc4MzgxOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/IMapSqlConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTozODo0NFrOHynRSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTozODo0NFrOHynRSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzNDI0OA==", "bodyText": "We should use this way every time we have an equi-join for right.__key, e.g.:\nSELECT * \nFROM a JOIN b ON a.field=b.__key and b.field=10", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2648#discussion_r522834248", "createdAt": "2020-11-13T09:38:44Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/IMapSqlConnector.java", "diffHunk": "@@ -122,6 +132,69 @@ public final Table createTable(\n         );\n     }\n \n+    @Override\n+    public boolean supportsNestedLoopReader() {\n+        return true;\n+    }\n+\n+    @Nonnull @Override\n+    public Vertex nestedLoopReader(\n+            @Nonnull DAG dag,\n+            @Nonnull Table table0,\n+            @Nullable Expression<Boolean> predicate,\n+            @Nonnull List<Expression<?>> projections,\n+            @Nonnull JetJoinInfo joinInfo\n+    ) {\n+        PartitionedMapTable table = (PartitionedMapTable) table0;\n+\n+        ProcessorSupplier pSupplier;\n+        String name = table.getMapName();\n+        List<TableField> fields = table.getFields();\n+        QueryPath[] paths = fields.stream().map(field -> ((MapTableField) field).getPath()).toArray(QueryPath[]::new);\n+        QueryDataType[] types = fields.stream().map(TableField::getType).toArray(QueryDataType[]::new);\n+        QueryTargetDescriptor keyDescriptor = table.getKeyDescriptor();\n+        QueryTargetDescriptor valueDescriptor = table.getValueDescriptor();\n+\n+        KvRowProjector.Supplier rightRowProjectorSupplier =\n+                KvRowProjector.supplier(paths, types, keyDescriptor, valueDescriptor, predicate, projections);\n+\n+        String desc;\n+        if (isEquiJoinByPrimitiveKey(joinInfo, fields)) {\n+            pSupplier = new JoinByPrimitiveKeyProcessorSupplier(joinInfo, name, rightRowProjectorSupplier);\n+            desc = \"imap.get\";\n+        } else if (joinInfo.isEquiJoin()) {\n+            pSupplier = new JoinByPredicateProcessorSupplier(joinInfo, name, paths, rightRowProjectorSupplier);\n+            desc = \"imap.entrySet(predicate)\";\n+        } else {\n+            pSupplier = new JoinScanProcessorSupplier(joinInfo, name, rightRowProjectorSupplier);\n+            desc = \"imap.entrySet(<full>)\";\n+        }\n+        return dag.newVertex(\n+                \"NestedLoopJoin(\" + toString(table) + \")-\" + desc + \"-\" + randomLetters(),\n+                pSupplier\n+        );\n+    }\n+\n+    private static boolean isEquiJoinByPrimitiveKey(JetJoinInfo joinInfo, List<TableField> fields) {\n+        if (joinInfo.rightEquiJoinIndices().length != 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "168583a337e4b46ea0f078150f365f7a7bf67958"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Nzk5NTIxOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/JoinScanProcessorSupplier.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozODozOVrOHypRFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDozODozOVrOHypRFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2Njk2Ng==", "bodyText": "We should:\n\ncache the result entrySet for some time (like 10 seconds). We should cache it projected.\nshare it among local processors: maybe have a volatile field in the PSupplier and have 0th local processor update it for everyone.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2648#discussion_r522866966", "createdAt": "2020-11-13T10:38:39Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/JoinScanProcessorSupplier.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.connector.map;\n+\n+import com.hazelcast.function.BiFunctionEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.jet.Traverser;\n+import com.hazelcast.jet.Traversers;\n+import com.hazelcast.jet.core.Processor;\n+import com.hazelcast.jet.core.ProcessorSupplier;\n+import com.hazelcast.jet.impl.execution.init.Contexts.ProcSupplierCtx;\n+import com.hazelcast.jet.impl.processor.TransformBatchedP;\n+import com.hazelcast.jet.sql.impl.ExpressionUtil;\n+import com.hazelcast.jet.sql.impl.JetJoinInfo;\n+import com.hazelcast.jet.sql.impl.connector.keyvalue.KvRowProjector;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.DataSerializable;\n+import com.hazelcast.query.impl.getters.Extractors;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map.Entry;\n+\n+@SuppressFBWarnings(\n+        value = {\"SE_BAD_FIELD\", \"SE_NO_SERIALVERSIONID\"},\n+        justification = \"the class is never java-serialized\"\n+)\n+final class JoinScanProcessorSupplier implements ProcessorSupplier, DataSerializable {\n+\n+    private static final int MAX_BATCH_SIZE = 1024;\n+\n+    private JetJoinInfo joinInfo;\n+    private String mapName;\n+    private KvRowProjector.Supplier rightRowProjectorSupplier;\n+\n+    private transient IMap<Object, Object> map;\n+    private transient InternalSerializationService serializationService;\n+    private transient Extractors extractors;\n+\n+    @SuppressWarnings(\"unused\")\n+    private JoinScanProcessorSupplier() {\n+    }\n+\n+    JoinScanProcessorSupplier(\n+            JetJoinInfo joinInfo,\n+            String mapName,\n+            KvRowProjector.Supplier rightRowProjectorSupplier\n+    ) {\n+        this.joinInfo = joinInfo;\n+        this.mapName = mapName;\n+        this.rightRowProjectorSupplier = rightRowProjectorSupplier;\n+    }\n+\n+    @Override\n+    public void init(@Nonnull Context context) {\n+        map = context.jetInstance().getMap(mapName);\n+        serializationService = ((ProcSupplierCtx) context).serializationService();\n+        extractors = Extractors.newBuilder(serializationService).build();\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Collection<? extends Processor> get(int count) {\n+        List<Processor> processors = new ArrayList<>(count);\n+        for (int i = 0; i < count; i++) {\n+            Processor processor = new TransformBatchedP<Object[], Object[]>(\n+                    MAX_BATCH_SIZE,\n+                    joinFn(joinInfo, map, rightRowProjectorSupplier.get(serializationService, extractors))\n+            ) {\n+                @Override\n+                public boolean isCooperative() {\n+                    return false;\n+                }\n+            };\n+            processors.add(processor);\n+        }\n+        return processors;\n+    }\n+\n+    private static FunctionEx<List<? super Object[]>, Traverser<Object[]>> joinFn(\n+            JetJoinInfo joinInfo,\n+            IMap<Object, Object> map,\n+            KvRowProjector rightRowProjector\n+    ) {\n+        BiFunctionEx<Object[], Object[], Object[]> joinFn = ExpressionUtil.joinFn(joinInfo.condition());\n+\n+        return lefts -> {\n+            List<Object[]> rows = new ArrayList<>();\n+            for (Entry<Object, Object> entry : map.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "168583a337e4b46ea0f078150f365f7a7bf67958"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MzM0OTQyOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/JoinScanProcessorSupplier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjoxOTo0MFrOIPy0Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwOTozNTozM1rOIQLhXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzMjExOA==", "bodyText": "Why do we limit the batch size? We do entrySet repeatedly but only in order to have fresh data. But I think the batch can be unlimited here (and it's practically limited already, the inbox has limited size). It might even be better to scan for updated data once per second.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2648#discussion_r553432118", "createdAt": "2021-01-07T16:19:40Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/JoinScanProcessorSupplier.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.connector.map;\n+\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.Traverser;\n+import com.hazelcast.jet.core.Processor;\n+import com.hazelcast.jet.core.ProcessorSupplier;\n+import com.hazelcast.jet.impl.processor.TransformBatchedP;\n+import com.hazelcast.jet.sql.impl.ExpressionUtil;\n+import com.hazelcast.jet.sql.impl.JetJoinInfo;\n+import com.hazelcast.jet.sql.impl.connector.keyvalue.KvRowProjector;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.DataSerializable;\n+import com.hazelcast.projection.Projection;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map.Entry;\n+\n+import static com.hazelcast.jet.Traversers.traverseIterable;\n+import static com.hazelcast.jet.impl.util.Util.extendArray;\n+\n+@SuppressFBWarnings(\n+        value = {\"SE_BAD_FIELD\", \"SE_NO_SERIALVERSIONID\"},\n+        justification = \"the class is never java-serialized\"\n+)\n+final class JoinScanProcessorSupplier implements ProcessorSupplier, DataSerializable {\n+\n+    private static final int MAX_BATCH_SIZE = 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e7685152c9191e01b45808e700dc4732aa0cca5"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzNjg5Mw==", "bodyText": "Removed the limit. I would not cache IMap data as that would change the semantics - i.e. one could not update IMap then produce Kafka record and join it while currently this is the case for all the strategies we use internally.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2648#discussion_r553836893", "createdAt": "2021-01-08T09:35:33Z", "author": {"login": "gierlachg"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/map/JoinScanProcessorSupplier.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.sql.impl.connector.map;\n+\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.Traverser;\n+import com.hazelcast.jet.core.Processor;\n+import com.hazelcast.jet.core.ProcessorSupplier;\n+import com.hazelcast.jet.impl.processor.TransformBatchedP;\n+import com.hazelcast.jet.sql.impl.ExpressionUtil;\n+import com.hazelcast.jet.sql.impl.JetJoinInfo;\n+import com.hazelcast.jet.sql.impl.connector.keyvalue.KvRowProjector;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.DataSerializable;\n+import com.hazelcast.projection.Projection;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map.Entry;\n+\n+import static com.hazelcast.jet.Traversers.traverseIterable;\n+import static com.hazelcast.jet.impl.util.Util.extendArray;\n+\n+@SuppressFBWarnings(\n+        value = {\"SE_BAD_FIELD\", \"SE_NO_SERIALVERSIONID\"},\n+        justification = \"the class is never java-serialized\"\n+)\n+final class JoinScanProcessorSupplier implements ProcessorSupplier, DataSerializable {\n+\n+    private static final int MAX_BATCH_SIZE = 1024;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQzMjExOA=="}, "originalCommit": {"oid": "3e7685152c9191e01b45808e700dc4732aa0cca5"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4447, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}