{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyMzQyNzY5", "number": 2671, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMjo0MjoyMlrOE5_6ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNzoyODozMlrOE6bkYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjUxNTE0OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMjo0MjoyMlrOH0zDdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMzowMTozOVrOH0zuoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEyNDQ3MQ==", "bodyText": "threadSafeStore.forEach(consumer); ?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525124471", "createdAt": "2020-11-17T12:42:22Z", "author": {"login": "gurbuzali"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "diffHunk": "@@ -209,4 +177,42 @@ protected long get() {\n         }\n     }\n \n+    /**\n+     * Map for storing metrics on a per name basis. Meant to offer fast,\n+     * single-threaded access, but also a loosely consistent, thread safe\n+     * way to iterate over the content.\n+     */\n+    private static class MetricsStore {\n+\n+        private Map<String, AbstractMetric> threadLocalStore;\n+        private volatile ConcurrentMap<String, AbstractMetric> threadSafeStore;\n+\n+        /**\n+         * Always called on the same thread, the one executing the Tasklet this context belongs to.\n+         */\n+        Metric localGet(String name, Unit unit, BiFunction<String, Unit, AbstractMetric> metricSupplier) {\n+            if (threadLocalStore == null) { //first metric being stored\n+                threadLocalStore = new HashMap<>();\n+                threadSafeStore = new ConcurrentHashMap<>();\n+            }\n+\n+            AbstractMetric metric = threadLocalStore.get(name);\n+            if (metric != null) {\n+                return metric;\n+            }\n+\n+            metric = metricSupplier.apply(name, unit);\n+            threadLocalStore.put(name, metric);\n+            threadSafeStore.put(name, metric);\n+\n+            return metric;\n+        }\n+\n+        void threadSafeForEach(BiConsumer<? super String, ? super AbstractMetric> consumer) {\n+            if (threadSafeStore != null) {\n+                threadLocalStore.forEach(consumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d38f24e7e7aa3fee93567ca35cf8106330ccd48a"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzNTUyMA==", "bodyText": "Yeah... copy-paste... Fixing it.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525135520", "createdAt": "2020-11-17T13:01:39Z", "author": {"login": "jbartok"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "diffHunk": "@@ -209,4 +177,42 @@ protected long get() {\n         }\n     }\n \n+    /**\n+     * Map for storing metrics on a per name basis. Meant to offer fast,\n+     * single-threaded access, but also a loosely consistent, thread safe\n+     * way to iterate over the content.\n+     */\n+    private static class MetricsStore {\n+\n+        private Map<String, AbstractMetric> threadLocalStore;\n+        private volatile ConcurrentMap<String, AbstractMetric> threadSafeStore;\n+\n+        /**\n+         * Always called on the same thread, the one executing the Tasklet this context belongs to.\n+         */\n+        Metric localGet(String name, Unit unit, BiFunction<String, Unit, AbstractMetric> metricSupplier) {\n+            if (threadLocalStore == null) { //first metric being stored\n+                threadLocalStore = new HashMap<>();\n+                threadSafeStore = new ConcurrentHashMap<>();\n+            }\n+\n+            AbstractMetric metric = threadLocalStore.get(name);\n+            if (metric != null) {\n+                return metric;\n+            }\n+\n+            metric = metricSupplier.apply(name, unit);\n+            threadLocalStore.put(name, metric);\n+            threadSafeStore.put(name, metric);\n+\n+            return metric;\n+        }\n+\n+        void threadSafeForEach(BiConsumer<? super String, ? super AbstractMetric> consumer) {\n+            if (threadSafeStore != null) {\n+                threadLocalStore.forEach(consumer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEyNDQ3MQ=="}, "originalCommit": {"oid": "d38f24e7e7aa3fee93567ca35cf8106330ccd48a"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzAwODI1OnYy", "diffSide": "LEFT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNzoxNDozMVrOH1f3dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNzoxNDozMVrOH1f3dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg1ODY3Ng==", "bodyText": "addUserTag(tagger) is not necessary any more", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525858676", "createdAt": "2020-11-18T07:14:31Z", "author": {"login": "gurbuzali"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "diffHunk": "@@ -50,47 +50,15 @@ Metric threadSafeMetric(String name, Unit unit) {\n     }\n \n     private Metric metric(String name, Unit unit, BiFunction<String, Unit, AbstractMetric> metricSupplier) {\n-        if (metrics == null) { //at most one already defined metric\n-            if (onlyMetric == null) { //no already defined metrics\n-                onlyMetric = metricSupplier.apply(name, unit);\n-                onlyName = name;\n-                return onlyMetric;\n-            } else { //one single already defined metric\n-                if (name.equals(onlyName)) { //single already defined metric same as the requested one\n-                    return onlyMetric;\n-                } else { //single already defined metric different from the requested one\n-                    metrics = new HashMap<>();\n-                    metrics.put(onlyName, onlyMetric);\n-\n-                    onlyMetric = null;\n-                    onlyName = null;\n-\n-                    AbstractMetric metric = metricSupplier.apply(name, unit);\n-                    metrics.put(name, metric);\n-                    return metric;\n-                }\n-            }\n-        } else { //multiple metrics already defined\n-            AbstractMetric metric = metrics.get(name);\n-            if (metric == null) { //requested metric not yet defined\n-                metric = metricSupplier.apply(name, unit);\n-                metrics.put(name, metric);\n-            }\n-            return metric;\n-        }\n+        return store.localGet(name, unit, metricSupplier);\n     }\n \n     @Override\n     public void provideDynamicMetrics(MetricDescriptor tagger, MetricsCollectionContext context) {\n-        if (onlyMetric != null) {\n-            context.collect(\n-                    addUserTag(tagger), onlyName, ProbeLevel.INFO, toProbeUnit(onlyMetric.unit()), onlyMetric.get()\n-            );\n-        } else if (metrics != null) {\n-            MetricDescriptor withUserTag = addUserTag(tagger);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f0e3ec968615c0a33d86c0c981533ab24606bb"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NzA0NTQ3OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwNzoyODozMlrOH1gNtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwODoyMjowOVrOH1h_NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NDM3Mw==", "bodyText": "we are doubling the memory footprint and complicating the implementation to provide a fast local get. Is this really necessary? does it affect the performance that much to use a single ConcurrentHashMap ?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525864373", "createdAt": "2020-11-18T07:28:32Z", "author": {"login": "gurbuzali"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "diffHunk": "@@ -209,4 +177,42 @@ protected long get() {\n         }\n     }\n \n+    /**\n+     * Map for storing metrics on a per name basis. Meant to offer fast,\n+     * single-threaded access, but also a loosely consistent, thread safe\n+     * way to iterate over the content.\n+     */\n+    private static class MetricsStore {\n+\n+        private Map<String, AbstractMetric> threadLocalStore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f0e3ec968615c0a33d86c0c981533ab24606bb"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3NDkzNg==", "bodyText": "The metric method is called for each processed item, so with just using the ConcurrentHashMap, the performance impact might be too big. At least that's what I think...", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525874936", "createdAt": "2020-11-18T07:51:26Z", "author": {"login": "jbartok"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "diffHunk": "@@ -209,4 +177,42 @@ protected long get() {\n         }\n     }\n \n+    /**\n+     * Map for storing metrics on a per name basis. Meant to offer fast,\n+     * single-threaded access, but also a loosely consistent, thread safe\n+     * way to iterate over the content.\n+     */\n+    private static class MetricsStore {\n+\n+        private Map<String, AbstractMetric> threadLocalStore;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NDM3Mw=="}, "originalCommit": {"oid": "36f0e3ec968615c0a33d86c0c981533ab24606bb"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg5MzQyOA==", "bodyText": "I was curious and suspected that a non-contended read-only CHM might be very similar to plain HM because non-contended volatile read on x86 is as fast as a non-volatile read:\nBenchmark     Mode  Cnt   Score   Error  Units\nChmBench.chm  avgt   10  21,687 \u00b1 0,122  ns/op\nChmBench.hm   avgt   10  22,610 \u00b1 0,163  ns/op\n\nsource:\n@BenchmarkMode(Mode.AverageTime)\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@State(Scope.Thread)\n@Fork(value = 1, warmups = 1)\n@Warmup(iterations = 10)\n@Measurement(iterations = 10)\npublic class ChmBench {\n\n    private final Map<String, Integer> chm = new ConcurrentHashMap<>();\n    private final Map<String, Integer> hm = new HashMap<>();\n\n    {\n        chm.put(\"1\", 1);\n        chm.put(\"2\", 2);\n        chm.put(\"3\", 3);\n\n        hm.putAll(chm);\n    }\n\n    @Benchmark\n    public void chm() {\n        chm.get(\"3\");\n        chm.get(\"1\");\n        chm.get(\"2\");\n    }\n\n    @Benchmark\n    public void hm() {\n        hm.get(\"3\");\n        hm.get(\"1\");\n        hm.get(\"2\");\n    }\n}\nMaybe another CPU will be different, I don't know. I used JDK 1.8.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2671#discussion_r525893428", "createdAt": "2020-11-18T08:22:09Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/metrics/MetricsContext.java", "diffHunk": "@@ -209,4 +177,42 @@ protected long get() {\n         }\n     }\n \n+    /**\n+     * Map for storing metrics on a per name basis. Meant to offer fast,\n+     * single-threaded access, but also a loosely consistent, thread safe\n+     * way to iterate over the content.\n+     */\n+    private static class MetricsStore {\n+\n+        private Map<String, AbstractMetric> threadLocalStore;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NDM3Mw=="}, "originalCommit": {"oid": "36f0e3ec968615c0a33d86c0c981533ab24606bb"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4491, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}