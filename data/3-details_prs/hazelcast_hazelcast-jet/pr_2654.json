{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5ODEwMjc4", "number": 2654, "title": "Add SQL CLI as jet sql command", "bodyText": "Add a basic CLI for Jet SQL\n\nAlso some minor refactoring / cleanup of duplicated code\nMove SQL module to lib module", "createdAt": "2020-11-12T11:13:45Z", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654", "merged": true, "mergeCommit": {"oid": "91ed1281f3cbb4f7222d2cbf837f0ff5eced3f14"}, "closed": true, "closedAt": "2020-12-30T07:02:11Z", "author": {"login": "cangencer"}, "timelineItems": {"totalCount": 74, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbwlbfgH2gAyNTE5ODEwMjc4OjM4ZDdiMTQxY2QwODAxYTA0OGM5NjZiNDM4ZDQyZTI1ZjE5OGZiOWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdq4lszgH2gAyNTE5ODEwMjc4OmM3Mzg1ODM0YTg3NzVhYTdkYjdhOWRmOTAzZDIxMTlkMTZmZjFlMjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "38d7b141cd0801a048c966b438d42e25f198fb9d", "author": {"user": {"login": "cangencer", "name": "Can Gencer"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/38d7b141cd0801a048c966b438d42e25f198fb9d", "committedDate": "2020-11-12T11:09:31Z", "message": "Add SQL CLI as jet sql command"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MDg4NTAy", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#pullrequestreview-529088502", "createdAt": "2020-11-12T13:33:28Z", "commit": {"oid": "38d7b141cd0801a048c966b438d42e25f198fb9d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzozMzoyOFrOHx67gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzozMzoyOFrOHx67gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEwNzc3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Command(description = \"Starts the SQL console\")\n          \n          \n            \n                @Command(description = \"Starts the SQL shell [BETA]\")", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r522107778", "createdAt": "2020-11-12T13:33:28Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -179,6 +186,57 @@ public void run() {\n         // top-level command, do nothing\n     }\n \n+    @Command(description = \"Starts the SQL console\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38d7b141cd0801a048c966b438d42e25f198fb9d"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0421d6f8795272c2495d34552e9a605db5a46d01", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/0421d6f8795272c2495d34552e9a605db5a46d01", "committedDate": "2020-11-13T10:11:51Z", "message": "Use JLine to read sql lines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "434dddb76f705b8c0089308ef8e732673f27d472", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/434dddb76f705b8c0089308ef8e732673f27d472", "committedDate": "2020-11-13T14:14:35Z", "message": "Optimize the dependencies to use minimal"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05961914e2faa237f375dc0663dd5220105f995b", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/05961914e2faa237f375dc0663dd5220105f995b", "committedDate": "2020-11-24T11:28:26Z", "message": "Add basic multiline support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be56112b727ff83a8911e51bbabe5f131800fe42", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/be56112b727ff83a8911e51bbabe5f131800fe42", "committedDate": "2020-11-24T11:38:54Z", "message": "Merge remote-tracking branch 'upstream/master' into jet-sql-cli"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32345737916c34076e18b803919c201d89b0003f", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/32345737916c34076e18b803919c201d89b0003f", "committedDate": "2020-11-24T12:02:58Z", "message": "Fix: Inner class must be static"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73ff14ad6c4c9dbe1351410b7037a7a8222d78de", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/73ff14ad6c4c9dbe1351410b7037a7a8222d78de", "committedDate": "2020-11-25T16:16:19Z", "message": "Improve multiline command support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6be306090f175f480bf4e291c970f32949dd0e1", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/d6be306090f175f480bf4e291c970f32949dd0e1", "committedDate": "2020-11-25T16:17:58Z", "message": "Fix checkstyle issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23a0e5a037f26b03e2746d530bca8da0238f4e08", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/23a0e5a037f26b03e2746d530bca8da0238f4e08", "committedDate": "2020-11-30T15:31:32Z", "message": "Improve the output format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3e9628ba44255731c9ac55c660b90c593cabebc", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/a3e9628ba44255731c9ac55c660b90c593cabebc", "committedDate": "2020-12-01T14:34:15Z", "message": "Add a way to cancel a sql query"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24403df629672b33582a2467b04f95afaade4d08", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/24403df629672b33582a2467b04f95afaade4d08", "committedDate": "2020-12-01T16:26:06Z", "message": "Centralize outputs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbf2bb8913d23ce0a82b1ad0423c2e64502d16b6", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/dbf2bb8913d23ce0a82b1ad0423c2e64502d16b6", "committedDate": "2020-12-01T17:05:02Z", "message": "Merge remote-tracking branch 'upstream/master' into jet-sql-cli"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0044eb3e054f3444abd44c0cb6a72d096a6843c3", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/0044eb3e054f3444abd44c0cb6a72d096a6843c3", "committedDate": "2020-12-01T17:23:45Z", "message": "Update hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyOTY0NzMw", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#pullrequestreview-542964730", "createdAt": "2020-12-02T15:39:29Z", "commit": {"oid": "0044eb3e054f3444abd44c0cb6a72d096a6843c3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNTozOTozMFrOH9hBRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNTozOTozMFrOH9hBRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2NjE4Mg==", "bodyText": "We can use ForkJoinPool.commonPool() here.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r534266182", "createdAt": "2020-12-02T15:39:30Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +766,311 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            final int[] roundBracketsBalance = new int[2];\n+            final int[] squareBracketsBalance = new int[2];\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                // once we reach the cursor, set the\n+                // position of the selected index\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        checkBracketBalance(roundBracketsBalance, currentChar, '(', ')');\n+                        checkBracketBalance(squareBracketsBalance, currentChar, '[', ']');\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            if (squareBracketsBalance[0] != 0 || squareBracketsBalance[1] != 0) {\n+                throw new EOFError(-1, cursor, \"Square brackets balance fails\");\n+            }\n+\n+            if (roundBracketsBalance[0] != 0 || roundBracketsBalance[1] != 0) {\n+                throw new EOFError(-1, cursor, \"Round brackets balance fails\");\n+            }\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private void checkBracketBalance(int[] balance, char actual,\n+                                         char openBracket, char closeBracket) {\n+            if (actual == openBracket) {\n+                balance[0]++;\n+            } else if (actual == closeBracket) {\n+                if (balance[0] > 0) {\n+                    balance[0]--;\n+                } else {\n+                    // closed bracket without open\n+                    balance[1]++;\n+                }\n+            }\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 15;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+\n+        ExecutorService executor\n+                = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0044eb3e054f3444abd44c0cb6a72d096a6843c3"}, "originalPosition": 428}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d23ffa7d854358882c95a6db6339d764949f824a", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/d23ffa7d854358882c95a6db6339d764949f824a", "committedDate": "2020-12-03T14:17:48Z", "message": "Add cli prompt messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29623c19c30ca4cf5e9a50c12924cfc6be192370", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/29623c19c30ca4cf5e9a50c12924cfc6be192370", "committedDate": "2020-12-03T14:19:23Z", "message": "Merge branch 'jet-sql-cli' of https://github.com/cangencer/hazelcast-jet into jet-sql-cli"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa14ccdfb1de1bc58b8509aa6c6a850466cfdb1b", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/fa14ccdfb1de1bc58b8509aa6c6a850466cfdb1b", "committedDate": "2020-12-03T14:45:09Z", "message": "Small improvements\n\nRemove parenthesis balance check\nReplace Executors.newSingleThreadExecutor() with ForkJoinPool.commonPool()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4882f030ef5d37f787c38e048741cdf54d2b89b", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/e4882f030ef5d37f787c38e048741cdf54d2b89b", "committedDate": "2020-12-03T16:41:51Z", "message": "Small improvement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53b584c287aa9f92cc2e00e59f1d41aaf34ab0fd", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/53b584c287aa9f92cc2e00e59f1d41aaf34ab0fd", "committedDate": "2020-12-04T08:03:20Z", "message": "Small improvements on output format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a87b0ff61b7985eb899f6b993f8ab95a813941e", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/8a87b0ff61b7985eb899f6b993f8ab95a813941e", "committedDate": "2020-12-04T08:25:31Z", "message": "Improve starting prompt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f40d0ba040a5ad91d962a2b272308511acbf52b1", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/f40d0ba040a5ad91d962a2b272308511acbf52b1", "committedDate": "2020-12-07T07:33:52Z", "message": "Improve starting prompt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5434e6c18094becfc88900c449a40db248c8f6db", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/5434e6c18094becfc88900c449a40db248c8f6db", "committedDate": "2020-12-07T14:20:45Z", "message": "Add colors to outputs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a62ae56331cf460cf0405460add9a2ca117fa3f", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/7a62ae56331cf460cf0405460add9a2ca117fa3f", "committedDate": "2020-12-11T10:23:56Z", "message": "Code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08c23f98ac2d3f23649c1f41b7e5391a8dacf20d", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/08c23f98ac2d3f23649c1f41b7e5391a8dacf20d", "committedDate": "2020-12-11T10:25:21Z", "message": "Merge remote-tracking branch 'upstream/master' into jet-sql-cli"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "065a63b419fabe948cd97b85af433fe40b1a62f5", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/065a63b419fabe948cd97b85af433fe40b1a62f5", "committedDate": "2020-12-11T10:42:54Z", "message": "Code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82ff71fcc1a674c36fdb823e75ae6d635179369a", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/82ff71fcc1a674c36fdb823e75ae6d635179369a", "committedDate": "2020-12-11T12:50:12Z", "message": "Merge remote-tracking branch 'upstream/master' into jet-sql-cli"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d87946c87928bc9a543163381058b2671d40230c", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/d87946c87928bc9a543163381058b2671d40230c", "committedDate": "2020-12-11T15:58:49Z", "message": "Add history command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf9a3b23ce4c6f0fba5d8041cfc88addd8995264", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/bf9a3b23ce4c6f0fba5d8041cfc88addd8995264", "committedDate": "2020-12-16T09:07:21Z", "message": "Merge remote-tracking branch 'upstream/master' into jet-sql-cli"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bb616158675ccd41d5395b7933885edd641a318", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/0bb616158675ccd41d5395b7933885edd641a318", "committedDate": "2020-12-16T11:53:08Z", "message": "Add SQL CLI documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d06c132625e748a310e6032132c6e3ec9ec4dc85", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/d06c132625e748a310e6032132c6e3ec9ec4dc85", "committedDate": "2020-12-16T13:53:16Z", "message": "Update prompts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73a415ff4ebb191f8ef32b15232da87c96a34e2e", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/73a415ff4ebb191f8ef32b15232da87c96a34e2e", "committedDate": "2020-12-16T14:38:38Z", "message": "Add sql docs link to the help prompt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e8f46dd6581431ab187e850c82f7732476a9eea", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/9e8f46dd6581431ab187e850c82f7732476a9eea", "committedDate": "2020-12-16T14:40:48Z", "message": "Fix style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5", "committedDate": "2020-12-18T08:18:41Z", "message": "Add info and error labels to the prompts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1a1c7db8cbe0f8ced4a25d8c2d46fa292847638", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/e1a1c7db8cbe0f8ced4a25d8c2d46fa292847638", "committedDate": "2020-12-21T13:53:16Z", "message": "Add deps for windows CLI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7046f226a5d0cd97ae53a1a4c44fdea1de438e6c", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/7046f226a5d0cd97ae53a1a4c44fdea1de438e6c", "committedDate": "2020-12-21T13:53:39Z", "message": "Address IDE warnings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/b85a56ca44f6ff2db99ecb4141e9131d961715ba", "committedDate": "2020-12-21T13:53:51Z", "message": "Merge remote-tracking branch 'remotes/hazelcast/master' into jet-sql-cli"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MzA3ODkw", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#pullrequestreview-556307890", "createdAt": "2020-12-21T11:19:46Z", "commit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMToyMDoxMVrOIJU7kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMTo0MToyNlrOIJVepw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1MTAyNw==", "bodyText": "it might be nice if these commands worked without the ;. I think it's common elsewhere.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546651027", "createdAt": "2020-12-21T11:20:11Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 603}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1NTE1MQ==", "bodyText": "The line is 106 characters long, which exceeds the traditional size for small terminals of 80 chars. At least it should not be indented.\nTo my taste it's also a bit splashy, something more meek like this would suffice:\n$ ./jet sql\nConnected to Hazelcast Jet 4.4 at 127.0.0.1:5007 (+1 more)\nType 'help' for instructions\nsql>\n\nThe version 4.4 is the cluster version, not client's. The IP is the IP of the 1st member, the +1 more indicates the cluster size (2 in this case).\nThe prompt can be just sql>. If we happen to connect to an imdg cluster, jet commands would not work.\nThe need to use ; and the Ctrl+C will be in the help, many people can figure them out i think.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546655151", "createdAt": "2020-12-21T11:29:43Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")\n+                .append(\"\\n\\t\\t\\t\\t Press Ctrl+C to cancel streaming queries\\n\\n\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 604}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1ODY0NQ==", "bodyText": "What about just OK?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546658645", "createdAt": "2020-12-21T11:38:04Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1OTA3OA==", "bodyText": "We have newline here, but not before an error. I lean towards not having it here.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546659078", "createdAt": "2020-12-21T11:39:02Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 489}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY2MDAwNw==", "bodyText": "The behavior of Ctrl+C, when a query isn't running, is surprising to me: it just exits the terminal. It would be better to just cancel the not-yet-submitted query, I often use that in a linux terminal.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546660007", "createdAt": "2020-12-21T11:41:26Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +813,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";\n+        }\n+\n+        for (int j = 0; j < wsLen / 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.append(colValue);\n+        for (int j = 0; j < wsLen / 2 + wsLen % 2; j++) {\n+            builder.append(' ');\n+        }\n+        builder.style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('|');\n+    }\n+\n+    private static void printSeparatorLine(int colSize, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append('+');\n+        for (int i = 0; i < colSize; i++) {\n+            for (int j = 0; j < colWidth; j++) {\n+                builder.append('-');\n+            }\n+            builder.append('+');\n+        }\n+        out.println(builder.toAnsi());\n+    }\n+\n+    private static class CliPrompts {\n+        static final String STARTING_PROMPT = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR))\n+                .append(\n+                \"\\to   o   o   o---o o---o o     o---o   o   o---o o-o-o        o o---o o-o-o   o---o   o---o   o\\n\" +\n+                \"\\t|   |  / \\\\     /  |     |     |      / \\\\  |       |          | |       |     |       |   |   |\\n\" +\n+                \"\\to---o o---o   o   o-o   |     o     o---o o---o   |          | o-o     |     o---o   o   o   o\\n\" +\n+                \"\\t|   | |   |  /    |     |     |     |   |     |   |      \\\\   | |       |         |   |   |   |\\n\" +\n+                \"\\to   o o   o o---o o---o o---o o---o o   o o---o   o       o--o o---o   o     o---o   o---\\\\\\\\  o---\")\n+                .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                .append(\"\\n\\t\\t\\t\\t Welcome to the Hazelcast Jet SQL Console(BETA)\")\n+                .append(\"\\n\\t\\t\\t\\t Commands end with semicolon\")\n+                .append(\"\\n\\t\\t\\t\\t Type 'HELP;' to display the available commands\")\n+                .append(\"\\n\\t\\t\\t\\t Press Ctrl+C to cancel streaming queries\\n\\n\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e6a420349ee9e4ef41ca7cd41bde25ba2e22c5"}, "originalPosition": 604}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "372bed818f72a9bd19728200e77109300c405ba7", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/372bed818f72a9bd19728200e77109300c405ba7", "committedDate": "2020-12-21T16:21:56Z", "message": "Partially address review comments\n\nReplace responses with more succint sentences\nFix: res.close() NPE issue\nUpdate NOTICE"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NDEwMDEx", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#pullrequestreview-556410011", "createdAt": "2020-12-21T14:16:45Z", "commit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNDoxNjo0NVrOIJZuOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxNjoxOTowNFrOIJd53g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcyOTUzMA==", "bodyText": "We could be a bit more smart here: 5 for boolean, 4 for tinyint, 6 for smallint, 12 for int, 20 for bigint, 8 for time, 10 for date, 19 for timestamp, 25 for timestamp_with_tz, 4 for null, real/double i can't tell from the top of my head and 20 for the rest (varchar, object).\nThis is how we print decimals currently (see price column):\nJET SQL> SELECT * FROM latest_trades;\n+--------------------+--------------------+--------------------+--------------------+\n|       __key        |       ticker       |       price        |       amount       |\n+--------------------+--------------------+--------------------+--------------------+\n|        ABCD        |        ABCD        |5.500000000000000...|         10         |\n|        EFGH        |        EFGH        |14.00000000000000...|         20         |\n+--------------------+--------------------+--------------------+--------------------+", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546729530", "createdAt": "2020-12-21T14:16:45Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 475}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjczMDA2Mg==", "bodyText": "We can use the unicode ellipsis, which is a single character: \u2026. Works fine on windows ;)", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546730062", "createdAt": "2020-12-21T14:17:38Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {\n+                            int nextLine = line.indexOf('\\n', i + 1);\n+                            if (nextLine > lastNonQuoteCommentIndex) {\n+                                i = nextLine;\n+                            } else {\n+                                return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+                            }\n+                        }\n+                    }\n+                }\n+                requiredSemicolon = i == line.length()\n+                        ? requiredSemicolon\n+                        : !lineEmptyOrFinishedWithSemicolon\n+                        || !Character.isWhitespace(line.charAt(i));\n+                if (requiredSemicolon) {\n+                    lineEmptyOrFinishedWithSemicolon = false;\n+                }\n+            }\n+            return !requiredSemicolon || lineEmptyOrFinishedWithSemicolon;\n+        }\n+\n+        private boolean isMultiLineComment(final CharSequence buffer, final int pos) {\n+            return pos < buffer.length() - 1\n+                    && buffer.charAt(pos) == '/'\n+                    && buffer.charAt(pos + 1) == '*';\n+        }\n+\n+        private boolean isOneLineComment(final String buffer, final int pos) {\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            final int newLinePos = buffer.indexOf('\\n');\n+            if ((newLinePos == -1 || newLinePos > pos)\n+                    && buffer.substring(0, pos).trim().isEmpty()) {\n+                for (String oneLineCommentString : oneLineComments) {\n+                    if (pos <= buffer.length() - oneLineCommentString.length()\n+                            && oneLineCommentString\n+                            .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            for (String oneLineCommentString : oneLineComments) {\n+                if (pos <= buffer.length() - oneLineCommentString.length()\n+                        && oneLineCommentString\n+                        .regionMatches(0, buffer, pos, oneLineCommentString.length())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private void executeSqlCmd(JetInstance jet, String command, Terminal terminal) {\n+        PrintWriter out = terminal.writer();\n+        final int colWidth = 20;\n+        AtomicReference<SqlResult> res = new AtomicReference<>();\n+        AtomicInteger rowCount = new AtomicInteger();\n+        ExecutorService executor = ForkJoinPool.commonPool();\n+        Future<?> resultFuture = executor.submit(() -> {\n+            try {\n+                res.set(jet.getSql().execute(command));\n+            } catch (HazelcastSqlException e) {\n+                String errorPrompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.RED))\n+                        .append(\"ERROR\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(e.getMessage())\n+                        .toAnsi();\n+                out.println(errorPrompt);\n+                return;\n+            }\n+            if (res.get().updateCount() == -1) {\n+                printMetadataInfo(res.get().getRowMetadata(), colWidth, out);\n+\n+                for (SqlRow row : res.get()) {\n+                    rowCount.getAndIncrement();\n+                    printRow(row, colWidth, out);\n+                }\n+                if (rowCount.get() > 0) {\n+                    printSeparatorLine(res.get().getRowMetadata().getColumnCount(), colWidth, out);\n+                }\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(String.valueOf(rowCount.get()))\n+                        .append(\" rows selected.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            } else {\n+                String prompt = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"\\n\")\n+                        .append('[')\n+                        .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                        .append(\"INFO\")\n+                        .style(AttributedStyle.BOLD)\n+                        .append(\"] \")\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"The query is successful.\")\n+                        .toAnsi();\n+                out.println(prompt);\n+            }\n+        });\n+\n+        terminal.handle(Terminal.Signal.INT, signal -> resultFuture.cancel(true));\n+\n+        try {\n+            resultFuture.get();\n+        } catch (CancellationException e) {\n+            res.get().close();\n+            String queryCancellationPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"\\n\")\n+                    .append('[')\n+                    .style(AttributedStyle.BOLD.foreground(AttributedStyle.GREEN))\n+                    .append(\"INFO\")\n+                    .style(AttributedStyle.BOLD)\n+                    .append(\"] \")\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(\"Query is cancelled. Until now, total \")\n+                    .append(String.valueOf(rowCount.get()))\n+                    .append(\" rows selected.\")\n+                    .toAnsi();\n+            out.println(queryCancellationPrompt);\n+            out.flush();\n+        } catch (InterruptedException | java.util.concurrent.ExecutionException e) {\n+            res.get().close();\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int colWidth, PrintWriter out) {\n+        int colSize = metadata.getColumnCount();\n+        printSeparatorLine(colSize, colWidth, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colSize; i++) {\n+            String colName = metadata.getColumn(i).getName();\n+            centralize(colWidth, builder, colName);\n+        }\n+        out.println(builder.toAnsi());\n+        printSeparatorLine(colSize, colWidth, out);\n+        out.flush();\n+    }\n+\n+    private static void printRow(SqlRow row, int colWidth, PrintWriter out) {\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        int colSize = row.getMetadata().getColumnCount();\n+        for (int i = 0; i < colSize; i++) {\n+            String colValue = row.getObject(i).toString();\n+            centralize(colWidth, builder, colValue);\n+        }\n+        out.println(builder.toAnsi());\n+        out.flush();\n+    }\n+\n+    private static void centralize(int colWidth, AttributedStringBuilder builder, String colValue) {\n+        builder.style(AttributedStyle.DEFAULT.foreground(PRIMARY_COLOR));\n+        int wsLen = 0;\n+        if (colValue.length() < colWidth) {\n+            wsLen = colWidth - colValue.length();\n+        } else {\n+            colValue = colValue.substring(0, colWidth - 3) + \"...\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 597}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc4OTMyNw==", "bodyText": "When you submit this command, it executes it, even though it doesn't end with ;:\n/**/\n\nSeems that after a multi-line comment it's treated as an end of command.\nAlso this:\n--;", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546789327", "createdAt": "2020-12-21T16:03:21Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MTU2MQ==", "bodyText": "The @see should not be here", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546791561", "createdAt": "2020-12-21T16:07:16Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MjQxNA==", "bodyText": "# is not one line comment in sql. It's probably a feature of sqline.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546792414", "createdAt": "2020-12-21T16:08:49Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 403}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5MzMxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // From one side there is an assumption that multi-line comment\n          \n          \n            \n                                // is completed, from the other side nextNonCommentedChar\n          \n          \n            \n                                // On one hand there is an assumption that multi-line comment\n          \n          \n            \n                                // is completed, on the other hand nextNonCommentedChar", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546793310", "createdAt": "2020-12-21T16:10:27Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 412}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njc5ODA0Ng==", "bodyText": "I think the toffset and ooffset are swapped here, it should have been:\n.regionMatches(i, line, 0, oneLineCommentString.length()))\n\nBut using startsWith will be much more readable IMO:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (i <= buffer.length() - oneLineCommentString.length()\n          \n          \n            \n                                            && oneLineCommentString\n          \n          \n            \n                                            .regionMatches(0, line, i, oneLineCommentString.length())) {\n          \n          \n            \n                                    if (line.substring(i).startsWith(oneLineCommentString)) {\n          \n      \n    \n    \n  \n\nSame for regionMatches above.\nThere also seems to be duplicate code in isOneLineComment below.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r546798046", "createdAt": "2020-12-21T16:19:04Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +814,373 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is mainly taken from\n+     *\n+     * @see <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonCommentData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastNonQuoteCommentIndex = 0;\n+\n+            for (int i = 0; i < line.length(); i++) {\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonCommentData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isMultiLineComment(line, i)) {\n+                        multiLineCommentStart = i;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        if (i - multiLineCommentStart > 2\n+                                && currentChar == '/' && line.charAt(i - 1) == '*') {\n+                            // End the block; arg could be empty, but that's fine\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 && isOneLineComment(line, i)) {\n+                        oneLineCommentStart = i;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        if (currentChar == '\\n') {\n+                            // End the block; arg could be empty, but that's fine\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        containsNonCommentData = true;\n+                        if (!Character.isWhitespace(currentChar)) {\n+                            lastNonQuoteCommentIndex = i;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            final int lastNonQuoteCommentIndex1 =\n+                    lastNonQuoteCommentIndex == line.length() - 1\n+                            && lastNonQuoteCommentIndex - 1 >= 0\n+                            ? lastNonQuoteCommentIndex - 1 : lastNonQuoteCommentIndex;\n+            if (containsNonCommentData\n+                    && !isLineFinishedWithSemicolon(\n+                    lastNonQuoteCommentIndex1, line)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+        /**\n+         * Returns whether a line (already trimmed) ends with a semicolon that\n+         * is not commented with one line comment.\n+         *\n+         * <p>ASSUMPTION: to have correct behavior, this method must be\n+         * called after quote and multi-line comments check calls, which implies that\n+         * there are no non-finished quotations or multi-line comments.\n+         *\n+         * @param buffer Input line to check for ending with ';'\n+         * @return true if the ends with non-commented ';'\n+         */\n+        private boolean isLineFinishedWithSemicolon(\n+                final int lastNonQuoteCommentIndex, final CharSequence buffer) {\n+            final String line = buffer.toString();\n+            boolean lineEmptyOrFinishedWithSemicolon = line.isEmpty();\n+            boolean requiredSemicolon = false;\n+            String[] oneLineComments = {\"#\", \"--\"};\n+            for (int i = lastNonQuoteCommentIndex; i < line.length(); i++) {\n+                if (';' == line.charAt(i)) {\n+                    lineEmptyOrFinishedWithSemicolon = true;\n+                    continue;\n+                } else if (i < line.length() - 1\n+                        && line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                    int nextNonCommentedChar = line.indexOf(\"*/\", i + \"/*\".length());\n+                    // From one side there is an assumption that multi-line comment\n+                    // is completed, from the other side nextNonCommentedChar\n+                    // could be negative or less than lastNonQuoteCommentIndex\n+                    // in case '/*' is a part of quoting string.\n+                    if (nextNonCommentedChar > lastNonQuoteCommentIndex) {\n+                        i = nextNonCommentedChar + \"*/\".length();\n+                    }\n+                } else {\n+                    for (String oneLineCommentString : oneLineComments) {\n+                        if (i <= buffer.length() - oneLineCommentString.length()\n+                                && oneLineCommentString\n+                                .regionMatches(0, line, i, oneLineCommentString.length())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b85a56ca44f6ff2db99ecb4141e9131d961715ba"}, "originalPosition": 422}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a8034be6f1acfbccbba099d50484ee10a40c849", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/5a8034be6f1acfbccbba099d50484ee10a40c849", "committedDate": "2020-12-21T17:14:26Z", "message": "Simplify executeSqlCmd()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59f7b45cf74db877df2a96df8d5f7da84eb794fe", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/59f7b45cf74db877df2a96df8d5f7da84eb794fe", "committedDate": "2020-12-21T17:25:45Z", "message": "Workaround the jline race in signal handlers\n\nSee https://github.com/jline/jline3/pull/629"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc573633cbac0f997596a0905b76ccd8873f6a57", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/fc573633cbac0f997596a0905b76ccd8873f6a57", "committedDate": "2020-12-22T08:27:33Z", "message": "Change the starting prompt wrt. review comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50107f5645bf647706dbb1cf94e94ccb3820196b", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/50107f5645bf647706dbb1cf94e94ccb3820196b", "committedDate": "2020-12-22T09:16:11Z", "message": "Fix wildcard import issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1fcbf704a8b57689c59f3863fcd69b75e7b35e0", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/b1fcbf704a8b57689c59f3863fcd69b75e7b35e0", "committedDate": "2020-12-22T10:22:51Z", "message": "Change styles"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e39ef489aa8959b4963a722701c33f267bbc76f", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/7e39ef489aa8959b4963a722701c33f267bbc76f", "committedDate": "2020-12-22T13:32:28Z", "message": "Simplify the code\n\n- Replace isOneLineComment() and isMultilineComment functions with\none liners\n- Add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9a952ad1a1e9c71e4d8b49412ef4ce1cd5258cf", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/e9a952ad1a1e9c71e4d8b49412ef4ce1cd5258cf", "committedDate": "2020-12-22T14:00:21Z", "message": "Allow special commands to run without semicolon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2905e2a1b0523ee37462ee68338239dbb0d2a74a", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/2905e2a1b0523ee37462ee68338239dbb0d2a74a", "committedDate": "2020-12-22T14:11:05Z", "message": "Update hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a338a7fe06f7427e0df5bc87df7fde69b04d66f3", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/a338a7fe06f7427e0df5bc87df7fde69b04d66f3", "committedDate": "2020-12-22T14:24:45Z", "message": "Remove Set.of() usage to be Java 8 compatible\n\nAlso, remove dot usages from prompts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85ebc0c198a451f2629aa957abd16d4aaaa6ac7b", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/85ebc0c198a451f2629aa957abd16d4aaaa6ac7b", "committedDate": "2020-12-22T14:25:08Z", "message": "Merge branch 'jet-sql-cli' of https://github.com/cangencer/hazelcast-jet into jet-sql-cli"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62a85d6994b083b93d1f9c2e8548167b0c63fa9d", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/62a85d6994b083b93d1f9c2e8548167b0c63fa9d", "committedDate": "2020-12-22T15:33:55Z", "message": "Fix history index issue\n\nHistory index points the last item and when this last item was removed\nthe index did not shift to the previous one. Fix the issue resulting\nfrom this by explicitly calling hist.resetIndex()."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "781c09b8b0525b9c27e294f0c34b6946565db17f", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/781c09b8b0525b9c27e294f0c34b6946565db17f", "committedDate": "2020-12-22T15:49:35Z", "message": "Replace \"...\" with \"\\u2026\""}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a29ede944196916916118c069096f274902e4b4", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/5a29ede944196916916118c069096f274902e4b4", "committedDate": "2020-12-22T16:16:04Z", "message": "Remove unused option"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baa1769895b9d18d6d859399c944b9c21b56b133", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/baa1769895b9d18d6d859399c944b9c21b56b133", "committedDate": "2020-12-23T06:35:26Z", "message": "Simplify and improve parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35fb068bb2863542d465886502a7e525425a208f", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/35fb068bb2863542d465886502a7e525425a208f", "committedDate": "2020-12-23T08:16:18Z", "message": "Determine column widths wrt. column types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "317959cb66906c694bb17aad7ad8105f87c3c7ec", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/317959cb66906c694bb17aad7ad8105f87c3c7ec", "committedDate": "2020-12-23T10:20:46Z", "message": "Fix magic number issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0875bc0f855464e32cfde7bc832a11331f2e811a", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/0875bc0f855464e32cfde7bc832a11331f2e811a", "committedDate": "2020-12-23T12:13:18Z", "message": "Right-aline the number type of columns"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "000205952a81eae3d3d82bb6174d20b6925dfd14", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/000205952a81eae3d3d82bb6174d20b6925dfd14", "committedDate": "2020-12-23T13:04:35Z", "message": "Indicate whether the client connected to the imdg or jet cluster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77ca87751cec9d41774f8dba921b08c53c7d2b55", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/77ca87751cec9d41774f8dba921b08c53c7d2b55", "committedDate": "2020-12-24T12:03:31Z", "message": "Merge remote-tracking branch 'upstream/master' into jet-sql-cli"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39712a9dbd24bc090b8fc42cb4a20fc98b69dd4e", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/39712a9dbd24bc090b8fc42cb4a20fc98b69dd4e", "committedDate": "2020-12-24T14:32:27Z", "message": "Update help prompt\n\nChange help prompt to refer the imdg sql doc when the client connected\n to imdg cluster."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f747d2071b48769139106eb45c3391c339af1610", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/f747d2071b48769139106eb45c3391c339af1610", "committedDate": "2020-12-25T07:51:20Z", "message": "Retry cluster connect forever in sql console"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5839ce105cb3608fdd55cf1e5d7c254172a9ffb6", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/5839ce105cb3608fdd55cf1e5d7c254172a9ffb6", "committedDate": "2020-12-25T08:20:04Z", "message": "Fix dead store to issue"}, "afterCommit": {"oid": "f747d2071b48769139106eb45c3391c339af1610", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/f747d2071b48769139106eb45c3391c339af1610", "committedDate": "2020-12-25T07:51:20Z", "message": "Retry cluster connect forever in sql console"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e65fa58189413f84532c87a4f5fc34af45b2372b", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/e65fa58189413f84532c87a4f5fc34af45b2372b", "committedDate": "2020-12-28T12:57:43Z", "message": "Update the docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47e62991106e421fcf7f388b43e7c2b6dae2b38d", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/47e62991106e421fcf7f388b43e7c2b6dae2b38d", "committedDate": "2020-12-28T13:26:21Z", "message": "Suppress findbugs warning since it generates false positive"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74aaaec71da6258874386ce6ac07fe600a1e5613", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/74aaaec71da6258874386ce6ac07fe600a1e5613", "committedDate": "2020-12-28T15:06:55Z", "message": "Fail the cmd if there are non-whitespace chars after semicolon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MjA4ODYy", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#pullrequestreview-559208862", "createdAt": "2020-12-28T16:15:28Z", "commit": {"oid": "74aaaec71da6258874386ce6ac07fe600a1e5613"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjoxNToyOFrOIL85BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjoxNToyOFrOIL85BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwMjg4NA==", "bodyText": "The condition can be simplified:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (command.length() > 0 && command.lastIndexOf(\";\") == (command.length() - 1)) {\n          \n          \n            \n                            if (command.length() > 0 && command.charAt(command.length() - 1) == ';') {\n          \n      \n    \n    \n  \n\nBut the issue is that this condition breaks the ; handling in MultilineParser. This command failse (note there's no ; at the end):\nsql> select ';' from foo\nThere are non-whitespace characters after the semicolon.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r549402884", "createdAt": "2020-12-28T16:15:28Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -179,6 +212,104 @@ public void run() {\n         // top-level command, do nothing\n     }\n \n+    @Command(description = \"Starts the SQL shell [BETA]\")\n+    public void sql(@Mixin(name = \"verbosity\") Verbosity verbosity,\n+                    @Mixin(name = \"targets\") TargetsMixin targets\n+    ) {\n+        runWithJet(targets, verbosity, true, jet -> {\n+            LineReader reader = LineReaderBuilder.builder().parser(new MultilineParser())\n+                    .variable(LineReader.SECONDARY_PROMPT_PATTERN, new AttributedStringBuilder()\n+                            .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR)).append(\"%M%P > \").toAnsi())\n+                    .variable(LineReader.INDENTATION, 2)\n+                    .option(LineReader.Option.DISABLE_EVENT_EXPANSION, true)\n+                    .appName(\"hazelcast-jet-sql\")\n+                    .build();\n+\n+            AtomicReference<SqlResult> activeSqlResult = new AtomicReference<>();\n+            reader.getTerminal().handle(Signal.INT, signal -> {\n+                SqlResult r = activeSqlResult.get();\n+                if (r != null) {\n+                    r.close();\n+                }\n+            });\n+\n+            PrintWriter writer = reader.getTerminal().writer();\n+            writer.println(sqlStartingPrompt(jet));\n+            writer.flush();\n+\n+            for (; ; ) {\n+                String command;\n+                try {\n+                    command = reader.readLine(new AttributedStringBuilder()\n+                            .style(AttributedStyle.DEFAULT.foreground(SECONDARY_COLOR))\n+                            .append(\"sql> \").toAnsi()).trim();\n+                } catch (EndOfFileException | IOError e) {\n+                    // Ctrl+D, and kill signals result in exit\n+                    writer.println(SQLCliConstants.EXIT_PROMPT);\n+                    writer.flush();\n+                    break;\n+                } catch (UserInterruptException e) {\n+                    // Ctrl+C cancels the not-yet-submitted query\n+                    continue;\n+                }\n+\n+                command = command.trim();\n+                if (command.length() > 0 && command.lastIndexOf(\";\") == (command.length() - 1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74aaaec71da6258874386ce6ac07fe600a1e5613"}, "originalPosition": 129}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17e903b09cc64c7f94dbd4f01683b4c5a407c590", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/17e903b09cc64c7f94dbd4f01683b4c5a407c590", "committedDate": "2020-12-29T06:51:26Z", "message": "Update hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e673b90f2166f0ef59dbb3780555c4e80d0b06ed", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/e673b90f2166f0ef59dbb3780555c4e80d0b06ed", "committedDate": "2020-12-29T07:36:35Z", "message": "Fix quoted, commented semicolon case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDI0NTM3", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#pullrequestreview-559424537", "createdAt": "2020-12-29T08:22:58Z", "commit": {"oid": "e673b90f2166f0ef59dbb3780555c4e80d0b06ed"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyMjo1OFrOIMJvKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwODoyNjo1OFrOIMJ0Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxMzM1NQ==", "bodyText": "Method seems incomplete. For example DECIMAL_FORMAT_LENGTH is unused, we use TIMESTAMP_WITH_TIME_ZONE_FORMAT_LENGTH for DECIMAL. Also at some types we ignore the header length. Maybe we could create determineColumnWidth that would do max(min(header.length(), MAX_HEADER_LENGTH), typeLength).", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r549613355", "createdAt": "2020-12-29T08:22:58Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +847,421 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is adapted from\n+     * <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonWhitespaceData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastSemicolonIdx = -1;\n+            for (int i = 0; i < line.length(); i++) {\n+                // If a one line comment, a multiline comment or a quote is not started before,\n+                // check if the character we're on is a quote character\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonWhitespaceData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 &&\n+                            line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                        // Enter the multiline comment block\n+                        multiLineCommentStart = i;\n+                        containsNonWhitespaceData = true;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        // In a multiline comment block\n+                        if (i - multiLineCommentStart > 2 &&\n+                                line.regionMatches(i - 1, \"*/\", 0, \"*/\".length())) {\n+                            // End the multiline block\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 &&\n+                            line.regionMatches(i, \"--\", 0, \"--\".length())) {\n+                        // Enter the one line comment block\n+                        oneLineCommentStart = i;\n+                        containsNonWhitespaceData = true;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        // In a one line comment\n+                        if (currentChar == '\\n') {\n+                            // End the one line comment block\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        if (currentChar == ';') {\n+                            lastSemicolonIdx = i;\n+                        } else if (!Character.isWhitespace(currentChar)) {\n+                            containsNonWhitespaceData = true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (SQLCliConstants.COMMAND_SET.contains(line.trim().toLowerCase(Locale.US))) {\n+                return;\n+            }\n+            // These EOFError exceptions are captured in LineReader's\n+            // readLine() method and it points out that the command\n+            // being written to console is not finalized and command\n+            // won't be read\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (oneLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"One line comment\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            if (containsNonWhitespaceData &&\n+                    (lastSemicolonIdx == -1 || lastSemicolonIdx >= cursor)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+    }\n+\n+    private void executeSqlCmd(\n+            JetInstance jet,\n+            String command,\n+            Terminal terminal,\n+            AtomicReference<SqlResult> activeSqlResult\n+    ) {\n+        PrintWriter out = terminal.writer();\n+        try (SqlResult sqlResult = jet.getSql().execute(command)) {\n+            activeSqlResult.set(sqlResult);\n+\n+            // if it's a result with an update count, just print it\n+            if (sqlResult.updateCount() != -1) {\n+                String message = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"OK\")\n+                        .toAnsi();\n+                out.println(message);\n+                return;\n+            }\n+            SqlRowMetadata rowMetadata = sqlResult.getRowMetadata();\n+            int[] colWidths = determineColumnWidths(rowMetadata);\n+            Alignment[] alignments = determineAlignments(rowMetadata);\n+\n+            // this is a result with rows. Print the header and rows, watch for concurrent cancellation\n+            printMetadataInfo(rowMetadata, colWidths, alignments, out);\n+\n+            int rowCount = 0;\n+            for (SqlRow row : sqlResult) {\n+                rowCount++;\n+                printRow(row, colWidths, alignments, out);\n+            }\n+\n+            // bottom line after all the rows\n+            printSeparatorLine(sqlResult.getRowMetadata().getColumnCount(), colWidths, out);\n+\n+            String message = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(String.valueOf(rowCount))\n+                    .append(\" row(s) selected\")\n+                    .toAnsi();\n+            out.println(message);\n+        } catch (HazelcastSqlException e) {\n+            // the query failed to execute\n+            String errorPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(e.getMessage())\n+                    .toAnsi();\n+            out.println(errorPrompt);\n+        }\n+    }\n+\n+    private static int[] determineColumnWidths(SqlRowMetadata metadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e673b90f2166f0ef59dbb3780555c4e80d0b06ed"}, "originalPosition": 582}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNDY2Mw==", "bodyText": "We should sanitize the colName the same way we sanitize values on line 1118 below. Or even more, replace every character below 32 with . or something.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#discussion_r549614663", "createdAt": "2020-12-29T08:26:58Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-all/src/main/java/com/hazelcast/jet/server/JetCommandLine.java", "diffHunk": "@@ -712,4 +847,421 @@ static Throwable peel(Throwable e) {\n         }\n     }\n \n+    /**\n+     * A parser for SQL-like inputs. Commands are terminated with a semicolon.\n+     * It is adapted from\n+     * <a href=\"https://github.com/julianhyde/sqlline/blob/master/src/main/java/sqlline/SqlLineParser.java\">\n+     * SqlLineParser</a>\n+     * which is licensed under the BSD-3-Clause License\n+     */\n+    private static final class MultilineParser extends DefaultParser {\n+\n+        private MultilineParser() {\n+        }\n+\n+        @Override\n+        public ParsedLine parse(String line, int cursor, Parser.ParseContext context) throws SyntaxError {\n+            super.setQuoteChars(new char[]{'\\'', '\"'});\n+            super.setEofOnUnclosedQuote(true);\n+            stateCheck(line, cursor);\n+            return new ArgumentList(line, Collections.emptyList(), -1, -1,\n+                    cursor, \"'\", -1, -1);\n+        }\n+\n+        private void stateCheck(String line, int cursor) {\n+            boolean containsNonWhitespaceData = false;\n+            int quoteStart = -1;\n+            int oneLineCommentStart = -1;\n+            int multiLineCommentStart = -1;\n+            int lastSemicolonIdx = -1;\n+            for (int i = 0; i < line.length(); i++) {\n+                // If a one line comment, a multiline comment or a quote is not started before,\n+                // check if the character we're on is a quote character\n+                if (oneLineCommentStart == -1\n+                        && multiLineCommentStart == -1\n+                        && quoteStart < 0\n+                        && (isQuoteChar(line, i))) {\n+                    // Start a quote block\n+                    quoteStart = i;\n+                    containsNonWhitespaceData = true;\n+                } else {\n+                    char currentChar = line.charAt(i);\n+                    if (quoteStart >= 0) {\n+                        // In a quote block\n+                        if ((line.charAt(quoteStart) == currentChar) && !isEscaped(line, i)) {\n+                            // End the block; arg could be empty, but that's fine\n+                            quoteStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 &&\n+                            line.regionMatches(i, \"/*\", 0, \"/*\".length())) {\n+                        // Enter the multiline comment block\n+                        multiLineCommentStart = i;\n+                        containsNonWhitespaceData = true;\n+                    } else if (multiLineCommentStart >= 0) {\n+                        // In a multiline comment block\n+                        if (i - multiLineCommentStart > 2 &&\n+                                line.regionMatches(i - 1, \"*/\", 0, \"*/\".length())) {\n+                            // End the multiline block\n+                            multiLineCommentStart = -1;\n+                        }\n+                    } else if (oneLineCommentStart == -1 &&\n+                            line.regionMatches(i, \"--\", 0, \"--\".length())) {\n+                        // Enter the one line comment block\n+                        oneLineCommentStart = i;\n+                        containsNonWhitespaceData = true;\n+                    } else if (oneLineCommentStart >= 0) {\n+                        // In a one line comment\n+                        if (currentChar == '\\n') {\n+                            // End the one line comment block\n+                            oneLineCommentStart = -1;\n+                        }\n+                    } else {\n+                        // Not in a quote or comment block\n+                        if (currentChar == ';') {\n+                            lastSemicolonIdx = i;\n+                        } else if (!Character.isWhitespace(currentChar)) {\n+                            containsNonWhitespaceData = true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (SQLCliConstants.COMMAND_SET.contains(line.trim().toLowerCase(Locale.US))) {\n+                return;\n+            }\n+            // These EOFError exceptions are captured in LineReader's\n+            // readLine() method and it points out that the command\n+            // being written to console is not finalized and command\n+            // won't be read\n+            if (isEofOnEscapedNewLine() && isEscapeChar(line, line.length() - 1)) {\n+                throw new EOFError(-1, cursor, \"Escaped new line\");\n+            }\n+\n+            if (isEofOnUnclosedQuote() && quoteStart >= 0) {\n+                throw new EOFError(-1, quoteStart, \"Missing closing quote\",\n+                        line.charAt(quoteStart) == '\\'' ? \"quote\" : \"dquote\");\n+            }\n+\n+            if (oneLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"One line comment\");\n+            }\n+\n+            if (multiLineCommentStart != -1) {\n+                throw new EOFError(-1, cursor, \"Missing end of comment\", \"**\");\n+            }\n+\n+            if (containsNonWhitespaceData &&\n+                    (lastSemicolonIdx == -1 || lastSemicolonIdx >= cursor)) {\n+                throw new EOFError(-1, cursor, \"Missing semicolon (;)\");\n+            }\n+        }\n+\n+    }\n+\n+    private void executeSqlCmd(\n+            JetInstance jet,\n+            String command,\n+            Terminal terminal,\n+            AtomicReference<SqlResult> activeSqlResult\n+    ) {\n+        PrintWriter out = terminal.writer();\n+        try (SqlResult sqlResult = jet.getSql().execute(command)) {\n+            activeSqlResult.set(sqlResult);\n+\n+            // if it's a result with an update count, just print it\n+            if (sqlResult.updateCount() != -1) {\n+                String message = new AttributedStringBuilder()\n+                        .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                        .append(\"OK\")\n+                        .toAnsi();\n+                out.println(message);\n+                return;\n+            }\n+            SqlRowMetadata rowMetadata = sqlResult.getRowMetadata();\n+            int[] colWidths = determineColumnWidths(rowMetadata);\n+            Alignment[] alignments = determineAlignments(rowMetadata);\n+\n+            // this is a result with rows. Print the header and rows, watch for concurrent cancellation\n+            printMetadataInfo(rowMetadata, colWidths, alignments, out);\n+\n+            int rowCount = 0;\n+            for (SqlRow row : sqlResult) {\n+                rowCount++;\n+                printRow(row, colWidths, alignments, out);\n+            }\n+\n+            // bottom line after all the rows\n+            printSeparatorLine(sqlResult.getRowMetadata().getColumnCount(), colWidths, out);\n+\n+            String message = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(String.valueOf(rowCount))\n+                    .append(\" row(s) selected\")\n+                    .toAnsi();\n+            out.println(message);\n+        } catch (HazelcastSqlException e) {\n+            // the query failed to execute\n+            String errorPrompt = new AttributedStringBuilder()\n+                    .style(AttributedStyle.BOLD.foreground(PRIMARY_COLOR))\n+                    .append(e.getMessage())\n+                    .toAnsi();\n+            out.println(errorPrompt);\n+        }\n+    }\n+\n+    private static int[] determineColumnWidths(SqlRowMetadata metadata) {\n+        int colCount = metadata.getColumnCount();\n+        int[] colWidths = new int[colCount];\n+        for (int i = 0; i < colCount; i++) {\n+            SqlColumnMetadata colMetadata = metadata.getColumn(i);\n+            SqlColumnType type = colMetadata.getType();\n+            String colName = colMetadata.getName();\n+            switch (type) {\n+                case BOOLEAN:\n+                    colWidths[i] = Math.max(SQLCliConstants.BOOLEAN_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case DATE:\n+                    colWidths[i] = Math.max(SQLCliConstants.DATE_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case TIMESTAMP_WITH_TIME_ZONE:\n+                case DECIMAL:\n+                case REAL:\n+                case DOUBLE:\n+                    colWidths[i] = SQLCliConstants.TIMESTAMP_WITH_TIME_ZONE_FORMAT_LENGTH;\n+                    break;\n+                case INTEGER:\n+                    colWidths[i] = Math.max(SQLCliConstants.INTEGER_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case NULL:\n+                case TINYINT:\n+                    colWidths[i] = Math.max(SQLCliConstants.TINYINT_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case SMALLINT:\n+                    colWidths[i] = Math.max(SQLCliConstants.SMALLINT_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case TIMESTAMP:\n+                    colWidths[i] = Math.max(SQLCliConstants.TIMESTAMP_FORMAT_LENGTH,\n+                            Math.min(colName.length(), SQLCliConstants.VARCHAR_FORMAT_LENGTH));\n+                    break;\n+                case BIGINT:\n+                case VARCHAR:\n+                case OBJECT:\n+                default:\n+                    colWidths[i] = SQLCliConstants.VARCHAR_FORMAT_LENGTH;\n+            }\n+        }\n+        return colWidths;\n+    }\n+\n+    private static Alignment[] determineAlignments(SqlRowMetadata metadata) {\n+        int colCount = metadata.getColumnCount();\n+        Alignment[] alignments = new Alignment[colCount];\n+        for (int i = 0; i < colCount; i++) {\n+            SqlColumnMetadata colMetadata = metadata.getColumn(i);\n+            SqlColumnType type = colMetadata.getType();\n+            String colName = colMetadata.getName();\n+            switch (type) {\n+                case BIGINT:\n+                case DECIMAL:\n+                case DOUBLE:\n+                case INTEGER:\n+                case REAL:\n+                case SMALLINT:\n+                case TINYINT:\n+                    alignments[i] = Alignment.RIGHT;\n+                    break;\n+                case BOOLEAN:\n+                case DATE:\n+                case NULL:\n+                case OBJECT:\n+                case TIMESTAMP:\n+                case VARCHAR:\n+                case TIMESTAMP_WITH_TIME_ZONE:\n+                default:\n+                    alignments[i] = Alignment.CENTER;\n+            }\n+        }\n+        return alignments;\n+    }\n+\n+    private static void printMetadataInfo(SqlRowMetadata metadata, int[] colWidths,\n+                                          Alignment[] alignments, PrintWriter out) {\n+        int colCount = metadata.getColumnCount();\n+        printSeparatorLine(colCount, colWidths, out);\n+        AttributedStringBuilder builder = new AttributedStringBuilder()\n+                .style(AttributedStyle.BOLD.foreground(SECONDARY_COLOR));\n+        builder.append(\"|\");\n+        for (int i = 0; i < colCount; i++) {\n+            String colName = metadata.getColumn(i).getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e673b90f2166f0ef59dbb3780555c4e80d0b06ed"}, "originalPosition": 670}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44ea15061a271e8e1d0d487f4b9022d924482627", "author": {"user": {"login": "ufukyilmaz", "name": null}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/44ea15061a271e8e1d0d487f4b9022d924482627", "committedDate": "2020-12-29T09:50:23Z", "message": "Add left alignment and change center alignments to it\n\nAlso, add small changes to improve readability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c80bcf87c8a9281e77a623027acc94f5e0e7df9b", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/c80bcf87c8a9281e77a623027acc94f5e0e7df9b", "committedDate": "2020-12-29T10:24:29Z", "message": "Touchups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NDY5MTUw", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2654#pullrequestreview-559469150", "createdAt": "2020-12-29T10:25:16Z", "commit": {"oid": "c80bcf87c8a9281e77a623027acc94f5e0e7df9b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be4b1af6457f9d710a113886fdaa176859250551", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/be4b1af6457f9d710a113886fdaa176859250551", "committedDate": "2020-12-29T10:50:03Z", "message": "Improve help text"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7385834a8775aa7db7a9df903d2119d16ff1e22", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/c7385834a8775aa7db7a9df903d2119d16ff1e22", "committedDate": "2020-12-29T10:57:55Z", "message": "Remove tab character in help output"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3510, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}