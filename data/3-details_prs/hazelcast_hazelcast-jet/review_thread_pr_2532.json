{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5MzQ0NDk4", "number": 2532, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMTozMToxNFrOElnPfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMTozNjoxOVrOElnViw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3ODc1NzEwOnYy", "diffSide": "LEFT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/Networking.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMTozMToxNFrOHVLe7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMjowMTowMFrOHVMnbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDI4NQ==", "bodyText": "Is this change mostly about \"FP delete\"? The new code has explicit types on everything, but with the types being Integer, Map etc., their true meaning is not known, and previously there were lambda parameters with descriptive names. I don't see a win here.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2532#discussion_r491970285", "createdAt": "2020-09-21T11:31:14Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/Networking.java", "diffHunk": "@@ -129,23 +131,26 @@ private void broadcastFlowControlPacket() {\n         }\n     }\n \n-    private byte[] createFlowControlPacket(Address member) throws IOException {\n+    private byte[] createFlowControlPacket(Address member, Connection expectedConnection) throws IOException {\n         try (BufferObjectDataOutput output = createObjectDataOutput(nodeEngine, lastFlowPacketSize)) {\n-            final boolean[] hasData = {false};\n+            boolean hasData = false;\n             Map<Long, ExecutionContext> executionContexts = jobExecutionService.getExecutionContextsFor(member);\n             output.writeInt(executionContexts.size());\n-            executionContexts.forEach((execId, exeCtx) -> uncheckRun(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "112e78192a14f1a2788d121bfdd505beabc8b1aa"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4ODg0NQ==", "bodyText": "I guess FP means functional programming. Then yes. It also creates less garbage and it's easier to debug.\nThe only real change is the argument to updateAndGetSendSeqLimitCompressed IIRC.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2532#discussion_r491988845", "createdAt": "2020-09-21T12:01:00Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/Networking.java", "diffHunk": "@@ -129,23 +131,26 @@ private void broadcastFlowControlPacket() {\n         }\n     }\n \n-    private byte[] createFlowControlPacket(Address member) throws IOException {\n+    private byte[] createFlowControlPacket(Address member, Connection expectedConnection) throws IOException {\n         try (BufferObjectDataOutput output = createObjectDataOutput(nodeEngine, lastFlowPacketSize)) {\n-            final boolean[] hasData = {false};\n+            boolean hasData = false;\n             Map<Long, ExecutionContext> executionContexts = jobExecutionService.getExecutionContextsFor(member);\n             output.writeInt(executionContexts.size());\n-            executionContexts.forEach((execId, exeCtx) -> uncheckRun(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDI4NQ=="}, "originalCommit": {"oid": "112e78192a14f1a2788d121bfdd505beabc8b1aa"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3ODc3MjU5OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/ReceiverTasklet.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMTozNjoxOVrOHVLoNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxMjowMzozMlrOHVMshg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MjY2MA==", "bodyText": "Does this just make a problem less likely? Since the read and write of this variable are concurrent to each other?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2532#discussion_r491972660", "createdAt": "2020-09-21T11:36:19Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/ReceiverTasklet.java", "diffHunk": "@@ -208,9 +217,14 @@ public int updateAndGetSendSeqLimitCompressed() {\n      *\n      * @param timestampNow value of the timestamp at the time the method is called. The timestamp\n      *                     must be obtained from {@code System.nanoTime()}.\n+     * @param expectedConnection The connection to which the result will be sent. We use it\n+     *                           to check that it's the same connection the tasklet was crated with.\n      */\n     // Invoked sequentially by a task scheduler\n-    int updateAndGetSendSeqLimitCompressed(long timestampNow) {\n+    int updateAndGetSendSeqLimitCompressed(long timestampNow, Connection expectedConnection) {\n+        if (!Objects.equals(expectedConnection, memberConnection)) {\n+            connectionChanged = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "112e78192a14f1a2788d121bfdd505beabc8b1aa"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk5MDE1MA==", "bodyText": "It should prevent the problem completely. The connectionChanged is checked in a loop so if it's changed to true (and it's only ever changed to true), it will be noticed, the error will be thrown and the job will fail and not get stuck.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2532#discussion_r491990150", "createdAt": "2020-09-21T12:03:32Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/ReceiverTasklet.java", "diffHunk": "@@ -208,9 +217,14 @@ public int updateAndGetSendSeqLimitCompressed() {\n      *\n      * @param timestampNow value of the timestamp at the time the method is called. The timestamp\n      *                     must be obtained from {@code System.nanoTime()}.\n+     * @param expectedConnection The connection to which the result will be sent. We use it\n+     *                           to check that it's the same connection the tasklet was crated with.\n      */\n     // Invoked sequentially by a task scheduler\n-    int updateAndGetSendSeqLimitCompressed(long timestampNow) {\n+    int updateAndGetSendSeqLimitCompressed(long timestampNow, Connection expectedConnection) {\n+        if (!Objects.equals(expectedConnection, memberConnection)) {\n+            connectionChanged = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MjY2MA=="}, "originalCommit": {"oid": "112e78192a14f1a2788d121bfdd505beabc8b1aa"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4575, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}