{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMjQwMTM5", "number": 2382, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNTozMDoxOFrOEP0cIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMDoyNDo1OVrOESv-FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDIzMjY1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/StreamSourceLong.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNTozMDoxOFrOGzsrSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMTo1NDozMVrOGzu7bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MjUzNg==", "bodyText": "Javadoc must be wrapped so that line length is 72 chars (ignoring initial indentation or *)", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456862536", "createdAt": "2020-07-19T05:30:18Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/StreamSourceLong.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.HOURS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Represents a StreamSource containing Long values which can be used\n+ * for performance pipeline testing and development.\n+ *\n+ * @since 4.3\n+ */\n+public class StreamSourceLong extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+    private static final long SIMPLE_TIME_SPAN_MILLIS = HOURS.toMillis(3);\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final boolean isReportingThroughput;\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    /**\n+     * Creates a stream source for Long values that is supposed to be used for performance testing purposes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5OTQzOA==", "bodyText": "Done w/ 8fcf108", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456899438", "createdAt": "2020-07-19T11:54:31Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/StreamSourceLong.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.HOURS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Represents a StreamSource containing Long values which can be used\n+ * for performance pipeline testing and development.\n+ *\n+ * @since 4.3\n+ */\n+public class StreamSourceLong extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+    private static final long SIMPLE_TIME_SPAN_MILLIS = HOURS.toMillis(3);\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final boolean isReportingThroughput;\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    /**\n+     * Creates a stream source for Long values that is supposed to be used for performance testing purposes.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MjUzNg=="}, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDIzMzc0OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNTozMTo1OVrOGzsrzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMTo1NDo0NVrOGzu7jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MjY2OQ==", "bodyText": "Wrap the params like this:\npublic static StreamSource<Long> longStreamSource(\n    long itemsPerSecond, long initialDelay, int preferredLocalParallelism\n) {", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456862669", "createdAt": "2020-07-19T05:31:59Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -213,50 +167,70 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n         }\n     }\n \n-    private static BatchSource<Long> longBatchSource(long range, int stepSize) {\n-        return SourceBuilder\n-                .batch(\"longs\", c -> new LongAccumulator())\n-                .<Long>fillBufferFn(new LongSource(range, stepSize)::fillBufferFn)\n-                .build();\n+    /**\n+     * Returns a stream source that contains long values and does late materialization\n+     * of values after distributing them across the cluster, which is useful for high-throughput\n+     * testing.\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStreamSource(long itemsPerSecond, long initialDelay) {\n+        return longStreamSource(itemsPerSecond, initialDelay, Vertex.LOCAL_PARALLELISM_USE_DEFAULT, false);\n     }\n \n-    private static StreamSource<Long> longStreamSource(long range, int stepSize) {\n-        return SourceBuilder\n-                .stream(\"longs\", c -> new LongAccumulator())\n-                .<Long>fillBufferFn(new LongSource(range, stepSize, true)::fillBufferFn)\n-                .build();\n+    /**\n+     * Returns a stream source that contains long values and does late materialization\n+     * of values after distributing them across the cluster, which is useful for high-throughput\n+     * testing.\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStreamSource(long itemsPerSecond, long initialDelay,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5OTQ2OQ==", "bodyText": "Done w/ 8fcf108", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456899469", "createdAt": "2020-07-19T11:54:45Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -213,50 +167,70 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n         }\n     }\n \n-    private static BatchSource<Long> longBatchSource(long range, int stepSize) {\n-        return SourceBuilder\n-                .batch(\"longs\", c -> new LongAccumulator())\n-                .<Long>fillBufferFn(new LongSource(range, stepSize)::fillBufferFn)\n-                .build();\n+    /**\n+     * Returns a stream source that contains long values and does late materialization\n+     * of values after distributing them across the cluster, which is useful for high-throughput\n+     * testing.\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStreamSource(long itemsPerSecond, long initialDelay) {\n+        return longStreamSource(itemsPerSecond, initialDelay, Vertex.LOCAL_PARALLELISM_USE_DEFAULT, false);\n     }\n \n-    private static StreamSource<Long> longStreamSource(long range, int stepSize) {\n-        return SourceBuilder\n-                .stream(\"longs\", c -> new LongAccumulator())\n-                .<Long>fillBufferFn(new LongSource(range, stepSize, true)::fillBufferFn)\n-                .build();\n+    /**\n+     * Returns a stream source that contains long values and does late materialization\n+     * of values after distributing them across the cluster, which is useful for high-throughput\n+     * testing.\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStreamSource(long itemsPerSecond, long initialDelay,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MjY2OQ=="}, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDIzNTE1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNTozNDoyNFrOGzssdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMTo1NDo1NVrOGzu7pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MjgzNw==", "bodyText": "Test method names shouldn't use _ arbitrarily. We use the camelCase except for the special format: when_preCondition_then_postCondition. The latter naming scheme is preferable for test methods.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456862837", "createdAt": "2020-07-19T05:34:24Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -50,29 +50,21 @@ public void test_items() {\n     }\n \n     @Test\n-    public void test_long_batch_range() {\n-        int upperValueRange = 10_000;\n-        Long[] input = LongStream.range(0, upperValueRange).boxed().toArray(Long[]::new);\n-        List<Long> expected = Arrays.asList(input);\n-\n-        TestSources.batchStageForLongRange(p, upperValueRange, 10)\n-                .apply(\n-                        Assertions.assertAnyOrder(expected)\n-                );\n-\n-        jet().newJob(p).join();\n-    }\n-\n-    @Test\n-    public void test_long_stream_range() throws Throwable {\n-        int upperValueRange = 10_000;\n-        Long[] input = LongStream.range(0, upperValueRange).boxed().toArray(Long[]::new);\n+    public void test_stream_source_long() throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5OTQ5NA==", "bodyText": "Done w/ 8fcf108", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456899494", "createdAt": "2020-07-19T11:54:55Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -50,29 +50,21 @@ public void test_items() {\n     }\n \n     @Test\n-    public void test_long_batch_range() {\n-        int upperValueRange = 10_000;\n-        Long[] input = LongStream.range(0, upperValueRange).boxed().toArray(Long[]::new);\n-        List<Long> expected = Arrays.asList(input);\n-\n-        TestSources.batchStageForLongRange(p, upperValueRange, 10)\n-                .apply(\n-                        Assertions.assertAnyOrder(expected)\n-                );\n-\n-        jet().newJob(p).join();\n-    }\n-\n-    @Test\n-    public void test_long_stream_range() throws Throwable {\n-        int upperValueRange = 10_000;\n-        Long[] input = LongStream.range(0, upperValueRange).boxed().toArray(Long[]::new);\n+    public void test_stream_source_long() throws Throwable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MjgzNw=="}, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDI0MTQ1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/StreamSourceLong.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNTo0MzowNFrOGzsvSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMTo1NTowM1rOGzu7tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MzU2Mw==", "bodyText": "You can reorder these two calls so that emitEvents() is first, then detectAndReportHiccup(). It is a bit cleaner that way.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456863563", "createdAt": "2020-07-19T05:43:04Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/StreamSourceLong.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.HOURS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Represents a StreamSource containing Long values which can be used\n+ * for performance pipeline testing and development.\n+ *\n+ * @since 4.3\n+ */\n+public class StreamSourceLong extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+    private static final long SIMPLE_TIME_SPAN_MILLIS = HOURS.toMillis(3);\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final boolean isReportingThroughput;\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    /**\n+     * Creates a stream source for Long values that is supposed to be used for performance testing purposes.\n+     *\n+     * @since 4.3\n+     */\n+    @Nonnull\n+    public StreamSourceLong(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy,\n+            boolean shouldReportThroughput\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();\n+        this.startTime = MILLISECONDS.toNanos(startTime + nanoTimeMillisToCurrentTimeMillis);\n+        this.itemsPerSecond = itemsPerSecond;\n+        this.isReportingThroughput = shouldReportThroughput;\n+    }\n+\n+    @Override\n+    protected void init(Context context) {\n+        totalParallelism = context.totalParallelism();\n+        globalProcessorIndex = context.globalProcessorIndex();\n+        emitPeriod = SECONDS.toNanos(1) * totalParallelism / itemsPerSecond;\n+        lastCallNanos = lastReport = emitSchedule =\n+                startTime + SECONDS.toNanos(1) * globalProcessorIndex / itemsPerSecond;\n+    }\n+\n+    @Override\n+    public boolean complete() {\n+        nowNanos = System.nanoTime();\n+        detectAndReportHiccup();\n+        emitEvents();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5OTUxMQ==", "bodyText": "Done w/ 8fcf108", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456899511", "createdAt": "2020-07-19T11:55:03Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/StreamSourceLong.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.HOURS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Represents a StreamSource containing Long values which can be used\n+ * for performance pipeline testing and development.\n+ *\n+ * @since 4.3\n+ */\n+public class StreamSourceLong extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+    private static final long SIMPLE_TIME_SPAN_MILLIS = HOURS.toMillis(3);\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final boolean isReportingThroughput;\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    /**\n+     * Creates a stream source for Long values that is supposed to be used for performance testing purposes.\n+     *\n+     * @since 4.3\n+     */\n+    @Nonnull\n+    public StreamSourceLong(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy,\n+            boolean shouldReportThroughput\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();\n+        this.startTime = MILLISECONDS.toNanos(startTime + nanoTimeMillisToCurrentTimeMillis);\n+        this.itemsPerSecond = itemsPerSecond;\n+        this.isReportingThroughput = shouldReportThroughput;\n+    }\n+\n+    @Override\n+    protected void init(Context context) {\n+        totalParallelism = context.totalParallelism();\n+        globalProcessorIndex = context.globalProcessorIndex();\n+        emitPeriod = SECONDS.toNanos(1) * totalParallelism / itemsPerSecond;\n+        lastCallNanos = lastReport = emitSchedule =\n+                startTime + SECONDS.toNanos(1) * globalProcessorIndex / itemsPerSecond;\n+    }\n+\n+    @Override\n+    public boolean complete() {\n+        nowNanos = System.nanoTime();\n+        detectAndReportHiccup();\n+        emitEvents();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MzU2Mw=="}, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTgwMzMzOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo0ODowOVrOG1DLTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjozNDoxMFrOG2ShvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3OTc1OQ==", "bodyText": "could these methods be moved to the top? we shouldn't have interleaving methods/inner classes", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458279759", "createdAt": "2020-07-21T17:48:09Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3OTgzNw==", "bodyText": "done in d476f97", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459579837", "createdAt": "2020-07-23T16:34:10Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3OTc1OQ=="}, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTgwNTAzOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo0ODozNlrOG1DMZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjozNzoyOVrOG2Spcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDAzOA==", "bodyText": "what unit is this in? is it in real-time or event time?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458280038", "createdAt": "2020-07-21T17:48:36Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4MTgxMA==", "bodyText": "Unit is added in d476f97.\nIt is real-time, however, it only affects the earliest timestamp that is going to be emitted.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459581810", "createdAt": "2020-07-23T16:37:29Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDAzOA=="}, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTgwNzE3OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo0OToxM1rOG1DNwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjozMzoyMlrOG2Sf8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDM4NQ==", "bodyText": "preferredLocalParallelism  can be already set at source stage level. What does it bring here?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458280385", "createdAt": "2020-07-21T17:49:13Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {\n+        return streamSourceLong(itemsPerSecond, initialDelay, Vertex.LOCAL_PARALLELISM_USE_DEFAULT);\n+    }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     * @param preferredLocalParallelism the preferred local parallelism\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(\n+            long itemsPerSecond, long initialDelay, int preferredLocalParallelism", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2Nzk0NA==", "bodyText": "As far as I can see, you can set the localParallelism at the stage level. Both, localParallelism and preferredLocalParallelism are considered in Vertex.determineLocalParallelism(int defaultParallelism):\n/**\n* Determines the local parallelism value for the vertex by looking\n* its local parallelism and meta supplier's preferred local parallelism.\n* If none of them is set, returns the provided default parallelism\n*/\nDoes that answer your question?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458667944", "createdAt": "2020-07-22T09:40:53Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {\n+        return streamSourceLong(itemsPerSecond, initialDelay, Vertex.LOCAL_PARALLELISM_USE_DEFAULT);\n+    }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     * @param preferredLocalParallelism the preferred local parallelism\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(\n+            long itemsPerSecond, long initialDelay, int preferredLocalParallelism", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDM4NQ=="}, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MDM2Ng==", "bodyText": "I guess we could remove preferredLocalParallelism from here, we have this feature for custom source implementations that can declare their preferred parallelism. But, since this is for ephemeral sources, we don't need it and can use sourceStage.setLocalParallelism()", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458790366", "createdAt": "2020-07-22T13:27:22Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {\n+        return streamSourceLong(itemsPerSecond, initialDelay, Vertex.LOCAL_PARALLELISM_USE_DEFAULT);\n+    }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     * @param preferredLocalParallelism the preferred local parallelism\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(\n+            long itemsPerSecond, long initialDelay, int preferredLocalParallelism", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDM4NQ=="}, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3OTM3Ng==", "bodyText": "removed with d476f97", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459579376", "createdAt": "2020-07-23T16:33:22Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {\n+        return streamSourceLong(itemsPerSecond, initialDelay, Vertex.LOCAL_PARALLELISM_USE_DEFAULT);\n+    }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     * @param preferredLocalParallelism the preferred local parallelism\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(\n+            long itemsPerSecond, long initialDelay, int preferredLocalParallelism", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDM4NQ=="}, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTgxMDA5OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo0OTo1OFrOG1DPiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjozODoxOVrOG2Srcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDg0Mw==", "bodyText": "javadoc lacks detail about what timestamps the items will have", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458280843", "createdAt": "2020-07-21T17:49:58Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4MjMyMg==", "bodyText": "Information got extended with d476f97", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459582322", "createdAt": "2020-07-23T16:38:19Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDg0Mw=="}, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTgxMzIyOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo1MDo1NFrOG1DRpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjozMzo0MVrOG2SglQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MTM4MQ==", "bodyText": "TestSources.longStream would be a better name I think, to mirror itemStream", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458281381", "createdAt": "2020-07-21T17:50:54Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3OTU0MQ==", "bodyText": "done in d476f97", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459579541", "createdAt": "2020-07-23T16:33:41Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MTM4MQ=="}, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODkyMzg4OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMDozOFrOG2aKwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjoxNTozMlrOG2kNrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNTAyNA==", "bodyText": "why not .collect(toList()) directly?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459705024", "createdAt": "2020-07-23T20:20:38Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -48,6 +49,30 @@ public void test_items() {\n         jet().newJob(p).join();\n     }\n \n+    @Test\n+    public void test_longStream() throws Throwable {\n+        int itemsPerSecond = 10;\n+        int timeout = 10;\n+        int numberOfExpectedValues = timeout * itemsPerSecond;\n+        Long[] input = LongStream.range(0, numberOfExpectedValues).boxed().toArray(Long[]::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTYxMg==", "bodyText": "Done with 2752257", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459869612", "createdAt": "2020-07-24T06:15:32Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -48,6 +49,30 @@ public void test_items() {\n         jet().newJob(p).join();\n     }\n \n+    @Test\n+    public void test_longStream() throws Throwable {\n+        int itemsPerSecond = 10;\n+        int timeout = 10;\n+        int numberOfExpectedValues = timeout * itemsPerSecond;\n+        Long[] input = LongStream.range(0, numberOfExpectedValues).boxed().toArray(Long[]::new);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNTAyNA=="}, "originalCommit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODkyNTc0OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMTowOFrOG2aL5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjoxNTo0MlrOG2kNxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNTMxOA==", "bodyText": "I don't think you need the fully qualified name here, package is already imported.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459705318", "createdAt": "2020-07-23T20:21:08Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} that emits an", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTYzNw==", "bodyText": "Done with 2752257", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459869637", "createdAt": "2020-07-24T06:15:42Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} that emits an", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNTMxOA=="}, "originalCommit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODkzMDQzOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMjozMlrOG2aO1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjoxNTo0OVrOG2kN2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNjA3MQ==", "bodyText": "in pipeline code, we always have . in the beginning of the line rather than end of previous.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459706071", "createdAt": "2020-07-23T20:22:32Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -48,6 +49,30 @@ public void test_items() {\n         jet().newJob(p).join();\n     }\n \n+    @Test\n+    public void test_longStream() throws Throwable {\n+        int itemsPerSecond = 10;\n+        int timeout = 10;\n+        int numberOfExpectedValues = timeout * itemsPerSecond;\n+        Long[] input = LongStream.range(0, numberOfExpectedValues).boxed().toArray(Long[]::new);\n+        List<Long> expected = Arrays.asList(input);\n+\n+        p.readFrom(TestSources.longStream(itemsPerSecond, 0)).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2OTY1Nw==", "bodyText": "Done with 2752257", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459869657", "createdAt": "2020-07-24T06:15:49Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -48,6 +49,30 @@ public void test_items() {\n         jet().newJob(p).join();\n     }\n \n+    @Test\n+    public void test_longStream() throws Throwable {\n+        int itemsPerSecond = 10;\n+        int timeout = 10;\n+        int numberOfExpectedValues = timeout * itemsPerSecond;\n+        Long[] input = LongStream.range(0, numberOfExpectedValues).boxed().toArray(Long[]::new);\n+        List<Long> expected = Arrays.asList(input);\n+\n+        p.readFrom(TestSources.longStream(itemsPerSecond, 0)).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNjA3MQ=="}, "originalCommit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ4MTM2OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxODo0NlrOG4ByYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo0NDo0OFrOG5DTjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMjcyMA==", "bodyText": "I would just inline this constant.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461402720", "createdAt": "2020-07-28T08:18:46Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3NjE3NQ==", "bodyText": "See other comment by @mtopolnik: \"This and the one above were used as configurable parameters when this code was local. I'd leave them as constants now and potentially expose them for configuration later on.\"", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r462476175", "createdAt": "2020-07-29T17:44:48Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMjcyMA=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ4MjM0OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxOTowNVrOG4BzEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODoyNjozM1rOG5Ez-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMjg5Nw==", "bodyText": "Why don't we use nanos here too? We wouldn't have to convert below.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461402897", "createdAt": "2020-07-28T08:19:05Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5NzQ2Ng==", "bodyText": "This and the one above were used as configurable parameters when this code was local. I'd leave them as constants now and potentially expose them for configuration later on.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461497466", "createdAt": "2020-07-28T11:03:55Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMjg5Nw=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwMDg1Ng==", "bodyText": "Threshold unit hint incorporated w/ df1ad0b", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r462500856", "createdAt": "2020-07-29T18:26:33Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMjg5Nw=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDcyODA1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOToyMDozNFrOG4EKzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo1ODoxN1rOG5DzkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0MTc0MA==", "bodyText": "The processor name should match the method name.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461441740", "createdAt": "2020-07-28T09:20:34Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStream(long eventsPerSecond, long initialDelayMillis) {\n+        return Sources.streamFromProcessorWithWatermarks(\"longValues\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4NDM2OQ==", "bodyText": "resolved w/ 05f23c8", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r462484369", "createdAt": "2020-07-29T17:58:17Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStream(long eventsPerSecond, long initialDelayMillis) {\n+        return Sources.streamFromProcessorWithWatermarks(\"longValues\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0MTc0MA=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDc4MzUzOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOTozNToxMFrOG4EtUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOTozNToxMFrOG4EtUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MDU3OA==", "bodyText": "We ignore the timestampFn in the eventTimePolicy. We also ignore the wrapFn: the pipeline will throw errors if one uses withoutTimestamp: it throws division by 0 because wmGranularity is 0 in that case.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461450578", "createdAt": "2020-07-28T09:35:10Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    LongStreamSourceP(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDgwODYyOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOTo0MTozN1rOG4E8kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODowMToyOFrOG5D7GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NDQ4MA==", "bodyText": "minor: We get a different startTime for each member. Not sure we need to fix it, the members can still have drifted clocks, but maybe comment about it here...", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461454480", "createdAt": "2020-07-28T09:41:37Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStream(long eventsPerSecond, long initialDelayMillis) {\n+        return Sources.streamFromProcessorWithWatermarks(\"longValues\",\n+                true,\n+                eventTimePolicy -> ProcessorMetaSupplier.of(\n+                        (Address ignored) -> {\n+                            long startTime = System.currentTimeMillis() + initialDelayMillis;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5ODQ2Mw==", "bodyText": "The intention was to give the same startTime for all members, it should be rewritten to ensure it.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461498463", "createdAt": "2020-07-28T11:05:53Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStream(long eventsPerSecond, long initialDelayMillis) {\n+        return Sources.streamFromProcessorWithWatermarks(\"longValues\",\n+                true,\n+                eventTimePolicy -> ProcessorMetaSupplier.of(\n+                        (Address ignored) -> {\n+                            long startTime = System.currentTimeMillis() + initialDelayMillis;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NDQ4MA=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4NjI5Nw==", "bodyText": "resolved w/ 703d740", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r462486297", "createdAt": "2020-07-29T18:01:28Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStream(long eventsPerSecond, long initialDelayMillis) {\n+        return Sources.streamFromProcessorWithWatermarks(\"longValues\",\n+                true,\n+                eventTimePolicy -> ProcessorMetaSupplier.of(\n+                        (Address ignored) -> {\n+                            long startTime = System.currentTimeMillis() + initialDelayMillis;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NDQ4MA=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDgxMjI4OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOTo0MjozNlrOG4E-7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODowMzoxMVrOG5D-4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NTA4Ng==", "bodyText": "Extra line", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461455086", "createdAt": "2020-07-28T09:42:36Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4NzI2Ng==", "bodyText": "resolved w/ 81e3d4f", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r462487266", "createdAt": "2020-07-29T18:03:11Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NTA4Ng=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDgyNDQxOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOTo0NTo0NFrOG4FGdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozMDo0MFrOG5bcnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NzAxNQ==", "bodyText": "We should use withNativeTimestamps(0) because that's what gets assigned to the items.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461457015", "createdAt": "2020-07-28T09:45:44Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -48,6 +50,29 @@ public void test_items() {\n         jet().newJob(p).join();\n     }\n \n+    @Test\n+    public void test_longStream() throws Throwable {\n+        int itemsPerSecond = 10;\n+        int timeout = 10;\n+        int numberOfExpectedValues = timeout * itemsPerSecond;\n+        List<Long> expected = LongStream.range(0, numberOfExpectedValues).boxed().collect(toList());\n+\n+        p.readFrom(TestSources.longStream(itemsPerSecond, 0))\n+                .withIngestionTimestamps()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MTcwOA==", "bodyText": "Resolved w/ fdf3cea", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r462871708", "createdAt": "2020-07-30T09:30:40Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -48,6 +50,29 @@ public void test_items() {\n         jet().newJob(p).join();\n     }\n \n+    @Test\n+    public void test_longStream() throws Throwable {\n+        int itemsPerSecond = 10;\n+        int timeout = 10;\n+        int numberOfExpectedValues = timeout * itemsPerSecond;\n+        List<Long> expected = LongStream.range(0, numberOfExpectedValues).boxed().collect(toList());\n+\n+        p.readFrom(TestSources.longStream(itemsPerSecond, 0))\n+                .withIngestionTimestamps()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NzAxNQ=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDgyNjg1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOTo0NjoyNFrOG4FH8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODoyOTozOFrOG5E6wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NzM5Mg==", "bodyText": "We should get the logger in init from context.getLogger()", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461457392", "createdAt": "2020-07-28T09:46:24Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwMjU5Mg==", "bodyText": "Resolved w/ 82b4287", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r462502592", "createdAt": "2020-07-29T18:29:38Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NzM5Mg=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDgzMTUwOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOTo0Nzo0NVrOG4FLDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMTowNzo1NlrOG4HsCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1ODE5MA==", "bodyText": "We can initialize the coutner with globalProcessorIndex and add totalParallelism in each iteration. This way we'll avoid the calculation each time.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461458190", "createdAt": "2020-07-28T09:47:45Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    LongStreamSourceP(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();\n+        this.startTime = MILLISECONDS.toNanos(startTime + nanoTimeMillisToCurrentTimeMillis);\n+        this.itemsPerSecond = itemsPerSecond;\n+    }\n+\n+    @Override\n+    protected void init(@Nonnull Context context) {\n+        totalParallelism = context.totalParallelism();\n+        globalProcessorIndex = context.globalProcessorIndex();\n+        emitPeriod = SECONDS.toNanos(1) * totalParallelism / itemsPerSecond;\n+        lastCallNanos = lastReport = emitSchedule =\n+                startTime + SECONDS.toNanos(1) * globalProcessorIndex / itemsPerSecond;\n+    }\n+\n+    @Override\n+    public boolean complete() {\n+        nowNanos = System.nanoTime();\n+        emitEvents();\n+        detectAndReportHiccup();\n+        if (logger.isFineEnabled()) {\n+            reportThroughput();\n+        }\n+        return false;\n+    }\n+\n+    private void emitEvents() {\n+        while (emitFromTraverser(traverser) && emitSchedule <= nowNanos) {\n+            long timestamp = NANOSECONDS.toMillis(emitSchedule) - nanoTimeMillisToCurrentTimeMillis;\n+            traverser.append(jetEvent(timestamp, counter * totalParallelism + globalProcessorIndex));\n+            counter++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5OTQwMg==", "bodyText": "This would break the invariant we rely on elsewhere, for the counter value to match the number of emitted events. The overhead of calculation isn't a concern, I think.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461499402", "createdAt": "2020-07-28T11:07:56Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    LongStreamSourceP(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();\n+        this.startTime = MILLISECONDS.toNanos(startTime + nanoTimeMillisToCurrentTimeMillis);\n+        this.itemsPerSecond = itemsPerSecond;\n+    }\n+\n+    @Override\n+    protected void init(@Nonnull Context context) {\n+        totalParallelism = context.totalParallelism();\n+        globalProcessorIndex = context.globalProcessorIndex();\n+        emitPeriod = SECONDS.toNanos(1) * totalParallelism / itemsPerSecond;\n+        lastCallNanos = lastReport = emitSchedule =\n+                startTime + SECONDS.toNanos(1) * globalProcessorIndex / itemsPerSecond;\n+    }\n+\n+    @Override\n+    public boolean complete() {\n+        nowNanos = System.nanoTime();\n+        emitEvents();\n+        detectAndReportHiccup();\n+        if (logger.isFineEnabled()) {\n+            reportThroughput();\n+        }\n+        return false;\n+    }\n+\n+    private void emitEvents() {\n+        while (emitFromTraverser(traverser) && emitSchedule <= nowNanos) {\n+            long timestamp = NANOSECONDS.toMillis(emitSchedule) - nanoTimeMillisToCurrentTimeMillis;\n+            traverser.append(jetEvent(timestamp, counter * totalParallelism + globalProcessorIndex));\n+            counter++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1ODE5MA=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDk1NTI1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMDoyNDoxN1rOG4GYLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMDoyNDoxN1rOG4GYLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3NzkzMg==", "bodyText": "Minor: We are not precise if there's a remainder. Instead of emitPeriod and emitSchedule we can calculate the expected counter value at current time and emit until it's greater than the current value. See for example here.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461477932", "createdAt": "2020-07-28T10:24:17Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    LongStreamSourceP(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();\n+        this.startTime = MILLISECONDS.toNanos(startTime + nanoTimeMillisToCurrentTimeMillis);\n+        this.itemsPerSecond = itemsPerSecond;\n+    }\n+\n+    @Override\n+    protected void init(@Nonnull Context context) {\n+        totalParallelism = context.totalParallelism();\n+        globalProcessorIndex = context.globalProcessorIndex();\n+        emitPeriod = SECONDS.toNanos(1) * totalParallelism / itemsPerSecond;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDk1NzY1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMDoyNDo1OVrOG4GZjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODozODoyMlrOG5FObA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3ODI4NA==", "bodyText": "We need to document:\n\nthat the emitted value is the timestamp value\nthat one has to use withNativeTimestamps(0) because other options are ignored (unless we fix it)\nthat members should have clocks synchronized", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461478284", "createdAt": "2020-07-28T10:24:59Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzODk5OA==", "bodyText": "The actual behavior is that the emitted value is a sequence 0,1,2,...\nAbout synchronized clocks: they should always be synchronized for member of a cluster so this doesn't create a new requirement. However, this can have a <strong>NOTE</strong> telling that the clock skew between any two members may result in an artificial increase of latency.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r462138998", "createdAt": "2020-07-29T08:45:26Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3ODI4NA=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwNzYyOA==", "bodyText": "Corresponding extension of Javadoc done w/ 680f042", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r462507628", "createdAt": "2020-07-29T18:38:22Z", "author": {"login": "guenter-hesse"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3ODI4NA=="}, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 140}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4659, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}