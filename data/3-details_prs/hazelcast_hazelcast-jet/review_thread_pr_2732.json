{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyNTk3ODMy", "number": 2732, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjo1MDowNVrOFB4KTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNzo0MDoxN1rOFCK8SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTEzMDM4OnYy", "diffSide": "RIGHT", "path": "extensions/kafka/src/main/java/com/hazelcast/jet/kafka/impl/StreamKafkaP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjo1MDowNVrOIAwNiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNjo1MDowNVrOIAwNiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2MDgwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    getLogger().info(\"New partition(s) handled: \" + newAssignments);\n          \n          \n            \n                    getLogger().info(\"New partition(s) assigned: \" + newAssignments);", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2732#discussion_r537660809", "createdAt": "2020-12-07T16:50:05Z", "author": {"login": "gierlachg"}, "path": "extensions/kafka/src/main/java/com/hazelcast/jet/kafka/impl/StreamKafkaP.java", "diffHunk": "@@ -107,60 +106,63 @@ protected void init(@Nonnull Context context) {\n         processorIndex = context.globalProcessorIndex();\n         totalParallelism = context.totalParallelism();\n         consumer = new KafkaConsumer<>(properties);\n-        assignPartitions(false);\n     }\n \n-    private void assignPartitions(boolean seekToBeginning) {\n+    private void assignPartitions() {\n         if (System.nanoTime() < nextMetadataCheck) {\n             return;\n         }\n-        boolean allEqual = true;\n-        for (int i = 0; i < topics.size(); i++) {\n-            int newCount = consumer.partitionsFor(topics.get(i)).size();\n-            allEqual &= partitionCounts[i] == newCount;\n-            partitionCounts[i] = newCount;\n-        }\n-        if (allEqual) {\n-            return;\n-        }\n-\n-        KafkaPartitionAssigner assigner = new KafkaPartitionAssigner(topics, partitionCounts, totalParallelism);\n-        Set<TopicPartition> newAssignments = assigner.topicPartitionsFor(processorIndex);\n-        logFinest(getLogger(), \"Currently assigned partitions: %s\", newAssignments);\n-\n-        newAssignments.removeAll(currentAssignment.keySet());\n-        if (!newAssignments.isEmpty()) {\n-            getLogger().info(\"Partition assignments changed, added partitions: \" + newAssignments);\n-            for (TopicPartition tp : newAssignments) {\n-                currentAssignment.put(tp, currentAssignment.size());\n-            }\n-            eventTimeMapper.addPartitions(newAssignments.size());\n-            consumer.assign(currentAssignment.keySet());\n-            if (seekToBeginning) {\n-                // for newly detected partitions, we should always seek to the beginning\n-                consumer.seekToBeginning(newAssignments);\n+        for (int topicIndex = 0; topicIndex < topics.size(); topicIndex++) {\n+            int newPartitionCount;\n+            String topicName = topics.get(topicIndex);\n+            try {\n+                newPartitionCount = consumer.partitionsFor(topicName, Duration.ofSeconds(1)).size();\n+            } catch (TimeoutException e) {\n+                // If we fail to get the metadata, don't try other topics (they are likely to fail too)\n+                getLogger().warning(\"Unable to get partition metadata, ignoring: \" + e, e);\n+                return;\n             }\n+\n+            handleNewPartitions(topicIndex, newPartitionCount);\n         }\n \n-        createOrExtendOffsetsArrays();\n         nextMetadataCheck = System.nanoTime() + METADATA_CHECK_INTERVAL_NANOS;\n     }\n \n-    private void createOrExtendOffsetsArrays() {\n-        for (int topicIdx = 0; topicIdx < partitionCounts.length; topicIdx++) {\n-            int newPartitionCount = partitionCounts[topicIdx];\n-            String topicName = topics.get(topicIdx);\n-            long[] oldOffsets = offsets.get(topicName);\n-            if (oldOffsets != null && oldOffsets.length == newPartitionCount) {\n-                continue;\n-            }\n-            long[] newOffsets = new long[newPartitionCount];\n-            Arrays.fill(newOffsets, -1);\n-            if (oldOffsets != null) {\n-                arraycopy(oldOffsets, 0, newOffsets, 0, oldOffsets.length);\n+    private void handleNewPartitions(int topicIndex, int newPartitionCount) {\n+        String topicName = topics.get(topicIndex);\n+        long[] oldTopicOffsets = offsets.get(topicName);\n+        if (oldTopicOffsets.length >= newPartitionCount) {\n+            return;\n+        }\n+        // extend the offsets array for this topic\n+        long[] newOffsets = Arrays.copyOf(oldTopicOffsets, newPartitionCount);\n+        Arrays.fill(newOffsets, oldTopicOffsets.length, newOffsets.length, -1);\n+        offsets.put(topicName, newOffsets);\n+        Collection<TopicPartition> newAssignments = new ArrayList<>();\n+        for (int partition = oldTopicOffsets.length; partition < newPartitionCount; partition++) {\n+            if (handledByThisProcessor(topicIndex, partition)) {\n+                TopicPartition tp = new TopicPartition(topicName, partition);\n+                currentAssignment.put(tp, currentAssignment.size());\n+                newAssignments.add(tp);\n             }\n-            offsets.put(topicName, newOffsets);\n         }\n+        if (newAssignments.isEmpty()) {\n+            return;\n+        }\n+        getLogger().info(\"New partition(s) handled: \" + newAssignments);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0d12238f53bc5ee9251cb76af167f90a3c98ef4"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3ODIwNzQ1OnYy", "diffSide": "RIGHT", "path": "extensions/kafka/src/test/java/com/hazelcast/jet/kafka/impl/StreamKafkaPTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNzo0MDoxN1rOIBLQfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNzo0MDoxN1rOIBLQfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEwMzkzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertTrue(processor.   currentAssignment.isEmpty());\n          \n          \n            \n                    assertTrue(processor.currentAssignment.isEmpty());", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2732#discussion_r538103933", "createdAt": "2020-12-08T07:40:17Z", "author": {"login": "gierlachg"}, "path": "extensions/kafka/src/test/java/com/hazelcast/jet/kafka/impl/StreamKafkaPTest.java", "diffHunk": "@@ -244,7 +246,7 @@ public void when_noAssignedPartitionAndAddedLater_then_resumesFromIdle() throws\n                 .setTotalParallelism(INITIAL_PARTITION_COUNT + 1)\n                 .setGlobalProcessorIndex(INITIAL_PARTITION_COUNT));\n \n-        assertTrue(processor.currentAssignment.isEmpty());\n+        assertTrue(processor.   currentAssignment.isEmpty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0d12238f53bc5ee9251cb76af167f90a3c98ef4"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4347, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}