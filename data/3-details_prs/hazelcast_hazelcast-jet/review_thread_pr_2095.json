{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNjQ1NjA4", "number": 2095, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNjowNVrODvAL3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozNTozN1rODvgBjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjEyNzAwOnYy", "diffSide": "RIGHT", "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/GrpcServices.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNjowNVrOGBLLHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNjowNVrOGBLLHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NDgyOA==", "bodyText": "Typo", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r403884828", "createdAt": "2020-04-06T07:36:05Z", "author": {"login": "frant-hartm"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/GrpcServices.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc;\n+\n+import com.hazelcast.function.BiConsumerEx;\n+import com.hazelcast.function.BiFunctionEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.function.SupplierEx;\n+import com.hazelcast.jet.grpc.impl.BidirectionalStreamingService;\n+import com.hazelcast.jet.grpc.impl.UnaryService;\n+import com.hazelcast.jet.pipeline.GeneralStage;\n+import com.hazelcast.jet.pipeline.ServiceFactory;\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Provides {@link ServiceFactory} implementations for calling gRPC\n+ * endpoints. The {@code ServiceFactory} created are designed to be\n+ * used with the {@link GeneralStage#mapUsingServiceAsync(ServiceFactory, BiFunctionEx) mapUsingServiceAsync}\n+ * transform.\n+ * <p>\n+ * Currently two types of gRPC services are supported:\n+ * <oul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d58731b54d50757430ecf246b7df8f6182176e41"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDU1NDgzOnYy", "diffSide": "RIGHT", "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/GrpcUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzowNjozOVrOGB1seQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzowNjozOVrOGB1seQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4MTQ5Nw==", "bodyText": "I would go with simple if else... it's 2 lines longer, but doesn't make my eyes turn back to my skull.\n        if (exception instanceof StatusException) {\n            return new StatusExceptionJet((StatusException) exception);\n        } else if (exception instanceof StatusRuntimeException) {\n            return new StatusRuntimeExceptionJet((StatusRuntimeException) exception);\n        } else {\n            return exception;\n        }", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r404581497", "createdAt": "2020-04-07T07:06:39Z", "author": {"login": "frant-hartm"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/GrpcUtil.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc.impl;\n+\n+import io.grpc.StatusException;\n+import io.grpc.StatusRuntimeException;\n+\n+public final class GrpcUtil {\n+\n+    private GrpcUtil() {\n+    }\n+\n+    /**\n+     * {@link io.grpc.StatusException} and {@link io.grpc.StatusRuntimeException}\n+     * break the Serializable contract, see\n+     * <a href=\"https://github.com/grpc/grpc-java/issues/1913\">gRPC Issue #1913</a>.\n+     * This method replaces them with serializable ones.\n+     *\n+     * @param exception the exception to examine and possibly replace\n+     * @return the same exception or a replacement if needed\n+     */\n+    public static Throwable translateGrpcException(Throwable exception) {\n+        return (exception instanceof StatusException)\n+                ? new StatusExceptionJet((StatusException) exception)\n+                : (exception instanceof StatusRuntimeException)\n+                ? new StatusRuntimeExceptionJet((StatusRuntimeException) exception)\n+                : exception;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY1MDM1OnYy", "diffSide": "RIGHT", "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/GrpcService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMzowOVrOGB2moA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMTowMTo0MVrOGB-RuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjM4NA==", "bodyText": "This means that for each service method defined in proto we need new instance of GrpcService, right?\nNot saying it's wrong, just checking it is conscious decision.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r404596384", "createdAt": "2020-04-07T07:33:09Z", "author": {"login": "frant-hartm"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/GrpcService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc;\n+\n+import com.hazelcast.function.BiFunctionEx;\n+import com.hazelcast.jet.pipeline.GeneralStage;\n+import com.hazelcast.jet.pipeline.ServiceFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Represents a gRPC service that can be used as part of a {@link\n+ * GeneralStage#mapUsingServiceAsync(ServiceFactory, BiFunctionEx)\n+ * mapUsingServiceAsync} call. Use {@link GrpcServices} to create a service.\n+ *\n+ * @param <T> type of the request object\n+ * @param <R> type of the response object\n+ *\n+ * @since 4.1\n+ */\n+@FunctionalInterface\n+public interface GrpcService<T, R> {\n+\n+    /**\n+     * Calls the requested service and returns a future which will be\n+     * completed with the result once a response is received.\n+     */\n+    @Nonnull\n+    CompletableFuture<R> call(@Nonnull T input);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyMjEwNA==", "bodyText": "Yes, it only covers calling one service. Technically you could combine multiple service factories into one, but this would require some additional work", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r404722104", "createdAt": "2020-04-07T11:01:41Z", "author": {"login": "cangencer"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/GrpcService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc;\n+\n+import com.hazelcast.function.BiFunctionEx;\n+import com.hazelcast.jet.pipeline.GeneralStage;\n+import com.hazelcast.jet.pipeline.ServiceFactory;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Represents a gRPC service that can be used as part of a {@link\n+ * GeneralStage#mapUsingServiceAsync(ServiceFactory, BiFunctionEx)\n+ * mapUsingServiceAsync} call. Use {@link GrpcServices} to create a service.\n+ *\n+ * @param <T> type of the request object\n+ * @param <R> type of the response object\n+ *\n+ * @since 4.1\n+ */\n+@FunctionalInterface\n+public interface GrpcService<T, R> {\n+\n+    /**\n+     * Calls the requested service and returns a future which will be\n+     * completed with the result once a response is received.\n+     */\n+    @Nonnull\n+    CompletableFuture<R> call(@Nonnull T input);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NjM4NA=="}, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDY1NzEzOnYy", "diffSide": "RIGHT", "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/UnaryService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozNDo1MlrOGB2qtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo1OTo0MFrOGCjbEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NzQzMQ==", "bodyText": "Is this ever going to be called? Should we check the future is completed when it is called or throw some exception if it shouldn't be called.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r404597431", "createdAt": "2020-04-07T07:34:52Z", "author": {"login": "frant-hartm"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/UnaryService.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc.impl;\n+\n+import com.hazelcast.function.BiConsumerEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.grpc.GrpcService;\n+import io.grpc.ManagedChannel;\n+import io.grpc.stub.StreamObserver;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+public final class UnaryService<T, R> implements GrpcService<T, R> {\n+\n+    private final BiConsumerEx<? super T, ? super StreamObserver<R>> callFn;\n+\n+    public UnaryService(\n+            @Nonnull ManagedChannel channel,\n+            @Nonnull FunctionEx<? super ManagedChannel, ? extends BiConsumerEx<T, StreamObserver<R>>> callStubFn\n+    ) {\n+        callFn = callStubFn.apply(channel);\n+    }\n+\n+    @Override @Nonnull\n+    public CompletableFuture<R> call(@Nonnull T input) {\n+        Observer<R> o = new Observer<>();\n+        callFn.accept(input, o);\n+        return o.future;\n+    }\n+\n+    public void destroy() {\n+    }\n+\n+    private static class Observer<O> implements StreamObserver<O> {\n+        private final CompletableFuture<O> future;\n+\n+        Observer() {\n+            this.future = new CompletableFuture<>();\n+        }\n+\n+        @Override\n+        public void onNext(O value) {\n+            if (!future.complete(value)) {\n+                throw new JetException(\"UnaryService.Observer.onNext() called, but its future is already completed\");\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            future.completeExceptionally(GrpcUtil.translateGrpcException(t));\n+        }\n+\n+        @Override\n+        public void onCompleted() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyMzI3OA==", "bodyText": "Yes it gets called. originally we were completing the future here, but it requires a volatile because gRPC doesn't guarantee same thread calls onComplete with onNext. I think it's more correct to do it it was previously. We don't want to complete the future if it would fail for some reason between onNext() and onCompleted() @mtopolnik what do you think?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r404723278", "createdAt": "2020-04-07T11:04:06Z", "author": {"login": "cangencer"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/UnaryService.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc.impl;\n+\n+import com.hazelcast.function.BiConsumerEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.grpc.GrpcService;\n+import io.grpc.ManagedChannel;\n+import io.grpc.stub.StreamObserver;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+public final class UnaryService<T, R> implements GrpcService<T, R> {\n+\n+    private final BiConsumerEx<? super T, ? super StreamObserver<R>> callFn;\n+\n+    public UnaryService(\n+            @Nonnull ManagedChannel channel,\n+            @Nonnull FunctionEx<? super ManagedChannel, ? extends BiConsumerEx<T, StreamObserver<R>>> callStubFn\n+    ) {\n+        callFn = callStubFn.apply(channel);\n+    }\n+\n+    @Override @Nonnull\n+    public CompletableFuture<R> call(@Nonnull T input) {\n+        Observer<R> o = new Observer<>();\n+        callFn.accept(input, o);\n+        return o.future;\n+    }\n+\n+    public void destroy() {\n+    }\n+\n+    private static class Observer<O> implements StreamObserver<O> {\n+        private final CompletableFuture<O> future;\n+\n+        Observer() {\n+            this.future = new CompletableFuture<>();\n+        }\n+\n+        @Override\n+        public void onNext(O value) {\n+            if (!future.complete(value)) {\n+                throw new JetException(\"UnaryService.Observer.onNext() called, but its future is already completed\");\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            future.completeExceptionally(GrpcUtil.translateGrpcException(t));\n+        }\n+\n+        @Override\n+        public void onCompleted() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NzQzMQ=="}, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc0Njc3NQ==", "bodyText": "I think there's no way gRPC will call onError after calling onNext. Note that this same interface, StreamObserver, serves the need of both unary and streaming responses. Either onNext or onError will be called, followed by onCompleted. OTOH, I'm also pretty sure there's a happens-before between callback invocations and that we could also go back and remove volatile. I just find this way more robust.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r404746775", "createdAt": "2020-04-07T11:48:30Z", "author": {"login": "mtopolnik"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/UnaryService.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc.impl;\n+\n+import com.hazelcast.function.BiConsumerEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.grpc.GrpcService;\n+import io.grpc.ManagedChannel;\n+import io.grpc.stub.StreamObserver;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+public final class UnaryService<T, R> implements GrpcService<T, R> {\n+\n+    private final BiConsumerEx<? super T, ? super StreamObserver<R>> callFn;\n+\n+    public UnaryService(\n+            @Nonnull ManagedChannel channel,\n+            @Nonnull FunctionEx<? super ManagedChannel, ? extends BiConsumerEx<T, StreamObserver<R>>> callStubFn\n+    ) {\n+        callFn = callStubFn.apply(channel);\n+    }\n+\n+    @Override @Nonnull\n+    public CompletableFuture<R> call(@Nonnull T input) {\n+        Observer<R> o = new Observer<>();\n+        callFn.accept(input, o);\n+        return o.future;\n+    }\n+\n+    public void destroy() {\n+    }\n+\n+    private static class Observer<O> implements StreamObserver<O> {\n+        private final CompletableFuture<O> future;\n+\n+        Observer() {\n+            this.future = new CompletableFuture<>();\n+        }\n+\n+        @Override\n+        public void onNext(O value) {\n+            if (!future.complete(value)) {\n+                throw new JetException(\"UnaryService.Observer.onNext() called, but its future is already completed\");\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            future.completeExceptionally(GrpcUtil.translateGrpcException(t));\n+        }\n+\n+        @Override\n+        public void onCompleted() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NzQzMQ=="}, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzMDcwNQ==", "bodyText": "you have to call onNext and then onComplete seperately on the server code, so I think it could happen.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r405330705", "createdAt": "2020-04-08T07:59:40Z", "author": {"login": "cangencer"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/UnaryService.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc.impl;\n+\n+import com.hazelcast.function.BiConsumerEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.grpc.GrpcService;\n+import io.grpc.ManagedChannel;\n+import io.grpc.stub.StreamObserver;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+public final class UnaryService<T, R> implements GrpcService<T, R> {\n+\n+    private final BiConsumerEx<? super T, ? super StreamObserver<R>> callFn;\n+\n+    public UnaryService(\n+            @Nonnull ManagedChannel channel,\n+            @Nonnull FunctionEx<? super ManagedChannel, ? extends BiConsumerEx<T, StreamObserver<R>>> callStubFn\n+    ) {\n+        callFn = callStubFn.apply(channel);\n+    }\n+\n+    @Override @Nonnull\n+    public CompletableFuture<R> call(@Nonnull T input) {\n+        Observer<R> o = new Observer<>();\n+        callFn.accept(input, o);\n+        return o.future;\n+    }\n+\n+    public void destroy() {\n+    }\n+\n+    private static class Observer<O> implements StreamObserver<O> {\n+        private final CompletableFuture<O> future;\n+\n+        Observer() {\n+            this.future = new CompletableFuture<>();\n+        }\n+\n+        @Override\n+        public void onNext(O value) {\n+            if (!future.complete(value)) {\n+                throw new JetException(\"UnaryService.Observer.onNext() called, but its future is already completed\");\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable t) {\n+            future.completeExceptionally(GrpcUtil.translateGrpcException(t));\n+        }\n+\n+        @Override\n+        public void onCompleted() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NzQzMQ=="}, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTI3MzcyOnYy", "diffSide": "RIGHT", "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/UnaryService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDoxNTo1MVrOGB8ukw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzoxNToyNFrOGCusAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NjcyMw==", "bodyText": "Can this be called while the future from call is waiting for completion?\nWould it be a problem?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r404696723", "createdAt": "2020-04-07T10:15:51Z", "author": {"login": "frant-hartm"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/UnaryService.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc.impl;\n+\n+import com.hazelcast.function.BiConsumerEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.grpc.GrpcService;\n+import io.grpc.ManagedChannel;\n+import io.grpc.stub.StreamObserver;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+public final class UnaryService<T, R> implements GrpcService<T, R> {\n+\n+    private final BiConsumerEx<? super T, ? super StreamObserver<R>> callFn;\n+\n+    public UnaryService(\n+            @Nonnull ManagedChannel channel,\n+            @Nonnull FunctionEx<? super ManagedChannel, ? extends BiConsumerEx<T, StreamObserver<R>>> callStubFn\n+    ) {\n+        callFn = callStubFn.apply(channel);\n+    }\n+\n+    @Override @Nonnull\n+    public CompletableFuture<R> call(@Nonnull T input) {\n+        Observer<R> o = new Observer<>();\n+        callFn.accept(input, o);\n+        return o.future;\n+    }\n+\n+    public void destroy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTI2Nw==", "bodyText": "the requests should be failed when the channel is shutdown. Either way this means processors will be shutting down, so I don't think anything should be left hanging.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r405515267", "createdAt": "2020-04-08T13:15:24Z", "author": {"login": "cangencer"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/impl/UnaryService.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc.impl;\n+\n+import com.hazelcast.function.BiConsumerEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.grpc.GrpcService;\n+import io.grpc.ManagedChannel;\n+import io.grpc.stub.StreamObserver;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+public final class UnaryService<T, R> implements GrpcService<T, R> {\n+\n+    private final BiConsumerEx<? super T, ? super StreamObserver<R>> callFn;\n+\n+    public UnaryService(\n+            @Nonnull ManagedChannel channel,\n+            @Nonnull FunctionEx<? super ManagedChannel, ? extends BiConsumerEx<T, StreamObserver<R>>> callStubFn\n+    ) {\n+        callFn = callStubFn.apply(channel);\n+    }\n+\n+    @Override @Nonnull\n+    public CompletableFuture<R> call(@Nonnull T input) {\n+        Observer<R> o = new Observer<>();\n+        callFn.accept(input, o);\n+        return o.future;\n+    }\n+\n+    public void destroy() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NjcyMw=="}, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTMzNzU5OnYy", "diffSide": "RIGHT", "path": "extensions/grpc/src/test/java/com/hazelcast/jet/grpc/GrpcServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozMzo1NFrOGB9WfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozMzo1NFrOGB9WfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwNjk0MQ==", "bodyText": "I think it is quite hard to work what happens when, what is input/output of what even on this toy example, the example with productInfo and brokerInfo is even harder to read.\nIMHO the main issue is that the logical flow jumps back and forth in the source code\n\nmapping from the pipeline to the request at line 84\nservice definition (including the actual operation on the stub) at line 76\nmapping the service response at line 85\n\nAnd the complicated functions returning consumers/functions etc.. don't help:\nFunctionEx<? super ManagedChannel, ? extends FunctionEx<StreamObserver<R>, StreamObserver<T>>>\n\nWe should provide more syntactic sugar so it's easier to use for a regular developer. Something along the lines of:\n        ServiceFactory<?, ? extends GrpcService<GreeterStub>> greeterService =\n                bidirectionalStreamingService(\n                        () -> ManagedChannelBuilder.forAddress(\"localhost\", port).usePlaintext()\n                );\n\n        Pipeline p = Pipeline.create();\n        BatchStage<String> stage = p.readFrom(TestSources.items(\"one\", \"two\", \"three\", \"four\"));\n\n        // When\n        BatchStage<String> mapped = stage.mapUsingServiceAsyncXXX(greeterService,\n                (item) -> HelloRequest.newBuilder().setName(item).build(),\n                GreeterStub::sayHelloBidirectional,\n                (response) -> response.getMessage() // Or just HelloReply::getMessage\n        );", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r404706941", "createdAt": "2020-04-07T10:33:54Z", "author": {"login": "frant-hartm"}, "path": "extensions/grpc/src/test/java/com/hazelcast/jet/grpc/GrpcServiceTest.java", "diffHunk": "@@ -0,0 +1,316 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc;\n+\n+import com.hazelcast.jet.SimpleTestInClusterSupport;\n+import com.hazelcast.jet.config.JetConfig;\n+import com.hazelcast.jet.grpc.greeter.GreeterGrpc;\n+import com.hazelcast.jet.grpc.greeter.GreeterOuterClass.HelloReply;\n+import com.hazelcast.jet.grpc.greeter.GreeterOuterClass.HelloRequest;\n+import com.hazelcast.jet.impl.util.ExceptionUtil;\n+import com.hazelcast.jet.pipeline.BatchStage;\n+import com.hazelcast.jet.pipeline.BatchStageWithKey;\n+import com.hazelcast.jet.pipeline.Pipeline;\n+import com.hazelcast.jet.pipeline.ServiceFactory;\n+import com.hazelcast.jet.pipeline.Sinks;\n+import com.hazelcast.jet.pipeline.test.AssertionSinks;\n+import com.hazelcast.jet.pipeline.test.TestSources;\n+import io.grpc.BindableService;\n+import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Server;\n+import io.grpc.ServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import static com.hazelcast.jet.grpc.GrpcServices.bidirectionalStreamingService;\n+import static com.hazelcast.jet.grpc.GrpcServices.unaryService;\n+import static java.util.stream.Collectors.toList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+public class GrpcServiceTest extends SimpleTestInClusterSupport {\n+\n+    private static final int ITEM_COUNT = 10_000;\n+    Server server;\n+\n+    @BeforeClass\n+    public static void setup() {\n+        initialize(2, new JetConfig());\n+    }\n+\n+    @After\n+    public void teardown() {\n+        if (server != null) {\n+            server.shutdown() ;\n+        }\n+    }\n+\n+    @Test\n+    public void when_bidirectionalStreaming() throws IOException {\n+        // Given\n+        server = createServer(new GreeterServiceImpl());\n+        final int port = server.getPort();\n+\n+        ServiceFactory<?, ? extends GrpcService<HelloRequest, HelloReply>> greeterService =\n+                bidirectionalStreaming(port);\n+\n+        Pipeline p = Pipeline.create();\n+        BatchStage<String> stage = p.readFrom(TestSources.items(\"one\", \"two\", \"three\", \"four\"));\n+\n+        // When\n+        BatchStage<String> mapped = stage.mapUsingServiceAsync(greeterService, (service, item) -> {\n+            HelloRequest req = HelloRequest.newBuilder().setName(item).build();\n+            return service.call(req).thenApply(HelloReply::getMessage);\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTM0MzQ5OnYy", "diffSide": "RIGHT", "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/GrpcServices.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozNTozN1rOGB9aNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMDozNTozN1rOGB9aNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwNzg5NQ==", "bodyText": "See the comment in GrpcServiceTest.java where this is used", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2095#discussion_r404707895", "createdAt": "2020-04-07T10:35:37Z", "author": {"login": "frant-hartm"}, "path": "extensions/grpc/src/main/java/com/hazelcast/jet/grpc/GrpcServices.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.grpc;\n+\n+import com.hazelcast.function.BiConsumerEx;\n+import com.hazelcast.function.BiFunctionEx;\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.function.SupplierEx;\n+import com.hazelcast.jet.grpc.impl.BidirectionalStreamingService;\n+import com.hazelcast.jet.grpc.impl.UnaryService;\n+import com.hazelcast.jet.pipeline.GeneralStage;\n+import com.hazelcast.jet.pipeline.ServiceFactory;\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+\n+import javax.annotation.Nonnull;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Provides {@link ServiceFactory} implementations for calling gRPC\n+ * endpoints. The {@code ServiceFactory} created are designed to be\n+ * used with the {@link GeneralStage#mapUsingServiceAsync(ServiceFactory, BiFunctionEx) mapUsingServiceAsync}\n+ * transform.\n+ * <p>\n+ * Currently two types of gRPC services are supported:\n+ * <oul>\n+ *     <li>{@link #unaryService(SupplierEx, FunctionEx) unary}</li>\n+ *     <li>{@link #bidirectionalStreamingService(SupplierEx, FunctionEx)} (SupplierEx, FunctionEx)\n+ *     bidirectionalStreaming}</li>\n+ * </ul>\n+ *\n+ * @since 4.1\n+ */\n+public final class GrpcServices {\n+\n+    private GrpcServices() {\n+    }\n+\n+    /**\n+     * Creates a {@link ServiceFactory} that calls out to a\n+     * <a href=\"https://grpc.io/docs/guides/concepts/#unary-rpc\">unary gRPC service</a>.\n+     * <p>\n+     * For example, given the protobuf definition below:\n+     * <pre>{@code\n+     * service Greeter {\n+     *   // Sends a greeting\n+     *   rpc SayHello (HelloRequest) returns (HelloReply) {}\n+     * }\n+     * }</pre>\n+     * We can create the following service factory:\n+     * <pre>{@code\n+     * ServiceFactory<?, ? extends GrpcService<HelloRequest, HelloResponse> greeterService = unaryService(\n+     *     () -> ManagedChannelBuilder.forAddress(\"localhost\", 5000).usePlaintext(),\n+     *     channel -> GreeterGrpc.newStub(channel)::sayHello\n+     * );\n+     * }</pre>\n+     * where {@code GreeterGrpc} is the class auto-generated by the protobuf\n+     * compiler.\n+     * <p>\n+     * The created {@link ServiceFactory} should be used with the\n+     * {@link GeneralStage#mapUsingServiceAsync(ServiceFactory, BiFunctionEx) mapUsingServiceAsync}\n+     * transform as follows:\n+     * <pre>{@code\n+     * Pipeline p = Pipeline.create();\n+     * p.readFrom(TestSources.items(\"one\", \"two\", \"three\", \"four\"))\n+     *     .mapUsingServiceAsync(greeterService, (service, input) -> {\n+     *         HelloRequest request = HelloRequest.newBuilder().setName(input).build();\n+     *        return service.call(request);\n+     * })\n+     *  .writeTo(Sinks.logger());\n+     * }</pre>\n+     * <p>\n+     * The remote end can signal an error for a given input item. In that case\n+     * the {@link CompletableFuture} returned from {@code service.call(request)}\n+     * will be completed with that exception. To catch and handle it, use the\n+     * {@code CompletableFuture} API.\n+     *\n+     * @param channelFn creates the channel builder. A single channel is created per Jet member\n+     *                  and shared among the processor instances.\n+     * @param callStubFn a function which, given a channel, creates the stub and returns a\n+     *                   function that calls the stub given the input item and the observer.\n+     *                   It will be called once per input item.\n+     * @param <T> type of the request object\n+     * @param <R> type of the response object\n+     */\n+    @Nonnull\n+    public static <T, R> ServiceFactory<?, ? extends GrpcService<T, R>> unaryService(\n+            @Nonnull SupplierEx<? extends ManagedChannelBuilder<?>> channelFn,\n+            @Nonnull FunctionEx<? super ManagedChannel, ? extends BiConsumerEx<T, StreamObserver<R>>> callStubFn\n+    ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0f9fc1aaa438859ade7ba94d5f977acc4c4587"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4752, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}