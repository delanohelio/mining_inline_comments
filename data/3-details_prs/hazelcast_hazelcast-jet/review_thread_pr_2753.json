{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM3MDY1NTIx", "number": 2753, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoxMTo0OFrOFE1XzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzo0NDozNlrOFFcYsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjEzMDY5OnYy", "diffSide": "RIGHT", "path": "extensions/csv/src/main/java/com/hazelcast/jet/csv/impl/CsvReadFileFnProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoxMTo0OFrOIFCpoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMTowOTozNlrOIFLcTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1NzIxNw==", "bodyText": "I think you could avoid projection if header == stringArrayFieldList.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542157217", "createdAt": "2020-12-14T07:11:48Z", "author": {"login": "gierlachg"}, "path": "extensions/csv/src/main/java/com/hazelcast/jet/csv/impl/CsvReadFileFnProvider.java", "diffHunk": "@@ -47,18 +53,49 @@\n )\n public class CsvReadFileFnProvider implements ReadFileFnProvider {\n \n+    @SuppressWarnings(\"unchecked\")\n     @Nonnull\n     @Override\n     public <T> FunctionEx<Path, Stream<T>> createReadFileFn(@Nonnull FileFormat<T> format) {\n         CsvFileFormat<T> csvFileFormat = (CsvFileFormat<T>) format;\n         Class<?> formatClazz = csvFileFormat.clazz(); // Format is not Serializable\n \n         return path -> {\n-            ObjectReader reader = new CsvMapper().readerFor(formatClazz != null ? formatClazz : Map.class)\n-                                                 .withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n-                                                 .with(CsvSchema.emptySchema().withHeader());\n             FileInputStream fis = new FileInputStream(path.toFile());\n-            return StreamSupport.<T>stream(Spliterators.spliteratorUnknownSize(reader.readValues(fis), ORDERED), false)\n+            MappingIterator<T> iterator;\n+            Function<T, T> projection = r -> r;\n+            if (formatClazz == String[].class) {\n+                ObjectReader reader = new CsvMapper().enable(Feature.WRAP_AS_ARRAY)\n+                                                     .readerFor(String[].class)\n+                                                     .with(CsvSchema.emptySchema().withSkipFirstDataRow(false));\n+                iterator = reader.readValues(fis);\n+                if (!iterator.hasNext()) {\n+                    throw new JetException(\"Header row missing in \" + path);\n+                }\n+                String[] header = (String[]) iterator.next();\n+                List<String> fieldList = csvFileFormat.stringArrayFieldList();\n+                if (fieldList != null) {\n+                    int[] simpleFieldMap = createSimpleFieldMap(fieldList, header);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwMTI2Mw==", "bodyText": "fixed", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542301263", "createdAt": "2020-12-14T11:09:36Z", "author": {"login": "viliam-durina"}, "path": "extensions/csv/src/main/java/com/hazelcast/jet/csv/impl/CsvReadFileFnProvider.java", "diffHunk": "@@ -47,18 +53,49 @@\n )\n public class CsvReadFileFnProvider implements ReadFileFnProvider {\n \n+    @SuppressWarnings(\"unchecked\")\n     @Nonnull\n     @Override\n     public <T> FunctionEx<Path, Stream<T>> createReadFileFn(@Nonnull FileFormat<T> format) {\n         CsvFileFormat<T> csvFileFormat = (CsvFileFormat<T>) format;\n         Class<?> formatClazz = csvFileFormat.clazz(); // Format is not Serializable\n \n         return path -> {\n-            ObjectReader reader = new CsvMapper().readerFor(formatClazz != null ? formatClazz : Map.class)\n-                                                 .withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n-                                                 .with(CsvSchema.emptySchema().withHeader());\n             FileInputStream fis = new FileInputStream(path.toFile());\n-            return StreamSupport.<T>stream(Spliterators.spliteratorUnknownSize(reader.readValues(fis), ORDERED), false)\n+            MappingIterator<T> iterator;\n+            Function<T, T> projection = r -> r;\n+            if (formatClazz == String[].class) {\n+                ObjectReader reader = new CsvMapper().enable(Feature.WRAP_AS_ARRAY)\n+                                                     .readerFor(String[].class)\n+                                                     .with(CsvSchema.emptySchema().withSkipFirstDataRow(false));\n+                iterator = reader.readValues(fis);\n+                if (!iterator.hasNext()) {\n+                    throw new JetException(\"Header row missing in \" + path);\n+                }\n+                String[] header = (String[]) iterator.next();\n+                List<String> fieldList = csvFileFormat.stringArrayFieldList();\n+                if (fieldList != null) {\n+                    int[] simpleFieldMap = createSimpleFieldMap(fieldList, header);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1NzIxNw=="}, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjEzNzQ2OnYy", "diffSide": "RIGHT", "path": "extensions/csv/src/main/java/com/hazelcast/jet/csv/impl/CsvReadFileFnProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoxNDoxMFrOIFCtQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoxNDoxMFrOIFCtQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1ODE0Ng==", "bodyText": "Hadoop variant needs exactly same logic, I guess it could be somehow shared.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542158146", "createdAt": "2020-12-14T07:14:10Z", "author": {"login": "gierlachg"}, "path": "extensions/csv/src/main/java/com/hazelcast/jet/csv/impl/CsvReadFileFnProvider.java", "diffHunk": "@@ -47,18 +53,49 @@\n )\n public class CsvReadFileFnProvider implements ReadFileFnProvider {\n \n+    @SuppressWarnings(\"unchecked\")\n     @Nonnull\n     @Override\n     public <T> FunctionEx<Path, Stream<T>> createReadFileFn(@Nonnull FileFormat<T> format) {\n         CsvFileFormat<T> csvFileFormat = (CsvFileFormat<T>) format;\n         Class<?> formatClazz = csvFileFormat.clazz(); // Format is not Serializable\n \n         return path -> {\n-            ObjectReader reader = new CsvMapper().readerFor(formatClazz != null ? formatClazz : Map.class)\n-                                                 .withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n-                                                 .with(CsvSchema.emptySchema().withHeader());\n             FileInputStream fis = new FileInputStream(path.toFile());\n-            return StreamSupport.<T>stream(Spliterators.spliteratorUnknownSize(reader.readValues(fis), ORDERED), false)\n+            MappingIterator<T> iterator;\n+            Function<T, T> projection = r -> r;\n+            if (formatClazz == String[].class) {\n+                ObjectReader reader = new CsvMapper().enable(Feature.WRAP_AS_ARRAY)\n+                                                     .readerFor(String[].class)\n+                                                     .with(CsvSchema.emptySchema().withSkipFirstDataRow(false));\n+                iterator = reader.readValues(fis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjEzOTkzOnYy", "diffSide": "LEFT", "path": "extensions/hadoop/src/test/java/com/hazelcast/jet/hadoop/file/CsvFileFormatTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoxNDo1NlrOIFCuig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzozOTo0M1rOIF8_QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1ODQ3NA==", "bodyText": "We could use a test, proving that projection works.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542158474", "createdAt": "2020-12-14T07:14:56Z", "author": {"login": "gierlachg"}, "path": "extensions/hadoop/src/test/java/com/hazelcast/jet/hadoop/file/CsvFileFormatTest.java", "diffHunk": "@@ -33,7 +33,6 @@\n \n     @Test\n     public void shouldReadCsvFile() {\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjczNDAxOA==", "bodyText": "Added a unit test for the Util.createFieldProjection() method.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542734018", "createdAt": "2020-12-14T20:16:34Z", "author": {"login": "viliam-durina"}, "path": "extensions/hadoop/src/test/java/com/hazelcast/jet/hadoop/file/CsvFileFormatTest.java", "diffHunk": "@@ -33,7 +33,6 @@\n \n     @Test\n     public void shouldReadCsvFile() {\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1ODQ3NA=="}, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExMzAyNA==", "bodyText": "I agree there should be some tests in the file connector for this. It is user facing API and there is non trivial amount of new code here. I pushed some.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r543113024", "createdAt": "2020-12-15T07:39:43Z", "author": {"login": "frant-hartm"}, "path": "extensions/hadoop/src/test/java/com/hazelcast/jet/hadoop/file/CsvFileFormatTest.java", "diffHunk": "@@ -33,7 +33,6 @@\n \n     @Test\n     public void shouldReadCsvFile() {\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1ODQ3NA=="}, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjE0NjI0OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/file/CsvFileFormat.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoxNjo1NlrOIFCx6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzo0MjoyN1rOIF9FPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1OTMzNg==", "bodyText": "Does it make sense to have clazz & stringArrayFieldList at the same time? Maybe, both should be final and we should have 2 constructors setting clazz in one and stringArrayFieldList in the other?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542159336", "createdAt": "2020-12-14T07:16:56Z", "author": {"login": "gierlachg"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/file/CsvFileFormat.java", "diffHunk": "@@ -34,6 +35,7 @@\n     public static final String FORMAT_CSV = \"csv\";\n \n     private Class<T> clazz;\n+    private List<String> stringArrayFieldList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcyMTY5NA==", "bodyText": "I followed the style already in the class, with a mutable clazz.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542721694", "createdAt": "2020-12-14T20:05:02Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/file/CsvFileFormat.java", "diffHunk": "@@ -34,6 +35,7 @@\n     public static final String FORMAT_CSV = \"csv\";\n \n     private Class<T> clazz;\n+    private List<String> stringArrayFieldList;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1OTMzNg=="}, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExNDU1OA==", "bodyText": "We originaly had a final clazz, changed it with the SQL file connector. now looking at all the places maybe we could go back to final clazz and always provide a class (either Map, instead of null), TreeNode for json etc. This way we could avoid the cases if null then this class..", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r543114558", "createdAt": "2020-12-15T07:42:27Z", "author": {"login": "frant-hartm"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/file/CsvFileFormat.java", "diffHunk": "@@ -34,6 +35,7 @@\n     public static final String FORMAT_CSV = \"csv\";\n \n     private Class<T> clazz;\n+    private List<String> stringArrayFieldList;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1OTMzNg=="}, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjE1MzcyOnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/file/AvroMetadataResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoxOTozMlrOIFC2FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTo1NTowMlrOIFkcbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MDQwNQ==", "bodyText": "I'm not sure i like formatForSample & formatForData. Maybe just implement resolveMetadata in subclasses?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542160405", "createdAt": "2020-12-14T07:19:32Z", "author": {"login": "gierlachg"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/file/AvroMetadataResolver.java", "diffHunk": "@@ -33,7 +33,7 @@\n     private static final FileFormat<Map<String, String>> FORMAT = FileFormat.avro();\n \n     @Override\n-    protected FileFormat<?> format() {\n+    protected FileFormat<?> formatForSample() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxMDg5Mg==", "bodyText": "done in 3772e38", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542710892", "createdAt": "2020-12-14T19:55:02Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/file/AvroMetadataResolver.java", "diffHunk": "@@ -33,7 +33,7 @@\n     private static final FileFormat<Map<String, String>> FORMAT = FileFormat.avro();\n \n     @Override\n-    protected FileFormat<?> format() {\n+    protected FileFormat<?> formatForSample() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MDQwNQ=="}, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjE1NjA5OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/file/CsvMetadataResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoyMDoxNFrOIFC3Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTo1ODo1M1rOIFks8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MDcxOQ==", "bodyText": "Why distinct is needed here? Maybe it should be part of validation?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542160719", "createdAt": "2020-12-14T07:20:14Z", "author": {"login": "gierlachg"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/file/CsvMetadataResolver.java", "diffHunk": "@@ -42,7 +50,16 @@\n     }\n \n     @Override\n-    protected SupplierEx<QueryTarget> queryTargetSupplier() {\n-        return CsvQueryTarget::new;\n+    protected SupplierEx<QueryTarget> queryTargetSupplier(List<MappingField> resolvedFields) {\n+        List<String> fieldMap = createFieldList(resolvedFields);\n+        return () -> new CsvQueryTarget(fieldMap);\n+    }\n+\n+    @Nonnull\n+    private static List<String> createFieldList(List<MappingField> resolvedFields) {\n+        return resolvedFields.stream()\n+                      .map(f -> f.externalName() != null ? f.externalName() : f.name())\n+                      .distinct()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxNTEyMw==", "bodyText": "You could theoretically add a mapping with two columns pointing to the same external name:\nCREATE MAPPING my_file (\n  col1 INT EXTERNAL NAME col1,\n  col1_again INT EXTERNAL NAME col1\n) ...\n\nWill add a test for that.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542715123", "createdAt": "2020-12-14T19:58:53Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-sql/src/main/java/com/hazelcast/jet/sql/impl/connector/file/CsvMetadataResolver.java", "diffHunk": "@@ -42,7 +50,16 @@\n     }\n \n     @Override\n-    protected SupplierEx<QueryTarget> queryTargetSupplier() {\n-        return CsvQueryTarget::new;\n+    protected SupplierEx<QueryTarget> queryTargetSupplier(List<MappingField> resolvedFields) {\n+        List<String> fieldMap = createFieldList(resolvedFields);\n+        return () -> new CsvQueryTarget(fieldMap);\n+    }\n+\n+    @Nonnull\n+    private static List<String> createFieldList(List<MappingField> resolvedFields) {\n+        return resolvedFields.stream()\n+                      .map(f -> f.externalName() != null ? f.externalName() : f.name())\n+                      .distinct()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MDcxOQ=="}, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjE1Nzk0OnYy", "diffSide": "RIGHT", "path": "extensions/csv/src/main/java/com/hazelcast/jet/csv/impl/CsvReadFileFnProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoyMDo1NlrOIFC4Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTo1NzoxMVrOIFkleQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MDk5MA==", "bodyText": "Is res[index] == -1 condition needed?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542160990", "createdAt": "2020-12-14T07:20:56Z", "author": {"login": "gierlachg"}, "path": "extensions/csv/src/main/java/com/hazelcast/jet/csv/impl/CsvReadFileFnProvider.java", "diffHunk": "@@ -68,4 +105,17 @@\n     public String format() {\n         return CsvFileFormat.FORMAT_CSV;\n     }\n+\n+    private static int[] createSimpleFieldMap(List<String> fieldList, String[] actualHeader) {\n+        int[] res = new int[fieldList.size()];\n+        Arrays.fill(res, -1);\n+        for (int i = 0; i < actualHeader.length; i++) {\n+            int index = fieldList.indexOf(actualHeader[i]);\n+            // if the header is present in the file and we didn't encounter it yet, store its index\n+            if (index >= 0 && res[index] == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxMzIwOQ==", "bodyText": "Yes, that's to ensure that if a duplicate header is found, the first one is used, not the last one. We don't overwrite index for a column that already has an index.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r542713209", "createdAt": "2020-12-14T19:57:11Z", "author": {"login": "viliam-durina"}, "path": "extensions/csv/src/main/java/com/hazelcast/jet/csv/impl/CsvReadFileFnProvider.java", "diffHunk": "@@ -68,4 +105,17 @@\n     public String format() {\n         return CsvFileFormat.FORMAT_CSV;\n     }\n+\n+    private static int[] createSimpleFieldMap(List<String> fieldList, String[] actualHeader) {\n+        int[] res = new int[fieldList.size()];\n+        Arrays.fill(res, -1);\n+        for (int i = 0; i < actualHeader.length; i++) {\n+            int index = fieldList.indexOf(actualHeader[i]);\n+            // if the header is present in the file and we didn't encounter it yet, store its index\n+            if (index >= 0 && res[index] == -1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MDk5MA=="}, "originalCommit": {"oid": "bff559c8fc476db3d06c1dc150beef5b47208e34"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjQ5ODg0OnYy", "diffSide": "RIGHT", "path": "extensions/hadoop/src/main/java/com/hazelcast/jet/hadoop/impl/HadoopFileSourceFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzozODoxN1rOIF88Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTozNzoyOFrOIGcsBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExMjI1OQ==", "bodyText": "Maybe use org.apache.hadoop.conf.Configuration#setStrings(String, String[])", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r543112259", "createdAt": "2020-12-15T07:38:17Z", "author": {"login": "frant-hartm"}, "path": "extensions/hadoop/src/main/java/com/hazelcast/jet/hadoop/impl/HadoopFileSourceFactory.java", "diffHunk": "@@ -197,7 +199,13 @@ public String format() {\n \n             Class<?> clazz = csvFileFormat.clazz();\n             if (clazz != null) {\n-                job.getConfiguration().set(CSV_INPUT_FORMAT_BEAN_CLASS, clazz.getCanonicalName());\n+                job.getConfiguration().set(CSV_INPUT_FORMAT_BEAN_CLASS, clazz.getName());\n+            }\n+            List<String> fieldList = csvFileFormat.stringArrayFieldList();\n+            if (fieldList != null) {\n+                for (int i = 0; i < fieldList.size(); i++) {\n+                    job.getConfiguration().set(CSV_INPUT_FORMAT_FIELD_LIST_PREFIX + i, fieldList.get(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e8eedec80108039af44871fc1ee9948e08de167"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzMjM4OQ==", "bodyText": "Looked good, but it trivially joins the strings using \",\" and the uses String.split(\",\"). Though not common, a field name can contain a ,, especially in CSV when headers are sometimes typed in Excel...", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r543632389", "createdAt": "2020-12-15T19:37:28Z", "author": {"login": "viliam-durina"}, "path": "extensions/hadoop/src/main/java/com/hazelcast/jet/hadoop/impl/HadoopFileSourceFactory.java", "diffHunk": "@@ -197,7 +199,13 @@ public String format() {\n \n             Class<?> clazz = csvFileFormat.clazz();\n             if (clazz != null) {\n-                job.getConfiguration().set(CSV_INPUT_FORMAT_BEAN_CLASS, clazz.getCanonicalName());\n+                job.getConfiguration().set(CSV_INPUT_FORMAT_BEAN_CLASS, clazz.getName());\n+            }\n+            List<String> fieldList = csvFileFormat.stringArrayFieldList();\n+            if (fieldList != null) {\n+                for (int i = 0; i < fieldList.size(); i++) {\n+                    job.getConfiguration().set(CSV_INPUT_FORMAT_FIELD_LIST_PREFIX + i, fieldList.get(i));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExMjI1OQ=="}, "originalCommit": {"oid": "0e8eedec80108039af44871fc1ee9948e08de167"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjUwNjU5OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/util/Util.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzo0MDoyMlrOIF9AjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTo1MzoyNVrOIGdT-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExMzM1Nw==", "bodyText": "The false condition here isn't covered by tests.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r543113357", "createdAt": "2020-12-15T07:40:22Z", "author": {"login": "frant-hartm"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/util/Util.java", "diffHunk": "@@ -548,4 +550,51 @@ public static String formatJobDuration(long durationMs) {\n         String textUpToHours = String.format(\"%02d:%02d:%02d.%03d\", hours, minutes, seconds, millis);\n         return sign + (durationMs > 0 ? durationMs + \"d \" : \"\") + textUpToHours;\n     }\n+\n+    /**\n+     * Given a list of input field names and a list of output field names\n+     * creates a projection to map between these.\n+     * <p>\n+     * For example, if input names are {@code [surname, name, address]} and\n+     * output names are {@code [name, surname, age]}, then the function,\n+     * applied to {@code [Smith, John, New York]} will return {@code [John,\n+     * Smith, (null)]}. That is, it will map the fields from the input order to\n+     * output order. The output field named {@code age} is missing in input, so\n+     * the value for it is {@code null} for any input.\n+     *\n+     * @param inputFields the input headers\n+     * @param outputFields the output headers\n+     * @return the indices to map input to output\n+     */\n+    @Nonnull\n+    public static Function<String[], String[]> createFieldProjection(\n+            @Nonnull String[] inputFields,\n+            @Nonnull List<String> outputFields\n+    ) {\n+        if (outputFields.equals(asList(inputFields))) {\n+            // shortcut - the mapping is an identity\n+            return i -> i;\n+        }\n+        int[] simpleFieldMap = new int[outputFields.size()];\n+        Arrays.fill(simpleFieldMap, -1);\n+        for (int i = 0; i < inputFields.length; i++) {\n+            int index = outputFields.indexOf(inputFields[i]);\n+            // if the inputFields is present in the file and we didn't encounter it yet, store its index\n+            if (index >= 0 && simpleFieldMap[index] == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e8eedec80108039af44871fc1ee9948e08de167"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0MjYxNg==", "bodyText": "Both conditions are covered in integration tests. I added unit test coverage, if that's what you mean.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r543642616", "createdAt": "2020-12-15T19:53:25Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/util/Util.java", "diffHunk": "@@ -548,4 +550,51 @@ public static String formatJobDuration(long durationMs) {\n         String textUpToHours = String.format(\"%02d:%02d:%02d.%03d\", hours, minutes, seconds, millis);\n         return sign + (durationMs > 0 ? durationMs + \"d \" : \"\") + textUpToHours;\n     }\n+\n+    /**\n+     * Given a list of input field names and a list of output field names\n+     * creates a projection to map between these.\n+     * <p>\n+     * For example, if input names are {@code [surname, name, address]} and\n+     * output names are {@code [name, surname, age]}, then the function,\n+     * applied to {@code [Smith, John, New York]} will return {@code [John,\n+     * Smith, (null)]}. That is, it will map the fields from the input order to\n+     * output order. The output field named {@code age} is missing in input, so\n+     * the value for it is {@code null} for any input.\n+     *\n+     * @param inputFields the input headers\n+     * @param outputFields the output headers\n+     * @return the indices to map input to output\n+     */\n+    @Nonnull\n+    public static Function<String[], String[]> createFieldProjection(\n+            @Nonnull String[] inputFields,\n+            @Nonnull List<String> outputFields\n+    ) {\n+        if (outputFields.equals(asList(inputFields))) {\n+            // shortcut - the mapping is an identity\n+            return i -> i;\n+        }\n+        int[] simpleFieldMap = new int[outputFields.size()];\n+        Arrays.fill(simpleFieldMap, -1);\n+        for (int i = 0; i < inputFields.length; i++) {\n+            int index = outputFields.indexOf(inputFields[i]);\n+            // if the inputFields is present in the file and we didn't encounter it yet, store its index\n+            if (index >= 0 && simpleFieldMap[index] == -1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExMzM1Nw=="}, "originalCommit": {"oid": "0e8eedec80108039af44871fc1ee9948e08de167"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjUyMjc1OnYy", "diffSide": "RIGHT", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/file/FileSourceBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNzo0NDozNlrOIF9Jmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTo1NjoxNFrOIGdcDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExNTY3NA==", "bodyText": "I find the double negation less readable.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r543115674", "createdAt": "2020-12-15T07:44:36Z", "author": {"login": "frant-hartm"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/file/FileSourceBuilder.java", "diffHunk": "@@ -98,7 +98,7 @@\n      */\n     public FileSourceBuilder(@Nonnull String path) {\n         this.path = requireNonNull(path, \"path must not be null\");\n-        if (!(Paths.get(path).isAbsolute() || hasHadoopPrefix(path))) {\n+        if (!hasHadoopPrefix(path) && !Paths.get(path).isAbsolute()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e8eedec80108039af44871fc1ee9948e08de167"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0NDY4Nw==", "bodyText": "You can't read it aloud with the parenthesis, but no dispute against taste (proti gustu \u017eiaden di\u0161put\u00e1t :) ), reverting", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2753#discussion_r543644687", "createdAt": "2020-12-15T19:56:14Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/file/FileSourceBuilder.java", "diffHunk": "@@ -98,7 +98,7 @@\n      */\n     public FileSourceBuilder(@Nonnull String path) {\n         this.path = requireNonNull(path, \"path must not be null\");\n-        if (!(Paths.get(path).isAbsolute() || hasHadoopPrefix(path))) {\n+        if (!hasHadoopPrefix(path) && !Paths.get(path).isAbsolute()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExNTY3NA=="}, "originalCommit": {"oid": "0e8eedec80108039af44871fc1ee9948e08de167"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4366, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}