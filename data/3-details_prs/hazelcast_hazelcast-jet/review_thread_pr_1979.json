{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0ODc5Mjgz", "number": 1979, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOToyMTo1MFrODf0yAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOToyNToxOFrODf01zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njk3MjE2OnYy", "diffSide": "RIGHT", "path": "site/docs/api/serialization.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOToyMTo1MFrOFpwIfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOToyMTo1MFrOFpwIfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNDU0MA==", "bodyText": "WDYT  about crucial to efficient usage of Hazelcast Jet ?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379324540", "createdAt": "2020-02-14T09:21:50Z", "author": {"login": "eminn"}, "path": "site/docs/api/serialization.md", "diffHunk": "@@ -3,6 +3,87 @@ title: Serialization\n id: serialization\n ---\n \n-## How Data is serialized in Jet\n+## (De)Serialization in Jet\n \n-TODO\n+To be able to send object state over a network or store it in a file \n+one has to first serialize it into raw bytes. Similarly, to be able to \n+fetch an object state over a wire or read it from a persistent storage \n+one has to deserialize it from raw bytes first. As Hazelcast Jet is a \n+distributed system by nature (de)serialization is integral part of it. \n+Understanding, when it is involved, how does it support the pipelines \n+and knowing differences between each of the strategies is crucial to \n+efficient Jet usage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62471c8fb8b903642f0b1e287383b65e3df81a8d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njk3NDc2OnYy", "diffSide": "RIGHT", "path": "site/docs/api/serialization.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOToyMjo0OFrOFpwKCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOToyMjo0OFrOFpwKCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNDkzNg==", "bodyText": "Maybe a link to the DAG section if we have it atm or a javadoc link ?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379324936", "createdAt": "2020-02-14T09:22:48Z", "author": {"login": "eminn"}, "path": "site/docs/api/serialization.md", "diffHunk": "@@ -3,6 +3,87 @@ title: Serialization\n id: serialization\n ---\n \n-## How Data is serialized in Jet\n+## (De)Serialization in Jet\n \n-TODO\n+To be able to send object state over a network or store it in a file \n+one has to first serialize it into raw bytes. Similarly, to be able to \n+fetch an object state over a wire or read it from a persistent storage \n+one has to deserialize it from raw bytes first. As Hazelcast Jet is a \n+distributed system by nature (de)serialization is integral part of it. \n+Understanding, when it is involved, how does it support the pipelines \n+and knowing differences between each of the strategies is crucial to \n+efficient Jet usage.\n+\n+Hazelcast Jet closely integrates with Hazelcast IMDG exposing many of \n+its features to Jet users. In particular, one can use IMDG data \n+structure as Jet `Source` and/or `Sink`. Objects retrieved from and \n+stored in those have to be (de)serializable.\n+\n+Another case which might require (de)serializable objects is sending \n+computation results between remote vertices. Hazelcast Jet tries to \n+minimize network traffic as much as possible, nonetheless different \n+parts of a `DAG` can reside on separate cluster members. To catch ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62471c8fb8b903642f0b1e287383b65e3df81a8d"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njk4MTg4OnYy", "diffSide": "RIGHT", "path": "site/docs/api/serialization.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOToyNToxOFrOFpwOdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOTo0NToyNlrOFpw0UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNjA3MQ==", "bodyText": "Maybe a link to the benchmark source for reproducibility ?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379326071", "createdAt": "2020-02-14T09:25:18Z", "author": {"login": "eminn"}, "path": "site/docs/api/serialization.md", "diffHunk": "@@ -3,6 +3,87 @@ title: Serialization\n id: serialization\n ---\n \n-## How Data is serialized in Jet\n+## (De)Serialization in Jet\n \n-TODO\n+To be able to send object state over a network or store it in a file \n+one has to first serialize it into raw bytes. Similarly, to be able to \n+fetch an object state over a wire or read it from a persistent storage \n+one has to deserialize it from raw bytes first. As Hazelcast Jet is a \n+distributed system by nature (de)serialization is integral part of it. \n+Understanding, when it is involved, how does it support the pipelines \n+and knowing differences between each of the strategies is crucial to \n+efficient Jet usage.\n+\n+Hazelcast Jet closely integrates with Hazelcast IMDG exposing many of \n+its features to Jet users. In particular, one can use IMDG data \n+structure as Jet `Source` and/or `Sink`. Objects retrieved from and \n+stored in those have to be (de)serializable.\n+\n+Another case which might require (de)serializable objects is sending \n+computation results between remote vertices. Hazelcast Jet tries to \n+minimize network traffic as much as possible, nonetheless different \n+parts of a `DAG` can reside on separate cluster members. To catch \n+(de)serialization issues early on, we recommend using a 2-member local \n+Jet cluster for development and testing.\n+\n+Currently, Hazelcast Jet supports 6 interfaces to (de)serialize objects:\n+- [java.io.Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)\n+- [java.io.Externalizable](https://docs.oracle.com/javase/8/docs/api/java/io/Externalizable.html)\n+- [com.hazelcast.nio.serialization.DataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/DataSerializable.html)\n+- [com.hazelcast.nio.serialization.IdentifiedDataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/IdentifiedDataSerializable.html)\n+- [com.hazelcast.nio.serialization.Portable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/Portable.html)\n+- [com.hazelcast.nio.serialization.StreamSerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/StreamSerializer.html) &\n+  [com.hazelcast.nio.serialization.ByteArraySerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/ByteArraySerializer.html)\n+\n+The following table provides a comparison between them to help you in \n+deciding which interface to use in your applications.\n+|      Serialization interface      |                                                                      Advantages                                                                      |                                               Drawbacks                                              |\n+|:---------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------:|\n+|            Serializable           | <ul><li>Easy to start with, requires no implementation</li></ul>                                                                                     | <ul><li>CPU intensive</li><li>Space inefficient</li></ul>                                            |\n+|           Externalizable          | <ul><li>Faster and more space efficient than Serializable</li></ul>                                                                                  | <ul><li>CPU intensive</li><li>Space inefficient</li><li>Requires implementation</li></ul>            |\n+|          DataSerializable         | <ul><li>Faster and more space efficient than java standard interfaces</li></ul>                                                                      | <ul><li>Requires implementation</li></ul>                                                            |\n+|     IdentifiedDataSerializable    | <ul><li>Relatively fast and space efficient</li></ul>                                                                                                | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+|              Portable             | <ul><li>Faster and more space efficient than java standard interfaces</li><li>Supports versioning</li><li>Supports partial deserialization</li></ul> | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+| [Stream&#124;ByteArray]Serializer | <ul><li>The fastest and lightest out of supported interfaces</li></ul>                                                                               | <ul><li>Requires implementation</li><li>Requires registration during cluster setup</li></ul>         |\n+\n+Below you can find rough performance numbers one can expect when \n+employing each of those strategies. A straightforward benchmark which continuously serializes and then ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62471c8fb8b903642f0b1e287383b65e3df81a8d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzMDYwMw==", "bodyText": "I'm not sure about this, I wanted the readers just to have an idea about the potential performance. Where would that sit if we wanted to add it?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379330603", "createdAt": "2020-02-14T09:34:48Z", "author": {"login": "gierlachg"}, "path": "site/docs/api/serialization.md", "diffHunk": "@@ -3,6 +3,87 @@ title: Serialization\n id: serialization\n ---\n \n-## How Data is serialized in Jet\n+## (De)Serialization in Jet\n \n-TODO\n+To be able to send object state over a network or store it in a file \n+one has to first serialize it into raw bytes. Similarly, to be able to \n+fetch an object state over a wire or read it from a persistent storage \n+one has to deserialize it from raw bytes first. As Hazelcast Jet is a \n+distributed system by nature (de)serialization is integral part of it. \n+Understanding, when it is involved, how does it support the pipelines \n+and knowing differences between each of the strategies is crucial to \n+efficient Jet usage.\n+\n+Hazelcast Jet closely integrates with Hazelcast IMDG exposing many of \n+its features to Jet users. In particular, one can use IMDG data \n+structure as Jet `Source` and/or `Sink`. Objects retrieved from and \n+stored in those have to be (de)serializable.\n+\n+Another case which might require (de)serializable objects is sending \n+computation results between remote vertices. Hazelcast Jet tries to \n+minimize network traffic as much as possible, nonetheless different \n+parts of a `DAG` can reside on separate cluster members. To catch \n+(de)serialization issues early on, we recommend using a 2-member local \n+Jet cluster for development and testing.\n+\n+Currently, Hazelcast Jet supports 6 interfaces to (de)serialize objects:\n+- [java.io.Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)\n+- [java.io.Externalizable](https://docs.oracle.com/javase/8/docs/api/java/io/Externalizable.html)\n+- [com.hazelcast.nio.serialization.DataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/DataSerializable.html)\n+- [com.hazelcast.nio.serialization.IdentifiedDataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/IdentifiedDataSerializable.html)\n+- [com.hazelcast.nio.serialization.Portable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/Portable.html)\n+- [com.hazelcast.nio.serialization.StreamSerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/StreamSerializer.html) &\n+  [com.hazelcast.nio.serialization.ByteArraySerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/ByteArraySerializer.html)\n+\n+The following table provides a comparison between them to help you in \n+deciding which interface to use in your applications.\n+|      Serialization interface      |                                                                      Advantages                                                                      |                                               Drawbacks                                              |\n+|:---------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------:|\n+|            Serializable           | <ul><li>Easy to start with, requires no implementation</li></ul>                                                                                     | <ul><li>CPU intensive</li><li>Space inefficient</li></ul>                                            |\n+|           Externalizable          | <ul><li>Faster and more space efficient than Serializable</li></ul>                                                                                  | <ul><li>CPU intensive</li><li>Space inefficient</li><li>Requires implementation</li></ul>            |\n+|          DataSerializable         | <ul><li>Faster and more space efficient than java standard interfaces</li></ul>                                                                      | <ul><li>Requires implementation</li></ul>                                                            |\n+|     IdentifiedDataSerializable    | <ul><li>Relatively fast and space efficient</li></ul>                                                                                                | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+|              Portable             | <ul><li>Faster and more space efficient than java standard interfaces</li><li>Supports versioning</li><li>Supports partial deserialization</li></ul> | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+| [Stream&#124;ByteArray]Serializer | <ul><li>The fastest and lightest out of supported interfaces</li></ul>                                                                               | <ul><li>Requires implementation</li><li>Requires registration during cluster setup</li></ul>         |\n+\n+Below you can find rough performance numbers one can expect when \n+employing each of those strategies. A straightforward benchmark which continuously serializes and then ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNjA3MQ=="}, "originalCommit": {"oid": "62471c8fb8b903642f0b1e287383b65e3df81a8d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNDMwOQ==", "bodyText": "I think https://github.com/hazelcast/hazelcast-jmh is a good candidate for that. My thinking was that they can take the benchmarking boilerplate and plug their own POJOs to see the real performance impact for their actual objects.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379334309", "createdAt": "2020-02-14T09:42:30Z", "author": {"login": "eminn"}, "path": "site/docs/api/serialization.md", "diffHunk": "@@ -3,6 +3,87 @@ title: Serialization\n id: serialization\n ---\n \n-## How Data is serialized in Jet\n+## (De)Serialization in Jet\n \n-TODO\n+To be able to send object state over a network or store it in a file \n+one has to first serialize it into raw bytes. Similarly, to be able to \n+fetch an object state over a wire or read it from a persistent storage \n+one has to deserialize it from raw bytes first. As Hazelcast Jet is a \n+distributed system by nature (de)serialization is integral part of it. \n+Understanding, when it is involved, how does it support the pipelines \n+and knowing differences between each of the strategies is crucial to \n+efficient Jet usage.\n+\n+Hazelcast Jet closely integrates with Hazelcast IMDG exposing many of \n+its features to Jet users. In particular, one can use IMDG data \n+structure as Jet `Source` and/or `Sink`. Objects retrieved from and \n+stored in those have to be (de)serializable.\n+\n+Another case which might require (de)serializable objects is sending \n+computation results between remote vertices. Hazelcast Jet tries to \n+minimize network traffic as much as possible, nonetheless different \n+parts of a `DAG` can reside on separate cluster members. To catch \n+(de)serialization issues early on, we recommend using a 2-member local \n+Jet cluster for development and testing.\n+\n+Currently, Hazelcast Jet supports 6 interfaces to (de)serialize objects:\n+- [java.io.Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)\n+- [java.io.Externalizable](https://docs.oracle.com/javase/8/docs/api/java/io/Externalizable.html)\n+- [com.hazelcast.nio.serialization.DataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/DataSerializable.html)\n+- [com.hazelcast.nio.serialization.IdentifiedDataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/IdentifiedDataSerializable.html)\n+- [com.hazelcast.nio.serialization.Portable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/Portable.html)\n+- [com.hazelcast.nio.serialization.StreamSerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/StreamSerializer.html) &\n+  [com.hazelcast.nio.serialization.ByteArraySerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/ByteArraySerializer.html)\n+\n+The following table provides a comparison between them to help you in \n+deciding which interface to use in your applications.\n+|      Serialization interface      |                                                                      Advantages                                                                      |                                               Drawbacks                                              |\n+|:---------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------:|\n+|            Serializable           | <ul><li>Easy to start with, requires no implementation</li></ul>                                                                                     | <ul><li>CPU intensive</li><li>Space inefficient</li></ul>                                            |\n+|           Externalizable          | <ul><li>Faster and more space efficient than Serializable</li></ul>                                                                                  | <ul><li>CPU intensive</li><li>Space inefficient</li><li>Requires implementation</li></ul>            |\n+|          DataSerializable         | <ul><li>Faster and more space efficient than java standard interfaces</li></ul>                                                                      | <ul><li>Requires implementation</li></ul>                                                            |\n+|     IdentifiedDataSerializable    | <ul><li>Relatively fast and space efficient</li></ul>                                                                                                | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+|              Portable             | <ul><li>Faster and more space efficient than java standard interfaces</li><li>Supports versioning</li><li>Supports partial deserialization</li></ul> | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+| [Stream&#124;ByteArray]Serializer | <ul><li>The fastest and lightest out of supported interfaces</li></ul>                                                                               | <ul><li>Requires implementation</li><li>Requires registration during cluster setup</li></ul>         |\n+\n+Below you can find rough performance numbers one can expect when \n+employing each of those strategies. A straightforward benchmark which continuously serializes and then ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNjA3MQ=="}, "originalCommit": {"oid": "62471c8fb8b903642f0b1e287383b65e3df81a8d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNTc2MA==", "bodyText": "Makes sense. I need to polish it then a bit and add it.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1979#discussion_r379335760", "createdAt": "2020-02-14T09:45:26Z", "author": {"login": "gierlachg"}, "path": "site/docs/api/serialization.md", "diffHunk": "@@ -3,6 +3,87 @@ title: Serialization\n id: serialization\n ---\n \n-## How Data is serialized in Jet\n+## (De)Serialization in Jet\n \n-TODO\n+To be able to send object state over a network or store it in a file \n+one has to first serialize it into raw bytes. Similarly, to be able to \n+fetch an object state over a wire or read it from a persistent storage \n+one has to deserialize it from raw bytes first. As Hazelcast Jet is a \n+distributed system by nature (de)serialization is integral part of it. \n+Understanding, when it is involved, how does it support the pipelines \n+and knowing differences between each of the strategies is crucial to \n+efficient Jet usage.\n+\n+Hazelcast Jet closely integrates with Hazelcast IMDG exposing many of \n+its features to Jet users. In particular, one can use IMDG data \n+structure as Jet `Source` and/or `Sink`. Objects retrieved from and \n+stored in those have to be (de)serializable.\n+\n+Another case which might require (de)serializable objects is sending \n+computation results between remote vertices. Hazelcast Jet tries to \n+minimize network traffic as much as possible, nonetheless different \n+parts of a `DAG` can reside on separate cluster members. To catch \n+(de)serialization issues early on, we recommend using a 2-member local \n+Jet cluster for development and testing.\n+\n+Currently, Hazelcast Jet supports 6 interfaces to (de)serialize objects:\n+- [java.io.Serializable](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html)\n+- [java.io.Externalizable](https://docs.oracle.com/javase/8/docs/api/java/io/Externalizable.html)\n+- [com.hazelcast.nio.serialization.DataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/DataSerializable.html)\n+- [com.hazelcast.nio.serialization.IdentifiedDataSerializable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/IdentifiedDataSerializable.html)\n+- [com.hazelcast.nio.serialization.Portable](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/Portable.html)\n+- [com.hazelcast.nio.serialization.StreamSerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/StreamSerializer.html) &\n+  [com.hazelcast.nio.serialization.ByteArraySerializer](https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/nio/serialization/ByteArraySerializer.html)\n+\n+The following table provides a comparison between them to help you in \n+deciding which interface to use in your applications.\n+|      Serialization interface      |                                                                      Advantages                                                                      |                                               Drawbacks                                              |\n+|:---------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------------------------:|:----------------------------------------------------------------------------------------------------:|\n+|            Serializable           | <ul><li>Easy to start with, requires no implementation</li></ul>                                                                                     | <ul><li>CPU intensive</li><li>Space inefficient</li></ul>                                            |\n+|           Externalizable          | <ul><li>Faster and more space efficient than Serializable</li></ul>                                                                                  | <ul><li>CPU intensive</li><li>Space inefficient</li><li>Requires implementation</li></ul>            |\n+|          DataSerializable         | <ul><li>Faster and more space efficient than java standard interfaces</li></ul>                                                                      | <ul><li>Requires implementation</li></ul>                                                            |\n+|     IdentifiedDataSerializable    | <ul><li>Relatively fast and space efficient</li></ul>                                                                                                | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+|              Portable             | <ul><li>Faster and more space efficient than java standard interfaces</li><li>Supports versioning</li><li>Supports partial deserialization</li></ul> | <ul><li>Requires implementation</li><li>Requires factory registration during cluster setup</li></ul> |\n+| [Stream&#124;ByteArray]Serializer | <ul><li>The fastest and lightest out of supported interfaces</li></ul>                                                                               | <ul><li>Requires implementation</li><li>Requires registration during cluster setup</li></ul>         |\n+\n+Below you can find rough performance numbers one can expect when \n+employing each of those strategies. A straightforward benchmark which continuously serializes and then ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyNjA3MQ=="}, "originalCommit": {"oid": "62471c8fb8b903642f0b1e287383b65e3df81a8d"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4866, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}