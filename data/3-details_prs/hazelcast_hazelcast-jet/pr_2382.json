{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMjQwMTM5", "number": 2382, "title": "Adding test data sources designed for benchmarking purposes", "bodyText": "Adding this streaming source:\nStreamSource<Long> longStream(long eventsPerSecond, long initialDelayMillis) \nIt is a high-throughput source with precisely controlled timing, to be used for benchmarking Jet's throughput and latency.\nFixes #2244\nChecklist\n\n Tags Set\n Milestone Set\n New public APIs have @Nonnull/@Nullable annotations\n New public APIs have @since tags in Javadoc", "createdAt": "2020-06-30T19:12:31Z", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382", "merged": true, "mergeCommit": {"oid": "981182e3d1ee481b3877ed02ba6a2af3812975c5"}, "closed": true, "closedAt": "2020-08-04T19:56:48Z", "author": {"login": "guenter-hesse"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwXHcwAH2gAyNDQyMjQwMTM5OmUyOWRkYjM0M2QyZmIxYTBjMjI5YmQ0OTlkYWMyZWZmYjAxODhmOGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7nXB8AFqTQ2MDg1ODU1MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e29ddb343d2fb1a0c229bd499dac2effb0188f8f", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/e29ddb343d2fb1a0c229bd499dac2effb0188f8f", "committedDate": "2020-06-30T15:10:24Z", "message": "add methods for distributed batch and stream stages w/ long values for high-throughput testing purposes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/3830ffc780dcfb89ff6da89bef6b655eb03f6d88", "committedDate": "2020-07-18T14:39:42Z", "message": "advanced source creation for performance testing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMTAwMTEz", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#pullrequestreview-451100113", "createdAt": "2020-07-19T05:30:17Z", "commit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNTozMDoxOFrOGzsrSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNTozNDoyNFrOGzssdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MjUzNg==", "bodyText": "Javadoc must be wrapped so that line length is 72 chars (ignoring initial indentation or *)", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456862536", "createdAt": "2020-07-19T05:30:18Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/StreamSourceLong.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.HOURS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Represents a StreamSource containing Long values which can be used\n+ * for performance pipeline testing and development.\n+ *\n+ * @since 4.3\n+ */\n+public class StreamSourceLong extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+    private static final long SIMPLE_TIME_SPAN_MILLIS = HOURS.toMillis(3);\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final boolean isReportingThroughput;\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    /**\n+     * Creates a stream source for Long values that is supposed to be used for performance testing purposes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MjY2OQ==", "bodyText": "Wrap the params like this:\npublic static StreamSource<Long> longStreamSource(\n    long itemsPerSecond, long initialDelay, int preferredLocalParallelism\n) {", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456862669", "createdAt": "2020-07-19T05:31:59Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -213,50 +167,70 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n         }\n     }\n \n-    private static BatchSource<Long> longBatchSource(long range, int stepSize) {\n-        return SourceBuilder\n-                .batch(\"longs\", c -> new LongAccumulator())\n-                .<Long>fillBufferFn(new LongSource(range, stepSize)::fillBufferFn)\n-                .build();\n+    /**\n+     * Returns a stream source that contains long values and does late materialization\n+     * of values after distributing them across the cluster, which is useful for high-throughput\n+     * testing.\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStreamSource(long itemsPerSecond, long initialDelay) {\n+        return longStreamSource(itemsPerSecond, initialDelay, Vertex.LOCAL_PARALLELISM_USE_DEFAULT, false);\n     }\n \n-    private static StreamSource<Long> longStreamSource(long range, int stepSize) {\n-        return SourceBuilder\n-                .stream(\"longs\", c -> new LongAccumulator())\n-                .<Long>fillBufferFn(new LongSource(range, stepSize, true)::fillBufferFn)\n-                .build();\n+    /**\n+     * Returns a stream source that contains long values and does late materialization\n+     * of values after distributing them across the cluster, which is useful for high-throughput\n+     * testing.\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStreamSource(long itemsPerSecond, long initialDelay,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MjgzNw==", "bodyText": "Test method names shouldn't use _ arbitrarily. We use the camelCase except for the special format: when_preCondition_then_postCondition. The latter naming scheme is preferable for test methods.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456862837", "createdAt": "2020-07-19T05:34:24Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -50,29 +50,21 @@ public void test_items() {\n     }\n \n     @Test\n-    public void test_long_batch_range() {\n-        int upperValueRange = 10_000;\n-        Long[] input = LongStream.range(0, upperValueRange).boxed().toArray(Long[]::new);\n-        List<Long> expected = Arrays.asList(input);\n-\n-        TestSources.batchStageForLongRange(p, upperValueRange, 10)\n-                .apply(\n-                        Assertions.assertAnyOrder(expected)\n-                );\n-\n-        jet().newJob(p).join();\n-    }\n-\n-    @Test\n-    public void test_long_stream_range() throws Throwable {\n-        int upperValueRange = 10_000;\n-        Long[] input = LongStream.range(0, upperValueRange).boxed().toArray(Long[]::new);\n+    public void test_stream_source_long() throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMTAwNjc2", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#pullrequestreview-451100676", "createdAt": "2020-07-19T05:43:04Z", "commit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNTo0MzowNFrOGzsvSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNTo0MzowNFrOGzsvSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MzU2Mw==", "bodyText": "You can reorder these two calls so that emitEvents() is first, then detectAndReportHiccup(). It is a bit cleaner that way.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r456863563", "createdAt": "2020-07-19T05:43:04Z", "author": {"login": "mtopolnik"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/StreamSourceLong.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.HOURS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Represents a StreamSource containing Long values which can be used\n+ * for performance pipeline testing and development.\n+ *\n+ * @since 4.3\n+ */\n+public class StreamSourceLong extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+    private static final long SIMPLE_TIME_SPAN_MILLIS = HOURS.toMillis(3);\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final boolean isReportingThroughput;\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    /**\n+     * Creates a stream source for Long values that is supposed to be used for performance testing purposes.\n+     *\n+     * @since 4.3\n+     */\n+    @Nonnull\n+    public StreamSourceLong(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy,\n+            boolean shouldReportThroughput\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();\n+        this.startTime = MILLISECONDS.toNanos(startTime + nanoTimeMillisToCurrentTimeMillis);\n+        this.itemsPerSecond = itemsPerSecond;\n+        this.isReportingThroughput = shouldReportThroughput;\n+    }\n+\n+    @Override\n+    protected void init(Context context) {\n+        totalParallelism = context.totalParallelism();\n+        globalProcessorIndex = context.globalProcessorIndex();\n+        emitPeriod = SECONDS.toNanos(1) * totalParallelism / itemsPerSecond;\n+        lastCallNanos = lastReport = emitSchedule =\n+                startTime + SECONDS.toNanos(1) * globalProcessorIndex / itemsPerSecond;\n+    }\n+\n+    @Override\n+    public boolean complete() {\n+        nowNanos = System.nanoTime();\n+        detectAndReportHiccup();\n+        emitEvents();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3830ffc780dcfb89ff6da89bef6b655eb03f6d88"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fcf10859c9274eca0f80fe5f7b45bac375000dc", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/8fcf10859c9274eca0f80fe5f7b45bac375000dc", "committedDate": "2020-07-19T11:48:04Z", "message": "incorporated PR feedback (formatting, function call reordering), renamed method to stay consistent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/5672b33bf92c7e8774f2246ad543a51c4ac61989", "committedDate": "2020-07-20T17:19:55Z", "message": "added javadoc, minor improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNjkyNjM3", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#pullrequestreview-452692637", "createdAt": "2020-07-21T17:48:09Z", "commit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo0ODowOVrOG1DLTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo1MDo1NFrOG1DRpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3OTc1OQ==", "bodyText": "could these methods be moved to the top? we shouldn't have interleaving methods/inner classes", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458279759", "createdAt": "2020-07-21T17:48:09Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDAzOA==", "bodyText": "what unit is this in? is it in real-time or event time?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458280038", "createdAt": "2020-07-21T17:48:36Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDM4NQ==", "bodyText": "preferredLocalParallelism  can be already set at source stage level. What does it bring here?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458280385", "createdAt": "2020-07-21T17:49:13Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {\n+        return streamSourceLong(itemsPerSecond, initialDelay, Vertex.LOCAL_PARALLELISM_USE_DEFAULT);\n+    }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     * @param preferredLocalParallelism the preferred local parallelism\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(\n+            long itemsPerSecond, long initialDelay, int preferredLocalParallelism", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MDg0Mw==", "bodyText": "javadoc lacks detail about what timestamps the items will have", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458280843", "createdAt": "2020-07-21T17:49:58Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4MTM4MQ==", "bodyText": "TestSources.longStream would be a better name I think, to mirror itemStream", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r458281381", "createdAt": "2020-07-21T17:50:54Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -161,4 +187,59 @@ void fillBuffer(TimestampedSourceBuffer<T> buf) throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} for {@code\n+     * long} values. The value creation is distributed across the cluster and\n+     * is done using {@link StreamSourceLong}. All {@link StreamSourceLong}\n+     * instances are created identically, one per cluster member. The returned\n+     * source is designed to be used for high-throughput performance testing.\n+     *\n+     * @param itemsPerSecond how many items should be emitted each second\n+     * @param initialDelay initial delay before emitting values\n+     *\n+     * @return {@link com.hazelcast.jet.pipeline.StreamSource} with {@code long} values\n+     *          created in a distributed fashion\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> streamSourceLong(long itemsPerSecond, long initialDelay) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5672b33bf92c7e8774f2246ad543a51c4ac61989"}, "originalPosition": 169}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d476f97f6c1cb3bdd945b2b0da124869086022da", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/d476f97f6c1cb3bdd945b2b0da124869086022da", "committedDate": "2020-07-23T16:26:07Z", "message": "javadoc updated, renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f6fa02da75b7212618c438609791826c7c08bfa", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/4f6fa02da75b7212618c438609791826c7c08bfa", "committedDate": "2020-07-23T18:57:14Z", "message": "Improve Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c514b8011c3e35cd98081e00efed84b468c6304b", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/c514b8011c3e35cd98081e00efed84b468c6304b", "committedDate": "2020-07-23T18:58:07Z", "message": "Rename StreamSourceLong -> LongStreamSourceP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b97dd6dc1e7ccc9c5572f3c6629e576d5d5de38", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/7b97dd6dc1e7ccc9c5572f3c6629e576d5d5de38", "committedDate": "2020-07-23T19:16:17Z", "message": "test renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d33a229db98a86da0246e4c4bd61a2b2baf191b", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/8d33a229db98a86da0246e4c4bd61a2b2baf191b", "committedDate": "2020-07-23T19:35:14Z", "message": "Extended Javadoc, updated annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/a82bac864f43a580610f9c055c2900b549bca85d", "committedDate": "2020-07-23T20:16:42Z", "message": "Added paragraph in Javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDY2MjE0", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#pullrequestreview-454466214", "createdAt": "2020-07-23T20:20:38Z", "commit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMDozOFrOG2aKwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMjozMlrOG2aO1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNTAyNA==", "bodyText": "why not .collect(toList()) directly?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459705024", "createdAt": "2020-07-23T20:20:38Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -48,6 +49,30 @@ public void test_items() {\n         jet().newJob(p).join();\n     }\n \n+    @Test\n+    public void test_longStream() throws Throwable {\n+        int itemsPerSecond = 10;\n+        int timeout = 10;\n+        int numberOfExpectedValues = timeout * itemsPerSecond;\n+        Long[] input = LongStream.range(0, numberOfExpectedValues).boxed().toArray(Long[]::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNTMxOA==", "bodyText": "I don't think you need the fully qualified name here, package is already imported.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459705318", "createdAt": "2020-07-23T20:21:08Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link com.hazelcast.jet.pipeline.StreamSource} that emits an", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNjA3MQ==", "bodyText": "in pipeline code, we always have . in the beginning of the line rather than end of previous.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r459706071", "createdAt": "2020-07-23T20:22:32Z", "author": {"login": "cangencer"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -48,6 +49,30 @@ public void test_items() {\n         jet().newJob(p).join();\n     }\n \n+    @Test\n+    public void test_longStream() throws Throwable {\n+        int itemsPerSecond = 10;\n+        int timeout = 10;\n+        int numberOfExpectedValues = timeout * itemsPerSecond;\n+        Long[] input = LongStream.range(0, numberOfExpectedValues).boxed().toArray(Long[]::new);\n+        List<Long> expected = Arrays.asList(input);\n+\n+        p.readFrom(TestSources.longStream(itemsPerSecond, 0)).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a82bac864f43a580610f9c055c2900b549bca85d"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27522575900e3e43d31d1615b99d225ea8025c35", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/27522575900e3e43d31d1615b99d225ea8025c35", "committedDate": "2020-07-24T06:14:22Z", "message": "Simplifications and formatting changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/2981be348b87bfe2fb7079ad265deb263b6e6988", "committedDate": "2020-07-24T07:32:52Z", "message": "Reflow para"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1ODc1NDk5", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#pullrequestreview-455875499", "createdAt": "2020-07-27T15:09:51Z", "commit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NDA1OTUz", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#pullrequestreview-456405953", "createdAt": "2020-07-28T08:18:46Z", "commit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxODo0NlrOG4ByYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMDoyNDo1OVrOG4GZjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMjcyMA==", "bodyText": "I would just inline this constant.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461402720", "createdAt": "2020-07-28T08:18:46Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMjg5Nw==", "bodyText": "Why don't we use nanos here too? We wouldn't have to convert below.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461402897", "createdAt": "2020-07-28T08:19:05Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0MTc0MA==", "bodyText": "The processor name should match the method name.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461441740", "createdAt": "2020-07-28T09:20:34Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStream(long eventsPerSecond, long initialDelayMillis) {\n+        return Sources.streamFromProcessorWithWatermarks(\"longValues\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MDU3OA==", "bodyText": "We ignore the timestampFn in the eventTimePolicy. We also ignore the wrapFn: the pipeline will throw errors if one uses withoutTimestamp: it throws division by 0 because wmGranularity is 0 in that case.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461450578", "createdAt": "2020-07-28T09:35:10Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    LongStreamSourceP(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NDQ4MA==", "bodyText": "minor: We get a different startTime for each member. Not sure we need to fix it, the members can still have drifted clocks, but maybe comment about it here...", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461454480", "createdAt": "2020-07-28T09:41:37Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *\n+     */\n+    @Nonnull\n+    public static StreamSource<Long> longStream(long eventsPerSecond, long initialDelayMillis) {\n+        return Sources.streamFromProcessorWithWatermarks(\"longValues\",\n+                true,\n+                eventTimePolicy -> ProcessorMetaSupplier.of(\n+                        (Address ignored) -> {\n+                            long startTime = System.currentTimeMillis() + initialDelayMillis;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NTA4Ng==", "bodyText": "Extra line", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461455086", "createdAt": "2020-07-28T09:42:36Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.\n+     *\n+     * @param eventsPerSecond the desired event rate\n+     * @param initialDelayMillis initial delay in milliseconds before emitting values\n+     *\n+     * @since 4.3\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NzAxNQ==", "bodyText": "We should use withNativeTimestamps(0) because that's what gets assigned to the items.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461457015", "createdAt": "2020-07-28T09:45:44Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/test/java/com/hazelcast/jet/pipeline/test/TestSourcesTest.java", "diffHunk": "@@ -48,6 +50,29 @@ public void test_items() {\n         jet().newJob(p).join();\n     }\n \n+    @Test\n+    public void test_longStream() throws Throwable {\n+        int itemsPerSecond = 10;\n+        int timeout = 10;\n+        int numberOfExpectedValues = timeout * itemsPerSecond;\n+        List<Long> expected = LongStream.range(0, numberOfExpectedValues).boxed().collect(toList());\n+\n+        p.readFrom(TestSources.longStream(itemsPerSecond, 0))\n+                .withIngestionTimestamps()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1NzM5Mg==", "bodyText": "We should get the logger in init from context.getLogger()", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461457392", "createdAt": "2020-07-28T09:46:24Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1ODE5MA==", "bodyText": "We can initialize the coutner with globalProcessorIndex and add totalParallelism in each iteration. This way we'll avoid the calculation each time.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461458190", "createdAt": "2020-07-28T09:47:45Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    LongStreamSourceP(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();\n+        this.startTime = MILLISECONDS.toNanos(startTime + nanoTimeMillisToCurrentTimeMillis);\n+        this.itemsPerSecond = itemsPerSecond;\n+    }\n+\n+    @Override\n+    protected void init(@Nonnull Context context) {\n+        totalParallelism = context.totalParallelism();\n+        globalProcessorIndex = context.globalProcessorIndex();\n+        emitPeriod = SECONDS.toNanos(1) * totalParallelism / itemsPerSecond;\n+        lastCallNanos = lastReport = emitSchedule =\n+                startTime + SECONDS.toNanos(1) * globalProcessorIndex / itemsPerSecond;\n+    }\n+\n+    @Override\n+    public boolean complete() {\n+        nowNanos = System.nanoTime();\n+        emitEvents();\n+        detectAndReportHiccup();\n+        if (logger.isFineEnabled()) {\n+            reportThroughput();\n+        }\n+        return false;\n+    }\n+\n+    private void emitEvents() {\n+        while (emitFromTraverser(traverser) && emitSchedule <= nowNanos) {\n+            long timestamp = NANOSECONDS.toMillis(emitSchedule) - nanoTimeMillisToCurrentTimeMillis;\n+            traverser.append(jetEvent(timestamp, counter * totalParallelism + globalProcessorIndex));\n+            counter++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3NzkzMg==", "bodyText": "Minor: We are not precise if there's a remainder. Instead of emitPeriod and emitSchedule we can calculate the expected counter value at current time and emit until it's greater than the current value. See for example here.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461477932", "createdAt": "2020-07-28T10:24:17Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/LongStreamSourceP.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.pipeline.test;\n+\n+import com.hazelcast.jet.core.AbstractProcessor;\n+import com.hazelcast.jet.core.AppendableTraverser;\n+import com.hazelcast.jet.core.EventTimePolicy;\n+import com.hazelcast.jet.core.Watermark;\n+import com.hazelcast.logging.ILogger;\n+import com.hazelcast.logging.Logger;\n+\n+import javax.annotation.Nonnull;\n+\n+import static com.hazelcast.jet.impl.JetEvent.jetEvent;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * Implements the {@link TestSources#longStream} source.\n+ *\n+ * @since 4.3\n+ */\n+public class LongStreamSourceP extends AbstractProcessor {\n+\n+    private static final long SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS = 10;\n+\n+    private static final long REPORT_PERIOD_NANOS = SECONDS.toNanos(SOURCE_THROUGHPUT_REPORTING_PERIOD_SECONDS);\n+    private static final long HICCUP_REPORT_THRESHOLD_MILLIS = 10;\n+    private final long nanoTimeMillisToCurrentTimeMillis = determineTimeOffset();\n+    private final long startTime;\n+    private final long itemsPerSecond;\n+    private final ILogger logger = Logger.getLogger(LongStreamSourceP.class);\n+    private final long wmGranularity;\n+    private final long wmOffset;\n+    private long globalProcessorIndex;\n+    private long totalParallelism;\n+    private long emitPeriod;\n+\n+    private final AppendableTraverser<Object> traverser = new AppendableTraverser<>(2);\n+    private long emitSchedule;\n+    private long lastReport;\n+    private long counterAtLastReport;\n+    private long lastCallNanos;\n+    private long counter;\n+    private long lastEmittedWm;\n+    private long nowNanos;\n+\n+    LongStreamSourceP(\n+            long startTime,\n+            long itemsPerSecond,\n+            EventTimePolicy<? super Long> eventTimePolicy\n+    ) {\n+        this.wmGranularity = eventTimePolicy.watermarkThrottlingFrameSize();\n+        this.wmOffset = eventTimePolicy.watermarkThrottlingFrameOffset();\n+        this.startTime = MILLISECONDS.toNanos(startTime + nanoTimeMillisToCurrentTimeMillis);\n+        this.itemsPerSecond = itemsPerSecond;\n+    }\n+\n+    @Override\n+    protected void init(@Nonnull Context context) {\n+        totalParallelism = context.totalParallelism();\n+        globalProcessorIndex = context.globalProcessorIndex();\n+        emitPeriod = SECONDS.toNanos(1) * totalParallelism / itemsPerSecond;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3ODI4NA==", "bodyText": "We need to document:\n\nthat the emitted value is the timestamp value\nthat one has to use withNativeTimestamps(0) because other options are ignored (unless we fix it)\nthat members should have clocks synchronized", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#discussion_r461478284", "createdAt": "2020-07-28T10:24:59Z", "author": {"login": "viliam-durina"}, "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/test/TestSources.java", "diffHunk": "@@ -132,6 +136,50 @@ private TestSources() {\n             .build();\n     }\n \n+    /**\n+     * Returns a {@link StreamSource} that emits an ever-increasing sequence of\n+     * {@code Long} numbers with native timestamps that are exactly the same\n+     * amount of time apart, as specified by the supplied {@code\n+     * eventsPerSecond} parameter. The source is distributed and suitable for\n+     * high-throughput performance testing. It emits the events at the maximum\n+     * possible speed, constrained by the invariant that it will never emit an\n+     * event whose timestamp is in the future.\n+     * <p>\n+     * The emission of events is distributed across the parallel processors in\n+     * a round-robin fashion: processor 0 emits the first event, processor 1\n+     * the second one, and so on. There is no coordination that would prevent\n+     * processor 1 from emitting its event before processor 0, though, so this\n+     * only applies to the event timestamps.\n+     * <p>\n+     * Use the {@code initialDelayMillis} parameter to give enough time to the\n+     * Jet cluster to initialize the job on the whole cluster before the time\n+     * of the first event arrives, so that there is no initial flood of events\n+     * from the past. The point of reference is the moment at which the\n+     * coordinator node creates the job's execution plan, before sending it out\n+     * to the rest of the cluster.\n+     * <p>\n+     * This source is not fault-tolerant. The sequence will be reset once a job\n+     * is restarted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2981be348b87bfe2fb7079ad265deb263b6e6988"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05f23c869eb7482725d35cec40226f1cb0aae193", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/05f23c869eb7482725d35cec40226f1cb0aae193", "committedDate": "2020-07-28T11:37:11Z", "message": "Fix source name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "703d740fd25ff35a8e89e67a541b09de3589904c", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/703d740fd25ff35a8e89e67a541b09de3589904c", "committedDate": "2020-07-28T11:37:54Z", "message": "Use the same startTime for all members"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "905d7c5e32fbc5ae15ad14b5759cfc622a4b88fd", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/905d7c5e32fbc5ae15ad14b5759cfc622a4b88fd", "committedDate": "2020-07-28T11:38:06Z", "message": "Rename counter -> emittedCount"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b6a3a92733af8bd7db90331eb8ec7bcb0eee53b", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/4b6a3a92733af8bd7db90331eb8ec7bcb0eee53b", "committedDate": "2020-07-28T13:20:32Z", "message": "Improve event scheduling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da22d82b109b557ff5a82d392620b25a6da96633", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/da22d82b109b557ff5a82d392620b25a6da96633", "committedDate": "2020-07-28T13:20:33Z", "message": "Expose private method in EventTimeMapper\n\nAllow it to accept nanoTime() from the caller"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce2e40f1c0f74fa9e1fb9ba13e5d8d395240a9a9", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/ce2e40f1c0f74fa9e1fb9ba13e5d8d395240a9a9", "committedDate": "2020-07-28T13:00:11Z", "message": "Improve event scheduling"}, "afterCommit": {"oid": "da22d82b109b557ff5a82d392620b25a6da96633", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/da22d82b109b557ff5a82d392620b25a6da96633", "committedDate": "2020-07-28T13:20:33Z", "message": "Expose private method in EventTimeMapper\n\nAllow it to accept nanoTime() from the caller"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f50b4ca5dc6b68f3493612884f41f3a4f6b2b673", "author": {"user": {"login": "mtopolnik", "name": "Marko Topolnik"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/f50b4ca5dc6b68f3493612884f41f3a4f6b2b673", "committedDate": "2020-07-28T13:34:19Z", "message": "Use EventTimeMapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81e3d4fae53b64dd6a4f1b4b8a9f1990d5644600", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/81e3d4fae53b64dd6a4f1b4b8a9f1990d5644600", "committedDate": "2020-07-29T18:02:40Z", "message": "Remove extra line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7edb81954a9533c57a00626872714e6885fe0b7", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/f7edb81954a9533c57a00626872714e6885fe0b7", "committedDate": "2020-07-29T18:20:49Z", "message": "Remove unused imports in TestSources.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df1ad0b2f1c96e84b60f259769bb8ffb87e66dce", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/df1ad0b2f1c96e84b60f259769bb8ffb87e66dce", "committedDate": "2020-07-29T18:24:43Z", "message": "Change unit of hiccup threshold from ms to ns in order to reduce required unit conversions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82b4287d014a71310c4bc08727ef6680cf932776", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/82b4287d014a71310c4bc08727ef6680cf932776", "committedDate": "2020-07-29T18:29:03Z", "message": "Retrieve logger from Context in init method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "680f0421c3cabb9cfee9fad1f2859175e4685117", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/680f0421c3cabb9cfee9fad1f2859175e4685117", "committedDate": "2020-07-29T18:37:45Z", "message": "Added note to Javadoc mentioning the consequences of a clock skew"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71d01dbebcb61eb2b2974554740302fabce802ec", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/71d01dbebcb61eb2b2974554740302fabce802ec", "committedDate": "2020-07-30T07:24:52Z", "message": "Removing unused import from LongStreamSourceP.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdf3cea0a6990a959312dd7e0c730d0e8c8e87be", "author": {"user": {"login": "guenter-hesse", "name": "Guenter Hesse"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/fdf3cea0a6990a959312dd7e0c730d0e8c8e87be", "committedDate": "2020-07-30T09:29:52Z", "message": "Use native timestamps instead of ingestion ts in test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16b48a82d71881f346d3af68770c65b41406e716", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/16b48a82d71881f346d3af68770c65b41406e716", "committedDate": "2020-08-04T13:39:52Z", "message": "Merge branch 'master' into guenter-hesse/master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46d760680f979be7a1b0822eb6bb7ed86281a529", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/46d760680f979be7a1b0822eb6bb7ed86281a529", "committedDate": "2020-08-04T13:49:29Z", "message": "Fix test failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cfed4b445fc9a2af4bae91dc82e192ee314eb4b", "author": {"user": {"login": "viliam-durina", "name": "Viliam Durina"}}, "url": "https://github.com/hazelcast/hazelcast-jet/commit/2cfed4b445fc9a2af4bae91dc82e192ee314eb4b", "committedDate": "2020-08-04T14:18:35Z", "message": "Simplify the test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwODU4NTUw", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2382#pullrequestreview-460858550", "createdAt": "2020-08-04T14:19:04Z", "commit": {"oid": "46d760680f979be7a1b0822eb6bb7ed86281a529"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3709, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}