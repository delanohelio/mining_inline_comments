{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwMjAzNzAw", "number": 2537, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjo1MjozNlrOEmZRAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjo1Njo0M1rOEmZWpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Njk1Mjk4OnYy", "diffSide": "RIGHT", "path": "extensions/cdc-mysql/src/test/java/com/hazelcast/jet/cdc/mysql/MySqlCdcNetworkIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjo1MjozNlrOHWY2Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjo1MjozNlrOHWY2Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIzNzc4Ng==", "bodyText": "Could you add a comment explaining this? I have no idea why it is needed.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2537#discussion_r493237786", "createdAt": "2020-09-23T06:52:36Z", "author": {"login": "frant-hartm"}, "path": "extensions/cdc-mysql/src/test/java/com/hazelcast/jet/cdc/mysql/MySqlCdcNetworkIntegrationTest.java", "diffHunk": "@@ -93,6 +99,12 @@\n         });\n     }\n \n+    @Before\n+    public void before() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0319c6fd0e2c2fbb8e17e3afb901766ce2af7199"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Njk2NzQzOnYy", "diffSide": "RIGHT", "path": "extensions/cdc-mysql/src/test/java/com/hazelcast/jet/cdc/mysql/MySqlCdcNetworkIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNjo1Njo0M1rOHWY-sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzoyNDoxNlrOHWZ2qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIzOTk4NQ==", "bodyText": "Not related to this PR, but could it be made more deterministic by having a CountDownLatch, call await here and CountDownLatch#countDown in a first step of the pipeline (peek/map)?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2537#discussion_r493239985", "createdAt": "2020-09-23T06:56:43Z", "author": {"login": "frant-hartm"}, "path": "extensions/cdc-mysql/src/test/java/com/hazelcast/jet/cdc/mysql/MySqlCdcNetworkIntegrationTest.java", "diffHunk": "@@ -139,31 +151,34 @@ public void when_networkDisconnectDuringSnapshotting_then_jetSourceIsStuckUntilR\n                 ToxiproxyContainer toxiproxy = initToxiproxy(network);\n         ) {\n             MySQLContainer<?> mysql = initMySql(network, null);\n-            ToxiproxyContainer.ContainerProxy proxy = initProxy(toxiproxy, mysql);\n-            Pipeline pipeline = initPipeline(proxy.getContainerIpAddress(), proxy.getProxyPort());\n-            // when job starts\n-            JetInstance jet = createJetMembers(2)[0];\n-            Job job = jet.newJob(pipeline);\n-            assertJobStatusEventually(job, RUNNING);\n+            try {\n+                ToxiproxyContainer.ContainerProxy proxy = initProxy(toxiproxy, mysql);\n+                Pipeline pipeline = initPipeline(proxy.getContainerIpAddress(), proxy.getProxyPort());\n+                // when job starts\n+                JetInstance jet = createJetMembers(2)[0];\n+                Job job = jet.newJob(pipeline);\n+                assertJobStatusEventually(job, RUNNING);\n \n-            // and snapshotting is ongoing (we have no exact way of identifying\n-            // the moment, but random sleep will catch it at least some of the time)\n-            TimeUnit.MILLISECONDS.sleep(ThreadLocalRandom.current().nextInt(0, 500));\n+                // and snapshotting is ongoing (we have no exact way of identifying\n+                // the moment, but random sleep will catch it at least some of the time)\n+                TimeUnit.MILLISECONDS.sleep(ThreadLocalRandom.current().nextInt(0, 500));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0319c6fd0e2c2fbb8e17e3afb901766ce2af7199"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI1NDMxMw==", "bodyText": "In this test I'm trying to see what happens if the connection to the DB drops while snapshotting is going on. Snapshotting is a process with 9 stages. I'm interested to see what happens in all the stages, on connection drop. If I would make the test more deterministic (for example the way you suggest), then it would probably always trigger around the same stage, towards the end or after snapshotting. I don't want that. With such a random sleep there will eventually always be runs for all possible scenarios. Yes, it's not deterministic, will be hard to debug, but if there is a problem we will likely find out about it. Eventually. This was my thinking.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2537#discussion_r493254313", "createdAt": "2020-09-23T07:24:16Z", "author": {"login": "jbartok"}, "path": "extensions/cdc-mysql/src/test/java/com/hazelcast/jet/cdc/mysql/MySqlCdcNetworkIntegrationTest.java", "diffHunk": "@@ -139,31 +151,34 @@ public void when_networkDisconnectDuringSnapshotting_then_jetSourceIsStuckUntilR\n                 ToxiproxyContainer toxiproxy = initToxiproxy(network);\n         ) {\n             MySQLContainer<?> mysql = initMySql(network, null);\n-            ToxiproxyContainer.ContainerProxy proxy = initProxy(toxiproxy, mysql);\n-            Pipeline pipeline = initPipeline(proxy.getContainerIpAddress(), proxy.getProxyPort());\n-            // when job starts\n-            JetInstance jet = createJetMembers(2)[0];\n-            Job job = jet.newJob(pipeline);\n-            assertJobStatusEventually(job, RUNNING);\n+            try {\n+                ToxiproxyContainer.ContainerProxy proxy = initProxy(toxiproxy, mysql);\n+                Pipeline pipeline = initPipeline(proxy.getContainerIpAddress(), proxy.getProxyPort());\n+                // when job starts\n+                JetInstance jet = createJetMembers(2)[0];\n+                Job job = jet.newJob(pipeline);\n+                assertJobStatusEventually(job, RUNNING);\n \n-            // and snapshotting is ongoing (we have no exact way of identifying\n-            // the moment, but random sleep will catch it at least some of the time)\n-            TimeUnit.MILLISECONDS.sleep(ThreadLocalRandom.current().nextInt(0, 500));\n+                // and snapshotting is ongoing (we have no exact way of identifying\n+                // the moment, but random sleep will catch it at least some of the time)\n+                TimeUnit.MILLISECONDS.sleep(ThreadLocalRandom.current().nextInt(0, 500));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIzOTk4NQ=="}, "originalCommit": {"oid": "0319c6fd0e2c2fbb8e17e3afb901766ce2af7199"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4577, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}