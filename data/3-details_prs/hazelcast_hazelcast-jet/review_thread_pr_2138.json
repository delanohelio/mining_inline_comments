{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MTg3MDUw", "number": 2138, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozMjoxOFrODvAG3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0Nzo1N1rODvAcFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjExNDIyOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozMjoxOFrOGBLDiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozMjoxOFrOGBLDiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4Mjg5MQ==", "bodyText": "\"similar to\" was actually better (easier to pronounce) and it is grammatically acceptable.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403882891", "createdAt": "2020-04-06T07:32:18Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -249,8 +249,8 @@ p.readFrom(S3Sources.s3(singletonList(\"input-bucket\"), \"prefix\",\n  .writeTo(Sinks.logger());\n ```\n \n-The S3 sink works similar to the local file sink, writing a line to the\n-output for each input item:\n+The S3 sink works similarly to the local file sink, writing a line to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjEyMzE2OnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNDo1OFrOGBLIzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNDo1OFrOGBLIzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NDIzOA==", "bodyText": "using the ... patterns", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403884238", "createdAt": "2020-04-06T07:34:58Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -424,7 +424,7 @@ or greater than 1.0.0.\n ###\u00a0JMS\n \n JMS (Java Message Service) is a standard API for communicating with\n-various message brokers using the publish-subscribe patterns.\n+various message brokers using queue or publish-subscribe patterns.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjEyOTUzOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNjo1MVrOGBLMpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNjo1MVrOGBLMpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NTIyMw==", "bodyText": "shared, durable", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403885223", "createdAt": "2020-04-06T07:36:51Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -433,34 +433,61 @@ There are several brokers that implement the JMS standard, including:\n * IBM MQ\n * RabbitMQ\n * Solace\n+* ...\n \n-Jet is able to utilize these brokers both as a source and sink through\n+Jet is able to utilize these brokers both as a source and a sink through\n the use of the JMS API.\n \n-To use a JMS broker, such as ActiveMQ, you'll need the client libraries\n-either on the classpath (by putting them on the `lib` folder) of the\n-node or submit them with the job. The Jet JMS connector is part of the\n+To use a JMS broker, such as ActiveMQ, you need the client libraries\n+either on the classpath (by putting them into the `lib` folder) of the\n+node or submit them with the job. The Jet JMS connector is a part of the\n `hazelcast-jet` module, so requires no other dependencies than the\n client jar.\n \n+####\u00a0JMS Source Connector\n+\n A very simple pipeline which consumes messages from a given ActiveMQ\n-and then logs them is given below:\n+queue and then logs them is given below:\n+\n+```java\n+Pipeline p = Pipeline.create();\n+p.readFrom(Sources.jmsQueue(\"queueName\",\n+        () -> new ActiveMQConnectionFactory(\"tcp://localhost:61616\")))\n+ .withoutTimestamps()\n+ .writeTo(Sinks.logger());\n+```\n+\n+For a topic you can choose whether the consumer is durable or shared.\n+You need to use the `consumerFn` to create the desired consumer using a\n+JMS `Session` object.\n+\n+If you create a shared consumer, you need to let Jet know by calling\n+`sharedConsumer(true)` on the builder. If you don't do this, only one\n+cluster member will actually connect to the JMS broker and will receive\n+all of the messages. We always assume a shared consumer for queues.\n+\n+If you create a non-durable consumer, the fault-tolerance features won't\n+work since the JMS broker won't track which messages were delivered to\n+the client and which not.\n+\n+Below is a simple example to create a non-durable non-shared topic\n+source:\n \n ```java\n Pipeline p = Pipeline.create();\n-p.readFrom(Sources.jmsQueue(() -> new ActiveMQConnectionFactory(\n-        \"tcp://localhost:61616\"), \"queue\"))\n+p.readFrom(Sources.jmsTopic(\"topic\",\n+        () -> new ActiveMQConnectionFactory(\"tcp://localhost:61616\")))\n  .withoutTimestamps()\n  .writeTo(Sinks.logger());\n ```\n \n-For the topic, we recommend using a durable consumer where possible\n-so that you are able to make use of fault-tolerance features of Jet:\n+Here is a more complex example that uses a shared and durable consumer:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjEzMDkzOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNzoxNVrOGBLNcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNzoxNVrOGBLNcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NTQyNA==", "bodyText": "with the ... guarantee", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403885424", "createdAt": "2020-04-06T07:37:15Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjEzMjUxOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNzo0MlrOGBLOVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozNzo0MlrOGBLOVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NTY1Mw==", "bodyText": "for the ... consumer. --The-- fault tolerance", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403885653", "createdAt": "2020-04-06T07:37:42Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjEzODA0OnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozOToxOFrOGBLRhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozOToxOFrOGBLRhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NjQ3MA==", "bodyText": "In the ... mode\nsaves the IDs", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403886470", "createdAt": "2020-04-06T07:39:18Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved\n+by acknowledging the consumed messages only after they were fully\n+processed by the downstream stages. Acknowledging is done once per\n+snapshot, you need to enable the processing guarantee in the\n+`JobConfig`.\n+\n+In exactly-once mode the processor saves IDs of the messages processed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjEzOTc5OnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozOTo0OFrOGBLSkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzozOTo0OFrOGBLSkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NjczOA==", "bodyText": "extract the ... ID", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403886738", "createdAt": "2020-04-06T07:39:48Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved\n+by acknowledging the consumed messages only after they were fully\n+processed by the downstream stages. Acknowledging is done once per\n+snapshot, you need to enable the processing guarantee in the\n+`JobConfig`.\n+\n+In exactly-once mode the processor saves IDs of the messages processed\n+since the last snapshot into the snapshotted state. Therefore this mode\n+will not work if your messages don't have the JMS Message ID set (it is\n+an optional feature of JMS). In this case you need to set `messageIdFn`\n+on the builder to extract message ID from the payload. If you don't have", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE0MDgwOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MDowNFrOGBLTKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MDowNFrOGBLTKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4Njg4OQ==", "bodyText": "In the ... mode (twice)", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403886889", "createdAt": "2020-04-06T07:40:04Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved\n+by acknowledging the consumed messages only after they were fully\n+processed by the downstream stages. Acknowledging is done once per\n+snapshot, you need to enable the processing guarantee in the\n+`JobConfig`.\n+\n+In exactly-once mode the processor saves IDs of the messages processed\n+since the last snapshot into the snapshotted state. Therefore this mode\n+will not work if your messages don't have the JMS Message ID set (it is\n+an optional feature of JMS). In this case you need to set `messageIdFn`\n+on the builder to extract message ID from the payload. If you don't have\n+a message ID to use, you must reduce the source guarantee to\n+at-least-once:\n+\n+```java\n+p.readFrom(Sources.jmsTopicBuilder(...)\n+        .maxGuarantee(ProcessingGuarantee.AT_LEAST_ONCE)\n+        ...\n+```\n+\n+In at-least-once mode messages are acknowledged in the same way as in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE0MjQ0OnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MDozMVrOGBLUJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MDozMVrOGBLUJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NzE0MQ==", "bodyText": "in the ... mode.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403887141", "createdAt": "2020-04-06T07:40:31Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -471,21 +498,40 @@ p.readFrom(Sources.jmsTopicBuilder(() ->\n  .writeTo(Sinks.logger());\n ```\n \n-It is recommended to use the JMS topic with a shared consumer so that\n-multiple Jet nodes can read in parallel, otherwise a global parallelism\n-of 1 will be used, meaning only a single node will receive all the\n-messages. When you create a shared consumer in the `consumerFn`, you\n-should also call `sharedConsumer(true)` on the builder, as in the sample\n-code above. For a queue we always assume a shared consumer.\n+#### Source fault tolerance\n+\n+The source connector is fault-tolerant with exactly-once guarantee\n+(except for non-durable topic consumer). The fault tolerance is achieved\n+by acknowledging the consumed messages only after they were fully\n+processed by the downstream stages. Acknowledging is done once per\n+snapshot, you need to enable the processing guarantee in the\n+`JobConfig`.\n+\n+In exactly-once mode the processor saves IDs of the messages processed\n+since the last snapshot into the snapshotted state. Therefore this mode\n+will not work if your messages don't have the JMS Message ID set (it is\n+an optional feature of JMS). In this case you need to set `messageIdFn`\n+on the builder to extract message ID from the payload. If you don't have\n+a message ID to use, you must reduce the source guarantee to\n+at-least-once:\n+\n+```java\n+p.readFrom(Sources.jmsTopicBuilder(...)\n+        .maxGuarantee(ProcessingGuarantee.AT_LEAST_ONCE)\n+        ...\n+```\n+\n+In at-least-once mode messages are acknowledged in the same way as in\n+exactly-once mode, but message IDs are not saved to the snapshot.\n \n-####\u00a0Using as a sink\n+If you have no processing guarantee enabled, the processor will consume\n+the messages in `DUPS_OK_ACKNOWLEDGE` mode.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE0Mzg1OnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MTowMFrOGBLU9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MTowMFrOGBLU9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NzM1MA==", "bodyText": "the ... guarantee.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403887350", "createdAt": "2020-04-06T07:41:00Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE0NDQzOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MToxM1rOGBLVTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MToxM1rOGBLVTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NzQzNw==", "bodyText": "consistent with", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403887437", "createdAt": "2020-04-06T07:41:13Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, messages are committed consistently with the last state", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE1MTE2OnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MzoyNVrOGBLZeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MzoyNVrOGBLZeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4ODUwNg==", "bodyText": "\"wrought\" doesn't belong here. Maybe \"introduced\" or possibly \"brought\"?", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403888506", "createdAt": "2020-04-06T07:43:25Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, messages are committed consistently with the last state\n+snapshot. This greatly increases the latency, it is determined by the\n+snapshot interval: messages are visible to consumers only after the\n+commit. In order to make it work, the connection factory you provide has\n+to implement `javax.jms.XAConnectionFactory`, otherwise the job will not\n+start.\n+\n+If you want to avoid the higher latency, decrease the overhead wrought", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE1MjIyOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0Mzo0MlrOGBLaHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0Mzo0MlrOGBLaHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4ODY2OA==", "bodyText": "the ... mode", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403888668", "createdAt": "2020-04-06T07:43:42Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, messages are committed consistently with the last state\n+snapshot. This greatly increases the latency, it is determined by the\n+snapshot interval: messages are visible to consumers only after the\n+commit. In order to make it work, the connection factory you provide has\n+to implement `javax.jms.XAConnectionFactory`, otherwise the job will not\n+start.\n+\n+If you want to avoid the higher latency, decrease the overhead wrought\n+by the XA transactions, if your JMS implementation doesn't support XA\n+transactions or if you just don't need the guarantee, you can reduce it\n+just for the sink:\n+\n+```java\n+stage.writeTo(Sinks\n+         .jmsQueueBuilder(() -> new ActiveMQConnectionFactory(\"tcp://localhost:61616\"))\n+         // decrease the guarantee for the sink\n+         .exactlyOnce(false)\n+         .build());\n+```\n+\n+In at-least-once mode or if no guarantee is enabled, the transaction is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE1MzI3OnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0Mzo1OFrOGBLauQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0Mzo1OFrOGBLauQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4ODgyNQ==", "bodyText": "this is --the-- JMS's way", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403888825", "createdAt": "2020-04-06T07:43:58Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -503,40 +549,46 @@ p.readFrom(Sources.list(\"inputList\"))\n  );\n ```\n \n+####\u00a0Fault Tolerance\n+\n+The JMS sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, messages are committed consistently with the last state\n+snapshot. This greatly increases the latency, it is determined by the\n+snapshot interval: messages are visible to consumers only after the\n+commit. In order to make it work, the connection factory you provide has\n+to implement `javax.jms.XAConnectionFactory`, otherwise the job will not\n+start.\n+\n+If you want to avoid the higher latency, decrease the overhead wrought\n+by the XA transactions, if your JMS implementation doesn't support XA\n+transactions or if you just don't need the guarantee, you can reduce it\n+just for the sink:\n+\n+```java\n+stage.writeTo(Sinks\n+         .jmsQueueBuilder(() -> new ActiveMQConnectionFactory(\"tcp://localhost:61616\"))\n+         // decrease the guarantee for the sink\n+         .exactlyOnce(false)\n+         .build());\n+```\n+\n+In at-least-once mode or if no guarantee is enabled, the transaction is\n+committed after each batch of messages: transactions are used for\n+performance as this is the JMS' way to send messages in batches. Batches", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE1ODI3OnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0NToyMFrOGBLdmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0NToyMFrOGBLdmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4OTU2Mg==", "bodyText": "I would remove \"out there\", it is conversational.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403889562", "createdAt": "2020-04-06T07:45:20Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -770,12 +822,12 @@ which we will explore.\n \n ###\u00a0JDBC\n \n-JDBC is a very well established database API supported by every major\n-relational (and many non-relational) database implementation out there\n+JDBC is a well-established database API supported by every major\n+relational (and many non-relational) database implementations out there", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE2MTYyOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0NjoxOVrOGBLftw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0NjoxOVrOGBLftw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MDEwMw==", "bodyText": "I think \"JDBC driver\" is the official name, not just common usage.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403890103", "createdAt": "2020-04-06T07:46:19Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -770,12 +822,12 @@ which we will explore.\n \n ###\u00a0JDBC\n \n-JDBC is a very well established database API supported by every major\n-relational (and many non-relational) database implementation out there\n+JDBC is a well-established database API supported by every major\n+relational (and many non-relational) database implementations out there\n including Oracle, MySQL, PostgreSQL, Microsoft SQL Server. The libraries\n-are typically referred to as _drivers_ and every major database vendor will\n-have this driver available for either download or on a package repository\n-such as maven.\n+are typically referred to as _JDBC drivers_ and every major database", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE2MzIzOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0Njo0M1rOGBLgpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0Njo0M1rOGBLgpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MDM0MQ==", "bodyText": "in a package repository", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403890341", "createdAt": "2020-04-06T07:46:43Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -770,12 +822,12 @@ which we will explore.\n \n ###\u00a0JDBC\n \n-JDBC is a very well established database API supported by every major\n-relational (and many non-relational) database implementation out there\n+JDBC is a well-established database API supported by every major\n+relational (and many non-relational) database implementations out there\n including Oracle, MySQL, PostgreSQL, Microsoft SQL Server. The libraries\n-are typically referred to as _drivers_ and every major database vendor will\n-have this driver available for either download or on a package repository\n-such as maven.\n+are typically referred to as _JDBC drivers_ and every major database\n+vendor will have this driver available for either download or on a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE2NjY5OnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0NzozNFrOGBLiqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0NzozNFrOGBLiqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MDg1Nw==", "bodyText": "the ... guarantee.", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403890857", "createdAt": "2020-04-06T07:47:34Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -837,7 +889,38 @@ p.readFrom(KafkaSources.<Person>kafka(.., \"people\"))\n JDBC sink will automatically try to reconnect during database\n connectivity issues and is suitable for use in streaming jobs. If you\n want to avoid duplicate writes to the database, then a suitable\n-_insert-or-update_ statement should be used instead of `INSERT`.\n+_insert-or-update_ statement should be used instead of `INSERT`, such as\n+`MERGE` or `REPLACE` or `INSERT .. ON CONFLICT ..`.\n+\n+#### Fault tolerance\n+\n+The JDBC sink supports exactly-once guarantee. It uses two-phase XA", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjE2ODUyOnYy", "diffSide": "RIGHT", "path": "site/docs/api/sources-sinks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0Nzo1N1rOGBLjtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0Nzo1N1rOGBLjtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg5MTEyNA==", "bodyText": "the variant", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2138#discussion_r403891124", "createdAt": "2020-04-06T07:47:57Z", "author": {"login": "mtopolnik"}, "path": "site/docs/api/sources-sinks.md", "diffHunk": "@@ -837,7 +889,38 @@ p.readFrom(KafkaSources.<Person>kafka(.., \"people\"))\n JDBC sink will automatically try to reconnect during database\n connectivity issues and is suitable for use in streaming jobs. If you\n want to avoid duplicate writes to the database, then a suitable\n-_insert-or-update_ statement should be used instead of `INSERT`.\n+_insert-or-update_ statement should be used instead of `INSERT`, such as\n+`MERGE` or `REPLACE` or `INSERT .. ON CONFLICT ..`.\n+\n+#### Fault tolerance\n+\n+The JDBC sink supports exactly-once guarantee. It uses two-phase XA\n+transactions, the DML statements are committed consistently with the\n+last state snapshot. This greatly increases the latency, it is\n+determined by the snapshot interval: messages are visible to consumers\n+only after the commit. In order to make it work, instead of the JDBC URL\n+you have to use variant with `Supplier<CommonDataSource>` and it must", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afda210804e7962885450934a2be3829bdff013"}, "originalPosition": 278}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4786, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}