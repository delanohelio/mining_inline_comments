{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NjczMjIw", "number": 15000, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozMzowMVrOEXZ5Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNzo0MVrOEZpV0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTc2OTMxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozMzowMVrOG_LfHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNzo0MzozMVrOHA9Qjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTY2Mg==", "bodyText": "We shouldn't have a seperate runtime planchecker, since the runtime plan has the same requirements as the \"final\" plan. Instead, we should be running the planchecker for the final stage after doing runtime optimization", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r468901662", "createdAt": "2020-08-11T22:33:01Z", "author": {"login": "rschlussel"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java", "diffHunk": "@@ -74,6 +74,9 @@ public PlanChecker(FeaturesConfig featuresConfig, boolean forceSingleNode)\n                         new VerifyProjectionLocality(),\n                         new DynamicFiltersChecker(),\n                         new WarnOnScanWithoutPartitionPredicate(featuresConfig))\n+                .putAll(\n+                        Stage.RUNTIME,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38db5e2ad4c8f684dd12effff496dac840df73da"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyMzIyMQ==", "bodyText": "Discussed offline. We do not want to modify any existing checks in the FINAL and FRAGMENT stages, but there are problems for using each of the two stage to carry out runtime checking (e.g. FINAL is targeting a whole plan, FRAGMENT is generic whereas the streaming property check is specific to fragments with their exchange sources materialized). So decide to add a RUNTIME stage and copy all necessary checks into this stage. Future runtime checks around exchange materialized stages will also go into this new category.", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r470123221", "createdAt": "2020-08-13T17:32:12Z", "author": {"login": "pguofb"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java", "diffHunk": "@@ -74,6 +74,9 @@ public PlanChecker(FeaturesConfig featuresConfig, boolean forceSingleNode)\n                         new VerifyProjectionLocality(),\n                         new DynamicFiltersChecker(),\n                         new WarnOnScanWithoutPartitionPredicate(featuresConfig))\n+                .putAll(\n+                        Stage.RUNTIME,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTY2Mg=="}, "originalCommit": {"oid": "38db5e2ad4c8f684dd12effff496dac840df73da"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc2NDY5Ng==", "bodyText": "sorry, been thinking about this again.  is there a way to make this check in the \"fragment\" section, but for it to only run if the plan has a tablescan stage.  Because the check isn't specific to anything that happens at runtime, it's just that runtime optimization happens to only involve certain kinds of fragments", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r470764696", "createdAt": "2020-08-14T17:41:21Z", "author": {"login": "rschlussel"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java", "diffHunk": "@@ -74,6 +74,9 @@ public PlanChecker(FeaturesConfig featuresConfig, boolean forceSingleNode)\n                         new VerifyProjectionLocality(),\n                         new DynamicFiltersChecker(),\n                         new WarnOnScanWithoutPartitionPredicate(featuresConfig))\n+                .putAll(\n+                        Stage.RUNTIME,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTY2Mg=="}, "originalCommit": {"oid": "38db5e2ad4c8f684dd12effff496dac840df73da"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc2NTcxMQ==", "bodyText": "Sure, totally make sense.", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r470765711", "createdAt": "2020-08-14T17:43:31Z", "author": {"login": "pguofb"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java", "diffHunk": "@@ -74,6 +74,9 @@ public PlanChecker(FeaturesConfig featuresConfig, boolean forceSingleNode)\n                         new VerifyProjectionLocality(),\n                         new DynamicFiltersChecker(),\n                         new WarnOnScanWithoutPartitionPredicate(featuresConfig))\n+                .putAll(\n+                        Stage.RUNTIME,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMTY2Mg=="}, "originalCommit": {"oid": "38db5e2ad4c8f684dd12effff496dac840df73da"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTc3MzY5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateRuntimeSwappedJoins.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozNDo0NVrOG_LhsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzozMzowMVrOHAWFyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMjMyMA==", "bodyText": "This plan checker is too specific to a particular optimizer rule.  PlanCheckers should be enforcing general requirements for a valid plan regardless of what optimizers ran.", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r468902320", "createdAt": "2020-08-11T22:34:45Z", "author": {"login": "rschlussel"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateRuntimeSwappedJoins.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.sanity;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.planner.TypeProvider;\n+import com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties;\n+import com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.StreamProperties;\n+import com.facebook.presto.sql.planner.plan.InternalPlanVisitor;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.sanity.PlanChecker.Checker;\n+\n+import java.util.List;\n+\n+import static com.facebook.presto.SystemSessionProperties.getTaskConcurrency;\n+import static com.facebook.presto.SystemSessionProperties.isSpillEnabled;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.defaultParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.exactlyPartitionedOn;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.fixedParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.singleStream;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.derivePropertiesRecursively;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+public class ValidateRuntimeSwappedJoins", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38db5e2ad4c8f684dd12effff496dac840df73da"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyMzk3OA==", "bodyText": "Discussed offline. The naming is changed to reflect its actual purpose.", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r470123978", "createdAt": "2020-08-13T17:33:01Z", "author": {"login": "pguofb"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateRuntimeSwappedJoins.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.sanity;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.planner.TypeProvider;\n+import com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties;\n+import com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.StreamProperties;\n+import com.facebook.presto.sql.planner.plan.InternalPlanVisitor;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.sanity.PlanChecker.Checker;\n+\n+import java.util.List;\n+\n+import static com.facebook.presto.SystemSessionProperties.getTaskConcurrency;\n+import static com.facebook.presto.SystemSessionProperties.isSpillEnabled;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.defaultParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.exactlyPartitionedOn;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.fixedParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.singleStream;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.derivePropertiesRecursively;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+public class ValidateRuntimeSwappedJoins", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMjMyMA=="}, "originalCommit": {"oid": "38db5e2ad4c8f684dd12effff496dac840df73da"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI0ODI4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/LegacySqlQueryScheduler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMzo0MVrOHClDvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDo1MDozM1rOHCmMxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NjM2NA==", "bodyText": "I worry about this because then we won't know if this feature breaks.  I think we should let it fail instead, or at least have a test mode that we let fail and turn on for all our tests (similar to ignore-stats-calculator-failures)", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472466364", "createdAt": "2020-08-18T20:23:41Z", "author": {"login": "rschlussel"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/LegacySqlQueryScheduler.java", "diffHunk": "@@ -538,7 +556,13 @@ private StreamingPlanSection tryCostBasedOptimize(StreamingPlanSection section)\n                 .forEach(currentSubPlan -> {\n                     Optional<PlanFragment> newPlanFragment = performRuntimeOptimizations(currentSubPlan);\n                     if (newPlanFragment.isPresent()) {\n-                        oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        try {\n+                            planChecker.validatePlanFragment(newPlanFragment.get().getRoot(), session, metadata, sqlParser, variableAllocator.getTypes(), warningCollector);\n+                            oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        }\n+                        catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c77723ef8d58b03eb59352067e29ba35cd7d1de"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ4NTA2MQ==", "bodyText": "Sure, let's just have it fail instead.", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472485061", "createdAt": "2020-08-18T20:50:33Z", "author": {"login": "pguofb"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/LegacySqlQueryScheduler.java", "diffHunk": "@@ -538,7 +556,13 @@ private StreamingPlanSection tryCostBasedOptimize(StreamingPlanSection section)\n                 .forEach(currentSubPlan -> {\n                     Optional<PlanFragment> newPlanFragment = performRuntimeOptimizations(currentSubPlan);\n                     if (newPlanFragment.isPresent()) {\n-                        oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        try {\n+                            planChecker.validatePlanFragment(newPlanFragment.get().getRoot(), session, metadata, sqlParser, variableAllocator.getTypes(), warningCollector);\n+                            oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        }\n+                        catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NjM2NA=="}, "originalCommit": {"oid": "4c77723ef8d58b03eb59352067e29ba35cd7d1de"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI1NDUxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/SqlQueryScheduler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNDo0NFrOHClHlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNDo0NFrOHClHlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NzM1MA==", "bodyText": "ditto", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472467350", "createdAt": "2020-08-18T20:24:44Z", "author": {"login": "rschlussel"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/scheduler/SqlQueryScheduler.java", "diffHunk": "@@ -428,7 +446,13 @@ private StreamingPlanSection tryCostBasedOptimize(StreamingPlanSection section)\n                 .forEach(currentSubPlan -> {\n                     Optional<PlanFragment> newPlanFragment = performRuntimeOptimizations(currentSubPlan);\n                     if (newPlanFragment.isPresent()) {\n-                        oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        try {\n+                            planChecker.validatePlanFragment(newPlanFragment.get().getRoot(), session, metadata, sqlParser, variableAllocator.getTypes(), warningCollector);\n+                            oldToNewFragment.put(currentSubPlan.getFragment(), newPlanFragment.get());\n+                        }\n+                        catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c77723ef8d58b03eb59352067e29ba35cd7d1de"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI2OTE1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNzoxNVrOHClRMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNzoxNVrOHClRMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2OTgxMA==", "bodyText": "error message shouldn't mention runtime swapped join", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472469810", "createdAt": "2020-08-18T20:27:15Z", "author": {"login": "rschlussel"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.sanity;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.planner.TypeProvider;\n+import com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties;\n+import com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.StreamProperties;\n+import com.facebook.presto.sql.planner.plan.InternalPlanVisitor;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RemoteSourceNode;\n+import com.facebook.presto.sql.planner.sanity.PlanChecker.Checker;\n+\n+import java.util.List;\n+\n+import static com.facebook.presto.SystemSessionProperties.getTaskConcurrency;\n+import static com.facebook.presto.SystemSessionProperties.isSpillEnabled;\n+import static com.facebook.presto.sql.planner.optimizations.PlanNodeSearcher.searchFrom;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.defaultParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.exactlyPartitionedOn;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.fixedParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.singleStream;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.derivePropertiesRecursively;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+public class ValidateStreamingJoins\n+        implements Checker\n+{\n+    @Override\n+    public void validate(PlanNode planNode, Session session, Metadata metadata, SqlParser sqlParser, TypeProvider types, WarningCollector warningCollector)\n+    {\n+        planNode.accept(new Visitor(session, metadata, sqlParser, types, warningCollector), null);\n+    }\n+\n+    private static final class Visitor\n+            extends InternalPlanVisitor<Void, Void>\n+    {\n+        private final Session session;\n+        private final Metadata metadata;\n+        private final SqlParser sqlParser;\n+        private final TypeProvider types;\n+        private final WarningCollector warningCollector;\n+\n+        private Visitor(Session sesstion, Metadata metadata, SqlParser sqlParser, TypeProvider types, WarningCollector warningCollector)\n+        {\n+            this.session = sesstion;\n+            this.metadata = metadata;\n+            this.sqlParser = sqlParser;\n+            this.types = types;\n+            this.warningCollector = warningCollector;\n+        }\n+\n+        @Override\n+        public Void visitPlan(PlanNode node, Void context)\n+        {\n+            node.getSources().forEach(source -> source.accept(this, context));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitJoin(JoinNode node, Void context)\n+        {\n+            // Validate the streaming property of the join node is satisfied when no RemoteSourceNode is involved.\n+            if (!searchFrom(node).where(RemoteSourceNode.class::isInstance).matches()) {\n+                List<VariableReferenceExpression> buildJoinVariables = node.getCriteria().stream()\n+                        .map(JoinNode.EquiJoinClause::getRight)\n+                        .collect(toImmutableList());\n+                StreamPreferredProperties requiredBuildProperty;\n+                if (getTaskConcurrency(session) > 1) {\n+                    requiredBuildProperty = exactlyPartitionedOn(buildJoinVariables);\n+                }\n+                else {\n+                    requiredBuildProperty = singleStream();\n+                }\n+                StreamProperties buildProperties = derivePropertiesRecursively(node.getRight(), metadata, session, types, sqlParser);\n+                checkArgument(requiredBuildProperty.isSatisfiedBy(buildProperties), \"Build side needs an additional local exchange for runtime swapped join: %s\", node.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c77723ef8d58b03eb59352067e29ba35cd7d1de"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI3MTg2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNzo0MVrOHClTAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNzo0MVrOHClTAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MDI3Mg==", "bodyText": "error message shouldn't mention runtime swapped join", "url": "https://github.com/prestodb/presto/pull/15000#discussion_r472470272", "createdAt": "2020-08-18T20:27:41Z", "author": {"login": "rschlussel"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/ValidateStreamingJoins.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.sanity;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.planner.TypeProvider;\n+import com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties;\n+import com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.StreamProperties;\n+import com.facebook.presto.sql.planner.plan.InternalPlanVisitor;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RemoteSourceNode;\n+import com.facebook.presto.sql.planner.sanity.PlanChecker.Checker;\n+\n+import java.util.List;\n+\n+import static com.facebook.presto.SystemSessionProperties.getTaskConcurrency;\n+import static com.facebook.presto.SystemSessionProperties.isSpillEnabled;\n+import static com.facebook.presto.sql.planner.optimizations.PlanNodeSearcher.searchFrom;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.defaultParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.exactlyPartitionedOn;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.fixedParallelism;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPreferredProperties.singleStream;\n+import static com.facebook.presto.sql.planner.optimizations.StreamPropertyDerivations.derivePropertiesRecursively;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+public class ValidateStreamingJoins\n+        implements Checker\n+{\n+    @Override\n+    public void validate(PlanNode planNode, Session session, Metadata metadata, SqlParser sqlParser, TypeProvider types, WarningCollector warningCollector)\n+    {\n+        planNode.accept(new Visitor(session, metadata, sqlParser, types, warningCollector), null);\n+    }\n+\n+    private static final class Visitor\n+            extends InternalPlanVisitor<Void, Void>\n+    {\n+        private final Session session;\n+        private final Metadata metadata;\n+        private final SqlParser sqlParser;\n+        private final TypeProvider types;\n+        private final WarningCollector warningCollector;\n+\n+        private Visitor(Session sesstion, Metadata metadata, SqlParser sqlParser, TypeProvider types, WarningCollector warningCollector)\n+        {\n+            this.session = sesstion;\n+            this.metadata = metadata;\n+            this.sqlParser = sqlParser;\n+            this.types = types;\n+            this.warningCollector = warningCollector;\n+        }\n+\n+        @Override\n+        public Void visitPlan(PlanNode node, Void context)\n+        {\n+            node.getSources().forEach(source -> source.accept(this, context));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitJoin(JoinNode node, Void context)\n+        {\n+            // Validate the streaming property of the join node is satisfied when no RemoteSourceNode is involved.\n+            if (!searchFrom(node).where(RemoteSourceNode.class::isInstance).matches()) {\n+                List<VariableReferenceExpression> buildJoinVariables = node.getCriteria().stream()\n+                        .map(JoinNode.EquiJoinClause::getRight)\n+                        .collect(toImmutableList());\n+                StreamPreferredProperties requiredBuildProperty;\n+                if (getTaskConcurrency(session) > 1) {\n+                    requiredBuildProperty = exactlyPartitionedOn(buildJoinVariables);\n+                }\n+                else {\n+                    requiredBuildProperty = singleStream();\n+                }\n+                StreamProperties buildProperties = derivePropertiesRecursively(node.getRight(), metadata, session, types, sqlParser);\n+                checkArgument(requiredBuildProperty.isSatisfiedBy(buildProperties), \"Build side needs an additional local exchange for runtime swapped join: %s\", node.getId());\n+\n+                StreamPreferredProperties requiredProbeProperty;\n+                if (isSpillEnabled(session)) {\n+                    requiredProbeProperty = fixedParallelism();\n+                }\n+                else {\n+                    requiredProbeProperty = defaultParallelism(session);\n+                }\n+                StreamProperties probeProperties = derivePropertiesRecursively(node.getLeft(), metadata, session, types, sqlParser);\n+                checkArgument(requiredProbeProperty.isSatisfiedBy(probeProperties), \"Probe side needs an additional local exchange for runtime swapped join: %s\", node.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c77723ef8d58b03eb59352067e29ba35cd7d1de"}, "originalPosition": 103}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2285, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}