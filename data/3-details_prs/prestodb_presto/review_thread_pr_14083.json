{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNzQzMzI5", "number": 14083, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMzoyNTowMFrODe_3og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwMTo1MTowN1rODgihnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODMwMzA2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMzoyNTowMFrOFoc1pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODo1NDo1NVrOFo6lEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1OTg0NQ==", "bodyText": "Is enqueue called from multiple threads? IOW do multiple threads enter this loop and fetch nextClientBufferIndex?", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r377959845", "createdAt": "2020-02-11T23:25:00Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();\n+        for (int i = 0; i < buffers.size(); i++) {\n+            buffers.get(index).loadPagesIfNecessary(masterBuffer);\n+            index = (index + 1) % buffers.size();\n             if (masterBuffer.isEmpty()) {\n+                // Resume from the next client buffer on the next iteration\n+                nextClientBufferIndex.set(index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3Mjg3Nw==", "bodyText": "I believe it\u2019s possible that yes, they could. I didn\u2019t look into it because I propose that scenario is not a \u201cproblem\u201d worth solving because if that does happen this implementation will put one thread \u201cin front\u201d of the other in performing the iteration at all times (even if the leading caller changes between iterations). The net result is that the leading caller releases any blocked clients and the trailing caller has no effect. That seems preferable to putting more synchronization around enqueue operations, because this path only matters when the producer side is slower than consumers. A faster producer still drives the output distribution through consumption rate.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r377972877", "createdAt": "2020-02-12T00:05:21Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();\n+        for (int i = 0; i < buffers.size(); i++) {\n+            buffers.get(index).loadPagesIfNecessary(masterBuffer);\n+            index = (index + 1) % buffers.size();\n             if (masterBuffer.isEmpty()) {\n+                // Resume from the next client buffer on the next iteration\n+                nextClientBufferIndex.set(index);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1OTg0NQ=="}, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NzEyMQ==", "bodyText": "WFM", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r378447121", "createdAt": "2020-02-12T18:54:55Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();\n+        for (int i = 0; i < buffers.size(); i++) {\n+            buffers.get(index).loadPagesIfNecessary(masterBuffer);\n+            index = (index + 1) % buffers.size();\n             if (masterBuffer.isEmpty()) {\n+                // Resume from the next client buffer on the next iteration\n+                nextClientBufferIndex.set(index);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1OTg0NQ=="}, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODMwMzU3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMzoyNToxM1rOFoc18g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTo1MToyMFrOFo8aGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1OTkyMg==", "bodyText": "Given the current usage you don't need nextClientBufferIndex to be an AtomicLong. volatile would suffice.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r377959922", "createdAt": "2020-02-11T23:25:13Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -73,6 +73,9 @@\n     @GuardedBy(\"this\")\n     private final ConcurrentMap<OutputBufferId, ClientBuffer> buffers = new ConcurrentHashMap<>();\n \n+    //  The index of the first client buffer that should be polled\n+    private final AtomicInteger nextClientBufferIndex = new AtomicInteger(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3OTgzNA==", "bodyText": "I tend to prefer Aomic* over volatile for maintainability because of how easy it is for future changes to treat volatile fields as \u201cregular int\u201d and do something like use it in a loop counter. I\u2019m fine changing it to volatile if you prefer.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r377979834", "createdAt": "2020-02-12T00:29:15Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -73,6 +73,9 @@\n     @GuardedBy(\"this\")\n     private final ConcurrentMap<OutputBufferId, ClientBuffer> buffers = new ConcurrentHashMap<>();\n \n+    //  The index of the first client buffer that should be polled\n+    private final AtomicInteger nextClientBufferIndex = new AtomicInteger(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1OTkyMg=="}, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NzA4Mg==", "bodyText": "I don't have a strong preference in this case. You can leave it as is.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r378477082", "createdAt": "2020-02-12T19:51:20Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -73,6 +73,9 @@\n     @GuardedBy(\"this\")\n     private final ConcurrentMap<OutputBufferId, ClientBuffer> buffers = new ConcurrentHashMap<>();\n \n+    //  The index of the first client buffer that should be polled\n+    private final AtomicInteger nextClientBufferIndex = new AtomicInteger(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk1OTkyMg=="}, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODMwOTM3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMzoyNzo0N1rOFoc5bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNToyMDozNFrOFpX4yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MDgxNA==", "bodyText": "This reordered checking if the masterBuffer is empty before loading the client. Depending on which case is more common this results in a bunch of extra lock acquisitions inside a client.\nI think this also means that the index is incremented even if no data is loaded into it which might be undesirable?", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r377960814", "createdAt": "2020-02-11T23:27:47Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();\n+        for (int i = 0; i < buffers.size(); i++) {\n+            buffers.get(index).loadPagesIfNecessary(masterBuffer);\n+            index = (index + 1) % buffers.size();\n             if (masterBuffer.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3Nzc3NQ==", "bodyText": "The code was a little cleaner this way (not a ton) but the assumptions are:\n\nthis code path only matters when the producing side is slow, and the master buffer is usually emptied before all client buffers have been fed (or: most clients are waiting on data)\nsince we just added data to the buffer, at least one iteration will receive data unless a race is lost in a very narrow window. Checking for empty first does not completely remove that window\n\nIf that occurs then yes, a client may \u201cmiss a turn\u201d. I think that\u2019s probably ok since missing a turn under these conditions implies that almost all clients are starved. The goal is not to be perfectly fair, but rather to spread the trickle of data more evenly.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r377977775", "createdAt": "2020-02-12T00:22:36Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();\n+        for (int i = 0; i < buffers.size(); i++) {\n+            buffers.get(index).loadPagesIfNecessary(masterBuffer);\n+            index = (index + 1) % buffers.size();\n             if (masterBuffer.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MDgxNA=="}, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1MTE0OQ==", "bodyText": "Could this introduce a weird odd/even bias? Or maybe not odd/even depending on how many clients a given input is divided up over, but some multiple of whatever clients buffer.\n        // handle potential for racy update of indexOffset and buffer list copy\n        int index = nextClientBufferIndex.get() % buffers.size();\n        for (int i = 0; i < buffers.size(); i++) {\n            if (masterBuffer.isEmpty()) {\n                break;\n            }\n            buffers.get(index).loadPagesIfNecessary(masterBuffer);\n            index = (index + 1) % buffers.size();\n        }\n        // Resume from the next client buffer on the next iteration\n        nextClientBufferIndex.set(index);\n\nDoesn't look much worse to me and it does closer to what you would expect.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r378451149", "createdAt": "2020-02-12T19:02:25Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();\n+        for (int i = 0; i < buffers.size(); i++) {\n+            buffers.get(index).loadPagesIfNecessary(masterBuffer);\n+            index = (index + 1) % buffers.size();\n             if (masterBuffer.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MDgxNA=="}, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkyNzMwNA==", "bodyText": "Sure. I've reordered the check to the start of the loop to match your example with one change: the atomic write to nextClientBufferIndex is still only necessary when the loop exits early. If the loop completes then no atomic write is necessary because the next iteration starts from the same offset as the previous one.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r378927304", "createdAt": "2020-02-13T15:20:34Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();\n+        for (int i = 0; i < buffers.size(); i++) {\n+            buffers.get(index).loadPagesIfNecessary(masterBuffer);\n+            index = (index + 1) % buffers.size();\n             if (masterBuffer.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MDgxNA=="}, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODMxMjIyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMzoyOToxMFrOFoc7OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNzoxOTo1OVrOFpcm9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MTI3Mg==", "bodyText": "I'm not sure why this is written this way. Why materialize this list on read every time? Why not materialize it only when the set of buffers changes?\nOrthogonal to your set of changes though.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r377961272", "createdAt": "2020-02-11T23:29:10Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -395,7 +409,7 @@ private synchronized ClientBuffer getBuffer(OutputBufferId id)\n         return buffer;\n     }\n \n-    private synchronized Collection<ClientBuffer> safeGetBuffersSnapshot()\n+    private synchronized List<ClientBuffer> safeGetBuffersSnapshot()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3OTA1Mw==", "bodyText": "I looked at that too, but shied away from it because of the on demand client buffer creation inside of \u201cget\u201d. Keeping the two structures in sync seemed brittle, but can definitely be done.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r377979053", "createdAt": "2020-02-12T00:26:57Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -395,7 +409,7 @@ private synchronized ClientBuffer getBuffer(OutputBufferId id)\n         return buffer;\n     }\n \n-    private synchronized Collection<ClientBuffer> safeGetBuffersSnapshot()\n+    private synchronized List<ClientBuffer> safeGetBuffersSnapshot()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MTI3Mg=="}, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAwNDY2MA==", "bodyText": "Yeah. It wouldn't be difficult to make not brittle just because the set of buffers is only ever added to. A CAS loop on updating the materialized list would be enough.\nTotally out of scope for this just seems like LHF.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379004660", "createdAt": "2020-02-13T17:19:59Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -395,7 +409,7 @@ private synchronized ClientBuffer getBuffer(OutputBufferId id)\n         return buffer;\n     }\n \n-    private synchronized Collection<ClientBuffer> safeGetBuffersSnapshot()\n+    private synchronized List<ClientBuffer> safeGetBuffersSnapshot()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2MTI3Mg=="}, "originalCommit": {"oid": "bdcd004e94fe322ac4e3db46af2da182857a3c30"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njk1ODk5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOToxNzoxNFrOFpwAug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMzoyODozOFrOFqGU7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyMjU1NA==", "bodyText": "Why do you need to do  % buffers.size() here since you already did index = (index + 1) % buffers.size(); when setting the value of it in the loop?", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379322554", "createdAt": "2020-02-14T09:17:14Z", "author": {"login": "yingsu00"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUxMDYwNg==", "bodyText": "The index is used before the value is clamped for subsequent iterations of the loop.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379510606", "createdAt": "2020-02-14T16:01:02Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyMjU1NA=="}, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY4ODE3NQ==", "bodyText": "I see. The buffer.size() could be changing between two enqueue calls.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379688175", "createdAt": "2020-02-14T23:28:38Z", "author": {"login": "yingsu00"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMyMjU1NA=="}, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzAxMTIwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOTozNDo0NFrOFpwgEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzo0MTo1NFrOFp-fOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzMDU3OA==", "bodyText": "Since you added the isEmpty() check and a new comment below, this comment line seems to be only for the section\nList<ClientBuffer> buffers = safeGetBuffersSnapshot();\n        if (buffers.isEmpty()) {\n            return;\n        }\n\nAnd this may cause confusion. Would it be better to move it to above line 268??", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379330578", "createdAt": "2020-02-14T09:34:44Z", "author": {"login": "yingsu00"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwOTExNg==", "bodyText": "The entire loop used to be in a separate method and it got pulled up. I hadn't noticed that happened. I think that might be why the comment makes less sense. Is there a reason that happened?", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379509116", "createdAt": "2020-02-14T15:58:21Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzMDU3OA=="}, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1OTczOA==", "bodyText": "Yeah, I kept this PR in sync and that change was based on feedback from the cross port trinodb/trino#2788 (comment)", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379559738", "createdAt": "2020-02-14T17:41:54Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzMDU3OA=="}, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NzAzNDUxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOTo0MjozNlrOFpwuzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNzo0MjozMFrOFp-gSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNDM0OQ==", "bodyText": "Maybe it's because I'm not a native English speaker, but I don't quite understand this sentence. What does client buffers present refer to? I saw you only updated the next index, but not the client buffers. What is **for** racy update? Would handle potential racy update of next index be enough?", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379334349", "createdAt": "2020-02-14T09:42:36Z", "author": {"login": "yingsu00"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNzk1OQ==", "bodyText": "Earlier in the method it retrieves a snapshot of the client buffers. The snapshot could be out of date as soon as it is retrieved. Another client buffer could get added to the set immediately after by another thread.\nThen another thread could update the index to point to the just added client buffer which doesn't exist in the snapshot that was copied.\nIf it's not clear to you then the comment could be more detailed. Spotting and understanding races is hard and we should try to be very particular about how we handle concurrency.", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379507959", "createdAt": "2020-02-14T15:56:26Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNDM0OQ=="}, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2MDAwOA==", "bodyText": "Correct, thanks for the clear explanation @aweisberg", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r379560008", "createdAt": "2020-02-14T17:42:30Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNDM0OQ=="}, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDQ2Njg1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwMTo1MTowN1rOFqzBuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwMTo1MzozMVrOFqzDgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyMDUzNg==", "bodyText": "It looks to me the only difference with trinodb/trino#2788 is the position of these two lines (line 268 - line 269). In trinodb/trino#2788, these two lines are at the beginning of for-loop (before the if (masterBuffer.isEmpty())) statement).\nCurious what's the discussion over this? :)", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r380420536", "createdAt": "2020-02-18T01:51:07Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();\n+        for (int i = 0; i < buffers.size(); i++) {\n             if (masterBuffer.isEmpty()) {\n+                // Resume from the current client buffer on the next iteration\n+                nextClientBufferIndex.set(index);\n                 break;\n             }\n-            clientBuffer.loadPagesIfNecessary(masterBuffer);\n+            buffers.get(index).loadPagesIfNecessary(masterBuffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyMDk5Mg==", "bodyText": "Update: I think the discussion is here: #14083 (comment)", "url": "https://github.com/prestodb/presto/pull/14083#discussion_r380420992", "createdAt": "2020-02-18T01:53:31Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/ArbitraryOutputBuffer.java", "diffHunk": "@@ -248,11 +253,20 @@ public void enqueue(Lifespan lifespan, List<SerializedPage> pages)\n         masterBuffer.addPages(serializedPageReferences);\n \n         // process any pending reads from the client buffers\n-        for (ClientBuffer clientBuffer : safeGetBuffersSnapshot()) {\n+        List<ClientBuffer> buffers = safeGetBuffersSnapshot();\n+        if (buffers.isEmpty()) {\n+            return;\n+        }\n+        // handle potential for racy update of next index and client buffers present\n+        int index = nextClientBufferIndex.get() % buffers.size();\n+        for (int i = 0; i < buffers.size(); i++) {\n             if (masterBuffer.isEmpty()) {\n+                // Resume from the current client buffer on the next iteration\n+                nextClientBufferIndex.set(index);\n                 break;\n             }\n-            clientBuffer.loadPagesIfNecessary(masterBuffer);\n+            buffers.get(index).loadPagesIfNecessary(masterBuffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyMDUzNg=="}, "originalCommit": {"oid": "766bbf23ba75231d61710a556aa08edc43eff5a9"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2988, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}