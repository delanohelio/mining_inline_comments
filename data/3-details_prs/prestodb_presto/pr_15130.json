{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxNjg1MTA0", "number": 15130, "title": "GC issue fixes in SliceDictionarySelectiveReader", "bodyText": "Previously we always allocate a dictionary for every rowgroup when opening a new rowgroup during read. When these dictionaries are humongous, the allocations could cause reliability and performance issues. This PR does the following:\n\nDefer the allocation of the dictionary to getBlock() so that lazyBlocks don't have to allocate memory if they don't need to be loaded.\nDo not create Slice objects when evaluating the filters.\nMaterializes the dictionaries if they are too large. Instead of outputting\na DictionaryBlock, it will output a plain VariableWidthBlock if the dictionaries\nsize is above certain threshold.\n\nThe experiment on user reported query shows over 10x reduction in allocations and over 2x CPU reduction in scan. The query that was reported problematic was\nSELECT COUNT(*) FROM t WHERE c IS NOT NULL;\n\nInput data was 58.4M rows, 4.29GB.\n\n\n\n\nTotal CPU\nWall Time\nTableScan CPU\n\n\n\n\nAria off\n429s\n64s\n7.14m\n\n\nAria on No fix\n407s\n68s\n6.77m\n\n\nAria on With Fix\n155s\n21s\n2.57m\n\n\n\nWithout fix, byte[] (out) was 291,270,027,152 bytes, with fix 13,340,988,744 bytes.\n== NO RELEASE NOTE ==", "createdAt": "2020-09-07T23:38:29Z", "url": "https://github.com/prestodb/presto/pull/15130", "merged": true, "mergeCommit": {"oid": "219c7d76eb42df406213e3ff4f9e8428028fc54e"}, "closed": true, "closedAt": "2020-09-15T13:39:18Z", "author": {"login": "yingsu00"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHBPT4AFqTQ4NDU4MjY1NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdI2lw0gFqTQ4Nzk5MDYxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTgyNjU1", "url": "https://github.com/prestodb/presto/pull/15130#pullrequestreview-484582655", "createdAt": "2020-09-09T00:41:19Z", "commit": {"oid": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDo0MToyMFrOHOyklA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDo0MToyMFrOHOyklA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MDY3Ng==", "bodyText": "nit: can we give it a more meaningful name?", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485270676", "createdAt": "2020-09-09T00:41:20Z", "author": {"login": "sujay-jain"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -87,16 +92,17 @@\n     private final int maxCodePointCount;\n     private final boolean isCharType;\n \n-    private byte[] stripeDictionaryData = EMPTY_DICTIONARY_DATA;\n-    private int[] stripeDictionaryOffsetVector = EMPTY_DICTIONARY_OFFSETS;\n-    private byte[] currentDictionaryData = EMPTY_DICTIONARY_DATA;\n+    private byte[] dictionaryData = EMPTY_DICTIONARY_DATA;\n+    private int[] dictionaryOffsetVector = EMPTY_DICTIONARY_OFFSETS;\n     private int[] stripeDictionaryLength = new int[0];\n     private int[] rowGroupDictionaryLength = new int[0];\n     private byte[] evaluationStatus;\n+    private byte[] tempValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTgyODY5", "url": "https://github.com/prestodb/presto/pull/15130#pullrequestreview-484582869", "createdAt": "2020-09-09T00:42:06Z", "commit": {"oid": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDo0MjowNlrOHOylWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDo0MjowNlrOHOylWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MDg3Mw==", "bodyText": "Could you elaborate on where the numbers came from? Is this something that's standard and well known?", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485270873", "createdAt": "2020-09-09T00:42:06Z", "author": {"login": "sujay-jain"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -78,6 +79,10 @@\n     // add one extra entry for null after stripe/rowGroup dictionary\n     private static final int[] EMPTY_DICTIONARY_OFFSETS = new int[2];\n \n+    // Each rowgroup has roughly 10K rows, and each batch reads 1K rows. So there're about 10 batches in a rowgroup.\n+    private static final int BATCHES_PER_ROWGROUP = 10;\n+    private static final float MATERIALIZATION_RATIO = 2.0f;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTkzMTY2", "url": "https://github.com/prestodb/presto/pull/15130#pullrequestreview-484593166", "createdAt": "2020-09-09T01:18:06Z", "commit": {"oid": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMToxODowNlrOHOzK4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMToxODowNlrOHOzK4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI4MDQ4MA==", "bodyText": "curious why just allNulls check won't be sufficient here", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485280480", "createdAt": "2020-09-09T01:18:06Z", "author": {"login": "sujay-jain"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -365,33 +386,69 @@ public Block getBlock(int[] positions, int positionCount)\n         checkState(positionCount <= outputPositionCount, \"Not enough values\");\n         checkState(!valuesInUse, \"BlockLease hasn't been closed yet\");\n \n-        if (allNulls) {\n+        if (allNulls || nullsCount == outputPositionCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTk1MDA0", "url": "https://github.com/prestodb/presto/pull/15130#pullrequestreview-484595004", "createdAt": "2020-09-09T01:24:14Z", "commit": {"oid": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMToyNDoxNVrOHOzRPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMToyNDoxNVrOHOzRPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI4MjExMA==", "bodyText": "do you think we could extract some of this into functions and have some unit tests for them? there's a lot going on and it is easy to make mistake. Extracting into a function whose name describes what we're doing would also make it more readable :) What do you think? (L394- L411, and L422-L32.. etc)", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485282110", "createdAt": "2020-09-09T01:24:15Z", "author": {"login": "sujay-jain"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -365,33 +386,69 @@ public Block getBlock(int[] positions, int positionCount)\n         checkState(positionCount <= outputPositionCount, \"Not enough values\");\n         checkState(!valuesInUse, \"BlockLease hasn't been closed yet\");\n \n-        if (allNulls) {\n+        if (allNulls || nullsCount == outputPositionCount) {\n             return new RunLengthEncodedBlock(outputType.createBlockBuilder(null, 1).appendNull().build(), positionCount);\n         }\n \n-        if (positionCount == outputPositionCount) {\n-            DictionaryBlock block = new DictionaryBlock(positionCount, dictionary, values);\n-            values = null;\n-            return block;\n+        // compact values(ids) array, and calculate 1) the slice sizeInBytes if materialized, and 2) number of nulls\n+        long blockSizeInBytes = 0;\n+        int nullsCount = 0;  // the nulls count for selected positions\n+        int i = 0;\n+        int j = 0;\n+        while (i < positionCount && j < outputPositionCount) {\n+            if (positions[i] != outputPositions[j]) {\n+                j++;\n+                continue;\n+            }\n+\n+            int id = this.values[j];\n+            values[i] = id;\n+\n+            blockSizeInBytes += dictionaryOffsetVector[id + 1] - dictionaryOffsetVector[id];\n+            nullsCount += id == currentDictionarySize - 1 ? 1 : 0;\n+\n+            i++;\n+            j++;\n         }\n \n-        int[] valuesCopy = new int[positionCount];\n+        // If all selected positions are null, just return RLE block.\n+        if (nullsCount == outputPositionCount) {\n+            return new RunLengthEncodedBlock(outputType.createBlockBuilder(null, 1).appendNull().build(), positionCount);\n+        }\n \n-        int positionIndex = 0;\n-        int nextPosition = positions[positionIndex];\n-        for (int i = 0; i < outputPositionCount; i++) {\n-            if (outputPositions[i] < nextPosition) {\n-                continue;\n+        // If the expected materialized size of the output block is smaller than a certain ratio of the dictionary size, we will materialize the values\n+        int dictionarySizeInBytes = dictionaryOffsetVector[currentDictionarySize - 1];\n+        if (blockSizeInBytes * BATCHES_PER_ROWGROUP < dictionarySizeInBytes / MATERIALIZATION_RATIO) {\n+            byte[] sliceData = new byte[toIntExact(blockSizeInBytes)];\n+            int[] offsetVector = new int[positionCount + 1];\n+            int currentOffset = 0;\n+            for (int k = 0; k < positionCount; k++) {\n+                int id = values[k];\n+                int offset = dictionaryOffsetVector[id];\n+                int length = dictionaryOffsetVector[id + 1] - offset;\n+                System.arraycopy(dictionaryData, offset, sliceData, currentOffset, length);\n+\n+                currentOffset += length;\n+                offsetVector[k + 1] = currentOffset;\n             }\n-            assert outputPositions[i] == nextPosition;\n-            valuesCopy[positionIndex] = this.values[i];\n-            positionIndex++;\n-            if (positionIndex >= positionCount) {\n-                break;\n+\n+            if (nullsCount > 0) {\n+                boolean[] isNullVector = new boolean[positionCount];\n+                for (int k = 0; k < positionCount; k++) {\n+                    if (values[k] == currentDictionarySize - 1) {\n+                        isNullVector[k] = true;\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2"}, "originalPosition": 199}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/90ef6a5070ed69288fdd5135a6e4b1dd7dcf89a2", "committedDate": "2020-09-07T23:29:45Z", "message": "Introduce large dictionary mode in SliceDictionarySelectiveReader\n\nPreviously we always allocate a dictionary for every rowgroup. When\nthese dictionaries are humongous, the allocations could cause reliability\nand performance issues. This commit materializes the dictionaries if\nthey are too large. Instead of outputting a DictionaryBlock, it will\noutput a plain VariableWidthBlock if the dictionaries size is above\ncertain threshold. The experiment on user reported query shows over 10x\nreduction in allocations and over 2x CPU reduction in scan."}, "afterCommit": {"oid": "fc597169ff1e05022e177ccafc2c7af513dba414", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/fc597169ff1e05022e177ccafc2c7af513dba414", "committedDate": "2020-09-09T08:15:00Z", "message": "Introduce large dictionary mode in SliceDictionarySelectiveReader\n\nPreviously we always allocate a dictionary for every rowgroup. When\nthese dictionaries are humongous, the allocations could cause reliability\nand performance issues. This commit materializes the dictionaries if\nthey are too large. Instead of outputting a DictionaryBlock, it will\noutput a plain VariableWidthBlock if the dictionaries size is above\ncertain threshold. The experiment on user reported query shows over 10x\nreduction in allocations and over 2x CPU reduction in scan."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MzAxOTE0", "url": "https://github.com/prestodb/presto/pull/15130#pullrequestreview-485301914", "createdAt": "2020-09-09T18:48:35Z", "commit": {"oid": "7aebb0e5020f0d1cd24b748bfe8f875dbe435b88"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODo0ODozNVrOHPVN0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTowNzozN1rOHPV12w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzODI5MA==", "bodyText": "Should probably be a checkState and not an assert", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485838290", "createdAt": "2020-09-09T18:48:35Z", "author": {"login": "sachdevs"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -286,12 +294,21 @@ private int readWithFilter(int[] positions, int positionCount)\n     private byte evaluateFilter(int position, int index, int length)\n     {\n         if (filter.testLength(length)) {\n-            int currentLength = dictionary.getSliceLength(index);\n-            Slice data = dictionary.getSlice(index, 0, currentLength);\n+            int currentLength = currentDictionaryOffsetVector[index + 1] - currentDictionaryOffsetVector[index];\n+\n+            boolean pass;\n             if (isCharType && length != currentLength) {\n-                data = Chars.padSpaces(data, maxCodePointCount);\n+                assert currentLength <= length;\n+                assert valueWithPadding != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aebb0e5020f0d1cd24b748bfe8f875dbe435b88"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0Mjc5OA==", "bodyText": "nit: if (dictionaryWrapped) return;, bring the rest out of the if block.", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485842798", "createdAt": "2020-09-09T18:56:54Z", "author": {"login": "sachdevs"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -409,9 +429,26 @@ public BlockLease getBlockView(int[] positions, int positionCount)\n         if (positionCount < outputPositionCount) {\n             compactValues(positions, positionCount);\n         }\n+        wrapDictionaryIfNecessary();\n         return newLease(new DictionaryBlock(positionCount, dictionary, values));\n     }\n \n+    private void wrapDictionaryIfNecessary()\n+    {\n+        if (!dictionaryWrapped) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aebb0e5020f0d1cd24b748bfe8f875dbe435b88"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0NzQzNQ==", "bodyText": "This logic needs some refactoring in order to be easier to read. We are making 3 different tests here:\n\nfilter.testLength(length)\nfilter.testBytes(valueWithPadding, 0, length); in the case of charType\nfilter.testBytes(currentDictionaryData, currentDictionaryOffsetVector[index], length); in case of non-charType\n\nIf any of these filters fail, we return FILTER_FAILED and in case of pass we return FILTER_PASSED. Using this information we can flatten this logic as follows:\nif (!filter.testLength(length))\n    return FILTER_FAILED;\nif (isCharType && length != currentLength) {\n    //...\n    if (!filter.testBytes(valueWithPadding, 0, length))\n        return FILTER_FAILED;\n} else if (!filter.testBytes(currentDictionaryData, currentDictionaryOffsetVector[index], length)) {\n    return FILTER_FAILED;\n}\n\n// the stuff you do once if(pass) {...}.\n\n\nNow we don't need the pass state variable and branches are clearer.", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485847435", "createdAt": "2020-09-09T19:05:40Z", "author": {"login": "sachdevs"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -286,12 +294,21 @@ private int readWithFilter(int[] positions, int positionCount)\n     private byte evaluateFilter(int position, int index, int length)\n     {\n         if (filter.testLength(length)) {\n-            int currentLength = dictionary.getSliceLength(index);\n-            Slice data = dictionary.getSlice(index, 0, currentLength);\n+            int currentLength = currentDictionaryOffsetVector[index + 1] - currentDictionaryOffsetVector[index];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aebb0e5020f0d1cd24b748bfe8f875dbe435b88"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0ODUzOQ==", "bodyText": "Not a huge fan of this dictionaryWrapped state variable. Makes this hard to read and we now need to account manually when we create the dictionary and it is not wrapped. This makes it prone to future bugs if devs don't know when this var is required to be updated. We already have a flag for stripeDictionaryOpen and this adds extra states. Let's put this beside the currentDictionarySize variable and add a comment for when to update this variable?", "url": "https://github.com/prestodb/presto/pull/15130#discussion_r485848539", "createdAt": "2020-09-09T19:07:37Z", "author": {"login": "sachdevs"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDictionarySelectiveReader.java", "diffHunk": "@@ -89,14 +90,19 @@\n \n     private byte[] stripeDictionaryData = EMPTY_DICTIONARY_DATA;\n     private int[] stripeDictionaryOffsetVector = EMPTY_DICTIONARY_OFFSETS;\n+    private byte[] rowGroupDictionaryData = EMPTY_DICTIONARY_DATA;\n+    private int[] rowGroupDictionaryOffsetVector = EMPTY_DICTIONARY_OFFSETS;\n     private byte[] currentDictionaryData = EMPTY_DICTIONARY_DATA;\n+    private int[] currentDictionaryOffsetVector;\n     private int[] stripeDictionaryLength = new int[0];\n     private int[] rowGroupDictionaryLength = new int[0];\n     private byte[] evaluationStatus;\n+    private byte[] valueWithPadding;\n \n     private int readOffset;\n \n     private VariableWidthBlock dictionary = new VariableWidthBlock(1, wrappedBuffer(EMPTY_DICTIONARY_DATA), EMPTY_DICTIONARY_OFFSETS, Optional.of(new boolean[] {true}));\n+    private boolean dictionaryWrapped;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aebb0e5020f0d1cd24b748bfe8f875dbe435b88"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26c21fc325c1c36c563dcf4136ecc486454bfeb3", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/26c21fc325c1c36c563dcf4136ecc486454bfeb3", "committedDate": "2020-09-11T00:46:01Z", "message": "Defer the creation of dictionary in SliceDictionarySelectiveReader\n\nPreviously the dicitonary data byte arrays were allocated as soon as a\nstripe or a rowgroup is open during read(). This commit persists them\nas local buffers, and only copies them to create the dictionary until\ngetBlock() is called. This way the expensive allocations can be avoided\nif a lazyBlock doesn't need to be read.\n\nMoreover, this commit avoids creating Slices when evaluating the\nfilters, which was also another source of big  memory allocations."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c25f40100c56cf2e66abf95d6eb7fcafe4a8088", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/2c25f40100c56cf2e66abf95d6eb7fcafe4a8088", "committedDate": "2020-09-11T00:46:01Z", "message": "Remove stripeDictionaryData buffer in SliceDictionarySelectiveReader\n\nIn the past two buffers were needed to store the dictionaries:\nstripeDictionaryData and rowgroupDictionaryData. The stripeDictionaryData\nis unnecessary because we can just use rowgroupDictionaryData. This\ncommit removes stripeDictionaryData and its offsets vector and renames\nthe rowgroupDictionaryData to dictionaryData. currentDicionaryData is\nalso removed since there is only one buffer now."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e705248144080bdf198d877f8cfdb0bbc06a02c", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/4e705248144080bdf198d877f8cfdb0bbc06a02c", "committedDate": "2020-09-11T00:46:01Z", "message": "Introduce large dictionary mode in SliceDictionarySelectiveReader\n\nPreviously we always allocate a dictionary for every rowgroup. When\nthese dictionaries are humongous, the allocations could cause reliability\nand performance issues. This commit materializes the dictionaries if\nthey are too large. Instead of outputting a DictionaryBlock, it will\noutput a plain VariableWidthBlock if the dictionaries size is above\ncertain threshold. The experiment on user reported query shows over 10x\nreduction in allocations and over 2x CPU reduction in scan."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc597169ff1e05022e177ccafc2c7af513dba414", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/fc597169ff1e05022e177ccafc2c7af513dba414", "committedDate": "2020-09-09T08:15:00Z", "message": "Introduce large dictionary mode in SliceDictionarySelectiveReader\n\nPreviously we always allocate a dictionary for every rowgroup. When\nthese dictionaries are humongous, the allocations could cause reliability\nand performance issues. This commit materializes the dictionaries if\nthey are too large. Instead of outputting a DictionaryBlock, it will\noutput a plain VariableWidthBlock if the dictionaries size is above\ncertain threshold. The experiment on user reported query shows over 10x\nreduction in allocations and over 2x CPU reduction in scan."}, "afterCommit": {"oid": "4e705248144080bdf198d877f8cfdb0bbc06a02c", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/4e705248144080bdf198d877f8cfdb0bbc06a02c", "committedDate": "2020-09-11T00:46:01Z", "message": "Introduce large dictionary mode in SliceDictionarySelectiveReader\n\nPreviously we always allocate a dictionary for every rowgroup. When\nthese dictionaries are humongous, the allocations could cause reliability\nand performance issues. This commit materializes the dictionaries if\nthey are too large. Instead of outputting a DictionaryBlock, it will\noutput a plain VariableWidthBlock if the dictionaries size is above\ncertain threshold. The experiment on user reported query shows over 10x\nreduction in allocations and over 2x CPU reduction in scan."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTkwNjE5", "url": "https://github.com/prestodb/presto/pull/15130#pullrequestreview-487990619", "createdAt": "2020-09-14T17:24:45Z", "commit": {"oid": "4e705248144080bdf198d877f8cfdb0bbc06a02c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 78, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}