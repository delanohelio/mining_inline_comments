{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNjg2NDI0", "number": 14758, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0MTo1MlrOEKkDoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0Nzo1OVrOEKkNlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTExOTY4OnYy", "diffSide": "RIGHT", "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcWriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0MTo1MlrOGrrXDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNjowMzoyN1rOGrsLpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MjM2Nw==", "bodyText": "do we have unit tests for stats of nested types?", "url": "https://github.com/prestodb/presto/pull/14758#discussion_r448452367", "createdAt": "2020-07-01T15:41:52Z", "author": {"login": "zzhao0"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcWriter.java", "diffHunk": "@@ -623,19 +629,19 @@ public void close()\n             List<WriterEncryptionGroup> writerEncryptionGroups = dwrfWriterEncryption.get().getWriterEncryptionGroups();\n             for (int i = 0; i < writerEncryptionGroups.size(); i++) {\n                 WriterEncryptionGroup group = writerEncryptionGroups.get(i);\n-                List<byte[]> columnStatistics = encryptedStats.get(i)\n-                        .stream()\n-                        .map(DwrfMetadataWriter::toColumnStatistics)\n-                        .map(AbstractMessageLite::toByteArray)\n-                        .collect(toImmutableList());\n-\n                 DwrfProto.FileStatistics fileStatistics = toFileStatistics(encryptedStats.get(i));\n-                byte[] serializedStats = fileStatistics.toByteArray();\n+                DwrfDataEncryptor dwrfDataEncryptor = dwrfEncryptionInfo.getEncryptorByGroupId(i);\n+                OrcOutputBuffer buffer = new OrcOutputBuffer(compression, Optional.of(dwrfDataEncryptor), maxCompressionBufferSize);\n+                fileStatistics.writeTo(buffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25fbb7dea70a1bbf5d7306981ad9f5c123284022"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2NTgzMA==", "bodyText": "We don't have any fileStatistics tests (Presto doesn't use filestatistics for dwrf, so none of our tests are testing the functionality, since we don't read them back). Let me think about how to write some kind of test though and I'll add it as a follow on", "url": "https://github.com/prestodb/presto/pull/14758#discussion_r448465830", "createdAt": "2020-07-01T16:03:27Z", "author": {"login": "rschlussel"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcWriter.java", "diffHunk": "@@ -623,19 +629,19 @@ public void close()\n             List<WriterEncryptionGroup> writerEncryptionGroups = dwrfWriterEncryption.get().getWriterEncryptionGroups();\n             for (int i = 0; i < writerEncryptionGroups.size(); i++) {\n                 WriterEncryptionGroup group = writerEncryptionGroups.get(i);\n-                List<byte[]> columnStatistics = encryptedStats.get(i)\n-                        .stream()\n-                        .map(DwrfMetadataWriter::toColumnStatistics)\n-                        .map(AbstractMessageLite::toByteArray)\n-                        .collect(toImmutableList());\n-\n                 DwrfProto.FileStatistics fileStatistics = toFileStatistics(encryptedStats.get(i));\n-                byte[] serializedStats = fileStatistics.toByteArray();\n+                DwrfDataEncryptor dwrfDataEncryptor = dwrfEncryptionInfo.getEncryptorByGroupId(i);\n+                OrcOutputBuffer buffer = new OrcOutputBuffer(compression, Optional.of(dwrfDataEncryptor), maxCompressionBufferSize);\n+                fileStatistics.writeTo(buffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MjM2Nw=="}, "originalCommit": {"oid": "25fbb7dea70a1bbf5d7306981ad9f5c123284022"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTEzMTI1OnYy", "diffSide": "RIGHT", "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcOutputBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0NDozMFrOGrrduQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNjowNDozMVrOGrsOKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NDA3Mw==", "bodyText": "It's unclear to me how you handle encrypted but uncompressed file. Would be good to throw in that case if not supported at the moment", "url": "https://github.com/prestodb/presto/pull/14758#discussion_r448454073", "createdAt": "2020-07-01T15:44:30Z", "author": {"login": "zzhao0"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcOutputBuffer.java", "diffHunk": "@@ -461,13 +456,21 @@ private void writeChunkToOutputStream(byte[] chunk, int offset, int length)\n \n         int compressedSize = compressor.compress(chunk, offset, length, compressionBuffer, 0, compressionBuffer.length);\n         if (compressedSize < length) {\n+            if (dwrfEncryptor.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25fbb7dea70a1bbf5d7306981ad9f5c123284022"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2NjQ3Mg==", "bodyText": "As per offline conversation I will add a follow up to support this.  I previously thought that wasn't supported by the file format.", "url": "https://github.com/prestodb/presto/pull/14758#discussion_r448466472", "createdAt": "2020-07-01T16:04:31Z", "author": {"login": "rschlussel"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcOutputBuffer.java", "diffHunk": "@@ -461,13 +456,21 @@ private void writeChunkToOutputStream(byte[] chunk, int offset, int length)\n \n         int compressedSize = compressor.compress(chunk, offset, length, compressionBuffer, 0, compressionBuffer.length);\n         if (compressedSize < length) {\n+            if (dwrfEncryptor.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NDA3Mw=="}, "originalCommit": {"oid": "25fbb7dea70a1bbf5d7306981ad9f5c123284022"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NTE0NTE5OnYy", "diffSide": "RIGHT", "path": "presto-orc/src/main/java/com/facebook/presto/orc/stream/OrcInputStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0Nzo1OVrOGrrmqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0Nzo1OVrOGrrmqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NjM2MA==", "bodyText": "This logic is correct for encrypted and compressed file (and a single chunk/page is uncompressed). We need to handle encrypted but uncompressed file.", "url": "https://github.com/prestodb/presto/pull/14758#discussion_r448456360", "createdAt": "2020-07-01T15:47:59Z", "author": {"login": "zzhao0"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/stream/OrcInputStream.java", "diffHunk": "@@ -462,11 +467,19 @@ private void advance()\n         if (isUncompressed) {\n             buffer = ensureCapacity(buffer, chunkLength);\n             length = compressedSliceInput.read(buffer, 0, chunkLength);\n+            if (dwrfDecryptor.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25fbb7dea70a1bbf5d7306981ad9f5c123284022"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2292, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}