{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2MzcwMTEz", "number": 14884, "title": "Fix flaky testRuntimeOptimizedStagesCorrectness", "bodyText": "Fixes #14882\nEssentially, this PR let the setUp() function wait for up to 3min so that all warmup queries (tpch copying) will finish populating their QueryCompletedEvent. This will avoid warm-up query completed events get accidentally captured as that of our testing queries. Further, we add additional checks on the queryId of the testing query and the query id of the captured query completed event, and skip the test when in extreme cases (e.g. warmup query completed event is delayed over 3min) where the two ids do not match.\n== NO RELEASE NOTE ==", "createdAt": "2020-07-24T16:08:45Z", "url": "https://github.com/prestodb/presto/pull/14884", "merged": true, "mergeCommit": {"oid": "57c24f15a0e5bf54bc3a2805defc92f49f463d60"}, "closed": true, "closedAt": "2020-07-27T15:37:33Z", "author": {"login": "pguofb"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc4LHRCABqjM1ODU1NjE0ODQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5DcfaAFqTQ1NTg4NTIwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5fca45841a76f764daf3b9627684db619d9be1aa", "author": {"user": {"login": "pguofb", "name": "Peizhen Guo"}}, "url": "https://github.com/prestodb/presto/commit/5fca45841a76f764daf3b9627684db619d9be1aa", "committedDate": "2020-07-24T18:10:43Z", "message": "Print plan to investigate root cause"}, "afterCommit": {"oid": "bd55659e7adde48a47d673286240376d891c13c0", "author": {"user": {"login": "pguofb", "name": "Peizhen Guo"}}, "url": "https://github.com/prestodb/presto/commit/bd55659e7adde48a47d673286240376d891c13c0", "committedDate": "2020-07-24T21:41:08Z", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bd55659e7adde48a47d673286240376d891c13c0", "author": {"user": {"login": "pguofb", "name": "Peizhen Guo"}}, "url": "https://github.com/prestodb/presto/commit/bd55659e7adde48a47d673286240376d891c13c0", "committedDate": "2020-07-24T21:41:08Z", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness"}, "afterCommit": {"oid": "04fdff8deb1941e0f870e5c9b999aa527d4275b8", "author": {"user": {"login": "pguofb", "name": "Peizhen Guo"}}, "url": "https://github.com/prestodb/presto/commit/04fdff8deb1941e0f870e5c9b999aa527d4275b8", "committedDate": "2020-07-26T00:10:13Z", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "04fdff8deb1941e0f870e5c9b999aa527d4275b8", "author": {"user": {"login": "pguofb", "name": "Peizhen Guo"}}, "url": "https://github.com/prestodb/presto/commit/04fdff8deb1941e0f870e5c9b999aa527d4275b8", "committedDate": "2020-07-26T00:10:13Z", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness"}, "afterCommit": {"oid": "a03efffa80471db1e408368c9c9fa463a32b2e91", "author": {"user": {"login": "pguofb", "name": "Peizhen Guo"}}, "url": "https://github.com/prestodb/presto/commit/a03efffa80471db1e408368c9c9fa463a32b2e91", "committedDate": "2020-07-26T01:25:30Z", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1ODA0MzA0", "url": "https://github.com/prestodb/presto/pull/14884#pullrequestreview-455804304", "createdAt": "2020-07-27T13:55:36Z", "commit": {"oid": "a03efffa80471db1e408368c9c9fa463a32b2e91"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMzo1NTozNlrOG3jkcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMzo1NTozNlrOG3jkcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwNzYzNQ==", "bodyText": "I worry that this means at some point the test can break and we won't know it because we aren't doing any checks. Is this part necessary for fixing the flakiness?  Is there a way to wait for the correct event instead?", "url": "https://github.com/prestodb/presto/pull/14884#discussion_r460907635", "createdAt": "2020-07-27T13:55:36Z", "author": {"login": "rschlussel"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java", "diffHunk": "@@ -101,58 +103,67 @@ public void testRuntimeOptimizedStagesCorrectness()\n     {\n         // We expect one runtime optimized stage: 1.\n         int expectedEvents = 2;\n-        runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey\", expectedEvents);\n+        QueryId queryId = runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey\", expectedEvents);\n         QueryCreatedEvent queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         QueryCompletedEvent queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         QueryMetadata queryMetadata = queryCompletedEvent.getMetadata();\n         Optional<List<StageId>> runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n-        assertTrue(runtimeOptimizedStages.isPresent());\n-        assertEquals(runtimeOptimizedStages.get().size(), 1);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n-                .map(stageId -> String.valueOf(stageId.getId()))\n-                .collect(toImmutableList()));\n+        if (queryMetadata.getQueryId().equals(queryId.toString())) {\n+            assertEquals(queryMetadata.getQueryId(), queryId.toString());\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+            assertTrue(runtimeOptimizedStages.isPresent());\n+            assertEquals(runtimeOptimizedStages.get().size(), 1);\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                    .map(stageId -> String.valueOf(stageId.getId()))\n+                    .collect(toImmutableList()));\n+        }\n \n         // Now, the following query should not trigger runtime optimizations, so should have empty list of runtime optimized stages.\n-        runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM supplier INNER JOIN nation ON supplier.nationkey=nation.nationkey\", expectedEvents);\n+        queryId = runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM supplier INNER JOIN nation ON supplier.nationkey=nation.nationkey\", expectedEvents);\n         queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        assertTrue(queryCompletedEvent.getMetadata().getRuntimeOptimizedStages().isEmpty());\n-        assertFalse(runtimeOptimizedStages.isPresent());\n+        if (queryCompletedEvent.getMetadata().getQueryId().equals(queryId.toString())) {\n+            assertTrue(queryCompletedEvent.getMetadata().getRuntimeOptimizedStages().isEmpty());\n+            assertFalse(runtimeOptimizedStages.isPresent());\n+        }\n \n         // Now, the following query should have two optimized joins in a single stage (both on the same nationkey), therefore expect only one optimized stage: 1.\n-        runQueryAndWaitForEvents(\"SELECT supplier.phone, regionkey, custkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey INNER JOIN customer ON nation.nationkey=customer.nationkey\", expectedEvents);\n+        queryId = runQueryAndWaitForEvents(\"SELECT supplier.phone, regionkey, custkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey INNER JOIN customer ON nation.nationkey=customer.nationkey\", expectedEvents);\n         queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         queryMetadata = queryCompletedEvent.getMetadata();\n         runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n-        assertTrue(runtimeOptimizedStages.isPresent());\n-        assertEquals(runtimeOptimizedStages.get().size(), 1);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n-                .map(stageId -> String.valueOf(stageId.getId()))\n-                .collect(toImmutableList()));\n+        if (queryMetadata.getQueryId().equals(queryId.toString())) {\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 1);\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+            assertTrue(runtimeOptimizedStages.isPresent());\n+            assertEquals(runtimeOptimizedStages.get().size(), 1);\n+            assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                    .map(stageId -> String.valueOf(stageId.getId()))\n+                    .collect(toImmutableList()));\n+        }\n \n         // Now, the following query should have two runtime optimized stages: 1 and 4, corresponding to the two join operations (on regionkey and nationkey respectively).\n-        runQueryAndWaitForEvents(\"WITH natreg AS (SELECT nation.regionkey, nationkey, region.name FROM region INNER JOIN nation ON nation.regionkey=region.regionkey) SELECT phone, regionkey FROM natreg INNER JOIN supplier ON supplier.nationkey=natreg.nationkey\", expectedEvents);\n+        queryId = runQueryAndWaitForEvents(\"WITH natreg AS (SELECT nation.regionkey, nationkey, region.name FROM region INNER JOIN nation ON nation.regionkey=region.regionkey) SELECT phone, regionkey FROM natreg INNER JOIN supplier ON supplier.nationkey=natreg.nationkey\", expectedEvents);\n         queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n         queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n         queryMetadata = queryCompletedEvent.getMetadata();\n         runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n \n-        assertEquals(queryMetadata.getRuntimeOptimizedStages().size(), 2);\n-        assertEquals(ImmutableSet.copyOf(queryMetadata.getRuntimeOptimizedStages()), ImmutableSet.of(\"1\", \"4\"));\n-        assertTrue(runtimeOptimizedStages.isPresent());\n-        assertEquals(runtimeOptimizedStages.get().size(), 2);\n-        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n-                .map(stageId -> String.valueOf(stageId.getId()))\n-                .collect(toImmutableList()));\n+        if (queryMetadata.getQueryId().equals(queryId.toString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a03efffa80471db1e408368c9c9fa463a32b2e91"}, "originalPosition": 119}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae604efaca53d86bd13fdcd674453380018d5500", "author": {"user": {"login": "pguofb", "name": "Peizhen Guo"}}, "url": "https://github.com/prestodb/presto/commit/ae604efaca53d86bd13fdcd674453380018d5500", "committedDate": "2020-07-27T14:12:51Z", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a03efffa80471db1e408368c9c9fa463a32b2e91", "author": {"user": {"login": "pguofb", "name": "Peizhen Guo"}}, "url": "https://github.com/prestodb/presto/commit/a03efffa80471db1e408368c9c9fa463a32b2e91", "committedDate": "2020-07-26T01:25:30Z", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness"}, "afterCommit": {"oid": "ae604efaca53d86bd13fdcd674453380018d5500", "author": {"user": {"login": "pguofb", "name": "Peizhen Guo"}}, "url": "https://github.com/prestodb/presto/commit/ae604efaca53d86bd13fdcd674453380018d5500", "committedDate": "2020-07-27T14:12:51Z", "message": "Fix flaky testRuntimeOptimizedStagesCorrectness"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1ODg1MjAw", "url": "https://github.com/prestodb/presto/pull/14884#pullrequestreview-455885200", "createdAt": "2020-07-27T15:20:36Z", "commit": {"oid": "ae604efaca53d86bd13fdcd674453380018d5500"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 315, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}