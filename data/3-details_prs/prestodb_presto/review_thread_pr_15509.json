{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NjIxMjQ4", "number": 15509, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzozODoxN1rOFK_AFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODoxODoxM1rOFL2ksQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDYyMjkyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeOperator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzozODoxN1rOIN6sOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTowNzo0N1rOIPWG1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2Mzk5NQ==", "bodyText": "Wondering why this isn't volatile? Are multi-field objects a case where unsafe publishing is a good idea?\nWith primitives, yeah I get it's just about physically impossible for the value to not eventually propagate and propagate atomically because it's word sized, but that isn't the case for references to objects as the stores for their contents can be out of order with publishing the reference.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551463995", "createdAt": "2021-01-04T17:38:17Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeOperator.java", "diffHunk": "@@ -92,6 +92,7 @@ public void noMoreOperators()\n     private final PlanNodeId sourceId;\n     private final ExchangeClient exchangeClient;\n     private final PagesSerde serde;\n+    private ListenableFuture<?> isBlocked = NOT_BLOCKED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fe7d4e3ecba9b779721c24b75e57322a9996adc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0NzMyNw==", "bodyText": "All accesses of this field (and operators in general) is done while holding the driver lock in a single threaded manner, so unsafe publication shouldn't be a concern. Even if that weren't true, the only risk would be somehow seeing null in this field because all of the ListenableFuture<?> instances returned here are amenable to being called multiple times- just at the cost of synchronizing into a critical section.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552947327", "createdAt": "2021-01-06T20:31:42Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeOperator.java", "diffHunk": "@@ -92,6 +92,7 @@ public void noMoreOperators()\n     private final PlanNodeId sourceId;\n     private final ExchangeClient exchangeClient;\n     private final PagesSerde serde;\n+    private ListenableFuture<?> isBlocked = NOT_BLOCKED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2Mzk5NQ=="}, "originalCommit": {"oid": "9fe7d4e3ecba9b779721c24b75e57322a9996adc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MTc0OQ==", "bodyText": "I don't think there is a guarantee that the ListenableFuture implementation is constructed in such a way that after the constructor completes the fields are visible? I did look at all the callers and yeah it looks like it is all from the driver loop I just didn't have as high a confidence as you that I wasn't missing something.\nLGTM", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552961749", "createdAt": "2021-01-06T21:07:47Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeOperator.java", "diffHunk": "@@ -92,6 +92,7 @@ public void noMoreOperators()\n     private final PlanNodeId sourceId;\n     private final ExchangeClient exchangeClient;\n     private final PagesSerde serde;\n+    private ListenableFuture<?> isBlocked = NOT_BLOCKED;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2Mzk5NQ=="}, "originalCommit": {"oid": "9fe7d4e3ecba9b779721c24b75e57322a9996adc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDYzMTE2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzo0MDo0OFrOIN6xHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo0MzoyOFrOIPVgxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NTI0NQ==", "bodyText": "Do you need to check this at all before calculating the size? Since it is checked in the synchronized block anyways?\nClosed and failed are rare events.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551465245", "createdAt": "2021-01-04T17:40:48Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MjAwNQ==", "bodyText": "Fair point, I'll remove the pre-checks.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552952005", "createdAt": "2021-01-06T20:43:28Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NTI0NQ=="}, "originalCommit": {"oid": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDY0MjEyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzo0NDoxNVrOIN63sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToyMDo0M1rOIPWaBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NjkyOA==", "bodyText": "Notify blocked callers also synchronizes on this so now it has to re-acquire the lock?", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551466928", "createdAt": "2021-01-04T17:44:15Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {\n             return false;\n         }\n \n-        pageBuffer.addAll(pages);\n+        //  Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n+        }\n+\n+        synchronized (this) {\n+            //  Re-check after lock is acquired\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n+\n+            pageBuffer.addAll(pages);\n \n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            responseSizeExponentialMovingAverage.update(responseSize);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+        }\n         if (!pages.isEmpty()) {\n             // notify all blocked callers\n             notifyBlockedCallers();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MTkxMw==", "bodyText": "Indeed it does, I think the best route here is going to be to clear the blocked callers list while holding the lock and notifying them after releasing it.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552951913", "createdAt": "2021-01-06T20:43:13Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {\n             return false;\n         }\n \n-        pageBuffer.addAll(pages);\n+        //  Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n+        }\n+\n+        synchronized (this) {\n+            //  Re-check after lock is acquired\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n+\n+            pageBuffer.addAll(pages);\n \n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            responseSizeExponentialMovingAverage.update(responseSize);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+        }\n         if (!pages.isEmpty()) {\n             // notify all blocked callers\n             notifyBlockedCallers();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NjkyOA=="}, "originalCommit": {"oid": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MzEwNg==", "bodyText": "In the common case pages will not be empty since one was just added so there is no reason to release the lock before acquiring the list of callers?\nHow common will it be that the list of blocked callers is non-empty? I imagine it depends a lot on the query and whether the producer or the consumer is faster.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552963106", "createdAt": "2021-01-06T21:11:22Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {\n             return false;\n         }\n \n-        pageBuffer.addAll(pages);\n+        //  Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n+        }\n+\n+        synchronized (this) {\n+            //  Re-check after lock is acquired\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n+\n+            pageBuffer.addAll(pages);\n \n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            responseSizeExponentialMovingAverage.update(responseSize);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+        }\n         if (!pages.isEmpty()) {\n             // notify all blocked callers\n             notifyBlockedCallers();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NjkyOA=="}, "originalCommit": {"oid": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjY2MA==", "bodyText": "In the common case pages will not be empty since one was just added so there is no reason to release the lock before acquiring the list of callers?\n\nYou're correct. Originally I restructured it this way to avoid holding the lock for the duration of the notifications being enqueued to the background executor (ScheduledThreadPoolExecutorService have a priority queue as their run queue even for non-scheduled runnables, so enqueues are more expensive than you might expect). I've updated the commit to just duplicate a little snippet of the notifyBlockedCallers() method with the synchronization in the right place.\n\nHow common will it be that the list of blocked callers is non-empty? I imagine it depends a lot on the query and whether the producer or the consumer is faster.\n\nIt should depend on the relative pace of consumers + producers, but I think it's probably very common for the exchange network throughput is slower than whatever consumes from the other side of the exchange. As an aside, before the operator ListenableFuture<?> isBlocked caching change each driver would enqueue at least 3 separate listeners because of the way that the Driver loop discards the future on the first pass.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552966660", "createdAt": "2021-01-06T21:20:43Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {\n             return false;\n         }\n \n-        pageBuffer.addAll(pages);\n+        //  Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n+        }\n+\n+        synchronized (this) {\n+            //  Re-check after lock is acquired\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n+\n+            pageBuffer.addAll(pages);\n \n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            responseSizeExponentialMovingAverage.update(responseSize);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+        }\n         if (!pages.isEmpty()) {\n             // notify all blocked callers\n             notifyBlockedCallers();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NjkyOA=="}, "originalCommit": {"oid": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDY2MTE3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzo0OTozNlrOIN7C0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo1NTo0NlrOIPVzvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2OTc3Ng==", "bodyText": "This is a bit different now in that there can be several threads attempting to notify blocked callers in different orders with different sets of blocked callers. Is that OK? Really hard to reason about without knowing how tolerant blocked callers are of being woken up in different orders.\nSeems like they want to pull data so it is fine for them to come up empty?", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551469776", "createdAt": "2021-01-04T17:49:36Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {\n             return false;\n         }\n \n-        pageBuffer.addAll(pages);\n+        //  Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n+        }\n+\n+        synchronized (this) {\n+            //  Re-check after lock is acquired\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n+\n+            pageBuffer.addAll(pages);\n \n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            responseSizeExponentialMovingAverage.update(responseSize);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+        }\n         if (!pages.isEmpty()) {\n             // notify all blocked callers\n             notifyBlockedCallers();\n         }\n-\n-        long pagesRetainedSizeInBytes = pages.stream()\n-                .mapToLong(SerializedPage::getRetainedSizeInBytes)\n-                .sum();\n-\n-        bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n-        maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n-        systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n-        successfulRequests++;\n-\n-        long responseSize = pages.stream()\n-                .mapToLong(SerializedPage::getSizeInBytes)\n-                .sum();\n-        responseSizeExponentialMovingAverage.update(responseSize);\n-\n         return true;\n     }\n \n-    private synchronized void notifyBlockedCallers()\n+    private void notifyBlockedCallers()\n     {\n-        List<SettableFuture<?>> callers = ImmutableList.copyOf(blockedCallers);\n-        blockedCallers.clear();\n+        List<SettableFuture<?>> callers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1Njg2MQ==", "bodyText": "Yep, even adding a single page to the buffer immediately wakes up any and all waiters so they have to be tolerant to that possibility- still, not a desirable thing to do but addressing that is non-trivial complexity wise.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552956861", "createdAt": "2021-01-06T20:55:46Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {\n             return false;\n         }\n \n-        pageBuffer.addAll(pages);\n+        //  Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n+        }\n+\n+        synchronized (this) {\n+            //  Re-check after lock is acquired\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n+\n+            pageBuffer.addAll(pages);\n \n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            responseSizeExponentialMovingAverage.update(responseSize);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+        }\n         if (!pages.isEmpty()) {\n             // notify all blocked callers\n             notifyBlockedCallers();\n         }\n-\n-        long pagesRetainedSizeInBytes = pages.stream()\n-                .mapToLong(SerializedPage::getRetainedSizeInBytes)\n-                .sum();\n-\n-        bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n-        maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n-        systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n-        successfulRequests++;\n-\n-        long responseSize = pages.stream()\n-                .mapToLong(SerializedPage::getSizeInBytes)\n-                .sum();\n-        responseSizeExponentialMovingAverage.update(responseSize);\n-\n         return true;\n     }\n \n-    private synchronized void notifyBlockedCallers()\n+    private void notifyBlockedCallers()\n     {\n-        List<SettableFuture<?>> callers = ImmutableList.copyOf(blockedCallers);\n-        blockedCallers.clear();\n+        List<SettableFuture<?>> callers;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2OTc3Ng=="}, "originalCommit": {"oid": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDY5MjExOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/BroadcastExchanger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzo1ODo0NlrOIN7V5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzo1ODo0NlrOIN7V5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NDY2Mw==", "bodyText": "This change doesn't look very controversial, LGTM.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551474663", "createdAt": "2021-01-04T17:58:46Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/BroadcastExchanger.java", "diffHunk": "@@ -19,6 +19,7 @@\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bd7bd4a5d6a1485b6d312701bf025fe5cd9bd69"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTI0ODMxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/LocalExchangeMemoryManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMDo0Nzo0OVrOIOAjMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMDo0Nzo0OVrOIOAjMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1OTk4NQ==", "bodyText": "This change seems not very controversial to me.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551559985", "createdAt": "2021-01-04T20:47:49Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -16,28 +16,26 @@\n import com.google.common.util.concurrent.ListenableFuture;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22f80c425c2192cf76fbb6cfdf892e69d2870b3c"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTI3MDMzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeOperator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMDo1NTowMlrOIOAwSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTowNzoxOFrOIPWGMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MzMzOQ==", "bodyText": "In some ways this feels a bit copy-pasta heavy. Not sure if it is better/worse to try and shoe-horn things into the base class.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551563339", "createdAt": "2021-01-04T20:55:02Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeOperator.java", "diffHunk": "@@ -92,6 +92,7 @@ public void noMoreOperators()\n     private final PlanNodeId sourceId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fe7d4e3ecba9b779721c24b75e57322a9996adc"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MTU4NQ==", "bodyText": "I think probably worse. I'm not sure how one would accomodate the slight variations in the behaviors of where the isBlocked trigger comes from without cluttering the Operator interface.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552961585", "createdAt": "2021-01-06T21:07:18Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeOperator.java", "diffHunk": "@@ -92,6 +92,7 @@ public void noMoreOperators()\n     private final PlanNodeId sourceId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MzMzOQ=="}, "originalCommit": {"oid": "9fe7d4e3ecba9b779721c24b75e57322a9996adc"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3OTcyNzg1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/LocalExchangeSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODoxODoxM1rOIPRPCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTowMDo1MVrOIPV8EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MTkzMQ==", "bodyText": "Not controversial either. But do the changes around managing the future have an impact? You are removing some volatile reads yes, but you are also adding conditional logic under the lock.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552881931", "createdAt": "2021-01-06T18:18:13Z", "author": {"login": "aweisberg"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -19,6 +19,7 @@\n import com.google.common.util.concurrent.ListenableFuture;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ea85926d19184c3cc023bb75ceccc886a3a8e36"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1ODk5Mg==", "bodyText": "True, but this will be a \"shallow check\" in that we're just comparing the reference value and not accessing the target of the reference. As such, one would expect this to amount to a very-local CPU cache entry because we've already taken ownership of the object monitor.\nUltimately it's not obvious whether to unconditionally save and clear the listener without branching is better here. It could well be that the CPU wouldn't issue a store operation if the value was null and null was being set.", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552958992", "createdAt": "2021-01-06T21:00:51Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -19,6 +19,7 @@\n import com.google.common.util.concurrent.ListenableFuture;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MTkzMQ=="}, "originalCommit": {"oid": "2ea85926d19184c3cc023bb75ceccc886a3a8e36"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3268, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}