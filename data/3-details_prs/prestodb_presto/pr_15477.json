{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTIxODEw", "number": 15477, "title": "Reduce output buffer lock contention", "bodyText": "Two commits attempting to reduce lock contention related to output buffers:\n\nRefactors LazyOutputBuffer to attempt to read the delegate OutputBuffer reference before synchronizing\nRefactors SerializedPageReference and usages to perform dereferencing in batches to avoid synchronizing on memory manager locks for each individual page.\n\n== NO RELEASE NOTE ==", "createdAt": "2020-11-25T15:22:22Z", "url": "https://github.com/prestodb/presto/pull/15477", "merged": true, "mergeCommit": {"oid": "8148cb3f329bca8cc13226e19fac34d25e4a0ecc"}, "closed": true, "closedAt": "2021-01-07T20:46:19Z", "author": {"login": "pettyjamesm"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgBuNBgBqjQwMzkxNDY1NjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdt4VJ2gFqTU2MzcxODA4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e36d5b1fb36000c42e974d082d70c08ab6c39df", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/9e36d5b1fb36000c42e974d082d70c08ab6c39df", "committedDate": "2020-11-25T15:13:18Z", "message": "Avoid synchronizing in OutputBufferMemoryManager#isOverutilized()"}, "afterCommit": {"oid": "330a77491af9a081799e69959e105102ec9d80aa", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/330a77491af9a081799e69959e105102ec9d80aa", "committedDate": "2020-11-25T17:20:00Z", "message": "Avoid synchronizing in OutputBufferMemoryManager#isOverutilized()"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "330a77491af9a081799e69959e105102ec9d80aa", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/330a77491af9a081799e69959e105102ec9d80aa", "committedDate": "2020-11-25T17:20:00Z", "message": "Avoid synchronizing in OutputBufferMemoryManager#isOverutilized()"}, "afterCommit": {"oid": "aa5a0680a6ad957f3b824ba504a25f7a413dd716", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/aa5a0680a6ad957f3b824ba504a25f7a413dd716", "committedDate": "2020-11-26T18:51:47Z", "message": "Remove lock contention bottlenecks from OutputBufferMemoryManager\n\n- Adds a fast-path to getBufferBlockedFuture() that avoids synchronizing\n  when the buffer is in a blocked state.\n- Avoids synchronizing for isOverutilized()\n- Refactors updateMemoryUsage (the hot path) to move some code outside\n  of the critical section and avoid registering more than one listener\n  action when blocked on memory"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa5a0680a6ad957f3b824ba504a25f7a413dd716", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/aa5a0680a6ad957f3b824ba504a25f7a413dd716", "committedDate": "2020-11-26T18:51:47Z", "message": "Remove lock contention bottlenecks from OutputBufferMemoryManager\n\n- Adds a fast-path to getBufferBlockedFuture() that avoids synchronizing\n  when the buffer is in a blocked state.\n- Avoids synchronizing for isOverutilized()\n- Refactors updateMemoryUsage (the hot path) to move some code outside\n  of the critical section and avoid registering more than one listener\n  action when blocked on memory"}, "afterCommit": {"oid": "e912cf1ba7d65257b5f25204092bfb9667248a0c", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/e912cf1ba7d65257b5f25204092bfb9667248a0c", "committedDate": "2020-11-26T19:34:25Z", "message": "Remove lock contention bottlenecks from OutputBufferMemoryManager\n\n- Adds a fast-path to getBufferBlockedFuture() that avoids synchronizing\n  when the buffer is in a blocked state.\n- Avoids synchronizing for isOverutilized()\n- Refactors updateMemoryUsage (the hot path) to move some code outside\n  of the critical section and avoid registering more than one listener\n  action when blocked on memory"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e912cf1ba7d65257b5f25204092bfb9667248a0c", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/e912cf1ba7d65257b5f25204092bfb9667248a0c", "committedDate": "2020-11-26T19:34:25Z", "message": "Remove lock contention bottlenecks from OutputBufferMemoryManager\n\n- Adds a fast-path to getBufferBlockedFuture() that avoids synchronizing\n  when the buffer is in a blocked state.\n- Avoids synchronizing for isOverutilized()\n- Refactors updateMemoryUsage (the hot path) to move some code outside\n  of the critical section and avoid registering more than one listener\n  action when blocked on memory"}, "afterCommit": {"oid": "3640c76ff29b5c86c4e304019b461a01ea7204aa", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/3640c76ff29b5c86c4e304019b461a01ea7204aa", "committedDate": "2020-11-26T20:18:13Z", "message": "Remove lock contention bottlenecks from OutputBufferMemoryManager\n\n- Adds a fast-path to getBufferBlockedFuture() that avoids synchronizing\n  when the buffer is in a blocked state.\n- Avoids synchronizing for isOverutilized()\n- Refactors updateMemoryUsage (the hot path) to move some code outside\n  of the critical section and avoid registering more than one listener\n  action when blocked on memory"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3640c76ff29b5c86c4e304019b461a01ea7204aa", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/3640c76ff29b5c86c4e304019b461a01ea7204aa", "committedDate": "2020-11-26T20:18:13Z", "message": "Remove lock contention bottlenecks from OutputBufferMemoryManager\n\n- Adds a fast-path to getBufferBlockedFuture() that avoids synchronizing\n  when the buffer is in a blocked state.\n- Avoids synchronizing for isOverutilized()\n- Refactors updateMemoryUsage (the hot path) to move some code outside\n  of the critical section and avoid registering more than one listener\n  action when blocked on memory"}, "afterCommit": {"oid": "9c37f55c10b1c0e2591fb85dbe0c44914677f068", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/9c37f55c10b1c0e2591fb85dbe0c44914677f068", "committedDate": "2020-12-08T15:56:34Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c37f55c10b1c0e2591fb85dbe0c44914677f068", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/9c37f55c10b1c0e2591fb85dbe0c44914677f068", "committedDate": "2020-12-08T15:56:34Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}, "afterCommit": {"oid": "79d88dc0bd30db09acd6537d1ef4785143e40ad5", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/79d88dc0bd30db09acd6537d1ef4785143e40ad5", "committedDate": "2020-12-08T16:15:30Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "79d88dc0bd30db09acd6537d1ef4785143e40ad5", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/79d88dc0bd30db09acd6537d1ef4785143e40ad5", "committedDate": "2020-12-08T16:15:30Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}, "afterCommit": {"oid": "1e9c7b035fe9c7934b714dce33010a5027fa8a47", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/1e9c7b035fe9c7934b714dce33010a5027fa8a47", "committedDate": "2020-12-08T16:53:07Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1e9c7b035fe9c7934b714dce33010a5027fa8a47", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/1e9c7b035fe9c7934b714dce33010a5027fa8a47", "committedDate": "2020-12-08T16:53:07Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}, "afterCommit": {"oid": "959a9012be3eff981ee62d4aa68d44fc3bc4e33c", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/959a9012be3eff981ee62d4aa68d44fc3bc4e33c", "committedDate": "2020-12-09T13:41:07Z", "message": "Add unsynchronized fast path in ExchangeClient"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "959a9012be3eff981ee62d4aa68d44fc3bc4e33c", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/959a9012be3eff981ee62d4aa68d44fc3bc4e33c", "committedDate": "2020-12-09T13:41:07Z", "message": "Add unsynchronized fast path in ExchangeClient"}, "afterCommit": {"oid": "86548af4718235a315a5acc7d86e4f991bcdd3d0", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/86548af4718235a315a5acc7d86e4f991bcdd3d0", "committedDate": "2020-12-09T13:41:07Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86548af4718235a315a5acc7d86e4f991bcdd3d0", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/86548af4718235a315a5acc7d86e4f991bcdd3d0", "committedDate": "2020-12-09T13:41:07Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}, "afterCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/2f0ff5a59ac91d7958884c2f0484e38312cd2433", "committedDate": "2020-12-14T17:34:30Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MTk2MzA4", "url": "https://github.com/prestodb/presto/pull/15477#pullrequestreview-559196308", "createdAt": "2020-12-28T15:42:38Z", "commit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTkwMTQ3", "url": "https://github.com/prestodb/presto/pull/15477#pullrequestreview-562190147", "createdAt": "2021-01-05T22:41:58Z", "commit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTk3MTUy", "url": "https://github.com/prestodb/presto/pull/15477#pullrequestreview-562197152", "createdAt": "2021-01-05T22:56:38Z", "commit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDM4NzY0", "url": "https://github.com/prestodb/presto/pull/15477#pullrequestreview-563038764", "createdAt": "2021-01-06T21:10:07Z", "commit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToxMDowN1rOIPWKZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToyMToxOFrOIPWbCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MjY2MQ==", "bodyText": "nit: we can use decrementAndGet(releasedPageCount)", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552962661", "createdAt": "2021-01-06T21:10:07Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);\n+        if (counter == null) {\n+            counter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong());\n+        }\n+        counter.addAndGet(pagesAdded);\n+    }\n+\n+    public void setNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        requireNonNull(lifespan, \"lifespan is null\");\n+        noMorePagesForLifespan.add(lifespan);\n+    }\n+\n+    public boolean isNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        return noMorePagesForLifespan.contains(lifespan);\n+    }\n+\n+    public boolean isFinishedForLifespan(Lifespan lifespan)\n+    {\n+        if (!noMorePagesForLifespan.contains(lifespan)) {\n+            return false;\n+        }\n+\n+        AtomicLong outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan);\n+        return outstandingPageCount == null || outstandingPageCount.get() == 0;\n+    }\n+\n+    @Override\n+    public void onPagesReleased(Lifespan lifespan, int releasedPageCount, long releasedSizeInBytes)\n+    {\n+        long outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan).addAndGet(-releasedPageCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MzY2NQ==", "bodyText": "I didn't see this childListener related logic in trinodb/trino#6097 ? And looks like it's only used in BroadcastOutputBuffer as a safety check:\ncheckState(totalBufferedPages.addAndGet(-releasedPageCount) >= 0);", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552963665", "createdAt": "2021-01-06T21:13:06Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);\n+        if (counter == null) {\n+            counter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong());\n+        }\n+        counter.addAndGet(pagesAdded);\n+    }\n+\n+    public void setNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        requireNonNull(lifespan, \"lifespan is null\");\n+        noMorePagesForLifespan.add(lifespan);\n+    }\n+\n+    public boolean isNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        return noMorePagesForLifespan.contains(lifespan);\n+    }\n+\n+    public boolean isFinishedForLifespan(Lifespan lifespan)\n+    {\n+        if (!noMorePagesForLifespan.contains(lifespan)) {\n+            return false;\n+        }\n+\n+        AtomicLong outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan);\n+        return outstandingPageCount == null || outstandingPageCount.get() == 0;\n+    }\n+\n+    @Override\n+    public void onPagesReleased(Lifespan lifespan, int releasedPageCount, long releasedSizeInBytes)\n+    {\n+        long outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan).addAndGet(-releasedPageCount);\n+        if (outstandingPageCount == 0 && noMorePagesForLifespan.contains(lifespan)) {\n+            Consumer<Lifespan> lifespanCompletionCallback = this.lifespanCompletionCallback;\n+            checkState(lifespanCompletionCallback != null, \"lifespanCompletionCallback is not null\");\n+            lifespanCompletionCallback.accept(lifespan);\n+        }\n+        memoryManager.updateMemoryUsage(-releasedSizeInBytes);\n+        if (childListener != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NDUzMw==", "bodyText": "this check looks quite universal -- wondering why it cannot be used for other buffer as well?", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552964533", "createdAt": "2021-01-06T21:15:10Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/BroadcastOutputBuffer.java", "diffHunk": "@@ -90,6 +87,9 @@ public BroadcastOutputBuffer(\n                 requireNonNull(maxBufferSize, \"maxBufferSize is null\").toBytes(),\n                 requireNonNull(systemMemoryContextSupplier, \"systemMemoryContextSupplier is null\"),\n                 requireNonNull(notificationExecutor, \"notificationExecutor is null\"));\n+        this.pageTracker = new LifespanSerializedPageTracker(memoryManager, Optional.of((lifespan, releasedPageCount, releasedSizeInBytes) -> {\n+            checkState(totalBufferedPages.addAndGet(-releasedPageCount) >= 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA==", "bodyText": "isn't computeIfAbsent will return the counter in the map if exist? -- so we don't need this extra get and can directly do\ncounter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong())", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552966920", "createdAt": "2021-01-06T21:21:18Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMTk3NTg4", "url": "https://github.com/prestodb/presto/pull/15477#pullrequestreview-563197588", "createdAt": "2021-01-07T04:06:23Z", "commit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f72e3189f048b4466ba5736961e8ac9181a3512", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/7f72e3189f048b4466ba5736961e8ac9181a3512", "committedDate": "2021-01-07T13:54:15Z", "message": "Avoid unnecessary synchronization in LazyOutputBuffer\n\nAdds an initial dereference attempt against the delegate output\nbuffer before synchronizing so that the common case of having already\nset the delegate output buffer might avoid unnecessarily synchronizing\non the LazyOutputBuffer itself."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/2f0ff5a59ac91d7958884c2f0484e38312cd2433", "committedDate": "2020-12-14T17:34:30Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}, "afterCommit": {"oid": "097d864b713a93a104d05c8bff403876c13a15e0", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/097d864b713a93a104d05c8bff403876c13a15e0", "committedDate": "2021-01-07T13:54:15Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2780e7aad2b66583ddbd7257e5817bf47f0812f2", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/2780e7aad2b66583ddbd7257e5817bf47f0812f2", "committedDate": "2021-01-07T18:18:59Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "097d864b713a93a104d05c8bff403876c13a15e0", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/097d864b713a93a104d05c8bff403876c13a15e0", "committedDate": "2021-01-07T13:54:15Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}, "afterCommit": {"oid": "2780e7aad2b66583ddbd7257e5817bf47f0812f2", "author": {"user": {"login": "pettyjamesm", "name": "James Petty"}}, "url": "https://github.com/prestodb/presto/commit/2780e7aad2b66583ddbd7257e5817bf47f0812f2", "committedDate": "2021-01-07T18:18:59Z", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNzE4MDg0", "url": "https://github.com/prestodb/presto/pull/15477#pullrequestreview-563718084", "createdAt": "2021-01-07T18:21:37Z", "commit": {"oid": "2780e7aad2b66583ddbd7257e5817bf47f0812f2"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4759, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}