{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3MTcyNzc1", "number": 14899, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNTowNjowNlrOES27iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNToxMzo0NFrOES3JTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjA5ODAwOnYy", "diffSide": "RIGHT", "path": "presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/BingTileUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNTowNjowNlrOG4RQag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMjoxNDowMVrOG4hf1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY1NjE3MA==", "bodyText": "nit: What do you think about ImmutableListBuilder + counter?", "url": "https://github.com/prestodb/presto/pull/14899#discussion_r461656170", "createdAt": "2020-07-28T15:06:06Z", "author": {"login": "arhimondr"}, "path": "presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/BingTileUtils.java", "diffHunk": "@@ -168,4 +186,163 @@ private static int axisToCoordinates(double axis, long mapSize)\n         int tileAxis = (int) clip(axis * mapSize, 0, mapSize - 1);\n         return tileAxis / TILE_PIXELS;\n     }\n+\n+    private static List<BingTile> findRawTileCovering(OGCGeometry ogcGeometry, int maxZoom)\n+    {\n+        Envelope envelope = getEnvelope(ogcGeometry);\n+        Optional<List<BingTile>> trivialResult = handleTrivialCases(envelope, maxZoom);\n+        if (trivialResult.isPresent()) {\n+            return trivialResult.get();\n+        }\n+\n+        accelerateGeometry(\n+                ogcGeometry, OperatorIntersects.local(), Geometry.GeometryAccelerationDegree.enumMedium);\n+\n+        Deque<TilingEntry> stack = new ArrayDeque<>();\n+        Consumer<BingTile> addIntersecting = tile -> {\n+            TilingEntry tilingEntry = new TilingEntry(tile);\n+            if (satisfiesTileEdgeCondition(envelope, tilingEntry)\n+                    && ogcGeometry.intersects(tilingEntry.polygon)) {\n+                stack.push(tilingEntry);\n+            }\n+        };\n+\n+        // Populate with initial tiles.  Since there aren't many low zoom tiles,\n+        // and throwing away totally disjoint ones is cheap (envelope check),\n+        // we might as well start comprehensively.\n+        ImmutableList.of(\n+                BingTile.fromCoordinates(0, 0, 1),\n+                BingTile.fromCoordinates(0, 1, 1),\n+                BingTile.fromCoordinates(1, 0, 1),\n+                BingTile.fromCoordinates(1, 1, 1)\n+        ).forEach(addIntersecting);\n+\n+        List<BingTile> outputTiles = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9c1114baa65e83fe9816b848d1bba7dfb71f964"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkyMjI2MA==", "bodyText": "I'd be all for it if the builder kept the counter.  As it is, it involves a separate variable that has to be kept in sync, which can lead to errors.\nIs the advantage that callers of this function won't be able to mutate the List?  (I think I've been corrupted by Rust; now I consider this function to relinquish ownership to the caller, so the caller gets to do what it likes :) ).", "url": "https://github.com/prestodb/presto/pull/14899#discussion_r461922260", "createdAt": "2020-07-28T22:14:01Z", "author": {"login": "jagill"}, "path": "presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/BingTileUtils.java", "diffHunk": "@@ -168,4 +186,163 @@ private static int axisToCoordinates(double axis, long mapSize)\n         int tileAxis = (int) clip(axis * mapSize, 0, mapSize - 1);\n         return tileAxis / TILE_PIXELS;\n     }\n+\n+    private static List<BingTile> findRawTileCovering(OGCGeometry ogcGeometry, int maxZoom)\n+    {\n+        Envelope envelope = getEnvelope(ogcGeometry);\n+        Optional<List<BingTile>> trivialResult = handleTrivialCases(envelope, maxZoom);\n+        if (trivialResult.isPresent()) {\n+            return trivialResult.get();\n+        }\n+\n+        accelerateGeometry(\n+                ogcGeometry, OperatorIntersects.local(), Geometry.GeometryAccelerationDegree.enumMedium);\n+\n+        Deque<TilingEntry> stack = new ArrayDeque<>();\n+        Consumer<BingTile> addIntersecting = tile -> {\n+            TilingEntry tilingEntry = new TilingEntry(tile);\n+            if (satisfiesTileEdgeCondition(envelope, tilingEntry)\n+                    && ogcGeometry.intersects(tilingEntry.polygon)) {\n+                stack.push(tilingEntry);\n+            }\n+        };\n+\n+        // Populate with initial tiles.  Since there aren't many low zoom tiles,\n+        // and throwing away totally disjoint ones is cheap (envelope check),\n+        // we might as well start comprehensively.\n+        ImmutableList.of(\n+                BingTile.fromCoordinates(0, 0, 1),\n+                BingTile.fromCoordinates(0, 1, 1),\n+                BingTile.fromCoordinates(1, 0, 1),\n+                BingTile.fromCoordinates(1, 1, 1)\n+        ).forEach(addIntersecting);\n+\n+        List<BingTile> outputTiles = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY1NjE3MA=="}, "originalCommit": {"oid": "e9c1114baa65e83fe9816b848d1bba7dfb71f964"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MjEzMzI3OnYy", "diffSide": "RIGHT", "path": "presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/BingTileUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNToxMzo0NFrOG4Rl7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNToxMzo0NFrOG4Rl7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY2MTY3Nw==", "bodyText": "nit: please move it before the findRawTileCovering , as findDissolvedTileCovering  uses findDissolvedTileCovering", "url": "https://github.com/prestodb/presto/pull/14899#discussion_r461661677", "createdAt": "2020-07-28T15:13:44Z", "author": {"login": "arhimondr"}, "path": "presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/BingTileUtils.java", "diffHunk": "@@ -168,4 +186,163 @@ private static int axisToCoordinates(double axis, long mapSize)\n         int tileAxis = (int) clip(axis * mapSize, 0, mapSize - 1);\n         return tileAxis / TILE_PIXELS;\n     }\n+\n+    private static List<BingTile> findRawTileCovering(OGCGeometry ogcGeometry, int maxZoom)\n+    {\n+        Envelope envelope = getEnvelope(ogcGeometry);\n+        Optional<List<BingTile>> trivialResult = handleTrivialCases(envelope, maxZoom);\n+        if (trivialResult.isPresent()) {\n+            return trivialResult.get();\n+        }\n+\n+        accelerateGeometry(\n+                ogcGeometry, OperatorIntersects.local(), Geometry.GeometryAccelerationDegree.enumMedium);\n+\n+        Deque<TilingEntry> stack = new ArrayDeque<>();\n+        Consumer<BingTile> addIntersecting = tile -> {\n+            TilingEntry tilingEntry = new TilingEntry(tile);\n+            if (satisfiesTileEdgeCondition(envelope, tilingEntry)\n+                    && ogcGeometry.intersects(tilingEntry.polygon)) {\n+                stack.push(tilingEntry);\n+            }\n+        };\n+\n+        // Populate with initial tiles.  Since there aren't many low zoom tiles,\n+        // and throwing away totally disjoint ones is cheap (envelope check),\n+        // we might as well start comprehensively.\n+        ImmutableList.of(\n+                BingTile.fromCoordinates(0, 0, 1),\n+                BingTile.fromCoordinates(0, 1, 1),\n+                BingTile.fromCoordinates(1, 0, 1),\n+                BingTile.fromCoordinates(1, 1, 1)\n+        ).forEach(addIntersecting);\n+\n+        List<BingTile> outputTiles = new ArrayList<>();\n+        while (!stack.isEmpty()) {\n+            TilingEntry entry = stack.pop();\n+            if (entry.tile.getZoomLevel() == maxZoom || ogcGeometry.contains(entry.polygon)) {\n+                outputTiles.add(entry.tile);\n+            }\n+            else {\n+                entry.tile.findChildren().forEach(addIntersecting);\n+                checkCondition(\n+                        outputTiles.size() + stack.size() <= MAX_COVERING_COUNT,\n+                        \"The zoom level is too high or the geometry is too large to compute a set \" +\n+                                \"of covering Bing tiles. Please use a lower zoom level, or tile only a section \" +\n+                                \"of the geometry.\");\n+            }\n+        }\n+        return outputTiles;\n+    }\n+\n+    private static Optional<List<BingTile>> handleTrivialCases(Envelope envelope, int zoom)\n+    {\n+        checkZoomLevel(zoom);\n+\n+        if (envelope.isEmpty()) {\n+            return Optional.of(ImmutableList.of());\n+        }\n+        checkLatitude(envelope.getYMin(), LATITUDE_SPAN_OUT_OF_RANGE);\n+        checkLatitude(envelope.getYMax(), LATITUDE_SPAN_OUT_OF_RANGE);\n+        checkLongitude(envelope.getXMin(), LONGITUDE_SPAN_OUT_OF_RANGE);\n+        checkLongitude(envelope.getXMax(), LONGITUDE_SPAN_OUT_OF_RANGE);\n+\n+        if (zoom == 0) {\n+            return Optional.of(ImmutableList.of(BingTile.fromCoordinates(0, 0, 0)));\n+        }\n+        if (envelope.getXMax() == envelope.getXMin() && envelope.getYMax() == envelope.getYMin()) {\n+            return Optional.of(ImmutableList.of(latitudeLongitudeToTile(envelope.getYMax(), envelope.getXMax(), zoom)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    /*\n+     * BingTiles don't contain their eastern/southern edges, so that each point lies\n+     * on a unique tile.  However, the easternmost and southernmost tiles must contain\n+     * their eastern and southern bounds (respectively), because they are the only\n+     * tiles that can.\n+     */\n+    private static boolean satisfiesTileEdgeCondition(Envelope query, TilingEntry entry)\n+    {\n+        BingTile tile = entry.tile;\n+        int maxXY = (1 << tile.getZoomLevel()) - 1;\n+        if (tile.getY() < maxXY && query.getYMax() == entry.envelope.getYMin()) {\n+            return false;\n+        }\n+        if (tile.getX() < maxXY && query.getXMin() == entry.envelope.getXMax()) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Find a minimal set of BingTiles (at different zooms), covering the geometry.\n+     * If a larger tile fits within the geometry, do not split it into smaller\n+     * tiles.  Do not split a tile past maxZoom.\n+     */\n+    public static List<BingTile> findDissolvedTileCovering(OGCGeometry ogcGeometry, int maxZoom)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9c1114baa65e83fe9816b848d1bba7dfb71f964"}, "originalPosition": 137}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2179, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}