{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5OTk0MTU1", "number": 15431, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMjo0NzoyN1rOE4YxMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTozNjoyNlrOE5212g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTYxNTIyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMjo0NzoyN1rOHyRs0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxNzo1MDowOVrOH0KfjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4MDg1MQ==", "bodyText": "can this be if (taskWriterCount >= taskConcurrency) ?", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r522480851", "createdAt": "2020-11-12T22:47:27Z", "author": {"login": "viczhang861"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -508,21 +508,45 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n             PlanWithProperties tableWriter;\n \n             if (!originalTableWriterNode.getTablePartitioningScheme().isPresent()) {\n-                tableWriter = planAndEnforceChildren(\n-                        new TableWriterNode(\n-                                originalTableWriterNode.getId(),\n-                                originalTableWriterNode.getSource(),\n-                                originalTableWriterNode.getTarget(),\n-                                variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n-                                variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n-                                variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n-                                originalTableWriterNode.getColumns(),\n-                                originalTableWriterNode.getColumnNames(),\n-                                originalTableWriterNode.getTablePartitioningScheme(),\n-                                originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n-                                statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n-                        fixedParallelism(),\n-                        fixedParallelism());\n+                int taskWriterCount = getTaskWriterCount(session);\n+                int taskConcurrency = getTaskConcurrency(session);\n+                if (taskWriterCount == taskConcurrency) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd035077ed50dd66e57d9251f60198774836214b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1OTkxNg==", "bodyText": "No. We want to allow taskWriterCount  and taskConcurrency  to be set independently. It should be allowed to set higher taskWriterCount  than taskConcurrency .", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r524459916", "createdAt": "2020-11-16T17:50:09Z", "author": {"login": "arhimondr"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -508,21 +508,45 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n             PlanWithProperties tableWriter;\n \n             if (!originalTableWriterNode.getTablePartitioningScheme().isPresent()) {\n-                tableWriter = planAndEnforceChildren(\n-                        new TableWriterNode(\n-                                originalTableWriterNode.getId(),\n-                                originalTableWriterNode.getSource(),\n-                                originalTableWriterNode.getTarget(),\n-                                variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n-                                variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n-                                variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n-                                originalTableWriterNode.getColumns(),\n-                                originalTableWriterNode.getColumnNames(),\n-                                originalTableWriterNode.getTablePartitioningScheme(),\n-                                originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n-                                statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n-                        fixedParallelism(),\n-                        fixedParallelism());\n+                int taskWriterCount = getTaskWriterCount(session);\n+                int taskConcurrency = getTaskConcurrency(session);\n+                if (taskWriterCount == taskConcurrency) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ4MDg1MQ=="}, "originalCommit": {"oid": "bd035077ed50dd66e57d9251f60198774836214b"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTcyMjAyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzoyMDo1OVrOHyStVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMTozNjo1MVrOIDeZHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NzM2NA==", "bodyText": "Could you explain why it is fixedParallelism() currently? I am trying to understand the difference for  public enum StreamDistribution { SINGLE, MULTIPLE, FIXED }", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r522497364", "createdAt": "2020-11-12T23:20:59Z", "author": {"login": "viczhang861"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -508,21 +508,45 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n             PlanWithProperties tableWriter;\n \n             if (!originalTableWriterNode.getTablePartitioningScheme().isPresent()) {\n-                tableWriter = planAndEnforceChildren(\n-                        new TableWriterNode(\n-                                originalTableWriterNode.getId(),\n-                                originalTableWriterNode.getSource(),\n-                                originalTableWriterNode.getTarget(),\n-                                variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n-                                variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n-                                variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n-                                originalTableWriterNode.getColumns(),\n-                                originalTableWriterNode.getColumnNames(),\n-                                originalTableWriterNode.getTablePartitioningScheme(),\n-                                originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n-                                statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n-                        fixedParallelism(),\n-                        fixedParallelism());\n+                int taskWriterCount = getTaskWriterCount(session);\n+                int taskConcurrency = getTaskConcurrency(session);\n+                if (taskWriterCount == taskConcurrency) {\n+                    tableWriter = planAndEnforceChildren(\n+                            new TableWriterNode(\n+                                    originalTableWriterNode.getId(),\n+                                    originalTableWriterNode.getSource(),\n+                                    originalTableWriterNode.getTarget(),\n+                                    variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n+                                    variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n+                                    variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n+                                    originalTableWriterNode.getColumns(),\n+                                    originalTableWriterNode.getColumnNames(),\n+                                    originalTableWriterNode.getTablePartitioningScheme(),\n+                                    originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n+                                    statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n+                            fixedParallelism(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd035077ed50dd66e57d9251f60198774836214b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ2MTYzMg==", "bodyText": "SINGLE - single operator instance is required (e.g.: OrderByOperator, TopNOperator, TableCommitOperator, etc.)\nFIXED - fixed number of operator instances is required (e.g.: HashAggregationOperator, WindowOperator, etc)\nMULTIPLE - there's no requirement for the number of operator instances (e.g.: ScanFiterProject Operator).\n\n\nCould you explain why it is fixedParallelism() currently?\n\nWe request fixed parallelism to ensure that the number of TableWriterOperators is fixed for a given task, so it produces a fixed number of output files.", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r524461632", "createdAt": "2020-11-16T17:52:46Z", "author": {"login": "arhimondr"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -508,21 +508,45 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n             PlanWithProperties tableWriter;\n \n             if (!originalTableWriterNode.getTablePartitioningScheme().isPresent()) {\n-                tableWriter = planAndEnforceChildren(\n-                        new TableWriterNode(\n-                                originalTableWriterNode.getId(),\n-                                originalTableWriterNode.getSource(),\n-                                originalTableWriterNode.getTarget(),\n-                                variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n-                                variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n-                                variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n-                                originalTableWriterNode.getColumns(),\n-                                originalTableWriterNode.getColumnNames(),\n-                                originalTableWriterNode.getTablePartitioningScheme(),\n-                                originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n-                                statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n-                        fixedParallelism(),\n-                        fixedParallelism());\n+                int taskWriterCount = getTaskWriterCount(session);\n+                int taskConcurrency = getTaskConcurrency(session);\n+                if (taskWriterCount == taskConcurrency) {\n+                    tableWriter = planAndEnforceChildren(\n+                            new TableWriterNode(\n+                                    originalTableWriterNode.getId(),\n+                                    originalTableWriterNode.getSource(),\n+                                    originalTableWriterNode.getTarget(),\n+                                    variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n+                                    variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n+                                    variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n+                                    originalTableWriterNode.getColumns(),\n+                                    originalTableWriterNode.getColumnNames(),\n+                                    originalTableWriterNode.getTablePartitioningScheme(),\n+                                    originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n+                                    statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n+                            fixedParallelism(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NzM2NA=="}, "originalCommit": {"oid": "bd035077ed50dd66e57d9251f60198774836214b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzODY3OA==", "bodyText": "Thanks for explanation.", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r524838678", "createdAt": "2020-11-17T02:09:27Z", "author": {"login": "viczhang861"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -508,21 +508,45 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n             PlanWithProperties tableWriter;\n \n             if (!originalTableWriterNode.getTablePartitioningScheme().isPresent()) {\n-                tableWriter = planAndEnforceChildren(\n-                        new TableWriterNode(\n-                                originalTableWriterNode.getId(),\n-                                originalTableWriterNode.getSource(),\n-                                originalTableWriterNode.getTarget(),\n-                                variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n-                                variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n-                                variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n-                                originalTableWriterNode.getColumns(),\n-                                originalTableWriterNode.getColumnNames(),\n-                                originalTableWriterNode.getTablePartitioningScheme(),\n-                                originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n-                                statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n-                        fixedParallelism(),\n-                        fixedParallelism());\n+                int taskWriterCount = getTaskWriterCount(session);\n+                int taskConcurrency = getTaskConcurrency(session);\n+                if (taskWriterCount == taskConcurrency) {\n+                    tableWriter = planAndEnforceChildren(\n+                            new TableWriterNode(\n+                                    originalTableWriterNode.getId(),\n+                                    originalTableWriterNode.getSource(),\n+                                    originalTableWriterNode.getTarget(),\n+                                    variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n+                                    variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n+                                    variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n+                                    originalTableWriterNode.getColumns(),\n+                                    originalTableWriterNode.getColumnNames(),\n+                                    originalTableWriterNode.getTablePartitioningScheme(),\n+                                    originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n+                                    statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n+                            fixedParallelism(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NzM2NA=="}, "originalCommit": {"oid": "bd035077ed50dd66e57d9251f60198774836214b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5MjEyMg==", "bodyText": "@arhimondr :\n\nMULTIPLE - there's no requirement for the number of operator instances (e.g.: ScanFiterProject Operator).\n\nSo essentially there will be one driver per each split?", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r524892122", "createdAt": "2020-11-17T05:26:18Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -508,21 +508,45 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n             PlanWithProperties tableWriter;\n \n             if (!originalTableWriterNode.getTablePartitioningScheme().isPresent()) {\n-                tableWriter = planAndEnforceChildren(\n-                        new TableWriterNode(\n-                                originalTableWriterNode.getId(),\n-                                originalTableWriterNode.getSource(),\n-                                originalTableWriterNode.getTarget(),\n-                                variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n-                                variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n-                                variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n-                                originalTableWriterNode.getColumns(),\n-                                originalTableWriterNode.getColumnNames(),\n-                                originalTableWriterNode.getTablePartitioningScheme(),\n-                                originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n-                                statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n-                        fixedParallelism(),\n-                        fixedParallelism());\n+                int taskWriterCount = getTaskWriterCount(session);\n+                int taskConcurrency = getTaskConcurrency(session);\n+                if (taskWriterCount == taskConcurrency) {\n+                    tableWriter = planAndEnforceChildren(\n+                            new TableWriterNode(\n+                                    originalTableWriterNode.getId(),\n+                                    originalTableWriterNode.getSource(),\n+                                    originalTableWriterNode.getTarget(),\n+                                    variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n+                                    variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n+                                    variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n+                                    originalTableWriterNode.getColumns(),\n+                                    originalTableWriterNode.getColumnNames(),\n+                                    originalTableWriterNode.getTablePartitioningScheme(),\n+                                    originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n+                                    statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n+                            fixedParallelism(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NzM2NA=="}, "originalCommit": {"oid": "bd035077ed50dd66e57d9251f60198774836214b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxNDU5MA==", "bodyText": "So essentially there will be one driver per each split?\n\nYeah. And the number of divers run in parallel for scan is controlled by a different set of properties (e.g.: task.max-drivers-per-task)", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r540514590", "createdAt": "2020-12-10T21:36:51Z", "author": {"login": "arhimondr"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -508,21 +508,45 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n             PlanWithProperties tableWriter;\n \n             if (!originalTableWriterNode.getTablePartitioningScheme().isPresent()) {\n-                tableWriter = planAndEnforceChildren(\n-                        new TableWriterNode(\n-                                originalTableWriterNode.getId(),\n-                                originalTableWriterNode.getSource(),\n-                                originalTableWriterNode.getTarget(),\n-                                variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n-                                variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n-                                variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n-                                originalTableWriterNode.getColumns(),\n-                                originalTableWriterNode.getColumnNames(),\n-                                originalTableWriterNode.getTablePartitioningScheme(),\n-                                originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n-                                statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n-                        fixedParallelism(),\n-                        fixedParallelism());\n+                int taskWriterCount = getTaskWriterCount(session);\n+                int taskConcurrency = getTaskConcurrency(session);\n+                if (taskWriterCount == taskConcurrency) {\n+                    tableWriter = planAndEnforceChildren(\n+                            new TableWriterNode(\n+                                    originalTableWriterNode.getId(),\n+                                    originalTableWriterNode.getSource(),\n+                                    originalTableWriterNode.getTarget(),\n+                                    variableAllocator.newVariable(\"partialrowcount\", BIGINT),\n+                                    variableAllocator.newVariable(\"partialfragments\", VARBINARY),\n+                                    variableAllocator.newVariable(\"partialcontext\", VARBINARY),\n+                                    originalTableWriterNode.getColumns(),\n+                                    originalTableWriterNode.getColumnNames(),\n+                                    originalTableWriterNode.getTablePartitioningScheme(),\n+                                    originalTableWriterNode.getPreferredShufflePartitioningScheme(),\n+                                    statisticAggregations.map(StatisticAggregations.Parts::getPartialAggregation)),\n+                            fixedParallelism(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NzM2NA=="}, "originalCommit": {"oid": "bd035077ed50dd66e57d9251f60198774836214b"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTAyODEwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNTozNjoyNlrOH0lDNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMTo0MTozNFrOIDejrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NTAzMQ==", "bodyText": "What's the difference between fixedParallelism() and defaultParallelism?\nAlso from the commit message\n\nFor partitioned writes the shuffle is added unconditionally.\n\nCurious what does it mean by \"partitioned writes\"? Do you mean the table write input is fixed distribution? (e.g. following aggregation or join)", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r524895031", "createdAt": "2020-11-17T05:36:26Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -549,7 +549,7 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n                 }\n             }\n             else {\n-                PlanWithProperties source = originalTableWriterNode.getSource().accept(this, fixedParallelism());\n+                PlanWithProperties source = originalTableWriterNode.getSource().accept(this, defaultParallelism(session));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d621c1d76077f5a0b87c4e345dc3d2b7a9ccc030"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NTgxMg==", "bodyText": "Just to double check: this is more about avoiding unnecessary local exchange, right?", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r524895812", "createdAt": "2020-11-17T05:39:24Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -549,7 +549,7 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n                 }\n             }\n             else {\n-                PlanWithProperties source = originalTableWriterNode.getSource().accept(this, fixedParallelism());\n+                PlanWithProperties source = originalTableWriterNode.getSource().accept(this, defaultParallelism(session));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NTAzMQ=="}, "originalCommit": {"oid": "d621c1d76077f5a0b87c4e345dc3d2b7a9ccc030"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxNzI5Mg==", "bodyText": "What's the difference between fixedParallelism() and defaultParallelism?\n\nThe difference is subtle. fixedParallelism() - FIXED distribution is preferred. defaultParallelism - parallel distribution is preferred (either MULTIPLE or FIXED). Since we are adding a local exchange unconditionally it doesn't make sense to request FIXED.\n\nCurious what does it mean by \"partitioned writes\"? Do you mean the table write input is fixed distribution? (e.g. following aggregation or join)\n\npartitioned writes is when you write into a bucketed table. For bucketed tables a hash based exchange is added unconditionally for correctness.\n\nJust to double check: this is more about avoiding unnecessary local exchange, right?\n\nYeah, since we are adding an exchange on top unconditionally, we don't want the exchange to be added when planning the upstream node", "url": "https://github.com/prestodb/presto/pull/15431#discussion_r540517292", "createdAt": "2020-12-10T21:41:34Z", "author": {"login": "arhimondr"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddLocalExchanges.java", "diffHunk": "@@ -549,7 +549,7 @@ public PlanWithProperties visitTableWriter(TableWriterNode originalTableWriterNo\n                 }\n             }\n             else {\n-                PlanWithProperties source = originalTableWriterNode.getSource().accept(this, fixedParallelism());\n+                PlanWithProperties source = originalTableWriterNode.getSource().accept(this, defaultParallelism(session));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg5NTAzMQ=="}, "originalCommit": {"oid": "d621c1d76077f5a0b87c4e345dc3d2b7a9ccc030"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3383, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}