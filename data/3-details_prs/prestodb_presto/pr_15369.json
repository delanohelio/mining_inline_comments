{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExOTA2ODk0", "number": 15369, "title": "Handle query level timeouts in Presto on Spark", "bodyText": "== NO RELEASE NOTE ==", "createdAt": "2020-10-28T23:34:39Z", "url": "https://github.com/prestodb/presto/pull/15369", "merged": true, "mergeCommit": {"oid": "aa55ea7d733a1a33068f7217afd31532a1643242"}, "closed": true, "closedAt": "2020-10-30T19:47:44Z", "author": {"login": "arhimondr"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXem5iAFqTUyMDM1Njc4NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXsK7PgFqTUyMDk4Njc0NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzU2Nzg0", "url": "https://github.com/prestodb/presto/pull/15369#pullrequestreview-520356784", "createdAt": "2020-10-30T03:36:07Z", "commit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzozNjowN1rOHq8E4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzo1NjozNlrOHq9PTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc4NjUzMA==", "bodyText": "nextTimeoutInMillis variable can be removed.", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514786530", "createdAt": "2020-10-30T03:36:07Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        try {\n+            while (true) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc5OTI5MQ==", "bodyText": "queryCompletionDeadline can be initialized immediately after queryStateTimer is created.", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514799291", "createdAt": "2020-10-30T03:49:55Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -728,13 +746,16 @@ private PrestoSparkQueryExecution(\n             this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n             this.pagesSerde = requireNonNull(pagesSerde, \"pagesSerde is null\");\n             this.executionExceptionFactory = requireNonNull(executionExceptionFactory, \"executionExceptionFactory is null\");\n+            this.queryTimeout = requireNonNull(queryTimeout, \"queryTimeout is null\");\n             this.queryStatusInfoOutputPath = requireNonNull(queryStatusInfoOutputPath, \"queryStatusInfoOutputPath is null\");\n             this.queryDataOutputPath = requireNonNull(queryDataOutputPath, \"queryDataOutputPath is null\");\n         }\n \n         @Override\n         public List<List<Object>> execute()\n         {\n+            queryCompletionDeadline = System.currentTimeMillis() + queryTimeout.toMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ==", "bodyText": "Why private static,  we can always read queryCompletionDeadline directly, which is simpler and guaranteed to be accurate.  Parameters timeout, timeUnit can be calculated from queryCompletionDeadline  and current time.", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514801569", "createdAt": "2020-10-30T03:52:24Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMjQ3Mg==", "bodyText": "Curious, when would this scenario happens?", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514802472", "createdAt": "2020-10-30T03:53:27Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        try {\n+            while (true) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n+                }\n+                try {\n+                    return action.get(timeout, timeUnit);\n+                }\n+                catch (TimeoutException e) {\n+                    // guard against spurious wakeup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwNTU4Mw==", "bodyText": "Same comment as  waitForActionsCompletionWithTimeout", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514805583", "createdAt": "2020-10-30T03:56:36Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNDAwMDIz", "url": "https://github.com/prestodb/presto/pull/15369#pullrequestreview-520400023", "createdAt": "2020-10-30T06:19:10Z", "commit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "216840446852fba36269496519fd9dd00f2650e2", "author": {"user": {"login": "arhimondr", "name": "Andrii Rosa"}}, "url": "https://github.com/prestodb/presto/commit/216840446852fba36269496519fd9dd00f2650e2", "committedDate": "2020-10-30T15:32:56Z", "message": "Handle query level timeouts in Presto on Spark"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e", "author": {"user": {"login": "arhimondr", "name": "Andrii Rosa"}}, "url": "https://github.com/prestodb/presto/commit/690225f1ef49eaf39f783ea176e15f8f01a3435e", "committedDate": "2020-10-28T23:28:49Z", "message": "Handle query level timeouts in Presto on Spark"}, "afterCommit": {"oid": "216840446852fba36269496519fd9dd00f2650e2", "author": {"user": {"login": "arhimondr", "name": "Andrii Rosa"}}, "url": "https://github.com/prestodb/presto/commit/216840446852fba36269496519fd9dd00f2650e2", "committedDate": "2020-10-30T15:32:56Z", "message": "Handle query level timeouts in Presto on Spark"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwOTg2NzQ0", "url": "https://github.com/prestodb/presto/pull/15369#pullrequestreview-520986744", "createdAt": "2020-10-30T19:45:03Z", "commit": {"oid": "216840446852fba36269496519fd9dd00f2650e2"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOTo0NTowM1rOHrdzuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOTo0NTowM1rOHrdzuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMzOTE5Mg==", "bodyText": "Maybe we can reuse this static function later", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515339192", "createdAt": "2020-10-30T19:45:03Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ=="}, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 181}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4645, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}