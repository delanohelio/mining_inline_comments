{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNTc3Mjg5", "number": 15362, "title": "Optimize TypedSet and map_concat, array_union", "bodyText": "This PR resolves the \"Avoid block building inside\" part in #15361. The optimizations included in this PR are\n\n\nAvoid block building inside.\nTypedSet has an internal BlockBuilder and appends each Block position being added to it. Block building using BlockBuilder is highly costly and inefficient operation. Here the BlockBuilder is needed to 1) resolve hash table probing collision 2) rehash. However, both are actually not a problem. In most use cases, whole blocks (instead of several positions of a block) are added to the TypedSet, and problem 1) can be resolved by keeping track of the blocks being added. 2) Rehashing is not needed since we can know the max number of entries before creating a TypedSet for most use cases. So we want to provide a method that adds a whole Block and just record the positions in the set using SelectedPositions objects. By providing this new interface, internal operations can be streamlined to more efficient loops. It also gives opportunity to get the result Block using more efficient APIs that allows encapsulated memory copying.\nIn the new OptimizedTypedSet class, we offer several operations: union, intersect and except. The operations can be called multiple times, but user does need to specify the max set size when creating the OptimizedTypedSet.\n\n\nAvoid computing the hash positions multiple times\nThe previous TypedSet usage sometimes require calculating the hash position multiple times if there are multiple TypedSets. For example array_intersect and array_except. Such usages build one TypedSet R, and based on the probe result on R, insert new elements to another TypedSet B. It requires to calculate the hash position multiple times. This can be avoided if the new TypdedSet can encapsulate the operations inside. The hashPosition calculated in hashtable A can be reused by hashtable B if the size and hash functions are the same.\n\n\nJMH benchmark shows up to 40% improvement for array_union:\n\n\n\nType\nBaseline\nSpecialized Baseline\nOptimizedTypedSet\nGain%\n\n\n\n\nBIGINT\n5511\n3742\n3320\n40%\n\n\nVARCHAR\n20414\nN/A\n14155\n31%\n\n\n\n\n\nJMH benchmark shows 82% improvement for non_empty case for map_concat when keyCount=100\nand POSITIONS=1000:\n\n\n    Baseline\n\n    Benchmark                     Mode  Cnt      Score      Error  Units\n    BenchmarkMapConcat.mapConcat  avgt   20  26710.925 \u00b1 2005.756  ns/op\n    Retained Size: 1,402,374 bytes\n\n    After\n    Benchmark                     Mode  Cnt      Score      Error  Units\n    BenchmarkMapConcat.mapConcat  avgt   20  14605.437 \u00b1 1209.786  ns/op\n    Retained Size: 1,373,273 bytes\n\n\nWhen keyCount=1000 and POSITIONS=1000, the baseline just OOMed. The optimized version succeeded.\n\n\nArray_intersect  showed up to 49% improvement in time and 72% savings in allocation rate. More detailed comparisons:\n\n\n\n\narray_except JMH benchmark shows 40% improvement:\n\n\n    Before\n    Benchmark                               Mode  Cnt       Score        Error  Units\n    BenchmarkArrayIntersect.arrayIntersect  avgt   10  618074.452 \u00b1 119912.203  ns/op\n\n    After\n    Benchmark                               Mode  Cnt       Score       Error  Units\n    BenchmarkArrayIntersect.arrayIntersect  avgt   10  376854.064 \u00b1 21616.063  ns/op\n\nProduction testing:\nTested using verifier on 1220 queries with map_concat, array_union, array_intersect, array_except. No failures found.\n== NO RELEASE NOTE ==", "createdAt": "2020-10-27T08:43:43Z", "url": "https://github.com/prestodb/presto/pull/15362", "merged": true, "mergeCommit": {"oid": "1e00009c582c36ce585e85e9ea583450a59c02d5"}, "closed": true, "closedAt": "2020-11-30T20:43:54Z", "author": {"login": "yingsu00"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWlKAPgBqjM5MjQ3Mjk3ODA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdhKcUTgFqTU0MDQ1MDE3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e32d6e3465c67b4f2c27f31d5ae00077440f6737", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/e32d6e3465c67b4f2c27f31d5ae00077440f6737", "committedDate": "2020-10-27T08:39:24Z", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op"}, "afterCommit": {"oid": "65bd19a9fb26148c399ac64ac80d65dbca4fb87e", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/65bd19a9fb26148c399ac64ac80d65dbca4fb87e", "committedDate": "2020-10-27T09:00:40Z", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65bd19a9fb26148c399ac64ac80d65dbca4fb87e", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/65bd19a9fb26148c399ac64ac80d65dbca4fb87e", "committedDate": "2020-10-27T09:00:40Z", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op"}, "afterCommit": {"oid": "980ce35a653a72d0cf9368147bdc0e6d10104bfa", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/980ce35a653a72d0cf9368147bdc0e6d10104bfa", "committedDate": "2020-10-27T19:14:39Z", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "980ce35a653a72d0cf9368147bdc0e6d10104bfa", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/980ce35a653a72d0cf9368147bdc0e6d10104bfa", "committedDate": "2020-10-27T19:14:39Z", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op"}, "afterCommit": {"oid": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/7fdfe62520dc93e37d41ec0f4164c90bc27cf577", "committedDate": "2020-10-27T19:16:24Z", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMjUyNDEx", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-521252411", "createdAt": "2020-11-01T19:16:14Z", "commit": {"oid": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxOToxNjoxNFrOHrxZsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxOToxNjoxNFrOHrxZsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2MDIxMA==", "bodyText": "nit: this on a new line or everything on same line", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r515660210", "createdAt": "2020-11-01T19:16:14Z", "author": {"login": "sujay-jain"}, "path": "presto-common/src/main/java/com/facebook/presto/common/block/AbstractMapBlock.java", "diffHunk": "@@ -284,9 +284,9 @@ public Block getBlock(int position)\n         int startEntryOffset = getOffset(position);\n         int endEntryOffset = getOffset(position + 1);\n         return new SingleMapBlock(\n+                position,\n                 startEntryOffset * 2,\n-                (endEntryOffset - startEntryOffset) * 2,\n-                this);\n+                (endEntryOffset - startEntryOffset) * 2, this);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMjU1MTc4", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-521255178", "createdAt": "2020-11-01T19:51:46Z", "commit": {"oid": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxOTo1MTo0NlrOHrxouQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxOTo1MTo0NlrOHrxouQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2NDA1Nw==", "bodyText": "maybe blocks[++currentBlockIndex] = block?", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r515664057", "createdAt": "2020-11-01T19:51:46Z", "author": {"login": "sujay-jain"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+\n+    private final Type elementType;\n+    private final String functionName;\n+\n+    // size is the number of elements added to the TypedSet (including null).\n+    private int size;\n+    private int hashCapacity;\n+    private int hashMask;\n+\n+    private Block[] blocks;\n+    private int maxBlockCount;\n+    private List<SelectedPositions> positionsForBlocks = new ArrayList<>();\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;\n+\n+    public OptimizedTypedSet(Type elementType, int maxBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        this.maxBlockCount = maxBlockCount;\n+        blocks = new Block[maxBlockCount];\n+        blockPositionByHash = new long[hashCapacity];\n+        Arrays.fill(blockPositionByHash, EMPTY_SLOT);\n+    }\n+\n+    /**\n+     * Add the block into the hash table blockPositionByHash using \"union\" semantics\n+     */\n+    public void addUnion(Block block)\n+    {\n+        if (positionsForBlocks.size() == maxBlockCount) {\n+            throw new IllegalArgumentException(\"Cannot add block to OptimizedTypedSet: maxBlockCount is reached\");\n+        }\n+\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        blocks[currentBlockIndex] = block;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNzU1MTQz", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-521755143", "createdAt": "2020-11-02T15:51:06Z", "commit": {"oid": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo1MTowNlrOHsKRhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo1MTowNlrOHsKRhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2NzcxNg==", "bodyText": "let's declare the 2 as a constant at the top", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r516067716", "createdAt": "2020-11-02T15:51:06Z", "author": {"login": "sujay-jain"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/ArrayUnionFunction.java", "diffHunk": "@@ -43,52 +36,13 @@ public static Block union(\n     {\n         int leftArrayCount = leftArray.getPositionCount();\n         int rightArrayCount = rightArray.getPositionCount();\n-        TypedSet typedSet = new TypedSet(type, leftArrayCount + rightArrayCount, \"array_union\");\n-        BlockBuilder distinctElementBlockBuilder = type.createBlockBuilder(null, leftArrayCount + rightArrayCount);\n-        appendTypedArray(leftArray, type, typedSet, distinctElementBlockBuilder);\n-        appendTypedArray(rightArray, type, typedSet, distinctElementBlockBuilder);\n-\n-        return distinctElementBlockBuilder.build();\n-    }\n-\n-    private static void appendTypedArray(Block array, Type type, TypedSet typedSet, BlockBuilder blockBuilder)\n-    {\n-        for (int i = 0; i < array.getPositionCount(); i++) {\n-            if (!typedSet.contains(array, i)) {\n-                typedSet.add(array, i);\n-                type.appendTo(array, i, blockBuilder);\n-            }\n-        }\n-    }\n+        OptimizedTypedSet typedSet = new OptimizedTypedSet(type, 2, leftArrayCount + rightArrayCount, \"array_union\");\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577"}, "originalPosition": 43}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/7fdfe62520dc93e37d41ec0f4164c90bc27cf577", "committedDate": "2020-10-27T19:16:24Z", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op"}, "afterCommit": {"oid": "0863764c17ddf513e33a6dc2b1c66dc4e713bcc9", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/0863764c17ddf513e33a6dc2b1c66dc4e713bcc9", "committedDate": "2020-11-03T09:13:21Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDg4ODI2", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-523488826", "createdAt": "2020-11-04T15:45:56Z", "commit": {"oid": "0863764c17ddf513e33a6dc2b1c66dc4e713bcc9"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0863764c17ddf513e33a6dc2b1c66dc4e713bcc9", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/0863764c17ddf513e33a6dc2b1c66dc4e713bcc9", "committedDate": "2020-11-03T09:13:21Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}, "afterCommit": {"oid": "f35720d3b36d534d53effa147f77c2ee5a7a65f4", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/f35720d3b36d534d53effa147f77c2ee5a7a65f4", "committedDate": "2020-11-05T10:11:16Z", "message": "Replace BenchmarkArrayIntersectFunctions with BenchmarkArraySetFunctions\n\nThis adds benchmarks for array_except and array_union as well."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f35720d3b36d534d53effa147f77c2ee5a7a65f4", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/f35720d3b36d534d53effa147f77c2ee5a7a65f4", "committedDate": "2020-11-05T10:11:16Z", "message": "Replace BenchmarkArrayIntersectFunctions with BenchmarkArraySetFunctions\n\nThis adds benchmarks for array_except and array_union as well."}, "afterCommit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/13ed5a5885a04a3e41564464ae198640a72e5db1", "committedDate": "2020-11-06T02:10:11Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTExMDcz", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-528511073", "createdAt": "2020-11-11T20:29:12Z", "commit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDoyOToxM1rOHxdJQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDoyOToxM1rOHxdJQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxOTc3OA==", "bodyText": "let's move this assignment to L90 where it is being used", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521619778", "createdAt": "2020-11-11T20:29:13Z", "author": {"login": "sujay-jain"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTE0OTIx", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-528514921", "createdAt": "2020-11-11T20:35:25Z", "commit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDozNToyNVrOHxdVlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDozNToyNVrOHxdVlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjkzMg==", "bodyText": "let's move this inside the else to keep the scope small", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521622932", "createdAt": "2020-11-11T20:35:25Z", "author": {"login": "sujay-jain"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        int positionCount = block.getPositionCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTE3NTkz", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-528517593", "createdAt": "2020-11-11T20:39:48Z", "commit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDozOTo0OFrOHxdeJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDozOTo0OFrOHxdeJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNTEyNQ==", "bodyText": "perhaps it is cleaner to do the +1 inside the ensureCapacity instead of here", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521625125", "createdAt": "2020-11-11T20:39:48Z", "author": {"login": "sujay-jain"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTIyMTg5", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-528522189", "createdAt": "2020-11-11T20:47:14Z", "commit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDo0NzoxNFrOHxds5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDo0NzoxNFrOHxds5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyODkwMg==", "bodyText": "the else part can be extracted into a function since getInsertPosition is also doing the same thing more or less.", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521628902", "createdAt": "2020-11-11T20:47:14Z", "author": {"login": "sujay-jain"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    private long[] initializeHashTable()\n+    {\n+        long[] newBlockPositionByHash = new long[hashCapacity]; // Create a new hashtable\n+        Arrays.fill(newBlockPositionByHash, EMPTY_SLOT);\n+        return newBlockPositionByHash;\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {\n+                if (positionCount == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), positionCount);\n+                }\n+            }\n+            int[] positions = selectedPositions.getPositions();\n+            for (int j = 0; j < positionCount; j++) {\n+                // offset is always 0\n+                int position = positions[j];\n+                if (block.isNull(position)) {\n+                    blockBuilder.appendNull();\n+                }\n+                else {\n+                    elementType.appendTo(block, position, blockBuilder);\n+                }\n+            }\n+        }\n+\n+        return blockBuilder.build();\n+    }\n+\n+    public List<SelectedPositions> getPositionsForBlocks()\n+    {\n+        return positionsForBlocks;\n+    }\n+\n+    public long getRetainedSizeInBytes()\n+    {\n+        long sizeInBytes = INSTANCE_SIZE + ARRAY_LIST_INSTANCE_SIZE + sizeOf(blockPositionByHash);\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            sizeInBytes += sizeOf(positionsForBlocks.get(i).getPositions());\n+        }\n+        return sizeInBytes;\n+    }\n+\n+    public void ensureBlocksCapacity(int capacity)\n+    {\n+        if (blocks == null || blocks.length < capacity) {\n+            blocks = Arrays.copyOf(blocks, capacity);\n+        }\n+    }\n+\n+    private int getMaskedHash(long rawHash)\n+    {\n+        return (int) (rawHash & hashMask);\n+    }\n+\n+    /**\n+     * Return the position in the hashtable the element at Block position should be inserted.\n+     *\n+     * @return The position of the hashtable to be inserted if the element does not exist, INVALID_POSITION otherwise.\n+     * @hashPosition The position into the hashtable the linear probing starts\n+     */\n+    private int getInsertPosition(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                // does not exist\n+                return hashPosition;\n+            }\n+            else {\n+                // Already has this element\n+                int blockIndex = (int) ((blockPosition & 0xffff_ffff_0000_0000L) >> 32);\n+                int positionWithinBlock = (int) (blockPosition & 0xffff_ffff);\n+                if (positionEqualsPosition(elementType, blocks[blockIndex], positionWithinBlock, block, position)) {\n+                    return INVALID_POSITION;\n+                }\n+            }\n+\n+            hashPosition = getMaskedHash(hashPosition + 1);\n+        }\n+    }\n+\n+    /**\n+     * Add an element to the hash table if it's not already existed.\n+     *\n+     * @param hashtable The target hash table the element to be inserted into\n+     * @param hashPosition The position into the hashtable the linear probing starts\n+     * @return true of the element is inserted, false otherwise\n+     */\n+    private boolean addElement(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                hashtable[hashPosition] = ((long) currentBlockIndex << 32) | position;\n+                return true;\n+            }\n+            else {\n+                // Already has this element\n+                int blockIndex = (int) ((blockPosition & 0xffff_ffff_0000_0000L) >> 32);\n+                int positionWithinBlock = (int) (blockPosition & 0xffff_ffff);\n+                if (positionEqualsPosition(elementType, blocks[blockIndex], positionWithinBlock, block, position)) {\n+                    return false;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "originalPosition": 342}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NTQ2NjU3", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-528546657", "createdAt": "2020-11-11T21:26:47Z", "commit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMToyNjo0OFrOHxe4ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMToyNjo0OFrOHxe4ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0ODI5MQ==", "bodyText": "There's common functionality between except and intersect eg: the for loop. Can we try to extract the common things to functions - makes it more readable and reduces changes of bugs :)", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521648291", "createdAt": "2020-11-11T21:26:48Z", "author": {"login": "sujay-jain"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    private long[] initializeHashTable()\n+    {\n+        long[] newBlockPositionByHash = new long[hashCapacity]; // Create a new hashtable\n+        Arrays.fill(newBlockPositionByHash, EMPTY_SLOT);\n+        return newBlockPositionByHash;\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1"}, "originalPosition": 169}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/13ed5a5885a04a3e41564464ae198640a72e5db1", "committedDate": "2020-11-06T02:10:11Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}, "afterCommit": {"oid": "4578da73101d41fbcb54eedb0cecf8e6a80f3c38", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/4578da73101d41fbcb54eedb0cecf8e6a80f3c38", "committedDate": "2020-11-12T05:48:25Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4578da73101d41fbcb54eedb0cecf8e6a80f3c38", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/4578da73101d41fbcb54eedb0cecf8e6a80f3c38", "committedDate": "2020-11-12T05:48:25Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}, "afterCommit": {"oid": "683a703e8e6078874de51d6dd618d590a5ae3f78", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/683a703e8e6078874de51d6dd618d590a5ae3f78", "committedDate": "2020-11-12T05:53:30Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NDA3NDIw", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-529407420", "createdAt": "2020-11-12T19:10:51Z", "commit": {"oid": "683a703e8e6078874de51d6dd618d590a5ae3f78"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5Njg2OTE1", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-529686915", "createdAt": "2020-11-13T03:53:03Z", "commit": {"oid": "e39114eec3edee89d908f54c5e44358c242e4da8"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMzo1MzowNFrOHyYyHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNDoxOTozNVrOHyZblQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU5Njg5Mg==", "bodyText": "two lines.", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522596892", "createdAt": "2020-11-13T03:53:04Z", "author": {"login": "rongrong"}, "path": "presto-common/src/main/java/com/facebook/presto/common/block/SingleMapBlock.java", "diffHunk": "@@ -120,9 +122,29 @@ public Block getLoadedBlock()\n             return this;\n         }\n         return new SingleMapBlock(\n+                positionInMap,\n                 offset,\n-                positionCount,\n-                mapBlock);\n+                positionCount, mapBlock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e39114eec3edee89d908f54c5e44358c242e4da8"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDM4MA==", "bodyText": "else is unnecessary.", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600380", "createdAt": "2020-11-13T04:08:19Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDQyOQ==", "bodyText": "else is unnecessary.", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600429", "createdAt": "2020-11-13T04:08:33Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDYwNQ==", "bodyText": "else is not necessary.", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600605", "createdAt": "2020-11-13T04:09:14Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {\n+                if (positionCount == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), positionCount);\n+                }\n+            }\n+            int[] positions = selectedPositions.getPositions();\n+            for (int j = 0; j < positionCount; j++) {\n+                // offset is always 0\n+                int position = positions[j];\n+                if (block.isNull(position)) {\n+                    blockBuilder.appendNull();\n+                }\n+                else {\n+                    elementType.appendTo(block, position, blockBuilder);\n+                }\n+            }\n+        }\n+\n+        return blockBuilder.build();\n+    }\n+\n+    public List<SelectedPositions> getPositionsForBlocks()\n+    {\n+        return positionsForBlocks;\n+    }\n+\n+    public long getRetainedSizeInBytes()\n+    {\n+        long sizeInBytes = INSTANCE_SIZE + ARRAY_LIST_INSTANCE_SIZE + sizeOf(blockPositionByHash);\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            sizeInBytes += sizeOf(positionsForBlocks.get(i).getPositions());\n+        }\n+        return sizeInBytes;\n+    }\n+\n+    private long[] initializeHashTable()\n+    {\n+        long[] newBlockPositionByHash = new long[hashCapacity]; // Create a new hashtable\n+        Arrays.fill(newBlockPositionByHash, EMPTY_SLOT);\n+        return newBlockPositionByHash;\n+    }\n+\n+    private void ensureBlocksCapacity(int capacity)\n+    {\n+        if (blocks == null || blocks.length < capacity) {\n+            blocks = Arrays.copyOf(blocks, capacity);\n+        }\n+    }\n+\n+    private int getMaskedHash(long rawHash)\n+    {\n+        return (int) (rawHash & hashMask);\n+    }\n+\n+    /**\n+     * Return the position in the hashtable the element at Block position should be inserted.\n+     *\n+     * @return The position of the hashtable to be inserted if the element does not exist, INVALID_POSITION otherwise.\n+     * @hashPosition The position into the hashtable the linear probing starts\n+     */\n+    private int getInsertPosition(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                // does not exist\n+                return hashPosition;\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDY3OA==", "bodyText": "else is not neccessary.", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600678", "createdAt": "2020-11-13T04:09:30Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {\n+                if (positionCount == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), positionCount);\n+                }\n+            }\n+            int[] positions = selectedPositions.getPositions();\n+            for (int j = 0; j < positionCount; j++) {\n+                // offset is always 0\n+                int position = positions[j];\n+                if (block.isNull(position)) {\n+                    blockBuilder.appendNull();\n+                }\n+                else {\n+                    elementType.appendTo(block, position, blockBuilder);\n+                }\n+            }\n+        }\n+\n+        return blockBuilder.build();\n+    }\n+\n+    public List<SelectedPositions> getPositionsForBlocks()\n+    {\n+        return positionsForBlocks;\n+    }\n+\n+    public long getRetainedSizeInBytes()\n+    {\n+        long sizeInBytes = INSTANCE_SIZE + ARRAY_LIST_INSTANCE_SIZE + sizeOf(blockPositionByHash);\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            sizeInBytes += sizeOf(positionsForBlocks.get(i).getPositions());\n+        }\n+        return sizeInBytes;\n+    }\n+\n+    private long[] initializeHashTable()\n+    {\n+        long[] newBlockPositionByHash = new long[hashCapacity]; // Create a new hashtable\n+        Arrays.fill(newBlockPositionByHash, EMPTY_SLOT);\n+        return newBlockPositionByHash;\n+    }\n+\n+    private void ensureBlocksCapacity(int capacity)\n+    {\n+        if (blocks == null || blocks.length < capacity) {\n+            blocks = Arrays.copyOf(blocks, capacity);\n+        }\n+    }\n+\n+    private int getMaskedHash(long rawHash)\n+    {\n+        return (int) (rawHash & hashMask);\n+    }\n+\n+    /**\n+     * Return the position in the hashtable the element at Block position should be inserted.\n+     *\n+     * @return The position of the hashtable to be inserted if the element does not exist, INVALID_POSITION otherwise.\n+     * @hashPosition The position into the hashtable the linear probing starts\n+     */\n+    private int getInsertPosition(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                // does not exist\n+                return hashPosition;\n+            }\n+            else {\n+                // Already has this element\n+                int blockIndex = (int) ((blockPosition & 0xffff_ffff_0000_0000L) >> 32);\n+                int positionWithinBlock = (int) (blockPosition & 0xffff_ffff);\n+                if (positionEqualsPosition(elementType, blocks[blockIndex], positionWithinBlock, block, position)) {\n+                    return INVALID_POSITION;\n+                }\n+            }\n+\n+            hashPosition = getMaskedHash(hashPosition + 1);\n+        }\n+    }\n+\n+    /**\n+     * Add an element to the hash table if it's not already existed.\n+     *\n+     * @param hashtable The target hash table the element to be inserted into\n+     * @param hashPosition The position into the hashtable the linear probing starts\n+     * @return true of the element is inserted, false otherwise\n+     */\n+    private boolean addElement(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                hashtable[hashPosition] = ((long) currentBlockIndex << 32) | position;\n+                return true;\n+            }\n+            else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDc4NQ==", "bodyText": "else is not necessary.", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600785", "createdAt": "2020-11-13T04:09:54Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {\n+                if (positionCount == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDgzMQ==", "bodyText": "else is not neccessary.", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600831", "createdAt": "2020-11-13T04:10:06Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwNjA2Ng==", "bodyText": "entries / 2 is very confusing to me. Maybe when compute entries in line 135, just /2 there?", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522606066", "createdAt": "2020-11-13T04:17:32Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/MapConcatFunction.java", "diffHunk": "@@ -139,42 +142,36 @@ public static Block mapConcat(MapType mapType, Object state, Block[] maps)\n             return maps[lastMapIndex];\n         }\n \n+        Type keyType = mapType.getKeyType();\n+        Type valueType = mapType.getValueType();\n+        OptimizedTypedSet typedSet = new OptimizedTypedSet(keyType, maps.length, entries / 2, FUNCTION_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5146dc9f40c905ba80eaaa691178ad352c1afa1f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwNjczMg==", "bodyText": "What is this for?", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522606732", "createdAt": "2020-11-13T04:18:30Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwNzUwOQ==", "bodyText": "Is this change intended?", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522607509", "createdAt": "2020-11-13T04:19:35Z", "author": {"login": "rongrong"}, "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/BenchmarkMapConcat.java", "diffHunk": "@@ -92,7 +92,7 @@\n         private String name = \"map_concat\";\n \n         @Param({\"left_empty\", \"right_empty\", \"both_empty\", \"non_empty\"})\n-        private String mapConfig = \"left_empty\";\n+        private String mapConfig = \"non_empty\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5146dc9f40c905ba80eaaa691178ad352c1afa1f"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "683a703e8e6078874de51d6dd618d590a5ae3f78", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/683a703e8e6078874de51d6dd618d590a5ae3f78", "committedDate": "2020-11-12T05:53:30Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}, "afterCommit": {"oid": "f9bd8b9e8dbce84f256dd7443990f20888d9e090", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/f9bd8b9e8dbce84f256dd7443990f20888d9e090", "committedDate": "2020-11-14T02:44:13Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f9bd8b9e8dbce84f256dd7443990f20888d9e090", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/f9bd8b9e8dbce84f256dd7443990f20888d9e090", "committedDate": "2020-11-14T02:44:13Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}, "afterCommit": {"oid": "6526b0aa75b6e0d246fd448dc46eef26b12e8e6a", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/6526b0aa75b6e0d246fd448dc46eef26b12e8e6a", "committedDate": "2020-11-14T02:47:09Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMDQ3MzA3", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-532047307", "createdAt": "2020-11-17T06:13:31Z", "commit": {"oid": "a10eb17e18b2b206f0ce2c1c97d82aa5b606f730"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjoxMzozMlrOH0lujw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNjoxMzozMlrOH0lujw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNjEyNw==", "bodyText": "curious: when would this happen? (in that case we will return the current block positions)", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r524906127", "createdAt": "2020-11-17T06:13:32Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+        // We need to create a new hash table because the elements in the set may be removed\n+        long[] newBlockPositionByHash = initializeHashTable();\n+\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hash = getMaskedHash(hashPosition(elementType, block, i));\n+            int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+            if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                // add to the hash table if it exists in blockPositionByHash\n+                if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                    positions[positionsIndex++] = i;\n+                }\n+            }\n+        }\n+\n+        blockPositionByHash = newBlockPositionByHash;\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size = positionsIndex;\n+\n+        clearPreviousBlocks();\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int[] positions = new int[positionCount];\n+\n+        // We need to create a new hash table because the elements in the set need be removed\n+        long[] newBlockPositionByHash = initializeHashTable();\n+\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hash = getMaskedHash(hashPosition(elementType, block, i));\n+            int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+            // add to the hash table if it does not exist in blockPositionByHash\n+            if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                    positions[positionsIndex++] = i;\n+                }\n+            }\n+        }\n+\n+        blockPositionByHash = newBlockPositionByHash;\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size = positionsIndex;\n+\n+        clearPreviousBlocks();\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a10eb17e18b2b206f0ce2c1c97d82aa5b606f730"}, "originalPosition": 228}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6526b0aa75b6e0d246fd448dc46eef26b12e8e6a", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/6526b0aa75b6e0d246fd448dc46eef26b12e8e6a", "committedDate": "2020-11-14T02:47:09Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}, "afterCommit": {"oid": "eeffc976e2d0d20d0ad90d350ba35be5a0dd29b6", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/eeffc976e2d0d20d0ad90d350ba35be5a0dd29b6", "committedDate": "2020-11-19T09:29:10Z", "message": "Add different sizes to BenchmarkMapConcat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb9f3f20d6df0611ab9d17456a6d2fd3600dd24e", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/bb9f3f20d6df0611ab9d17456a6d2fd3600dd24e", "committedDate": "2020-11-20T04:15:58Z", "message": "Introducing OptimizedTypedSet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fa35e6895978088dcdc54c45437e83cf133912d", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/9fa35e6895978088dcdc54c45437e83cf133912d", "committedDate": "2020-11-20T08:04:27Z", "message": "Optimize map_concat using OptimizedTypedSet\n\nJMH benchmark shows 1.82x improvement for non_empty case when keyCount=100\nand POSITIONS=1000:\n\nBaseline\nBenchmark                     Mode  Cnt      Score      Error  Units\nBenchmarkMapConcat.mapConcat  avgt   20  26710.925 \u00b1 2005.756  ns/op\nRetained Size: 1,402,374 bytes\n\nAfter\nBenchmark                     Mode  Cnt      Score      Error  Units\nBenchmarkMapConcat.mapConcat  avgt   20  14605.437 \u00b1 1209.786  ns/op\nRetained Size: 1,373,273 bytes\n\nWhen keyCount=1000 and POSITIONS=1000, the baseline just OOMed. The\noptimized version succeeded.\n\nAdd different sizes to BenchmarkMapConcat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5efff893a855e7af4b5409e972561ee1c35e65e2", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/5efff893a855e7af4b5409e972561ee1c35e65e2", "committedDate": "2020-11-20T08:30:07Z", "message": "Optimize array_union using OptimizedTypedSet\n\nJMH benchmark shows up to 40% improvement:\n\nType       | Baseline  | Specialized Baseline | OptimizedTypedSet | Gain%\n-----------|-----------|----------------------|-------------------|----------\nBIGINT     |      5511 |                 3742 |            3320   |      40%\nVARCHAR    |     20414 |                 N/A  |            14155  |      31%"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "766de45aa6fe2efb86647c8edb79ab6a04618085", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/766de45aa6fe2efb86647c8edb79ab6a04618085", "committedDate": "2020-11-20T08:30:08Z", "message": "Optimize array_except by using OptimizedTypedSet\n\nJMH benchmark shows 40% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score        Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  618074.452 \u00b1 119912.203  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  376854.064 \u00b1 21616.063  ns/op"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87d7f180fc6dec2f403cdbaf2098ffac2d91e2a2", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/87d7f180fc6dec2f403cdbaf2098ffac2d91e2a2", "committedDate": "2020-11-20T08:30:08Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eeffc976e2d0d20d0ad90d350ba35be5a0dd29b6", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/eeffc976e2d0d20d0ad90d350ba35be5a0dd29b6", "committedDate": "2020-11-19T09:29:10Z", "message": "Add different sizes to BenchmarkMapConcat"}, "afterCommit": {"oid": "87d7f180fc6dec2f403cdbaf2098ffac2d91e2a2", "author": {"user": null}, "url": "https://github.com/prestodb/presto/commit/87d7f180fc6dec2f403cdbaf2098ffac2d91e2a2", "committedDate": "2020-11-20T08:30:08Z", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNDUwMTc4", "url": "https://github.com/prestodb/presto/pull/15362#pullrequestreview-540450178", "createdAt": "2020-11-29T06:06:43Z", "commit": {"oid": "87d7f180fc6dec2f403cdbaf2098ffac2d91e2a2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4638, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}