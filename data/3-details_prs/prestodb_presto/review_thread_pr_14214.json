{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDM5NDc0", "number": 14214, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNDozNjo1N1rODpiShw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxODoxNTo0MlrODq6gAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODgwMDA3OnYy", "diffSide": "RIGHT", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/VerificationContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNDozNjo1N1rOF4xaVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQwMjo0Mzo0NFrOF5s4Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3NDEzMg==", "bodyText": "It's strange to me that this class is mutable and gets passed around and modified in several places.  Usually we try to limit the use of mutable objects in Presto, especially across different classes.  In my opinion the mutability here makes the lifecycle of each object confusing and makes the code more error prone (e.g. trying to update the same field 2x). The second commit seems like it's fixing a problem that's mostly caused by this being a mutable object.  And then later commits add even more things to this class, which I think just makes it more fragile. I think it would be better to break this class up into a few classes that can each be immutable.\nFor example, you can separate out an object for keeping the data verification info of control and test checksum queries and build that in DataVerfication.verify(), and then have another object that has all the determinism info that.gets built in the DeterminismAnalyzer and have the LimitDeterminismAnalysis also return the queryId, so that part can be immutable to.", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r395074132", "createdAt": "2020-03-19T14:36:57Z", "author": {"login": "rschlussel"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/VerificationContext.java", "diffHunk": "@@ -13,110 +13,220 @@\n  */\n package com.facebook.presto.verifier.framework;\n \n-import com.facebook.presto.verifier.event.DeterminismAnalysisRun;\n+import com.facebook.presto.jdbc.QueryStats;\n+import com.facebook.presto.verifier.event.DeterminismAnalysisDetails;\n import com.facebook.presto.verifier.event.QueryFailure;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n+import com.facebook.presto.verifier.event.VerifierQueryEvent;\n \n+import java.util.HashSet;\n import java.util.List;\n import java.util.Optional;\n+import java.util.Set;\n \n-import static com.facebook.presto.verifier.framework.LimitQueryDeterminismAnalysis.NOT_RUN;\n import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class VerificationContext", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1d1d10798fa97ac39fd98504a9d89e5cb65161b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA0ODQyMg==", "bodyText": "@rschlussel Comments addressed.\nInstead of expanding the mutable object VerificationContext, changes were made to make it immutable. Separate checksum-related mutable fields into CheckQueryContext, and use DeterminismAnalysisDetails.Builder to replace determinism analysis related mutable fields.", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r396048422", "createdAt": "2020-03-22T02:43:44Z", "author": {"login": "caithagoras"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/VerificationContext.java", "diffHunk": "@@ -13,110 +13,220 @@\n  */\n package com.facebook.presto.verifier.framework;\n \n-import com.facebook.presto.verifier.event.DeterminismAnalysisRun;\n+import com.facebook.presto.jdbc.QueryStats;\n+import com.facebook.presto.verifier.event.DeterminismAnalysisDetails;\n import com.facebook.presto.verifier.event.QueryFailure;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n+import com.facebook.presto.verifier.event.VerifierQueryEvent;\n \n+import java.util.HashSet;\n import java.util.List;\n import java.util.Optional;\n+import java.util.Set;\n \n-import static com.facebook.presto.verifier.framework.LimitQueryDeterminismAnalysis.NOT_RUN;\n import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class VerificationContext", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3NDEzMg=="}, "originalCommit": {"oid": "b1d1d10798fa97ac39fd98504a9d89e5cb65161b"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTYzODk4OnYy", "diffSide": "RIGHT", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTo1NjoyMlrOF6ZkzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozOTo0NlrOF7HGPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MDc0OQ==", "bodyText": "I don't feel the toOptional change helps with readability. Optional.of()/Optional.ofNullable() is already pretty succinct, used frequently throughout the code base, and it's obvious what they do.  The helper function is slightly shorter, but then I need to spend time figuring out if there's custom logic as part of toOptional.", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r396780749", "createdAt": "2020-03-23T21:56:22Z", "author": {"login": "rschlussel"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();\n+        AtomicReference<QueryBundle> test = new AtomicReference<>();\n+        AtomicReference<QueryStats> controlStats = new AtomicReference<>();\n+        AtomicReference<QueryStats> testStats = new AtomicReference<>();\n+        AtomicReference<QueryState> controlState = new AtomicReference<>(NOT_RUN);\n+        AtomicReference<QueryState> testState = new AtomicReference<>(NOT_RUN);\n         ChecksumQueryContext controlChecksumQueryContext = new ChecksumQueryContext();\n         ChecksumQueryContext testChecksumQueryContext = new ChecksumQueryContext();\n+        Optional<MatchResult> matchResult = Optional.empty();\n+        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n         DeterminismAnalysisDetails.Builder determinismAnalysisDetails = DeterminismAnalysisDetails.builder();\n \n         try {\n-            control = queryRewriter.rewriteQuery(sourceQuery.getControlQuery(), CONTROL);\n-            test = queryRewriter.rewriteQuery(sourceQuery.getTestQuery(), TEST);\n-            controlQueryStats = DataVerificationUtil.setupAndRun(prestoAction, control, false);\n-            testQueryStats = DataVerificationUtil.setupAndRun(prestoAction, test, false);\n-            matchResult = verify(control, test, controlChecksumQueryContext, testChecksumQueryContext);\n-\n-            if (matchResult.isMismatchPossiblyCausedByNonDeterminism()) {\n-                determinismAnalysis = Optional.of(determinismAnalyzer.analyze(control, matchResult.getControlChecksum(), determinismAnalysisDetails));\n+            // Rewrite queries\n+            control.set(queryRewriter.rewriteQuery(sourceQuery.getControlQuery(), CONTROL));\n+            test.set(queryRewriter.rewriteQuery(sourceQuery.getTestQuery(), TEST));\n+\n+            // Run queries\n+            runAndConsume(\n+                    () -> setupAndRun(prestoAction, control.get(), false),\n+                    controlStats::set,\n+                    e -> controlState.set(getFailingQueryState(e)));\n+            controlState.set(QueryState.SUCCEEDED);\n+            runAndConsume(\n+                    () -> setupAndRun(prestoAction, test.get(), false),\n+                    testStats::set,\n+                    e -> testState.set(getFailingQueryState(e)));\n+            testState.set(QueryState.SUCCEEDED);\n+\n+            // Verify results\n+            matchResult = Optional.of(verify(control.get(), test.get(), controlChecksumQueryContext, testChecksumQueryContext));\n+\n+            // Determinism analysis\n+            if (matchResult.get().isMismatchPossiblyCausedByNonDeterminism()) {\n+                determinismAnalysis = Optional.of(determinismAnalyzer.analyze(control.get(), matchResult.get().getControlChecksum(), determinismAnalysisDetails));\n             }\n             boolean maybeDeterministic = !determinismAnalysis.isPresent() ||\n                     determinismAnalysis.get().isDeterministic() ||\n                     determinismAnalysis.get().isUnknown();\n-            resultMismatched = maybeDeterministic && !matchResult.isMatched();\n+            resultMismatched = maybeDeterministic && !matchResult.get().isMatched();\n \n             return concludeVerification(\n-                    Optional.of(control),\n-                    Optional.of(test),\n-                    Optional.ofNullable(controlQueryStats),\n-                    Optional.ofNullable(testQueryStats),\n-                    Optional.empty(),\n-                    Optional.of(matchResult),\n+                    toOptional(control),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2bc2d5a4e0af661d202a09c04a8bba0379303fb"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNjU5MQ==", "bodyText": "Changed to Optional.ofNullable(reference.get())", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r397526591", "createdAt": "2020-03-24T23:39:46Z", "author": {"login": "caithagoras"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();\n+        AtomicReference<QueryBundle> test = new AtomicReference<>();\n+        AtomicReference<QueryStats> controlStats = new AtomicReference<>();\n+        AtomicReference<QueryStats> testStats = new AtomicReference<>();\n+        AtomicReference<QueryState> controlState = new AtomicReference<>(NOT_RUN);\n+        AtomicReference<QueryState> testState = new AtomicReference<>(NOT_RUN);\n         ChecksumQueryContext controlChecksumQueryContext = new ChecksumQueryContext();\n         ChecksumQueryContext testChecksumQueryContext = new ChecksumQueryContext();\n+        Optional<MatchResult> matchResult = Optional.empty();\n+        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n         DeterminismAnalysisDetails.Builder determinismAnalysisDetails = DeterminismAnalysisDetails.builder();\n \n         try {\n-            control = queryRewriter.rewriteQuery(sourceQuery.getControlQuery(), CONTROL);\n-            test = queryRewriter.rewriteQuery(sourceQuery.getTestQuery(), TEST);\n-            controlQueryStats = DataVerificationUtil.setupAndRun(prestoAction, control, false);\n-            testQueryStats = DataVerificationUtil.setupAndRun(prestoAction, test, false);\n-            matchResult = verify(control, test, controlChecksumQueryContext, testChecksumQueryContext);\n-\n-            if (matchResult.isMismatchPossiblyCausedByNonDeterminism()) {\n-                determinismAnalysis = Optional.of(determinismAnalyzer.analyze(control, matchResult.getControlChecksum(), determinismAnalysisDetails));\n+            // Rewrite queries\n+            control.set(queryRewriter.rewriteQuery(sourceQuery.getControlQuery(), CONTROL));\n+            test.set(queryRewriter.rewriteQuery(sourceQuery.getTestQuery(), TEST));\n+\n+            // Run queries\n+            runAndConsume(\n+                    () -> setupAndRun(prestoAction, control.get(), false),\n+                    controlStats::set,\n+                    e -> controlState.set(getFailingQueryState(e)));\n+            controlState.set(QueryState.SUCCEEDED);\n+            runAndConsume(\n+                    () -> setupAndRun(prestoAction, test.get(), false),\n+                    testStats::set,\n+                    e -> testState.set(getFailingQueryState(e)));\n+            testState.set(QueryState.SUCCEEDED);\n+\n+            // Verify results\n+            matchResult = Optional.of(verify(control.get(), test.get(), controlChecksumQueryContext, testChecksumQueryContext));\n+\n+            // Determinism analysis\n+            if (matchResult.get().isMismatchPossiblyCausedByNonDeterminism()) {\n+                determinismAnalysis = Optional.of(determinismAnalyzer.analyze(control.get(), matchResult.get().getControlChecksum(), determinismAnalysisDetails));\n             }\n             boolean maybeDeterministic = !determinismAnalysis.isPresent() ||\n                     determinismAnalysis.get().isDeterministic() ||\n                     determinismAnalysis.get().isUnknown();\n-            resultMismatched = maybeDeterministic && !matchResult.isMatched();\n+            resultMismatched = maybeDeterministic && !matchResult.get().isMatched();\n \n             return concludeVerification(\n-                    Optional.of(control),\n-                    Optional.of(test),\n-                    Optional.ofNullable(controlQueryStats),\n-                    Optional.ofNullable(testQueryStats),\n-                    Optional.empty(),\n-                    Optional.of(matchResult),\n+                    toOptional(control),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MDc0OQ=="}, "originalCommit": {"oid": "d2bc2d5a4e0af661d202a09c04a8bba0379303fb"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzE5ODA4OnYy", "diffSide": "RIGHT", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxODowMDo0NVrOF68rHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjoxNzozOVrOF9DZvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw==", "bodyText": "What's the purpose of using AtomicReferences?", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r397355807", "createdAt": "2020-03-24T18:00:45Z", "author": {"login": "rschlussel"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f214145c10fd320421da86474a9027ad7f93e94d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNzkwNQ==", "bodyText": "In 141 - 150, those variables are used in lambda, and IntelliJ complains about \"Variable used in lambda expression should be final or effectively final\" if they're nullable or Optional.\nInstead, I need a reference to those variables, with setter method for updating the value. AtomicReference seems to be easiest to use although I don't need the atomicity of the update. Otherwise, I'll need create a private static inner class Reference.", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r397527905", "createdAt": "2020-03-24T23:43:44Z", "author": {"login": "caithagoras"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, "originalCommit": {"oid": "f214145c10fd320421da86474a9027ad7f93e94d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUzNTQ5NQ==", "bodyText": "That seems sketchy to me, but I can't tell if it's actually a problem here or just seems bad (https://www.baeldung.com/java-lambda-effectively-final-local-variables is what I read to understand what the problems might be).  I feel it would be better to change it because my general philosophy is it's best if a reader doesn't have to think too hard to understand why code is correct.  However, you could alternatively get a review from someone with deeper Java knowledge to say whether there are any concerns in this case, and then also add a comment about why these use AtomicReference and why it's not a problem.", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399535495", "createdAt": "2020-03-27T21:00:48Z", "author": {"login": "rschlussel"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, "originalCommit": {"oid": "f214145c10fd320421da86474a9027ad7f93e94d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUzODI0Mw==", "bodyText": "This is an annoying limitation, but I usually create copy variables like so:\nQueryBundle control = null;\n\n        try {\n            // Rewrite queries\n            control = queryRewriter.rewriteQuery(sourceQuery.getControlQuery(), CONTROL);\n            test.set(queryRewriter.rewriteQuery(sourceQuery.getTestQuery(), TEST));\n\n            // Run queries\n            QueryBundle controlCopy = control;\n            runAndConsume(\n                    () -> setupAndRun(prestoAction, controlCopy, false),\n                    controlStats::set,\n                    e -> controlState.set(getFailingQueryState(e)));", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399538243", "createdAt": "2020-03-27T21:07:22Z", "author": {"login": "mbasmanova"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, "originalCommit": {"oid": "f214145c10fd320421da86474a9027ad7f93e94d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0MDg2Ng==", "bodyText": "@mbasmanova\nCopy would work only for variables to be read, but I also need values to be set in the the lambda.\ncontrolStats::set,\ne -> controlState.set(getFailingQueryState(e))\ncontrolStats and controlState are used as a 1-field mutable context object.\nIt is similar to creating a private mutable Context object wrapping all those field, define setters on each of them, and supply context::setControlStats and e->context.setControlState(getFailingQueryState(e)).", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399540866", "createdAt": "2020-03-27T21:13:51Z", "author": {"login": "caithagoras"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, "originalCommit": {"oid": "f214145c10fd320421da86474a9027ad7f93e94d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0NjY3Ng==", "bodyText": "@caithagoras Thanks for clarifying. I like the solution using Context object better.", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399546676", "createdAt": "2020-03-27T21:28:37Z", "author": {"login": "mbasmanova"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, "originalCommit": {"oid": "f214145c10fd320421da86474a9027ad7f93e94d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2MzE5OA==", "bodyText": "Done. Since @rschlussel advices against mutable classes, I'm making the mutable context a private static inner class to minimize exposure.", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399563198", "createdAt": "2020-03-27T22:17:39Z", "author": {"login": "caithagoras"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerification.java", "diffHunk": "@@ -109,144 +119,138 @@ public VerificationContext getVerificationContext()\n     public VerificationResult run()\n     {\n         boolean resultMismatched = false;\n-        QueryBundle control = null;\n-        QueryBundle test = null;\n-        MatchResult matchResult = null;\n-        Optional<DeterminismAnalysis> determinismAnalysis = Optional.empty();\n-\n-        QueryStats controlQueryStats = null;\n-        QueryStats testQueryStats = null;\n \n+        AtomicReference<QueryBundle> control = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NTgwNw=="}, "originalCommit": {"oid": "f214145c10fd320421da86474a9027ad7f93e94d"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MzI1MjUxOnYy", "diffSide": "RIGHT", "path": "presto-verifier/src/test/java/com/facebook/presto/verifier/framework/TestVerificationManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxODoxNTo0MlrOF69PAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxOTo0MzoyMFrOF8_mEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2NDk5NQ==", "bodyText": "Does this test that covers the case that was failing before?  Or if not, is there a test that does?", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r397364995", "createdAt": "2020-03-24T18:15:42Z", "author": {"login": "rschlussel"}, "path": "presto-verifier/src/test/java/com/facebook/presto/verifier/framework/TestVerificationManager.java", "diffHunk": "@@ -131,30 +131,23 @@ public void setup()\n     }\n \n     @Test\n-    public void testFailureRequeued()\n+    public void testFailureResubmitted()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ce164e93158d2316342c8372634cecfc535346d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwMDgxOA==", "bodyText": "No it does not, but I manually tested it. Adding that test a bit more complex, and I add a TODO here. Can we proceed with the PR so that we can use it for 0.234 verification? I'll add the test shortly. Thanks!", "url": "https://github.com/prestodb/presto/pull/14214#discussion_r399500818", "createdAt": "2020-03-27T19:43:20Z", "author": {"login": "caithagoras"}, "path": "presto-verifier/src/test/java/com/facebook/presto/verifier/framework/TestVerificationManager.java", "diffHunk": "@@ -131,30 +131,23 @@ public void setup()\n     }\n \n     @Test\n-    public void testFailureRequeued()\n+    public void testFailureResubmitted()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2NDk5NQ=="}, "originalCommit": {"oid": "9ce164e93158d2316342c8372634cecfc535346d"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2859, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}