{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NzY3MTYy", "number": 14527, "title": "Aggregation ORDER BY & DISTINCT spilling", "bodyText": "This PR implements ORDER BY and DISTINCT spilling for use in aggregation functions. Will be publishing docs on implementation details and updating this PR in the future.\n== RELEASE NOTES ==\n\nGeneral Changes\n* Add local disk spilling support for aggregation functions with `ORDER BY` or `DISTINCT` syntax.", "createdAt": "2020-05-14T05:52:23Z", "url": "https://github.com/prestodb/presto/pull/14527", "merged": true, "mergeCommit": {"oid": "3f7dca0ae7ed2535257fc66aedbba0e378a25449"}, "closed": true, "closedAt": "2020-07-02T21:12:37Z", "author": {"login": "sachdevs"}, "timelineItems": {"totalCount": 50, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchG-4nAFqTQxMTQ4MjkyNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxFfTIgFqTQ0MjAyMTQ4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDgyOTI2", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-411482926", "createdAt": "2020-05-14T05:53:25Z", "commit": {"oid": "eb2fdeb9adb4d59260e7f23598d2ee993cb84704"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo1MzoyNVrOGVM-7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTo1MzozOFrOGVM_KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4NTk5Ng==", "bodyText": "main part to review 2).", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r424885996", "createdAt": "2020-05-14T05:53:25Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -557,13 +563,14 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n         @Override\n         public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.addIntermediate(groupIdsBlock, block);\n         }\n \n         @Override\n         public void evaluateIntermediate(int groupId, BlockBuilder output)\n         {\n-            throw new UnsupportedOperationException();\n+            prepareFinal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb2fdeb9adb4d59260e7f23598d2ee993cb84704"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4NjA1Nw==", "bodyText": "main part to review 1).", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r424886057", "createdAt": "2020-05-14T05:53:38Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -477,22 +477,28 @@ public void addInput(WindowIndex index, List<Integer> channels, int startPositio\n         @Override\n         public void addIntermediate(Block block)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.addIntermediate(block);\n         }\n \n         @Override\n         public void evaluateIntermediate(BlockBuilder blockBuilder)\n         {\n-            throw new UnsupportedOperationException();\n+            sortAndAccumulatePages();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb2fdeb9adb4d59260e7f23598d2ee993cb84704"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMjY4ODk3", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-412268897", "createdAt": "2020-05-15T00:20:21Z", "commit": {"oid": "eb2fdeb9adb4d59260e7f23598d2ee993cb84704"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb2fdeb9adb4d59260e7f23598d2ee993cb84704", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/eb2fdeb9adb4d59260e7f23598d2ee993cb84704", "committedDate": "2020-05-14T05:50:59Z", "message": "testing implementation"}, "afterCommit": {"oid": "a69f43e074331b83252a3f183cbd442f05d49dc8", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/a69f43e074331b83252a3f183cbd442f05d49dc8", "committedDate": "2020-05-15T20:55:03Z", "message": "testing implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTY0MzM5", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-412964339", "createdAt": "2020-05-15T20:58:41Z", "commit": {"oid": "a69f43e074331b83252a3f183cbd442f05d49dc8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMDo1ODo0MVrOGWTqmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMDo1ODo0MVrOGWTqmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NDA1Nw==", "bodyText": "ignore these changes, they are not relevant  to the grouped accumulator which is what I've been focusing on.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r426044057", "createdAt": "2020-05-15T20:58:41Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -477,22 +486,27 @@ public void addInput(WindowIndex index, List<Integer> channels, int startPositio\n         @Override\n         public void addIntermediate(Block block)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.addIntermediate(block);\n         }\n \n         @Override\n         public void evaluateIntermediate(BlockBuilder blockBuilder)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.evaluateIntermediate(blockBuilder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69f43e074331b83252a3f183cbd442f05d49dc8"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTM5NDk4", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-413139498", "createdAt": "2020-05-17T08:33:09Z", "commit": {"oid": "a69f43e074331b83252a3f183cbd442f05d49dc8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwODozMzowOVrOGWfO8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QwODozMzowOVrOGWfO8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMzU4NA==", "bodyText": "Essentially, this is our own way to main the GroupedAccumulatorState. Highly recommend to take a look at how some implementations of GroupedAccumulatorState are used. Especially, how to use ObjectBigArray as the hash table.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r426233584", "createdAt": "2020-05-17T08:33:09Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -503,6 +517,7 @@ public void evaluateFinal(BlockBuilder blockBuilder)\n         private final List<Integer> orderByChannels;\n         private final List<SortOrder> orderings;\n         private final PagesIndex pagesIndex;\n+        private final Map<Long, RowBlockBuilder> pageMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69f43e074331b83252a3f183cbd442f05d49dc8"}, "originalPosition": 88}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a69f43e074331b83252a3f183cbd442f05d49dc8", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/a69f43e074331b83252a3f183cbd442f05d49dc8", "committedDate": "2020-05-15T20:55:03Z", "message": "testing implementation"}, "afterCommit": {"oid": "3912702acafbc0685c069ff0d3246b78abab2e6b", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/3912702acafbc0685c069ff0d3246b78abab2e6b", "committedDate": "2020-05-19T02:48:03Z", "message": "testing implementation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3912702acafbc0685c069ff0d3246b78abab2e6b", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/3912702acafbc0685c069ff0d3246b78abab2e6b", "committedDate": "2020-05-19T02:48:03Z", "message": "testing implementation"}, "afterCommit": {"oid": "9909c3dc45f1b1ada1f83da01564d01b1f7d991c", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/9909c3dc45f1b1ada1f83da01564d01b1f7d991c", "committedDate": "2020-05-19T03:04:26Z", "message": "testing implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MDcxMDMw", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-414071030", "createdAt": "2020-05-19T03:09:01Z", "commit": {"oid": "9909c3dc45f1b1ada1f83da01564d01b1f7d991c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzowOTowMVrOGXORhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzowOTowMVrOGXORhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDI5NA==", "bodyText": "So this bit is causing some issues since we cant append multiple rows to a single groupId. That's why the code wasn't working earlier, I was only putting one block per group id so we were missing a bunch of rows in the final step.\nNow, when I add multiple blocks for a single row, the page becomes malformed since there is an inconsistent position count between its blocks. I.e. this column has multiple rows for a single input group Id.\nBeen thinking of some alternatives today and maybe we should just serialize this and then write it as bytes but that definitely would have overhead. What do you think @highker ?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r427004294", "createdAt": "2020-05-19T03:09:01Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -563,7 +608,10 @@ public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n         @Override\n         public void evaluateIntermediate(int groupId, BlockBuilder output)\n         {\n-            throw new UnsupportedOperationException();\n+            RowBlock rowBlock = (RowBlock) pageMap.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                output.appendStructureInternal(rowBlock, i);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9909c3dc45f1b1ada1f83da01564d01b1f7d991c"}, "originalPosition": 137}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9909c3dc45f1b1ada1f83da01564d01b1f7d991c", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/9909c3dc45f1b1ada1f83da01564d01b1f7d991c", "committedDate": "2020-05-19T03:04:26Z", "message": "testing implementation"}, "afterCommit": {"oid": "6639b9188c15a7de00e72cc4d08cfe50dd52d4d3", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/6639b9188c15a7de00e72cc4d08cfe50dd52d4d3", "committedDate": "2020-05-19T20:06:01Z", "message": "testing implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MDU4Nzc2", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-415058776", "createdAt": "2020-05-20T07:25:07Z", "commit": {"oid": "6639b9188c15a7de00e72cc4d08cfe50dd52d4d3"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6639b9188c15a7de00e72cc4d08cfe50dd52d4d3", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/6639b9188c15a7de00e72cc4d08cfe50dd52d4d3", "committedDate": "2020-05-19T20:06:01Z", "message": "testing implementation"}, "afterCommit": {"oid": "2073f624298619e83cdf793c13540e83a258e3a0", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/2073f624298619e83cdf793c13540e83a258e3a0", "committedDate": "2020-05-29T22:04:03Z", "message": "semi working distinct spilling"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2073f624298619e83cdf793c13540e83a258e3a0", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/2073f624298619e83cdf793c13540e83a258e3a0", "committedDate": "2020-05-29T22:04:03Z", "message": "semi working distinct spilling"}, "afterCommit": {"oid": "2e869d8613f28033089596da191d96964a5f95d0", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/2e869d8613f28033089596da191d96964a5f95d0", "committedDate": "2020-06-01T17:35:33Z", "message": "Distinct spilling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDQ1ODA5", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-422045809", "createdAt": "2020-06-01T17:38:20Z", "commit": {"oid": "2e869d8613f28033089596da191d96964a5f95d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzozODoyMFrOGdTueQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzozODoyMFrOGdTueQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NTA4MQ==", "bodyText": "We need a better way to tell if unspill is happening, if the distinct aggregation isnt the last variable in the select block this will just fail.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r433385081", "createdAt": "2020-06-01T17:38:20Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -368,12 +401,44 @@ public Type getFinalType()\n         @Override\n         public Type getIntermediateType()\n         {\n-            throw new UnsupportedOperationException();\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n         }\n \n         @Override\n         public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n         {\n+            if (page.getBlock(page.getChannelCount() - 1) instanceof ArrayBlock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e869d8613f28033089596da191d96964a5f95d0"}, "originalPosition": 104}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2e869d8613f28033089596da191d96964a5f95d0", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/2e869d8613f28033089596da191d96964a5f95d0", "committedDate": "2020-06-01T17:35:33Z", "message": "Distinct spilling"}, "afterCommit": {"oid": "ac1d598c60f7099a21b381dea316c7d01d8ae1af", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/ac1d598c60f7099a21b381dea316c7d01d8ae1af", "committedDate": "2020-06-01T18:47:25Z", "message": "Distinct spilling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDI2NzU0", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-423026754", "createdAt": "2020-06-02T20:18:54Z", "commit": {"oid": "ac1d598c60f7099a21b381dea316c7d01d8ae1af"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a524f213b44dee0862054caa1c2b8c3e817efb0d", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/a524f213b44dee0862054caa1c2b8c3e817efb0d", "committedDate": "2020-06-02T20:47:02Z", "message": "Will remove, for testing refactor"}, "afterCommit": {"oid": "c1dd45d3f2432929e3065934be639bfb6a33fd3d", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/c1dd45d3f2432929e3065934be639bfb6a33fd3d", "committedDate": "2020-06-04T19:09:35Z", "message": "Refactored Distinct - testing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c1dd45d3f2432929e3065934be639bfb6a33fd3d", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/c1dd45d3f2432929e3065934be639bfb6a33fd3d", "committedDate": "2020-06-04T19:09:35Z", "message": "Refactored Distinct - testing"}, "afterCommit": {"oid": "3e6d3defe5dcdfb71ddeb9b054f95f34e576dd3b", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/3e6d3defe5dcdfb71ddeb9b054f95f34e576dd3b", "committedDate": "2020-06-04T19:55:02Z", "message": "Refactored ORDER BY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e6d3defe5dcdfb71ddeb9b054f95f34e576dd3b", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/3e6d3defe5dcdfb71ddeb9b054f95f34e576dd3b", "committedDate": "2020-06-04T19:55:02Z", "message": "Refactored ORDER BY"}, "afterCommit": {"oid": "7dc0fb367f013b8dce6c52208c6de02599359bdb", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/7dc0fb367f013b8dce6c52208c6de02599359bdb", "committedDate": "2020-06-04T20:04:26Z", "message": "Refactored ORDER BY"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7dc0fb367f013b8dce6c52208c6de02599359bdb", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/7dc0fb367f013b8dce6c52208c6de02599359bdb", "committedDate": "2020-06-04T20:04:26Z", "message": "Refactored ORDER BY"}, "afterCommit": {"oid": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "committedDate": "2020-06-04T20:10:09Z", "message": "Refactored ORDER BY"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NzkyNzA1", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-424792705", "createdAt": "2020-06-04T20:12:14Z", "commit": {"oid": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxMjoxNFrOGfWIqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNDo1MFrOGfWNuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTcwNw==", "bodyText": "This should probably happen in prepareFinal() but unsure how to do this without using twice as much memory.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435521707", "createdAt": "2020-06-04T20:12:14Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +702,115 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    private static class SpillableOrderingGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final OrderingGroupedAccumulator orderingGroupedAccumulator;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableOrderingGroupedAccumulator(\n+                GroupedAccumulator accumulator,\n+                List<Type> aggregationSourceTypes,\n+                List<Integer> orderByChannels,\n+                List<SortOrder> orderings,\n+                PagesIndex.Factory pagesIndexFactory)\n+        {\n+            this.orderingGroupedAccumulator = new OrderingGroupedAccumulator(accumulator, aggregationSourceTypes, orderByChannels, orderings, pagesIndexFactory);\n+            this.spillingTypes = aggregationSourceTypes;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return orderingGroupedAccumulator.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return orderingGroupedAccumulator.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            orderingGroupedAccumulator.addInput(groupIdsBlock, page);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjAzMg==", "bodyText": "Should happen in prepareFinal() but unsure how to do without using twice as much memory, same issue as order by.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435522032", "createdAt": "2020-06-04T20:12:51Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -399,27 +418,136 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n             accumulator.addInput(groupIds, new Page(filtered.getPositionCount(), columns));\n         }\n \n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            accumulator.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+        }\n+\n+        public void addBlocksToHash(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Work<Block> work = hash.markDistinctRows(new Page(blocks));\n+            checkState(work.process());\n+            Block distinctMask = work.getResult();\n+\n+            blocks[0] = distinctMask;\n+            accumulator.addInput(groupIds, new Page(blocks));\n+        }\n+    }\n+\n+    private static class SpillableDistinctingGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final DistinctingGroupedAccumulator distinctingGroupedAccumulator;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableDistinctingGroupedAccumulator(GroupedAccumulator accumulator,\n+                List<Type> inputTypes,\n+                List<Type> sourceTypes,\n+                List<Integer> inputChannels,\n+                Optional<Integer> maskChannel,\n+                Session session,\n+                JoinCompiler joinCompiler)\n+        {\n+            this.distinctingGroupedAccumulator = new DistinctingGroupedAccumulator(accumulator, inputTypes, sourceTypes, inputChannels, maskChannel, session, joinCompiler);\n+            this.spillingTypes = sourceTypes;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return distinctingGroupedAccumulator.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return distinctingGroupedAccumulator.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIds, Page page)\n+        {\n+            for (int pos = 0; pos < groupIds.getPositionCount(); pos++) {\n+                long groupId = groupIds.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIds.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            distinctingGroupedAccumulator.addInput(groupIds, page);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjQzNg==", "bodyText": "Block internals need to be exposed for this implementation. Let me know if there are any alternatives.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435522436", "createdAt": "2020-06-04T20:13:42Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -399,27 +418,136 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n             accumulator.addInput(groupIds, new Page(filtered.getPositionCount(), columns));\n         }\n \n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            accumulator.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+        }\n+\n+        public void addBlocksToHash(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Work<Block> work = hash.markDistinctRows(new Page(blocks));\n+            checkState(work.process());\n+            Block distinctMask = work.getResult();\n+\n+            blocks[0] = distinctMask;\n+            accumulator.addInput(groupIds, new Page(blocks));\n+        }\n+    }\n+\n+    private static class SpillableDistinctingGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final DistinctingGroupedAccumulator distinctingGroupedAccumulator;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableDistinctingGroupedAccumulator(GroupedAccumulator accumulator,\n+                List<Type> inputTypes,\n+                List<Type> sourceTypes,\n+                List<Integer> inputChannels,\n+                Optional<Integer> maskChannel,\n+                Session session,\n+                JoinCompiler joinCompiler)\n+        {\n+            this.distinctingGroupedAccumulator = new DistinctingGroupedAccumulator(accumulator, inputTypes, sourceTypes, inputChannels, maskChannel, session, joinCompiler);\n+            this.spillingTypes = sourceTypes;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return distinctingGroupedAccumulator.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return distinctingGroupedAccumulator.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIds, Page page)\n+        {\n+            for (int pos = 0; pos < groupIds.getPositionCount(); pos++) {\n+                long groupId = groupIds.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIds.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            distinctingGroupedAccumulator.addInput(groupIds, page);\n+        }\n+\n         @Override\n         public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n         {\n-            throw new UnsupportedOperationException();\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size() + 1];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel + 1] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMzAwMA==", "bodyText": "All of these need be conditionally created based on if spilling enabled/disabled + if we are using HashAggregationOperator. Not sure how to do this cleanly so left this as the default option for now.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435523000", "createdAt": "2020-06-04T20:14:50Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -167,23 +174,40 @@ public GroupedAccumulator createGroupedAccumulator()\n                 argumentTypes.add(sourceTypes.get(input));\n             }\n \n-            accumulator = new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler);\n+            accumulator = new SpillableDistinctingGroupedAccumulator(accumulator, argumentTypes, sourceTypes, inputChannels, maskChannel, session, joinCompiler);\n         }\n         else {\n             accumulator = instantiateGroupedAccumulator(inputChannels, maskChannel);\n         }\n \n-        if (orderByChannels.isEmpty()) {\n+        if (!hasOrderBy()) {\n             return accumulator;\n         }\n \n-        return new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory);\n+        return new SpillableOrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9"}, "originalPosition": 35}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "committedDate": "2020-06-04T20:10:09Z", "message": "Refactored ORDER BY"}, "afterCommit": {"oid": "ec43556b3db434a0cdef7624fad0f1799d7d6737", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/ec43556b3db434a0cdef7624fad0f1799d7d6737", "committedDate": "2020-06-04T20:25:50Z", "message": "Refactored ORDER BY"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDE4NTY0", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-425018564", "createdAt": "2020-06-05T06:08:33Z", "commit": {"oid": "ec43556b3db434a0cdef7624fad0f1799d7d6737"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNjowODozNFrOGfhhOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNjowODo1N1rOGfhhpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwODIxNw==", "bodyText": "SpillableDistinctingGroupedAccumulator and SpillableOrderingGroupedAccumulator are very much the same. We just need one and call it SpillableFinalOnlyGroupedAccumulator", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435708217", "createdAt": "2020-06-05T06:08:34Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -399,27 +418,136 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n             accumulator.addInput(groupIds, new Page(filtered.getPositionCount(), columns));\n         }\n \n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            accumulator.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+        }\n+\n+        public void addBlocksToHash(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Work<Block> work = hash.markDistinctRows(new Page(blocks));\n+            checkState(work.process());\n+            Block distinctMask = work.getResult();\n+\n+            blocks[0] = distinctMask;\n+            accumulator.addInput(groupIds, new Page(blocks));\n+        }\n+    }\n+\n+    private static class SpillableDistinctingGroupedAccumulator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec43556b3db434a0cdef7624fad0f1799d7d6737"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwODMyNw==", "bodyText": "This can be FinalOnlyGroupedAccumulator", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435708327", "createdAt": "2020-06-05T06:08:57Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -399,27 +418,136 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n             accumulator.addInput(groupIds, new Page(filtered.getPositionCount(), columns));\n         }\n \n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            accumulator.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+        }\n+\n+        public void addBlocksToHash(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Work<Block> work = hash.markDistinctRows(new Page(blocks));\n+            checkState(work.process());\n+            Block distinctMask = work.getResult();\n+\n+            blocks[0] = distinctMask;\n+            accumulator.addInput(groupIds, new Page(blocks));\n+        }\n+    }\n+\n+    private static class SpillableDistinctingGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final DistinctingGroupedAccumulator distinctingGroupedAccumulator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec43556b3db434a0cdef7624fad0f1799d7d6737"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTAxNzM2", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-425501736", "createdAt": "2020-06-05T17:47:12Z", "commit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo0NzoxMlrOGf3rjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo0NzoxMlrOGf3rjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MTMxMQ==", "bodyText": "Not too happy about having to do this since unsure of the memory implications. But this is the only way since the two accumulators format their pages in different ways. Let me know if you can think of any alternatives.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436071311", "createdAt": "2020-06-05T17:47:12Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NzA3OTg5", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-425707989", "createdAt": "2020-06-06T03:00:30Z", "commit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMzowMDozMFrOGgBdjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwNTowMzo1OFrOGgHLUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTU2NA==", "bodyText": "Do we need this change? Or this purely for test? If it's for test, I think we don't have to change this and just fix the tests.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436231564", "createdAt": "2020-06-06T03:00:30Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -41,7 +41,7 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTYxMg==", "bodyText": "Remove comment \"// hasOrderBy() || hasDistinct()\"", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436231612", "createdAt": "2020-06-06T03:01:04Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/HashAggregationOperator.java", "diffHunk": "@@ -367,7 +367,7 @@ public void addInput(Page page)\n \n         if (aggregationBuilder == null) {\n             // TODO: We ignore spillEnabled here if any aggregate has ORDER BY clause or DISTINCT because they are not yet implemented for spilling.\n-            if (step.isOutputPartial() || !spillEnabled || hasOrderBy() || hasDistinct()) {\n+            if (step.isOutputPartial() || !spillEnabled) { // hasOrderBy() || hasDistinct()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzOTQ3Mg==", "bodyText": "Add a javadoc to denote such accumulator does not support partial aggregation. But they need to support spilling", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436239472", "createdAt": "2020-06-06T05:16:36Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/FinalOnlyGroupedAccumulator.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.GroupByIdBlock;\n+\n+public abstract class FinalOnlyGroupedAccumulator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MTY3MA==", "bodyText": "Add a javadoc to denote this is for FinalOnlyGroupedAccumulator only", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436241670", "createdAt": "2020-06-06T05:54:03Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MjE2OA==", "bodyText": "blockBuilders", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436242168", "createdAt": "2020-06-06T06:02:53Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MjIzNg==", "bodyText": "position", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436242236", "createdAt": "2020-06-06T06:04:11Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0NDY2Mw==", "bodyText": "accidental change", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436244663", "createdAt": "2020-06-06T06:47:08Z", "author": {"login": "highker"}, "path": "presto-tests/src/main/java/com/facebook/presto/tests/AbstractTestAggregations.java", "diffHunk": "@@ -910,7 +910,7 @@ public void testGroupBySum()\n     @Test\n     public void testGroupByRequireIntegerCoercion()\n     {\n-        assertQuery(\"SELECT partkey, COUNT(DISTINCT shipdate), SUM(linenumber) FROM lineitem GROUP BY partkey\");\n+        assertQuery(\"SELECT partkey, COUNT(DISTINCT shipdate), SUM(linenumber) FROM lineitem GROUP BY partkeyTestHivePushdownDistributedQuer\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMjU0Mg==", "bodyText": "This will cause a bug: if the accumulator has distinct and orderBy, then the accumulator will be\n\nSpillableGroupedAccumulator wrapping\n\nOrderingGroupedAccumulator wrapping\n\nanother SpillableGroupedAccumulator and finally wrapping\n\nDistinctingGroupedAccumulator.\n\n\n\n\n\n\n\nHowever, it should be\n\nSpillableGroupedAccumulator wrapping\n\nOrderingGroupedAccumulator and then wrapping\n\nDistinctingGroupedAccumulator.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436322542", "createdAt": "2020-06-07T04:08:04Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -167,23 +174,48 @@ public GroupedAccumulator createGroupedAccumulator()\n                 argumentTypes.add(sourceTypes.get(input));\n             }\n \n-            accumulator = new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler);\n+            accumulator = new SpillableGroupedAccumulator(\n+                    sourceTypes,\n+                    new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler));\n         }\n         else {\n             accumulator = instantiateGroupedAccumulator(inputChannels, maskChannel);\n         }\n \n-        if (orderByChannels.isEmpty()) {\n+        if (!hasOrderBy()) {\n             return accumulator;\n         }\n \n-        return new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory);\n+        return new SpillableGroupedAccumulator(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMjY2Nw==", "bodyText": "Same here. What if it's orderBy + distinct?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436322667", "createdAt": "2020-06-07T04:10:52Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -167,23 +174,48 @@ public GroupedAccumulator createGroupedAccumulator()\n                 argumentTypes.add(sourceTypes.get(input));\n             }\n \n-            accumulator = new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler);\n+            accumulator = new SpillableGroupedAccumulator(\n+                    sourceTypes,\n+                    new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler));\n         }\n         else {\n             accumulator = instantiateGroupedAccumulator(inputChannels, maskChannel);\n         }\n \n-        if (orderByChannels.isEmpty()) {\n+        if (!hasOrderBy()) {\n             return accumulator;\n         }\n \n-        return new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory);\n+        return new SpillableGroupedAccumulator(\n+                sourceTypes,\n+                new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory));\n     }\n \n     @Override\n     public GroupedAccumulator createGroupedIntermediateAccumulator()\n     {\n         try {\n+            if (hasOrderBy()) {\n+                GroupedAccumulator accumulator = groupedAccumulatorConstructor.newInstance(stateDescriptors, inputChannels, maskChannel, lambdaProviders);\n+                return new SpillableGroupedAccumulator(\n+                        sourceTypes,\n+                        new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory));\n+            }\n+            if (hasDistinct()) {\n+                List<Type> argumentTypes = new ArrayList<>();\n+                for (int input : inputChannels) {\n+                    argumentTypes.add(sourceTypes.get(input));\n+                }\n+                // grouped accumulator needs to have channel 0 as distinct mask\n+                GroupedAccumulator accumulator = instantiateGroupedAccumulator(\n+                        inputChannels.stream()\n+                                .map(value -> value + 1)\n+                                .collect(Collectors.toList()),\n+                        Optional.of(0));\n+                return new SpillableGroupedAccumulator(\n+                        sourceTypes,\n+                        new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMjg1OQ==", "bodyText": "page.prependColumn is to do that right?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436322859", "createdAt": "2020-06-07T04:15:18Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -400,26 +426,29 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n         }\n \n         @Override\n-        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.evaluateFinal(groupId, output);\n         }\n \n         @Override\n-        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        public void prepareFinal()\n         {\n-            throw new UnsupportedOperationException();\n         }\n \n         @Override\n-        public void evaluateFinal(int groupId, BlockBuilder output)\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n         {\n-            accumulator.evaluateFinal(groupId, output);\n-        }\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            groupByAndBlocks[0] = groupIds;\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 1, blocks.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMjg3Ng==", "bodyText": "idAndBlocks", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436322876", "createdAt": "2020-06-07T04:15:42Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -400,26 +426,29 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n         }\n \n         @Override\n-        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.evaluateFinal(groupId, output);\n         }\n \n         @Override\n-        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        public void prepareFinal()\n         {\n-            throw new UnsupportedOperationException();\n         }\n \n         @Override\n-        public void evaluateFinal(int groupId, BlockBuilder output)\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n         {\n-            accumulator.evaluateFinal(groupId, output);\n-        }\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMzQzNw==", "bodyText": "The entire function body can be squashed into just one line right?\n\naddInput(groupIds, new Page(blocks));\n\nHaven't given a deep thought into distincting'saddIntermediateStateOnUnspill yet. But I assume it could be squashed. If that is the case, we don't need interface addIntermediateStateOnUnspill anymore. Will think about it in the next review iteration.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436323437", "createdAt": "2020-06-07T04:27:40Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDEwMg==", "bodyText": "check state that it is an array block builder", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324102", "createdAt": "2020-06-07T04:41:51Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+            delegate.addIntermediateStateOnUnspill(squashedGroupIds, blocks);\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            BlockBuilder arrayBlockBuilder = output.beginBlockEntry();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDE0MA==", "bodyText": "check state that block is instance of ArrayBlock", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324140", "createdAt": "2020-06-07T04:42:42Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDE1Ng==", "bodyText": "Do we really need this line? I think we can remove it. Check my comment below.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324156", "createdAt": "2020-06-07T04:43:01Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDU5MQ==", "bodyText": "I think for this function, we don't need to touch upon delegate. Instead, we need to collect all the squashedGroupIds and blocks into rawInputs by calling addInput(groupIdsBlock, page)", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324591", "createdAt": "2020-06-07T04:51:44Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+            delegate.addIntermediateStateOnUnspill(squashedGroupIds, blocks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDc2Nw==", "bodyText": "add a check state to make sure intermediateState is empty. We shouldn't touch intermediateState at this step anymore.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324767", "createdAt": "2020-06-07T04:55:31Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNTIwMQ==", "bodyText": "Add a check state to make sure intermediateState (or blockBuilders after renaming) is null. We shouldn't touch blockBuilders at this step anymore.\nNow, this is the key part. Let's take all the data in rawInputs and feed them into delegate.addInput(...). This should be the first time we touch delegate. Note that if rawInputs is a list or an array, we should deref the item so that we don't use 2X the memory. The easiest way to do so is to assign null to the entry that has just been fed into delegate.addInput(...).", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436325201", "createdAt": "2020-06-07T05:03:58Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+            delegate.addIntermediateStateOnUnspill(squashedGroupIds, blocks);\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            BlockBuilder arrayBlockBuilder = output.beginBlockEntry();\n+            RowBlock rowBlock = (RowBlock) intermediateState.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                arrayBlockBuilder.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 288}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Nzg5MTYx", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-425789161", "createdAt": "2020-06-07T05:48:34Z", "commit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwNTo0ODozNFrOGgHUzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwNTo1NTozMFrOGgHWiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNzYzMQ==", "bodyText": "Let's keep track of two data structures:\nprivate ObjectBigArray<RowBlockBuilder> blockBuilders = null;\nprivate List<Page> rawInputs = new ArrayList<>();  // or other list/array data structure", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436327631", "createdAt": "2020-06-07T05:48:34Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNzc0Nw==", "bodyText": "At this step, just do rawInputs.add(page.prependColumn(groupIdsBlock)); and that's it.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436327747", "createdAt": "2020-06-07T05:50:40Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNzg2Mw==", "bodyText": "At this step, explode block into page (RowBlock -> Block[]) with your logic. Then do addInput(groupIdsBlock, page);", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436327863", "createdAt": "2020-06-07T05:52:35Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyODA3Mg==", "bodyText": "We need to convert rawInputs into blockBuilders. So\n// this could be very expensive for the first time\nif (blockBuilders == null) {\n    blockBuilders = new ...;\n    for (Page page : rawInputs) {\n        // build the internal state just like your original logic for `addInput`.\n    }\n}\n\n// remaining logic", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436328072", "createdAt": "2020-06-07T05:55:30Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+            delegate.addIntermediateStateOnUnspill(squashedGroupIds, blocks);\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 271}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2ODE0NjA5", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-426814609", "createdAt": "2020-06-09T06:10:30Z", "commit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNjoxMDozMFrOGg6E2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNjoxMDozMFrOGg6E2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTEzMQ==", "bodyText": "If we don't wanna use too much memory for this method, we can always call compact() to materialize the mask. This is true for filter. Haven't read the AccumulatorCompiler in details, but might also be fine for distinctMask as well. This trick has been used in many place (e.g, GroupedTopNBuilder)", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r437159131", "createdAt": "2020-06-09T06:10:30Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -322,7 +354,7 @@ private static Page filter(Page page, Block mask)\n     }\n \n     private static class DistinctingGroupedAccumulator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8"}, "originalPosition": 73}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a83df35ebb8bdafe7c48bbea1265628207eb9c64", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/a83df35ebb8bdafe7c48bbea1265628207eb9c64", "committedDate": "2020-06-15T00:57:33Z", "message": "Refactor order by and distinct spilling, will squash on merge"}, "afterCommit": {"oid": "bdf63cfca5251134461e02fc75f584e57c5f1f0e", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/bdf63cfca5251134461e02fc75f584e57c5f1f0e", "committedDate": "2020-06-15T00:57:59Z", "message": "Refactor order by and distinct spilling, will squash on merge"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bdf63cfca5251134461e02fc75f584e57c5f1f0e", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/bdf63cfca5251134461e02fc75f584e57c5f1f0e", "committedDate": "2020-06-15T00:57:59Z", "message": "Refactor order by and distinct spilling, will squash on merge"}, "afterCommit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/0e9b7dd3f36b8a399f33af1a7013e96900470731", "committedDate": "2020-06-15T01:07:56Z", "message": "Refactor order by and distinct spilling, will squash on merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjcyNzc0", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-430272774", "createdAt": "2020-06-15T01:12:04Z", "commit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMToxMjowNFrOGjgtcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMToxNDozN1rOGjguzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTI2Ng==", "bodyText": "evaluateIntermediate can be called after prepareFinal since it is called by a separate revoking thread from my understanding. This means that we cannot set rawInputs = null.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r439889266", "createdAt": "2020-06-15T01:12:04Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +592,163 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            for (GroupIdPage groupIdPage : rawInputs) {\n+                delegate.addInput(groupIdPage.getGroupByIdBlock(), groupIdPage.getPage());\n+            }\n+\n+            // cannot set raw inputs to null because evaluateIntermediate may be called after prepareFinal()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTYxNQ==", "bodyText": "Made a pair class since otherwise we will have to separate group ids block and page every time we addInput to the delegate and make a new page object. Felt this was more efficient due to that.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r439889615", "createdAt": "2020-06-15T01:14:37Z", "author": {"login": "sachdevs"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +592,163 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            for (GroupIdPage groupIdPage : rawInputs) {\n+                delegate.addInput(groupIdPage.getGroupByIdBlock(), groupIdPage.getPage());\n+            }\n+\n+            // cannot set raw inputs to null because evaluateIntermediate may be called after prepareFinal()\n+            delegate.prepareFinal();\n+        }\n+\n+        private static class GroupIdPage", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "originalPosition": 303}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMzA3MjUz", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-430307253", "createdAt": "2020-06-15T03:54:05Z", "commit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMzo1NDowNVrOGjieew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMzo1NDowNVrOGjieew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkxODIwMw==", "bodyText": "Take a look at ColumnarArray and ColumnarRow. That may be helpful to make the modifiers untouched in presto-common", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r439918203", "createdAt": "2020-06-15T03:54:05Z", "author": {"login": "highker"}, "path": "presto-common/src/main/java/com/facebook/presto/common/block/AbstractArrayBlock.java", "diffHunk": "@@ -30,7 +30,7 @@\n public abstract class AbstractArrayBlock\n         implements Block\n {\n-    protected abstract Block getRawElementBlock();\n+    public abstract Block getRawElementBlock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMTQzNzUy", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-431143752", "createdAt": "2020-06-16T04:01:07Z", "commit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMjQwMjYy", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-431240262", "createdAt": "2020-06-16T07:43:04Z", "commit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0MzowNVrOGkPHWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0MzowNVrOGkPHWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY0OTU2MQ==", "bodyText": "Show we create spillable accumulator based on isSpillEnabled(session)?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r440649561", "createdAt": "2020-06-16T07:43:05Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -168,23 +176,57 @@ public GroupedAccumulator createGroupedAccumulator()\n             }\n \n             accumulator = new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler);\n+            if (!hasOrderBy()) {\n+                accumulator = new SpillableFinalOnlyGroupedAccumulator(sourceTypes, (FinalOnlyGroupedAccumulator) accumulator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "originalPosition": 24}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/0e9b7dd3f36b8a399f33af1a7013e96900470731", "committedDate": "2020-06-15T01:07:56Z", "message": "Refactor order by and distinct spilling, will squash on merge"}, "afterCommit": {"oid": "a510ffee36d03f4683e32e22db1a6197e4ad0ff5", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/a510ffee36d03f4683e32e22db1a6197e4ad0ff5", "committedDate": "2020-06-16T19:46:06Z", "message": "Refactor order by and distinct spilling, will squash on merge"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a510ffee36d03f4683e32e22db1a6197e4ad0ff5", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/a510ffee36d03f4683e32e22db1a6197e4ad0ff5", "committedDate": "2020-06-16T19:46:06Z", "message": "Refactor order by and distinct spilling, will squash on merge"}, "afterCommit": {"oid": "3691c6e2cb3589bddb99ceb6e7789b7eb75d15b4", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/3691c6e2cb3589bddb99ceb6e7789b7eb75d15b4", "committedDate": "2020-06-16T19:49:20Z", "message": "Refactor order by and distinct spilling, will squash on merge"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3691c6e2cb3589bddb99ceb6e7789b7eb75d15b4", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/3691c6e2cb3589bddb99ceb6e7789b7eb75d15b4", "committedDate": "2020-06-16T19:49:20Z", "message": "Refactor order by and distinct spilling, will squash on merge"}, "afterCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/e7b5eb567740a916c2456ee08d3e513cc4266c9a", "committedDate": "2020-06-16T20:09:39Z", "message": "Refactor order by and distinct spilling, will squash on merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMDA0Nzkx", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-432004791", "createdAt": "2020-06-17T01:52:37Z", "commit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMTo1MjozN1rOGky4Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMzo1NzoxOFrOGk0wpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIzNTU1NA==", "bodyText": "{@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441235554", "createdAt": "2020-06-17T01:52:37Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIzNTcyMg==", "bodyText": "{@link FinalOnlyGroupedAccumulator}", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441235722", "createdAt": "2020-06-17T01:53:10Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/FinalOnlyGroupedAccumulator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.GroupByIdBlock;\n+\n+/**\n+ * FinalOnlyGroupedAccumulator is an accumulator that does not support partial aggregation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NTMxNg==", "bodyText": "Use ObjectBigArray as well. Then we can remove rawInputsSize", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441245316", "createdAt": "2020-06-17T02:29:47Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NTM4Mg==", "bodyText": "break a line between constants and variables.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441245382", "createdAt": "2020-06-17T02:30:03Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NTUyNA==", "bodyText": "requireNonNull", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441245524", "createdAt": "2020-06-17T02:30:33Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI1NjEzNg==", "bodyText": "check state output instanceof ArrayBlockBuilder", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441256136", "createdAt": "2020-06-17T03:13:30Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI1NjE1OA==", "bodyText": "break a line", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441256158", "createdAt": "2020-06-17T03:13:37Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI1NjQwNQ==", "bodyText": "(long) cast is redundant", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441256405", "createdAt": "2020-06-17T03:14:56Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI1ODA2NQ==", "bodyText": "Add a comment to explain why we need to squash everything into a single cell.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441258065", "createdAt": "2020-06-17T03:21:36Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2MjMyOA==", "bodyText": "It took me a long while to understand what this part is doing. We need detailed comments to explain:\n\nColumnarArray flattens the squashed arrays; so there is no need to flatten block again.\nnewPositionCount is the unrolled position count already.\nunused is unused because we are unrolling for the same group id; this corresponds to how ColumnarArray unrolls internal block.\nColumnarRow already contains the unrolled blocks.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441262328", "createdAt": "2020-06-17T03:39:46Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2MzE5OQ==", "bodyText": "If we cannot set it to null, we can still deref it by rawInputs  = new ..", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441263199", "createdAt": "2020-06-17T03:43:29Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +592,163 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            for (GroupIdPage groupIdPage : rawInputs) {\n+                delegate.addInput(groupIdPage.getGroupByIdBlock(), groupIdPage.getPage());\n+            }\n+\n+            // cannot set raw inputs to null because evaluateIntermediate may be called after prepareFinal()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTI2Ng=="}, "originalCommit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2NjI2OA==", "bodyText": "Do we know if there will be a correctness issue if an aggregationBuilder already starts to build result and we start to revoke and produce intermediate ressult?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441266268", "createdAt": "2020-06-17T03:56:57Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2NjMyNA==", "bodyText": "requireNonNull", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441266324", "createdAt": "2020-06-17T03:57:12Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            for (GroupIdPage groupIdPage : rawInputs) {\n+                delegate.addInput(groupIdPage.getGroupByIdBlock(), groupIdPage.getPage());\n+            }\n+\n+            // cannot set raw inputs to null because evaluateIntermediate may be called after prepareFinal()\n+            delegate.prepareFinal();\n+        }\n+\n+        private static class GroupIdPage\n+        {\n+            private final GroupByIdBlock groupByIdBlock;\n+            private final Page page;\n+\n+            public GroupIdPage(GroupByIdBlock groupByIdBlock, Page page)\n+            {\n+                this.page = page;\n+                this.groupByIdBlock = groupByIdBlock;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2NjM0Mg==", "bodyText": "That is ok", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441266342", "createdAt": "2020-06-17T03:57:18Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +592,163 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            for (GroupIdPage groupIdPage : rawInputs) {\n+                delegate.addInput(groupIdPage.getGroupByIdBlock(), groupIdPage.getPage());\n+            }\n+\n+            // cannot set raw inputs to null because evaluateIntermediate may be called after prepareFinal()\n+            delegate.prepareFinal();\n+        }\n+\n+        private static class GroupIdPage", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTYxNQ=="}, "originalCommit": {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731"}, "originalPosition": 303}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/e7b5eb567740a916c2456ee08d3e513cc4266c9a", "committedDate": "2020-06-16T20:09:39Z", "message": "Refactor order by and distinct spilling, will squash on merge"}, "afterCommit": {"oid": "14268e4192b72c787923729b4d3350348ba99b5f", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/14268e4192b72c787923729b4d3350348ba99b5f", "committedDate": "2020-06-17T21:16:39Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NjI5ODQ2", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-434629846", "createdAt": "2020-06-22T06:19:03Z", "commit": {"oid": "14268e4192b72c787923729b4d3350348ba99b5f"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNjoxOTowM1rOGmzMMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNjozNDo0NFrOGmzgtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNzc3OQ==", "bodyText": "Instead of having these two new interfaces, we can make spillingEnabled a variable for AccumulatorFactoryBinder. spillingEnabled can be passed in through AccumulatorFactoryBinder::bind. In that way, we can avoid a lot of tunneling. spillingEnabled can be directly obtained from LocalExecutionPlanner", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r443337779", "createdAt": "2020-06-22T06:19:03Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/AccumulatorFactory.java", "diffHunk": "@@ -30,4 +30,8 @@\n     boolean hasOrderBy();\n \n     boolean hasDistinct();\n+\n+    GroupedAccumulator createSpillableGroupedAccumulator();\n+\n+    GroupedAccumulator createSpillableGroupedIntermediateAccumulator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14268e4192b72c787923729b4d3350348ba99b5f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzOTgwMw==", "bodyText": "Add a TODO to denote that there are tricks to avoid storing the whole page in memory. For distincting case, dedup is available by doing compaction.", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r443339803", "createdAt": "2020-06-22T06:25:05Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +582,173 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * {@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+\n+        private ObjectBigArray<GroupIdPage> rawInputs = new ObjectBigArray<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsLength;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = requireNonNull(delegate, \"delegate FinalOnlyGroupedAccumulator is null\");\n+            this.spillingTypes = requireNonNull(types, \"types is null\");\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + (rawInputs == null ? 0 : rawInputs.sizeOf()) + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputs.ensureCapacity(rawInputsLength);\n+            rawInputs.set(rawInputsLength, new GroupIdPage(groupIdsBlock, page));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14268e4192b72c787923729b4d3350348ba99b5f"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM0MTMyMg==", "bodyText": "Is this part necessary?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r443341322", "createdAt": "2020-06-22T06:29:45Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/builder/SpillableHashAggregationBuilder.java", "diffHunk": "@@ -155,13 +155,19 @@ private boolean hasPreviousSpillCompletedSuccessfully()\n     public ListenableFuture<?> startMemoryRevoke()\n     {\n         checkState(spillInProgress.isDone());\n+        if (hashAggregationBuilder.hasBuiltFinalResult()) {\n+            return spillInProgress;\n+        }\n         spillToDisk();\n         return spillInProgress;\n     }\n \n     @Override\n     public void finishMemoryRevoke()\n     {\n+        if (hashAggregationBuilder.hasBuiltFinalResult()) {\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14268e4192b72c787923729b4d3350348ba99b5f"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM0MzAzMA==", "bodyText": "If I understand correctly, the original logic can only happen if an operator that has never spilled and just started to build final results; however, a revoke request comes in. Am I right? If that is the case, shall we make a comment here?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r443343030", "createdAt": "2020-06-22T06:34:44Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/builder/SpillableHashAggregationBuilder.java", "diffHunk": "@@ -155,13 +155,19 @@ private boolean hasPreviousSpillCompletedSuccessfully()\n     public ListenableFuture<?> startMemoryRevoke()\n     {\n         checkState(spillInProgress.isDone());\n+        if (hashAggregationBuilder.hasBuiltFinalResult()) {\n+            return spillInProgress;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14268e4192b72c787923729b4d3350348ba99b5f"}, "originalPosition": 6}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "14268e4192b72c787923729b4d3350348ba99b5f", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/14268e4192b72c787923729b4d3350348ba99b5f", "committedDate": "2020-06-17T21:16:39Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}, "afterCommit": {"oid": "f69f15176e1bc8116bca6c788061939a4c2b0b69", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/f69f15176e1bc8116bca6c788061939a4c2b0b69", "committedDate": "2020-06-24T21:02:16Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f69f15176e1bc8116bca6c788061939a4c2b0b69", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/f69f15176e1bc8116bca6c788061939a4c2b0b69", "committedDate": "2020-06-24T21:02:16Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}, "afterCommit": {"oid": "0086104d5addf148d954c2960f49d0d9785b022b", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/0086104d5addf148d954c2960f49d0d9785b022b", "committedDate": "2020-06-24T21:22:15Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MTkwNjQ1", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-437190645", "createdAt": "2020-06-25T06:03:40Z", "commit": {"oid": "0086104d5addf148d954c2960f49d0d9785b022b"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0086104d5addf148d954c2960f49d0d9785b022b", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/0086104d5addf148d954c2960f49d0d9785b022b", "committedDate": "2020-06-24T21:22:15Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}, "afterCommit": {"oid": "8f9f6ea8256674083ea4ad1d85b7ec295206e6ca", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/8f9f6ea8256674083ea4ad1d85b7ec295206e6ca", "committedDate": "2020-06-30T18:05:56Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f9f6ea8256674083ea4ad1d85b7ec295206e6ca", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/8f9f6ea8256674083ea4ad1d85b7ec295206e6ca", "committedDate": "2020-06-30T18:05:56Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}, "afterCommit": {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/58dddc4e837b75169f9c5be5f1c01780288017ea", "committedDate": "2020-06-30T23:28:05Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNTA5MTk3", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-440509197", "createdAt": "2020-07-01T02:39:12Z", "commit": {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjozOToxMlrOGrU2QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMjo1MzozNlrOGrVDpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MzUyMA==", "bodyText": "add checkState(accumulator instance of FinalOnlyGroupedAccumulator)", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448083520", "createdAt": "2020-07-01T02:39:12Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -191,16 +228,22 @@ public GroupedAccumulator createGroupedIntermediateAccumulator()\n         }\n     }\n \n-    @Override\n-    public boolean hasOrderBy()\n+    private GroupedAccumulator createSpillableGroupedAccumulator()\n     {\n-        return !orderByChannels.isEmpty();\n+        GroupedAccumulator accumulator = createDefaultGroupedAccumulator();\n+        if (!hasDistinct() && !hasOrderBy()) {\n+            return accumulator;\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NDg0OA==", "bodyText": "For spillEnabled  == false, both returns createDefaultGroupedAccumulator()? That doesn't look right? Do we have unit tests to verify this?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448084848", "createdAt": "2020-07-01T02:44:47Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -151,10 +166,33 @@ public Accumulator createIntermediateAccumulator()\n \n     @Override\n     public GroupedAccumulator createGroupedAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedAccumulator() : createDefaultGroupedAccumulator();\n+    }\n+\n+    @Override\n+    public GroupedAccumulator createGroupedIntermediateAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedIntermediateAccumulator() : createDefaultGroupedAccumulator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NTU1OQ==", "bodyText": "Is this right? the function is to create IntermediateAccumulator but here it delegates to GroupedAccumulator and then use createDefaultGroupedAccumulator instead of createDefaultGroupedIntermediateAccumulator?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448085559", "createdAt": "2020-07-01T02:47:30Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -191,16 +228,22 @@ public GroupedAccumulator createGroupedIntermediateAccumulator()\n         }\n     }\n \n-    @Override\n-    public boolean hasOrderBy()\n+    private GroupedAccumulator createSpillableGroupedAccumulator()\n     {\n-        return !orderByChannels.isEmpty();\n+        GroupedAccumulator accumulator = createDefaultGroupedAccumulator();\n+        if (!hasDistinct() && !hasOrderBy()) {\n+            return accumulator;\n+        }\n+\n+        return new SpillableFinalOnlyGroupedAccumulator(sourceTypes, (FinalOnlyGroupedAccumulator) accumulator);\n     }\n \n-    @Override\n-    public boolean hasDistinct()\n+    private GroupedAccumulator createSpillableGroupedIntermediateAccumulator()\n     {\n-        return distinct;\n+        if (!hasOrderBy() && !hasDistinct()) {\n+            return createDefaultGroupedIntermediateAccumulator();\n+        }\n+        return createSpillableGroupedAccumulator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NjA4MA==", "bodyText": "\"delegate is null\");", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448086080", "createdAt": "2020-07-01T02:49:45Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +593,174 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * {@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+\n+        private ObjectBigArray<GroupIdPage> rawInputs = new ObjectBigArray<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsLength;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = requireNonNull(delegate, \"delegate FinalOnlyGroupedAccumulator is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NjkyNg==", "bodyText": "What are these changes?", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448086926", "createdAt": "2020-07-01T02:53:28Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2070,7 +2070,7 @@ private PhysicalOperation createLookupJoin(JoinNode node,\n             OptionalInt buildHashChannel = buildHashVariable.map(variableChannelGetter(buildSource))\n                     .map(OptionalInt::of).orElse(OptionalInt.empty());\n \n-            boolean spillEnabled = isSpillEnabled(context.getSession());\n+            boolean spillEnabled = false; //isSpillEnabled(context.getSession());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Njk1MA==", "bodyText": "Same", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448086950", "createdAt": "2020-07-01T02:53:36Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2203,9 +2203,6 @@ private OperatorFactory createLookupJoin(\n         private OptionalInt getJoinOperatorsCountForSpill(LocalExecutionPlanContext context, Session session)\n         {\n             OptionalInt driverInstanceCount = context.getDriverInstanceCount();\n-            if (isSpillEnabled(session)) {\n-                checkState(driverInstanceCount.isPresent(), \"A fixed distribution is required for JOIN when spilling is enabled\");\n-            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea"}, "originalPosition": 15}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/58dddc4e837b75169f9c5be5f1c01780288017ea", "committedDate": "2020-06-30T23:28:05Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}, "afterCommit": {"oid": "25d84bd505bb105516a7ecedfa65657b8da0bb6a", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/25d84bd505bb105516a7ecedfa65657b8da0bb6a", "committedDate": "2020-07-01T19:18:21Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25d84bd505bb105516a7ecedfa65657b8da0bb6a", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/25d84bd505bb105516a7ecedfa65657b8da0bb6a", "committedDate": "2020-07-01T19:18:21Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}, "afterCommit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/610733483ee27e956da837ce9b92b05d304030d7", "committedDate": "2020-07-01T19:20:04Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzY0MTIz", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-441364123", "createdAt": "2020-07-02T05:42:27Z", "commit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTo0MjoyN1rOGr-KDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTo1MjoyMlrOGr-U1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MDMzMg==", "bodyText": "This is the format I would propose\n    @Override\n    public GroupedAccumulator createGroupedAccumulator()\n    {\n        GroupedAccumulator accumulator = createDefaultGroupedAccumulator();\n\n        if (!spillEnabled || (!hasDistinct() && !hasOrderBy())) {\n            return accumulator;\n        }\n\n        checkState(accumulator instanceof FinalOnlyGroupedAccumulator, \"accumulator must contain distinct or order by\");\n        return new SpillableFinalOnlyGroupedAccumulator(sourceTypes, (FinalOnlyGroupedAccumulator) accumulator);\n    }", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448760332", "createdAt": "2020-07-02T05:42:27Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -151,10 +166,33 @@ public Accumulator createIntermediateAccumulator()\n \n     @Override\n     public GroupedAccumulator createGroupedAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedAccumulator() : createDefaultGroupedAccumulator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MDQ5OQ==", "bodyText": "createGenericGroupedAccumulator", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448760499", "createdAt": "2020-07-02T05:43:07Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -151,10 +166,33 @@ public Accumulator createIntermediateAccumulator()\n \n     @Override\n     public GroupedAccumulator createGroupedAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedAccumulator() : createDefaultGroupedAccumulator();\n+    }\n+\n+    @Override\n+    public GroupedAccumulator createGroupedIntermediateAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedIntermediateAccumulator() : createDefaultGroupedIntermediateAccumulator();\n+    }\n+\n+    @Override\n+    public boolean hasOrderBy()\n+    {\n+        return !orderByChannels.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean hasDistinct()\n+    {\n+        return distinct;\n+    }\n+\n+    private GroupedAccumulator createDefaultGroupedAccumulator()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MTEzMQ==", "bodyText": "Actually, is it even possible we need createSpillableGroupedIntermediateAccumulator()? Can we check if the following is good enough?\n    @Override\n    public GroupedAccumulator createGroupedIntermediateAccumulator()\n    {\n        checkState(!hasDistinct() || !hasOrderBy(), \"distinct or order by cannot have partial aggregation\");\n        \n        try {\n            return groupedAccumulatorConstructor.newInstance(stateDescriptors, ImmutableList.of(), Optional.empty(), lambdaProviders);\n        }\n        catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n    }", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448761131", "createdAt": "2020-07-02T05:45:29Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -151,10 +166,33 @@ public Accumulator createIntermediateAccumulator()\n \n     @Override\n     public GroupedAccumulator createGroupedAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedAccumulator() : createDefaultGroupedAccumulator();\n+    }\n+\n+    @Override\n+    public GroupedAccumulator createGroupedIntermediateAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedIntermediateAccumulator() : createDefaultGroupedIntermediateAccumulator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MTg0MA==", "bodyText": "We don't need this helper", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448761840", "createdAt": "2020-07-02T05:48:10Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -191,16 +228,23 @@ public GroupedAccumulator createGroupedIntermediateAccumulator()\n         }\n     }\n \n-    @Override\n-    public boolean hasOrderBy()\n+    private GroupedAccumulator createSpillableGroupedAccumulator()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MTg3Nw==", "bodyText": "same", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448761877", "createdAt": "2020-07-02T05:48:17Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -191,16 +228,23 @@ public GroupedAccumulator createGroupedIntermediateAccumulator()\n         }\n     }\n \n-    @Override\n-    public boolean hasOrderBy()\n+    private GroupedAccumulator createSpillableGroupedAccumulator()\n     {\n-        return !orderByChannels.isEmpty();\n+        GroupedAccumulator accumulator = createDefaultGroupedAccumulator();\n+        if (!hasDistinct() && !hasOrderBy()) {\n+            return accumulator;\n+        }\n+\n+        checkState(accumulator instanceof FinalOnlyGroupedAccumulator);\n+        return new SpillableFinalOnlyGroupedAccumulator(sourceTypes, (FinalOnlyGroupedAccumulator) accumulator);\n     }\n \n-    @Override\n-    public boolean hasDistinct()\n+    private GroupedAccumulator createSpillableGroupedIntermediateAccumulator()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MjUxNw==", "bodyText": "Add\nprivate static final int INSTANCE_SIZE = ClassLayout.parseClass(SpillableFinalOnlyGroupedAccumulator.class).instanceSize();", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448762517", "createdAt": "2020-07-02T05:50:30Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +594,174 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * {@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MzA5NA==", "bodyText": "@Override\n        public long getEstimatedSize()\n        {\n            return INSTANCE_SIZE +\n                    delegate.getEstimatedSize() +\n                    (rawInputs == null ? 0 : rawInputs.sizeOf()) +\n                    (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n        }", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448763094", "createdAt": "2020-07-02T05:52:22Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +594,174 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * {@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+\n+        private ObjectBigArray<GroupIdPage> rawInputs = new ObjectBigArray<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsLength;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = requireNonNull(delegate, \"delegate is null\");\n+            this.spillingTypes = requireNonNull(types, \"types is null\");\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7"}, "originalPosition": 247}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b53600fe25c55e9b1ffba74a4fe40542193ada8b", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/b53600fe25c55e9b1ffba74a4fe40542193ada8b", "committedDate": "2020-07-02T18:48:58Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "610733483ee27e956da837ce9b92b05d304030d7", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/610733483ee27e956da837ce9b92b05d304030d7", "committedDate": "2020-07-01T19:20:04Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}, "afterCommit": {"oid": "b53600fe25c55e9b1ffba74a4fe40542193ada8b", "author": {"user": {"login": "sachdevs", "name": "Saksham"}}, "url": "https://github.com/prestodb/presto/commit/b53600fe25c55e9b1ffba74a4fe40542193ada8b", "committedDate": "2020-07-02T18:48:58Z", "message": "Implement ORDER BY and DISTINCT spilling for aggregation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMDIxNDg2", "url": "https://github.com/prestodb/presto/pull/14527#pullrequestreview-442021486", "createdAt": "2020-07-02T21:12:05Z", "commit": {"oid": "b53600fe25c55e9b1ffba74a4fe40542193ada8b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1642, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}