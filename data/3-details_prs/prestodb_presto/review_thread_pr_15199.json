{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNTE2Mzgw", "number": 15199, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTo0MjoyMlrOEl0DjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTo1MTo0MFrOEl0PLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDg1NjQ1OnYy", "diffSide": "RIGHT", "path": "presto-orc/src/test/java/com/facebook/presto/orc/AbstractTestOrcReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTo0MjoyMlrOHVfzfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTo0MjoyMlrOHVfzfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMzIzMA==", "bodyText": "this test doesn't use testRoundTrip() because there is some bug with the hive reader reading the list value test (unrelated to encryption)", "url": "https://github.com/prestodb/presto/pull/15199#discussion_r492303230", "createdAt": "2020-09-21T19:42:22Z", "author": {"login": "rschlussel"}, "path": "presto-orc/src/test/java/com/facebook/presto/orc/AbstractTestOrcReader.java", "diffHunk": "@@ -493,6 +494,19 @@ public void testDwrfInvalidCheckpointsForStripeDictionary()\n                         .collect(toList()));\n     }\n \n+    @Test\n+    public void testExtraLargeColumnValue()\n+            throws Exception\n+    {\n+\n+        Random rnd = new Random(0);\n+        String val = rnd.doubles(50_000).mapToObj(Double::toString).collect(Collectors.joining(\",\"));\n+        tester.assertRoundTrip(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccca0457a599fd036ea3521763759d13ef84d125"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDg4NjIxOnYy", "diffSide": "RIGHT", "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcOutputBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTo1MTo0MFrOHVgGTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDowMjowOVrOHVgbcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwODA0NA==", "bodyText": "The message has two %s placeholders, it should either have two length arguments or not have the last %s.", "url": "https://github.com/prestodb/presto/pull/15199#discussion_r492308044", "createdAt": "2020-09-21T19:51:40Z", "author": {"login": "sdruzkin"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcOutputBuffer.java", "diffHunk": "@@ -446,35 +446,31 @@ private void writeChunkToOutputStream(byte[] chunk, int offset, int length)\n \n         checkArgument(length <= buffer.length, \"Write chunk length must be less than compression buffer size\");\n \n+        boolean isCompressed = false;\n         if (compressor != null) {\n             int minCompressionBufferSize = compressor.maxCompressedLength(length);\n             if (compressionBuffer.length < minCompressionBufferSize) {\n                 compressionBuffer = new byte[minCompressionBufferSize];\n             }\n             int compressedSize = compressor.compress(chunk, offset, length, compressionBuffer, 0, compressionBuffer.length);\n             if (compressedSize < length) {\n-                if (dwrfEncryptor.isPresent()) {\n-                    compressionBuffer = dwrfEncryptor.get().encrypt(compressionBuffer, 0, compressedSize);\n-                    compressedSize = compressionBuffer.length;\n-                    // size after encryption should not exceed what the 3 byte header can hold (2^23)\n-                    if (compressedSize > 8388608) {\n-                        throw new OrcEncryptionException(\"Encrypted data size %s exceeds limit of 2^23 %s\", compressedSize);\n-                    }\n-                }\n-                int chunkHeader = (compressedSize << 1);\n-                writeChunkedOutput(compressionBuffer, 0, compressedSize, chunkHeader);\n-                return;\n+                isCompressed = true;\n+                chunk = compressionBuffer;\n+                length = compressedSize;\n+                offset = 0;\n             }\n         }\n         if (dwrfEncryptor.isPresent()) {\n-            chunk = dwrfEncryptor.get().encrypt(chunk, 0, length);\n+            chunk = dwrfEncryptor.get().encrypt(chunk, offset, length);\n             length = chunk.length;\n+            offset = 0;\n             // size after encryption should not exceed what the 3 byte header can hold (2^23)\n             if (length > 8388608) {\n                 throw new OrcEncryptionException(\"Encrypted data size %s exceeds limit of 2^23 %s\", length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ccca0457a599fd036ea3521763759d13ef84d125"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMzQ1Ng==", "bodyText": "good catch, thank you!", "url": "https://github.com/prestodb/presto/pull/15199#discussion_r492313456", "createdAt": "2020-09-21T20:02:09Z", "author": {"login": "rschlussel"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcOutputBuffer.java", "diffHunk": "@@ -446,35 +446,31 @@ private void writeChunkToOutputStream(byte[] chunk, int offset, int length)\n \n         checkArgument(length <= buffer.length, \"Write chunk length must be less than compression buffer size\");\n \n+        boolean isCompressed = false;\n         if (compressor != null) {\n             int minCompressionBufferSize = compressor.maxCompressedLength(length);\n             if (compressionBuffer.length < minCompressionBufferSize) {\n                 compressionBuffer = new byte[minCompressionBufferSize];\n             }\n             int compressedSize = compressor.compress(chunk, offset, length, compressionBuffer, 0, compressionBuffer.length);\n             if (compressedSize < length) {\n-                if (dwrfEncryptor.isPresent()) {\n-                    compressionBuffer = dwrfEncryptor.get().encrypt(compressionBuffer, 0, compressedSize);\n-                    compressedSize = compressionBuffer.length;\n-                    // size after encryption should not exceed what the 3 byte header can hold (2^23)\n-                    if (compressedSize > 8388608) {\n-                        throw new OrcEncryptionException(\"Encrypted data size %s exceeds limit of 2^23 %s\", compressedSize);\n-                    }\n-                }\n-                int chunkHeader = (compressedSize << 1);\n-                writeChunkedOutput(compressionBuffer, 0, compressedSize, chunkHeader);\n-                return;\n+                isCompressed = true;\n+                chunk = compressionBuffer;\n+                length = compressedSize;\n+                offset = 0;\n             }\n         }\n         if (dwrfEncryptor.isPresent()) {\n-            chunk = dwrfEncryptor.get().encrypt(chunk, 0, length);\n+            chunk = dwrfEncryptor.get().encrypt(chunk, offset, length);\n             length = chunk.length;\n+            offset = 0;\n             // size after encryption should not exceed what the 3 byte header can hold (2^23)\n             if (length > 8388608) {\n                 throw new OrcEncryptionException(\"Encrypted data size %s exceeds limit of 2^23 %s\", length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwODA0NA=="}, "originalCommit": {"oid": "ccca0457a599fd036ea3521763759d13ef84d125"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3696, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}