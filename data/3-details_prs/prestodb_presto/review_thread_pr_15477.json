{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTIxODEw", "number": 15477, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToxMDowN1rOFL5t5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToyMToxOFrOFL548A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDI0MjkzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToxMDowN1rOIPWKZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTo0Mjo0N1rOIPW7pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MjY2MQ==", "bodyText": "nit: we can use decrementAndGet(releasedPageCount)", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552962661", "createdAt": "2021-01-06T21:10:07Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);\n+        if (counter == null) {\n+            counter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong());\n+        }\n+        counter.addAndGet(pagesAdded);\n+    }\n+\n+    public void setNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        requireNonNull(lifespan, \"lifespan is null\");\n+        noMorePagesForLifespan.add(lifespan);\n+    }\n+\n+    public boolean isNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        return noMorePagesForLifespan.contains(lifespan);\n+    }\n+\n+    public boolean isFinishedForLifespan(Lifespan lifespan)\n+    {\n+        if (!noMorePagesForLifespan.contains(lifespan)) {\n+            return false;\n+        }\n+\n+        AtomicLong outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan);\n+        return outstandingPageCount == null || outstandingPageCount.get() == 0;\n+    }\n+\n+    @Override\n+    public void onPagesReleased(Lifespan lifespan, int releasedPageCount, long releasedSizeInBytes)\n+    {\n+        long outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan).addAndGet(-releasedPageCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3NTI2OA==", "bodyText": "decrementAndGet() takes no arguments as it implies a value of -1", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552975268", "createdAt": "2021-01-06T21:42:47Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);\n+        if (counter == null) {\n+            counter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong());\n+        }\n+        counter.addAndGet(pagesAdded);\n+    }\n+\n+    public void setNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        requireNonNull(lifespan, \"lifespan is null\");\n+        noMorePagesForLifespan.add(lifespan);\n+    }\n+\n+    public boolean isNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        return noMorePagesForLifespan.contains(lifespan);\n+    }\n+\n+    public boolean isFinishedForLifespan(Lifespan lifespan)\n+    {\n+        if (!noMorePagesForLifespan.contains(lifespan)) {\n+            return false;\n+        }\n+\n+        AtomicLong outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan);\n+        return outstandingPageCount == null || outstandingPageCount.get() == 0;\n+    }\n+\n+    @Override\n+    public void onPagesReleased(Lifespan lifespan, int releasedPageCount, long releasedSizeInBytes)\n+    {\n+        long outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan).addAndGet(-releasedPageCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MjY2MQ=="}, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDI0OTI4OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToxMzowNlrOIPWOUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTo0NDo0NVrOIPW-mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MzY2NQ==", "bodyText": "I didn't see this childListener related logic in trinodb/trino#6097 ? And looks like it's only used in BroadcastOutputBuffer as a safety check:\ncheckState(totalBufferedPages.addAndGet(-releasedPageCount) >= 0);", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552963665", "createdAt": "2021-01-06T21:13:06Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);\n+        if (counter == null) {\n+            counter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong());\n+        }\n+        counter.addAndGet(pagesAdded);\n+    }\n+\n+    public void setNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        requireNonNull(lifespan, \"lifespan is null\");\n+        noMorePagesForLifespan.add(lifespan);\n+    }\n+\n+    public boolean isNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        return noMorePagesForLifespan.contains(lifespan);\n+    }\n+\n+    public boolean isFinishedForLifespan(Lifespan lifespan)\n+    {\n+        if (!noMorePagesForLifespan.contains(lifespan)) {\n+            return false;\n+        }\n+\n+        AtomicLong outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan);\n+        return outstandingPageCount == null || outstandingPageCount.get() == 0;\n+    }\n+\n+    @Override\n+    public void onPagesReleased(Lifespan lifespan, int releasedPageCount, long releasedSizeInBytes)\n+    {\n+        long outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan).addAndGet(-releasedPageCount);\n+        if (outstandingPageCount == 0 && noMorePagesForLifespan.contains(lifespan)) {\n+            Consumer<Lifespan> lifespanCompletionCallback = this.lifespanCompletionCallback;\n+            checkState(lifespanCompletionCallback != null, \"lifespanCompletionCallback is not null\");\n+            lifespanCompletionCallback.accept(lifespan);\n+        }\n+        memoryManager.updateMemoryUsage(-releasedSizeInBytes);\n+        if (childListener != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3NjAyNQ==", "bodyText": "That's correct. Since trino doesn't perform that sanity check there wasn't a need to add the same sub-listener logic. I'm not sure you'd want to add another atomic counter to the other buffers as they all have a more straightforward way of counting currently buffered pages (eg: bufferedPages.size())", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552976025", "createdAt": "2021-01-06T21:44:45Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);\n+        if (counter == null) {\n+            counter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong());\n+        }\n+        counter.addAndGet(pagesAdded);\n+    }\n+\n+    public void setNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        requireNonNull(lifespan, \"lifespan is null\");\n+        noMorePagesForLifespan.add(lifespan);\n+    }\n+\n+    public boolean isNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        return noMorePagesForLifespan.contains(lifespan);\n+    }\n+\n+    public boolean isFinishedForLifespan(Lifespan lifespan)\n+    {\n+        if (!noMorePagesForLifespan.contains(lifespan)) {\n+            return false;\n+        }\n+\n+        AtomicLong outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan);\n+        return outstandingPageCount == null || outstandingPageCount.get() == 0;\n+    }\n+\n+    @Override\n+    public void onPagesReleased(Lifespan lifespan, int releasedPageCount, long releasedSizeInBytes)\n+    {\n+        long outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan).addAndGet(-releasedPageCount);\n+        if (outstandingPageCount == 0 && noMorePagesForLifespan.contains(lifespan)) {\n+            Consumer<Lifespan> lifespanCompletionCallback = this.lifespanCompletionCallback;\n+            checkState(lifespanCompletionCallback != null, \"lifespanCompletionCallback is not null\");\n+            lifespanCompletionCallback.accept(lifespan);\n+        }\n+        memoryManager.updateMemoryUsage(-releasedSizeInBytes);\n+        if (childListener != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MzY2NQ=="}, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDI1NTIwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/BroadcastOutputBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToxNToxMFrOIPWRtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTo1MjowMlrOIPXJwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NDUzMw==", "bodyText": "this check looks quite universal -- wondering why it cannot be used for other buffer as well?", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552964533", "createdAt": "2021-01-06T21:15:10Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/BroadcastOutputBuffer.java", "diffHunk": "@@ -90,6 +87,9 @@ public BroadcastOutputBuffer(\n                 requireNonNull(maxBufferSize, \"maxBufferSize is null\").toBytes(),\n                 requireNonNull(systemMemoryContextSupplier, \"systemMemoryContextSupplier is null\"),\n                 requireNonNull(notificationExecutor, \"notificationExecutor is null\"));\n+        this.pageTracker = new LifespanSerializedPageTracker(memoryManager, Optional.of((lifespan, releasedPageCount, releasedSizeInBytes) -> {\n+            checkState(totalBufferedPages.addAndGet(-releasedPageCount) >= 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3ODg4MQ==", "bodyText": "See above comments, but I'm not sure the extra cost of tracking the count makes sense there since the number of buffered pages is more easily reasoned about through other means except for the broadcast buffer.", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552978881", "createdAt": "2021-01-06T21:52:02Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/BroadcastOutputBuffer.java", "diffHunk": "@@ -90,6 +87,9 @@ public BroadcastOutputBuffer(\n                 requireNonNull(maxBufferSize, \"maxBufferSize is null\").toBytes(),\n                 requireNonNull(systemMemoryContextSupplier, \"systemMemoryContextSupplier is null\"),\n                 requireNonNull(notificationExecutor, \"notificationExecutor is null\"));\n+        this.pageTracker = new LifespanSerializedPageTracker(memoryManager, Optional.of((lifespan, releasedPageCount, releasedSizeInBytes) -> {\n+            checkState(totalBufferedPages.addAndGet(-releasedPageCount) >= 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NDUzMw=="}, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDI3MTIwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToyMToxOFrOIPWbCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxODoxODowOFrOIP3BHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA==", "bodyText": "isn't computeIfAbsent will return the counter in the map if exist? -- so we don't need this extra get and can directly do\ncounter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong())", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552966920", "createdAt": "2021-01-06T21:21:18Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3MTA1MA==", "bodyText": "In JDK8 ConcurrentHashMap#computeIfAbsent unconditionally acquires a write lock even when the value is present (and even so, would unconditionally create lambda in any JDK version). Later JDK's address that, but since prestodb still supports JDK8 I chose to go this route.", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552971050", "createdAt": "2021-01-06T21:31:53Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA=="}, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5NTMzNg==", "bodyText": "@pettyjamesm : I see; that's good to learn :) . In that case perhaps add a comment explain why not directly using computeIfAbsent pattern?. Also since line 67 is not the common path, shall we just use putIfAbsent on line 67 instead?", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r553095336", "createdAt": "2021-01-07T03:55:44Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA=="}, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0MzM2NA==", "bodyText": "putIfAbsent unfortunately returns the previous value which makes it more awkward to use in this context than computeIfAbsent. I've added a comment about the common case avoiding a lambda creation but omitted the minutia about ConcurrentHashMap locking behaviors in JDK 8 since people won't care about that once it's no longer supported.", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r553343364", "createdAt": "2021-01-07T13:59:30Z", "author": {"login": "pettyjamesm"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA=="}, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMDk1OQ==", "bodyText": "@pettyjamesm : The major motivation of the comment is so maintainers of the code can refactor the code later by reading the comment, what about some comment like following:\n//  In JDK8 ConcurrentHashMap#computeIfAbsent unconditionally acquires a write lock even when the value is present\n// TODO: Remove this get ConcurrentHashMap#get call once Presto no longer supports JDK-8", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r553500959", "createdAt": "2021-01-07T18:18:08Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA=="}, "originalCommit": {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3429, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}