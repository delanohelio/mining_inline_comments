{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5ODMyODMw", "number": 14845, "title": "Support evaluating min/max only metadata query", "bodyText": "== RELEASE NOTES ==\n\nGeneral Changes\n* Add support to optimize min/max only metadata query. This is controlled by existing config ``optimizer.optimize-metadata-queries`` and session property ``optimize_metadata_queries``. Note that enabling this config/session property might change query result if there are metadata that refers to empty data, e.g. empty hive partition.\n\nNote that enabling existing config optimizer.optimize-metadata-queries and session property optimize_metadata_queries might change query result if there are metadata that refers to empty data, e.g. empty hive partition. For example, if we have two Hive ds partitions, one is 2020-07-01 and the other is 2020-08-01. Let's assume 2020-08-01 is an empty partition. Then when computing without metadata optimizer, the ds rows come from data, and since 2020-08-01 does not have any data, it won't be appearing in the result (e.g. DISTINCT ds would only return 2020-07-01). However, if metadata optimizer is enabled, then ds rows come from metastore, and DISTINCT ds would return both rows.", "createdAt": "2020-07-16T01:27:23Z", "url": "https://github.com/prestodb/presto/pull/14845", "merged": true, "mergeCommit": {"oid": "ef4b5378011084e2eb20b7307aa866431091e582"}, "closed": true, "closedAt": "2020-07-27T22:32:55Z", "author": {"login": "shixuan-fan"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1Ycg0ABqjM1NTE0MzQ4OTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5INEkgFqTQ1NjEyNjYwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a971fd72c59cf1fec5672c12b4c91f36d9a929a8", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/a971fd72c59cf1fec5672c12b4c91f36d9a929a8", "committedDate": "2020-07-16T01:22:03Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "2493b37a92cd40f3b696c1d9827785562235f958", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/2493b37a92cd40f3b696c1d9827785562235f958", "committedDate": "2020-07-16T05:32:46Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2493b37a92cd40f3b696c1d9827785562235f958", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/2493b37a92cd40f3b696c1d9827785562235f958", "committedDate": "2020-07-16T05:32:46Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "0656169ffe79a4441e0dba3112745d0d2b7a1f1a", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/0656169ffe79a4441e0dba3112745d0d2b7a1f1a", "committedDate": "2020-07-16T18:07:26Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0656169ffe79a4441e0dba3112745d0d2b7a1f1a", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/0656169ffe79a4441e0dba3112745d0d2b7a1f1a", "committedDate": "2020-07-16T18:07:26Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "abeffefc0147352aeba3d00881d6ea5734c739a9", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/abeffefc0147352aeba3d00881d6ea5734c739a9", "committedDate": "2020-07-18T17:15:52Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "abeffefc0147352aeba3d00881d6ea5734c739a9", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/abeffefc0147352aeba3d00881d6ea5734c739a9", "committedDate": "2020-07-18T17:15:52Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "d5a5fe94b49dd6324a3ab6fb2951cef4ab5f4f80", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/d5a5fe94b49dd6324a3ab6fb2951cef4ab5f4f80", "committedDate": "2020-07-22T17:12:59Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d5a5fe94b49dd6324a3ab6fb2951cef4ab5f4f80", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/d5a5fe94b49dd6324a3ab6fb2951cef4ab5f4f80", "committedDate": "2020-07-22T17:12:59Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "3756a124d7458297be7ea623c0bb057efaa99e5b", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/3756a124d7458297be7ea623c0bb057efaa99e5b", "committedDate": "2020-07-23T00:19:37Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3756a124d7458297be7ea623c0bb057efaa99e5b", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/3756a124d7458297be7ea623c0bb057efaa99e5b", "committedDate": "2020-07-23T00:19:37Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "6d81914bc64fd689380223cf788cdb27e0aae19e", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/6d81914bc64fd689380223cf788cdb27e0aae19e", "committedDate": "2020-07-23T00:30:42Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d81914bc64fd689380223cf788cdb27e0aae19e", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/6d81914bc64fd689380223cf788cdb27e0aae19e", "committedDate": "2020-07-23T00:30:42Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "bfca28aa15a51d2441bd2140834481c354c58ea5", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/bfca28aa15a51d2441bd2140834481c354c58ea5", "committedDate": "2020-07-23T01:12:03Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7030b174b59c2f5afd40fc5b9f91492b4573cd4", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/a7030b174b59c2f5afd40fc5b9f91492b4573cd4", "committedDate": "2020-07-23T17:40:29Z", "message": "Push expression translation above MetadataQueryOptimizer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04fcf53e29f2bac8fac5bf39285fbf204156d48c", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/04fcf53e29f2bac8fac5bf39285fbf204156d48c", "committedDate": "2020-07-23T17:40:29Z", "message": "Allow EnforceSingleRowNode for predicate extractor\n\nAssuming we have a daily ingested table that is partitioned on ds,\na filter like `ds = (SELECT '2020-07-01')` is converted into an\nINNER JOIN, but this value is not passed to the other side of Join,\nwhich leads to full table scan.\n\nThis commit will enable this value being treated as predicate, and\nthus we only need to read this one partition."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bfca28aa15a51d2441bd2140834481c354c58ea5", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/bfca28aa15a51d2441bd2140834481c354c58ea5", "committedDate": "2020-07-23T01:12:03Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/be7331a304d6abc02e2b83b91684e359562cbd4f", "committedDate": "2020-07-23T18:21:58Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1OTcxNTE1", "url": "https://github.com/prestodb/presto/pull/14845#pullrequestreview-455971515", "createdAt": "2020-07-27T17:04:20Z", "commit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1OTcyNTE0", "url": "https://github.com/prestodb/presto/pull/14845#pullrequestreview-455972514", "createdAt": "2020-07-27T17:05:45Z", "commit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1OTc4MjE3", "url": "https://github.com/prestodb/presto/pull/14845#pullrequestreview-455978217", "createdAt": "2020-07-27T17:13:40Z", "commit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzoxMzo0MFrOG3r1-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzozOToyNlrOG3sxWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0MzE5NA==", "bodyText": "Breakdown the params into multiple lines\n        queryRunner.execute(\n                shufflePartitionColumns,\n                \"CREATE TABLE test_metadata_aggregation_folding WITH (partitioned_by = ARRAY['ds']) AS \" +\n                        \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 7, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461043194", "createdAt": "2020-07-27T17:13:40Z", "author": {"login": "highker"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -277,6 +280,83 @@ public void testPartitionPruning()\n         }\n     }\n \n+    @Test\n+    public void testMetadataAggregationFolding()\n+    {\n+        QueryRunner queryRunner = getQueryRunner();\n+        Session optimizeMetadataQueries = Session.builder(this.getQueryRunner().getDefaultSession())\n+                .setSystemProperty(OPTIMIZE_METADATA_QUERIES, Boolean.toString(true))\n+                .build();\n+        Session shufflePartitionColumns = Session.builder(this.getQueryRunner().getDefaultSession())\n+                .setCatalogSessionProperty(HIVE_CATALOG, SHUFFLE_PARTITIONED_COLUMNS_FOR_TABLE_WRITE, Boolean.toString(true))\n+                .build();\n+\n+        queryRunner.execute(shufflePartitionColumns, \"CREATE TABLE test_metadata_aggregation_folding WITH (partitioned_by = ARRAY['ds']) AS \" +\n+                \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 7, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");\n+        queryRunner.execute(shufflePartitionColumns, \"CREATE TABLE test_metadata_aggregation_folding_more_partitions WITH (partitioned_by = ARRAY['ds']) AS \" +\n+                \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 200, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");\n+        queryRunner.execute(shufflePartitionColumns, \"CREATE TABLE test_metadata_aggregation_folding_null_partitions WITH (partitioned_by = ARRAY['ds']) AS \" +\n+                \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 7, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");\n+        queryRunner.execute(shufflePartitionColumns, \"INSERT INTO test_metadata_aggregation_folding_null_partitions SELECT 0 as orderkey, null AS ds\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0ODU5Nw==", "bodyText": "Maybe add a helper function when isReducible(node) is true and put the new logic there? This function is already pretty big.", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461048597", "createdAt": "2020-07-27T17:22:42Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0OTgxNA==", "bodyText": "if (domain.isNone()) {\n    continue;\n}", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461049814", "createdAt": "2020-07-27T17:24:44Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1MzY3Ng==", "bodyText": "evaluateMinMax", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461053676", "createdAt": "2020-07-27T17:30:59Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1NzAzNw==", "bodyText": "Use the util in Expressions to build CallExpression", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461057037", "createdAt": "2020-07-27T17:36:53Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)\n+        {\n+            QualifiedFunctionName scalarFunctionName = AGGREGATION_SCALAR_MAPPING.get(aggregationFunctionMetadata.getName());\n+            Type returnType = metadata.getTypeManager().getType(aggregationFunctionMetadata.getReturnType());\n+            while (arguments.size() > 1) {\n+                List<RowExpression> reducedArguments = new ArrayList<>();\n+                // We fold for every 100 values because GREATEST/LEAST has argument count limit\n+                for (List<RowExpression> partitionedArguments : Lists.partition(arguments, 100)) {\n+                    List<TypeSignatureProvider> typeSignatureProviders = partitionedArguments.stream()\n+                            .map(RowExpression::getType)\n+                            .map(Type::getTypeSignature)\n+                            .map(TypeSignatureProvider::new)\n+                            .collect(toImmutableList());\n+                    Object reducedValue = evaluateConstantRowExpression(\n+                            new CallExpression(\n+                                    scalarFunctionName.getFunctionName(),\n+                                    metadata.getFunctionManager().resolveFunction(Optional.empty(), scalarFunctionName, typeSignatureProviders),\n+                                    returnType,\n+                                    partitionedArguments),\n+                            metadata,\n+                            session.toConnectorSession());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1ODM5Mg==", "bodyText": "When will the result be null?", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461058392", "createdAt": "2020-07-27T17:39:26Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)\n+        {\n+            QualifiedFunctionName scalarFunctionName = AGGREGATION_SCALAR_MAPPING.get(aggregationFunctionMetadata.getName());\n+            Type returnType = metadata.getTypeManager().getType(aggregationFunctionMetadata.getReturnType());\n+            while (arguments.size() > 1) {\n+                List<RowExpression> reducedArguments = new ArrayList<>();\n+                // We fold for every 100 values because GREATEST/LEAST has argument count limit\n+                for (List<RowExpression> partitionedArguments : Lists.partition(arguments, 100)) {\n+                    List<TypeSignatureProvider> typeSignatureProviders = partitionedArguments.stream()\n+                            .map(RowExpression::getType)\n+                            .map(Type::getTypeSignature)\n+                            .map(TypeSignatureProvider::new)\n+                            .collect(toImmutableList());\n+                    Object reducedValue = evaluateConstantRowExpression(\n+                            new CallExpression(\n+                                    scalarFunctionName.getFunctionName(),\n+                                    metadata.getFunctionManager().resolveFunction(Optional.empty(), scalarFunctionName, typeSignatureProviders),\n+                                    returnType,\n+                                    partitionedArguments),\n+                            metadata,\n+                            session.toConnectorSession());\n+                    reducedArguments.add(constant(reducedValue, returnType));\n+                }\n+                arguments = reducedArguments;\n+            }\n+            if (arguments.isEmpty()) {\n+                return constant(null, returnType);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 182}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3435c2bfdaebd0e3870be4bd40fe79ad0a591707", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/3435c2bfdaebd0e3870be4bd40fe79ad0a591707", "committedDate": "2020-07-27T20:13:01Z", "message": "Remove unused field in MetadataQueryOptimizer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/be7331a304d6abc02e2b83b91684e359562cbd4f", "committedDate": "2020-07-23T18:21:58Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "fe7b487c62014ab9cd4424eb44aeaee6853c8a86", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/fe7b487c62014ab9cd4424eb44aeaee6853c8a86", "committedDate": "2020-07-27T20:44:52Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6df5fdb6b3ccd0edbd21e2de6952085c3b0af07", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/d6df5fdb6b3ccd0edbd21e2de6952085c3b0af07", "committedDate": "2020-07-27T20:49:00Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe7b487c62014ab9cd4424eb44aeaee6853c8a86", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/fe7b487c62014ab9cd4424eb44aeaee6853c8a86", "committedDate": "2020-07-27T20:44:52Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}, "afterCommit": {"oid": "d6df5fdb6b3ccd0edbd21e2de6952085c3b0af07", "author": {"user": {"login": "shixuan-fan", "name": "Shixuan Fan"}}, "url": "https://github.com/prestodb/presto/commit/d6df5fdb6b3ccd0edbd21e2de6952085c3b0af07", "committedDate": "2020-07-27T20:49:00Z", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MTI2NjA0", "url": "https://github.com/prestodb/presto/pull/14845#pullrequestreview-456126604", "createdAt": "2020-07-27T20:53:17Z", "commit": {"oid": "d6df5fdb6b3ccd0edbd21e2de6952085c3b0af07"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1275, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}