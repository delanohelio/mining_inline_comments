{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDE2NDk2", "number": 14303, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQwMDoxMzoyOFrODsQspQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNTowNzozOVrOD2vCkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NzM3NTA5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/CommonSubExpressionRewriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQwMDoxMzoyOFrOF9FFlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDoyODozOFrOGNr50Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU5MDgwNA==", "bodyText": "spelling", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r399590804", "createdAt": "2020-03-28T00:13:28Z", "author": {"login": "kaikalur"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/CommonSubExpressionRewriter.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.gen;\n+\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.InputReferenceExpression;\n+import com.facebook.presto.spi.relation.LambdaDefinitionExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionVisitor;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.PlanVariableAllocator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+public class CommonSubExpressionRewriter\n+{\n+    public static Map<Integer, Map<RowExpression, VariableReferenceExpression>> rewriteWithCSEByLevel(List<RowExpression> expressions)\n+    {\n+        if (expressions.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+\n+        CommonSubExpressionCollector expressionCollector = new CommonSubExpressionCollector();\n+        expressions.forEach(expression -> expression.accept(expressionCollector, null));\n+        Map<Integer, Set<RowExpression>> cseByLevel = expressionCollector.cseByLevel;\n+        if (cseByLevel.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+\n+        PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n+        ImmutableMap.Builder<Integer, Map<RowExpression, VariableReferenceExpression>> commonSubExpressions = ImmutableMap.builder();\n+        Map<RowExpression, VariableReferenceExpression> rewriteWith = new HashMap<>();\n+        int startCSELevel = cseByLevel.keySet().stream().reduce(Math::min).get();\n+        int maxCSELevel = cseByLevel.keySet().stream().reduce(Math::max).get();\n+        for (int i = startCSELevel; i <= maxCSELevel; i++) {\n+            if (cseByLevel.containsKey(i)) {\n+                ExpressionRewritter rewritter = new ExpressionRewritter(rewriteWith);\n+                ImmutableMap.Builder<RowExpression, VariableReferenceExpression> expressionVariableMapBuilder = ImmutableMap.builder();\n+                for (RowExpression expression : cseByLevel.get(i)) {\n+                    RowExpression rewritten = expression.accept(rewritter, null);\n+                    expressionVariableMapBuilder.put(rewritten, variableAllocator.newVariable(rewritten));\n+                }\n+                Map<RowExpression, VariableReferenceExpression> expressionVariableMap = expressionVariableMapBuilder.build();\n+                commonSubExpressions.put(i, expressionVariableMap);\n+                rewriteWith.putAll(expressionVariableMap);\n+            }\n+        }\n+        return commonSubExpressions.build();\n+    }\n+\n+    public static Map<Integer, Map<RowExpression, VariableReferenceExpression>> rewriteWithCSEByLevel(RowExpression expression)\n+    {\n+        return rewriteWithCSEByLevel(ImmutableList.of(expression));\n+    }\n+\n+    public static RowExpression rewriteExpressionWithCSE(RowExpression expression, Map<RowExpression, VariableReferenceExpression> rewriteWith)\n+    {\n+        ExpressionRewritter rewritter = new ExpressionRewritter(rewriteWith);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fbce588bc0f1da060b361d1fb2be97c8ee9dcf4"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwMzk4NQ==", "bodyText": "\"Rewriter\"? InteliJ said rewriter is also wrong \ud83d\ude02", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r417003985", "createdAt": "2020-04-29T00:28:38Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/CommonSubExpressionRewriter.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.gen;\n+\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.InputReferenceExpression;\n+import com.facebook.presto.spi.relation.LambdaDefinitionExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionVisitor;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.PlanVariableAllocator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+\n+public class CommonSubExpressionRewriter\n+{\n+    public static Map<Integer, Map<RowExpression, VariableReferenceExpression>> rewriteWithCSEByLevel(List<RowExpression> expressions)\n+    {\n+        if (expressions.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+\n+        CommonSubExpressionCollector expressionCollector = new CommonSubExpressionCollector();\n+        expressions.forEach(expression -> expression.accept(expressionCollector, null));\n+        Map<Integer, Set<RowExpression>> cseByLevel = expressionCollector.cseByLevel;\n+        if (cseByLevel.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+\n+        PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n+        ImmutableMap.Builder<Integer, Map<RowExpression, VariableReferenceExpression>> commonSubExpressions = ImmutableMap.builder();\n+        Map<RowExpression, VariableReferenceExpression> rewriteWith = new HashMap<>();\n+        int startCSELevel = cseByLevel.keySet().stream().reduce(Math::min).get();\n+        int maxCSELevel = cseByLevel.keySet().stream().reduce(Math::max).get();\n+        for (int i = startCSELevel; i <= maxCSELevel; i++) {\n+            if (cseByLevel.containsKey(i)) {\n+                ExpressionRewritter rewritter = new ExpressionRewritter(rewriteWith);\n+                ImmutableMap.Builder<RowExpression, VariableReferenceExpression> expressionVariableMapBuilder = ImmutableMap.builder();\n+                for (RowExpression expression : cseByLevel.get(i)) {\n+                    RowExpression rewritten = expression.accept(rewritter, null);\n+                    expressionVariableMapBuilder.put(rewritten, variableAllocator.newVariable(rewritten));\n+                }\n+                Map<RowExpression, VariableReferenceExpression> expressionVariableMap = expressionVariableMapBuilder.build();\n+                commonSubExpressions.put(i, expressionVariableMap);\n+                rewriteWith.putAll(expressionVariableMap);\n+            }\n+        }\n+        return commonSubExpressions.build();\n+    }\n+\n+    public static Map<Integer, Map<RowExpression, VariableReferenceExpression>> rewriteWithCSEByLevel(RowExpression expression)\n+    {\n+        return rewriteWithCSEByLevel(ImmutableList.of(expression));\n+    }\n+\n+    public static RowExpression rewriteExpressionWithCSE(RowExpression expression, Map<RowExpression, VariableReferenceExpression> rewriteWith)\n+    {\n+        ExpressionRewritter rewritter = new ExpressionRewritter(rewriteWith);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU5MDgwNA=="}, "originalCommit": {"oid": "7fbce588bc0f1da060b361d1fb2be97c8ee9dcf4"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODIzOTE3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/SystemSessionProperties.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTozNTozMlrOF-pG3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTozNTozMlrOF-pG3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyOTUzMw==", "bodyText": "plural - expressions - will be good", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r401229533", "createdAt": "2020-03-31T21:35:32Z", "author": {"login": "kaikalur"}, "path": "presto-main/src/main/java/com/facebook/presto/SystemSessionProperties.java", "diffHunk": "@@ -149,6 +149,7 @@\n     public static final String PARTITIONING_PRECISION_STRATEGY = \"partitioning_precision_strategy\";\n     public static final String EXPERIMENTAL_FUNCTIONS_ENABLED = \"experimental_functions_enabled\";\n     public static final String USE_LEGACY_SCHEDULER = \"use_legacy_scheduler\";\n+    public static final String OPTIMIZE_COMMON_SUB_EXPRESSION = \"optimize_common_sub_expression\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ff097ced412410a277176e43d11591d665ed64c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTIxMzI3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/SystemSessionProperties.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNToxODozOVrOF_Fqkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoxNjo1N1rOGOLOGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY5NzQyNw==", "bodyText": "subexpression (no underscore)\nSo\noptimize_common_subexpressions", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r401697427", "createdAt": "2020-04-01T15:18:39Z", "author": {"login": "kaikalur"}, "path": "presto-main/src/main/java/com/facebook/presto/SystemSessionProperties.java", "diffHunk": "@@ -149,6 +149,7 @@\n     public static final String PARTITIONING_PRECISION_STRATEGY = \"partitioning_precision_strategy\";\n     public static final String EXPERIMENTAL_FUNCTIONS_ENABLED = \"experimental_functions_enabled\";\n     public static final String USE_LEGACY_SCHEDULER = \"use_legacy_scheduler\";\n+    public static final String OPTIMIZE_COMMON_SUB_EXPRESSION = \"optimize_common_sub_expression\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ff097ced412410a277176e43d11591d665ed64c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxNzA4Mg==", "bodyText": "Changed to optimize_common_sub_expressions (added the \"s\" but kept the \"_\"). I don't quite like the look of isOptimizeCommonSubexprssions vs isOptimizeCommonSubExprssions\ud83d\ude02", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r417517082", "createdAt": "2020-04-29T18:16:57Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/SystemSessionProperties.java", "diffHunk": "@@ -149,6 +149,7 @@\n     public static final String PARTITIONING_PRECISION_STRATEGY = \"partitioning_precision_strategy\";\n     public static final String EXPERIMENTAL_FUNCTIONS_ENABLED = \"experimental_functions_enabled\";\n     public static final String USE_LEGACY_SCHEDULER = \"use_legacy_scheduler\";\n+    public static final String OPTIMIZE_COMMON_SUB_EXPRESSION = \"optimize_common_sub_expression\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY5NzQyNw=="}, "originalCommit": {"oid": "7ff097ced412410a277176e43d11591d665ed64c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTc5MjE5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOToyOToyNVrOGGIbtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOToyOToyNVrOGGIbtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MjgwNA==", "bodyText": "int channel", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r409082804", "createdAt": "2020-04-15T19:29:25Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java", "diffHunk": "@@ -283,32 +295,39 @@ private ProcessBatchResult processBatch(int batchSize)\n                 }\n \n                 // if possible, use previouslyComputedResults produced in prior optimistic failure attempt\n-                PageProjection projection = projections.get(i);\n-                if (previouslyComputedResults[i] != null && previouslyComputedResults[i].getPositionCount() >= batchSize) {\n-                    blocks[i] = previouslyComputedResults[i].getRegion(0, batchSize);\n+                int[] outputChannels = projection.getOutputChannels();\n+                // The progress on all output channels of a projection should be the same, so we just use the first one.\n+                if (previouslyComputedResults[outputChannels[0]] != null && previouslyComputedResults[outputChannels[0]].getPositionCount() >= batchSize) {\n+                    for (Integer channel : outputChannels) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "837fa3721c77492d94d1fbbe7f2c80212edd3bc2"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NDYxOTUyOnYy", "diffSide": "RIGHT", "path": "presto-bytecode/src/main/java/com/facebook/presto/bytecode/control/SwitchStatement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjoyMjo1OFrOGJlVeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMDoyODozNFrOGKRWVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMjA3Mw==", "bodyText": "hmmmm under what circumstances will we skip the end label?", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r412702073", "createdAt": "2020-04-22T06:22:58Z", "author": {"login": "highker"}, "path": "presto-bytecode/src/main/java/com/facebook/presto/bytecode/control/SwitchStatement.java", "diffHunk": "@@ -41,23 +41,31 @@ public static SwitchBuilder switchBuilder()\n         return new SwitchBuilder();\n     }\n \n+    public static SwitchBuilder switchBuilder(boolean skipEndLabel)\n+    {\n+        return new SwitchBuilder(skipEndLabel);\n+    }\n+\n     private final LabelNode endLabel = new LabelNode(\"switchEnd\");\n     private final LabelNode defaultLabel = new LabelNode(\"switchDefault\");\n     private final String comment;\n     private final BytecodeExpression expression;\n     private final SortedSet<CaseStatement> cases;\n     private final BytecodeNode defaultBody;\n+    private final boolean skipEndLabel;\n \n     private SwitchStatement(\n             String comment,\n             BytecodeExpression expression,\n             Iterable<CaseStatement> cases,\n-            BytecodeNode defaultBody)\n+            BytecodeNode defaultBody,\n+            boolean skipEndLabel)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "956d82c8b6d2b0f3224dd2c8a9fc0f54caa5eadc"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQyMzE4OQ==", "bodyText": "Was using switch statement to generate goto label at the end of cse evaluation. Because each case is a GOTO there's no need for another GOTO. @kaikalur was complaining about the generated bytecode looks strange so I added this. Anyways this change is removed as I'm abandoning the switch + GOTO approach and opted for cse evaluation functions instead.", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r413423189", "createdAt": "2020-04-23T00:28:34Z", "author": {"login": "rongrong"}, "path": "presto-bytecode/src/main/java/com/facebook/presto/bytecode/control/SwitchStatement.java", "diffHunk": "@@ -41,23 +41,31 @@ public static SwitchBuilder switchBuilder()\n         return new SwitchBuilder();\n     }\n \n+    public static SwitchBuilder switchBuilder(boolean skipEndLabel)\n+    {\n+        return new SwitchBuilder(skipEndLabel);\n+    }\n+\n     private final LabelNode endLabel = new LabelNode(\"switchEnd\");\n     private final LabelNode defaultLabel = new LabelNode(\"switchDefault\");\n     private final String comment;\n     private final BytecodeExpression expression;\n     private final SortedSet<CaseStatement> cases;\n     private final BytecodeNode defaultBody;\n+    private final boolean skipEndLabel;\n \n     private SwitchStatement(\n             String comment,\n             BytecodeExpression expression,\n             Iterable<CaseStatement> cases,\n-            BytecodeNode defaultBody)\n+            BytecodeNode defaultBody,\n+            boolean skipEndLabel)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMjA3Mw=="}, "originalCommit": {"oid": "956d82c8b6d2b0f3224dd2c8a9fc0f54caa5eadc"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MzU2NjYwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxOTo1MTo0NVrOGMJM1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDo0OToyMVrOGNsRhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NjgzNg==", "bodyText": "type(List.class, BlockBuilder.class) I guess? IIRC, without parametric, the code will be List<Object>\ncausing casting overhead. Same for many other places", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r415386836", "createdAt": "2020-04-26T19:51:45Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -242,31 +249,33 @@ private ClassDefinition definePageProjectWorkClass(SqlFunctionProperties sqlFunc\n         CachedInstanceBinder cachedInstanceBinder = new CachedInstanceBinder(classDefinition, callSiteBinder);\n \n         // process\n-        generateProcessMethod(classDefinition, blockBuilderField, propertiesField, pageField, selectedPositionsField, nextIndexOrPositionField, resultField);\n+        generateProcessMethod(classDefinition, blockBuilderFields, projections.size(), propertiesField, pageField, selectedPositionsField, nextIndexOrPositionField, resultField);\n \n         // getResult\n         MethodDefinition method = classDefinition.declareMethod(a(PUBLIC), \"getResult\", type(Object.class), ImmutableList.of());\n         method.getBody().append(method.getThis().getField(resultField)).ret(Object.class);\n \n         // evaluate\n-        Map<LambdaDefinitionExpression, CompiledLambda> compiledLambdaMap = generateMethodsForLambda(classDefinition, callSiteBinder, cachedInstanceBinder, projection, metadata, sqlFunctionProperties);\n-        generateEvaluateMethod(sqlFunctionProperties, classDefinition, callSiteBinder, cachedInstanceBinder, compiledLambdaMap, projection, blockBuilderField);\n+        Map<LambdaDefinitionExpression, CompiledLambda> compiledLambdaMap = generateMethodsForLambda(classDefinition, callSiteBinder, cachedInstanceBinder, projections, metadata, sqlFunctionProperties, \"\");\n+        generateEvaluateMethod(sqlFunctionProperties, classDefinition, callSiteBinder, cachedInstanceBinder, compiledLambdaMap, projections, blockBuilderFields);\n \n         // constructor\n-        Parameter blockBuilder = arg(\"blockBuilder\", BlockBuilder.class);\n+        Parameter blockBuilders = arg(\"blockBuilders\", List.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790306ff807826122fd01f631f9b86667886d04e"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAxMDA1NQ==", "bodyText": "Hmm, turns out Java being Java I still have to keep the cast.\njava.lang.NoSuchMethodError: java.util.List.get(I)Lcom/facebook/presto/spi/block/BlockBuilder;\n\nlacking real generics \ud83e\udd37\u200d\u2640\ufe0f", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r417010055", "createdAt": "2020-04-29T00:49:21Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -242,31 +249,33 @@ private ClassDefinition definePageProjectWorkClass(SqlFunctionProperties sqlFunc\n         CachedInstanceBinder cachedInstanceBinder = new CachedInstanceBinder(classDefinition, callSiteBinder);\n \n         // process\n-        generateProcessMethod(classDefinition, blockBuilderField, propertiesField, pageField, selectedPositionsField, nextIndexOrPositionField, resultField);\n+        generateProcessMethod(classDefinition, blockBuilderFields, projections.size(), propertiesField, pageField, selectedPositionsField, nextIndexOrPositionField, resultField);\n \n         // getResult\n         MethodDefinition method = classDefinition.declareMethod(a(PUBLIC), \"getResult\", type(Object.class), ImmutableList.of());\n         method.getBody().append(method.getThis().getField(resultField)).ret(Object.class);\n \n         // evaluate\n-        Map<LambdaDefinitionExpression, CompiledLambda> compiledLambdaMap = generateMethodsForLambda(classDefinition, callSiteBinder, cachedInstanceBinder, projection, metadata, sqlFunctionProperties);\n-        generateEvaluateMethod(sqlFunctionProperties, classDefinition, callSiteBinder, cachedInstanceBinder, compiledLambdaMap, projection, blockBuilderField);\n+        Map<LambdaDefinitionExpression, CompiledLambda> compiledLambdaMap = generateMethodsForLambda(classDefinition, callSiteBinder, cachedInstanceBinder, projections, metadata, sqlFunctionProperties, \"\");\n+        generateEvaluateMethod(sqlFunctionProperties, classDefinition, callSiteBinder, cachedInstanceBinder, compiledLambdaMap, projections, blockBuilderFields);\n \n         // constructor\n-        Parameter blockBuilder = arg(\"blockBuilder\", BlockBuilder.class);\n+        Parameter blockBuilders = arg(\"blockBuilders\", List.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NjgzNg=="}, "originalCommit": {"oid": "790306ff807826122fd01f631f9b86667886d04e"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MzU3MjA5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxOTo1NToyN1rOGMJPWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDoyMjowNlrOGNrxpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NzQ4Mg==", "bodyText": "hmmmm.... why .get(0) here?", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r415387482", "createdAt": "2020-04-26T19:55:27Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -135,7 +140,7 @@ public PageFunctionCompiler(Metadata metadata, int expressionCacheSize)\n             filterCache = CacheBuilder.newBuilder()\n                     .recordStats()\n                     .maximumSize(expressionCacheSize)\n-                    .build(CacheLoader.from(cacheKey -> compileFilterInternal(cacheKey.sqlFunctionProperties, cacheKey.rowExpression, Optional.empty())));\n+                    .build(CacheLoader.from(cacheKey -> compileFilterInternal(cacheKey.sqlFunctionProperties, cacheKey.rowExpressions.get(0), Optional.empty())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790306ff807826122fd01f631f9b86667886d04e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwMTg5NA==", "bodyText": "CacheKey takes List<RowExpression> now and for filter there's one and only one expression.", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r417001894", "createdAt": "2020-04-29T00:22:06Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -135,7 +140,7 @@ public PageFunctionCompiler(Metadata metadata, int expressionCacheSize)\n             filterCache = CacheBuilder.newBuilder()\n                     .recordStats()\n                     .maximumSize(expressionCacheSize)\n-                    .build(CacheLoader.from(cacheKey -> compileFilterInternal(cacheKey.sqlFunctionProperties, cacheKey.rowExpression, Optional.empty())));\n+                    .build(CacheLoader.from(cacheKey -> compileFilterInternal(cacheKey.sqlFunctionProperties, cacheKey.rowExpressions.get(0), Optional.empty())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NzQ4Mg=="}, "originalCommit": {"oid": "790306ff807826122fd01f631f9b86667886d04e"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MzU3NjAyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxOTo1NzozMlrOGMJRHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDoyMzo0NlrOGNrzsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NzkzMg==", "bodyText": "What happens to other types of RowExpressions?", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r415387932", "createdAt": "2020-04-26T19:57:32Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -197,12 +187,29 @@ public CacheStatsMBean getFilterCache()\n             return () -> projectionFunction;\n         }\n \n-        PageFieldsToInputParametersRewriter.Result result = rewritePageFieldsToInputParameters(projection);\n+        if (projectionCache == null) {\n+            return compileProjectionInternal(sqlFunctionProperties, ImmutableList.of(projection), classNameSuffix);\n+        }\n+        return projectionCache.getUnchecked(new CacheKey(sqlFunctionProperties, ImmutableList.of(projection)));\n+    }\n+\n+    private Supplier<PageProjectionWithOutputs> toPageProjectionWithOutputs(Supplier<PageProjection> pageProjection, int[] outputChannels)\n+    {\n+        return () -> new PageProjectionWithOutputs(pageProjection.get(), outputChannels);\n+    }\n+\n+    private Supplier<PageProjection> compileProjectionInternal(SqlFunctionProperties sqlFunctionProperties, List<RowExpression> projections, Optional<String> classNameSuffix)\n+    {\n+        requireNonNull(projections, \"projections is null\");\n+        checkArgument(projections.stream().allMatch(projection -> projection instanceof CallExpression || projection instanceof SpecialFormExpression));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790306ff807826122fd01f631f9b86667886d04e"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwMjQxOA==", "bodyText": "InputReferenceExpression and ConstantExpression are moved to compileProjection. I don't think they need to be cached.", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r417002418", "createdAt": "2020-04-29T00:23:46Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -197,12 +187,29 @@ public CacheStatsMBean getFilterCache()\n             return () -> projectionFunction;\n         }\n \n-        PageFieldsToInputParametersRewriter.Result result = rewritePageFieldsToInputParameters(projection);\n+        if (projectionCache == null) {\n+            return compileProjectionInternal(sqlFunctionProperties, ImmutableList.of(projection), classNameSuffix);\n+        }\n+        return projectionCache.getUnchecked(new CacheKey(sqlFunctionProperties, ImmutableList.of(projection)));\n+    }\n+\n+    private Supplier<PageProjectionWithOutputs> toPageProjectionWithOutputs(Supplier<PageProjection> pageProjection, int[] outputChannels)\n+    {\n+        return () -> new PageProjectionWithOutputs(pageProjection.get(), outputChannels);\n+    }\n+\n+    private Supplier<PageProjection> compileProjectionInternal(SqlFunctionProperties sqlFunctionProperties, List<RowExpression> projections, Optional<String> classNameSuffix)\n+    {\n+        requireNonNull(projections, \"projections is null\");\n+        checkArgument(projections.stream().allMatch(projection -> projection instanceof CallExpression || projection instanceof SpecialFormExpression));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4NzkzMg=="}, "originalCommit": {"oid": "790306ff807826122fd01f631f9b86667886d04e"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MzU3ODY5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQxOTo1OTowOVrOGMJSSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwMDoyNjozN1rOGNr3Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4ODIzNQ==", "bodyText": "I guess we don't have to do a copy if the list is immutable?", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r415388235", "createdAt": "2020-04-26T19:59:09Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -242,31 +249,33 @@ private ClassDefinition definePageProjectWorkClass(SqlFunctionProperties sqlFunc\n         CachedInstanceBinder cachedInstanceBinder = new CachedInstanceBinder(classDefinition, callSiteBinder);\n \n         // process\n-        generateProcessMethod(classDefinition, blockBuilderField, propertiesField, pageField, selectedPositionsField, nextIndexOrPositionField, resultField);\n+        generateProcessMethod(classDefinition, blockBuilderFields, projections.size(), propertiesField, pageField, selectedPositionsField, nextIndexOrPositionField, resultField);\n \n         // getResult\n         MethodDefinition method = classDefinition.declareMethod(a(PUBLIC), \"getResult\", type(Object.class), ImmutableList.of());\n         method.getBody().append(method.getThis().getField(resultField)).ret(Object.class);\n \n         // evaluate\n-        Map<LambdaDefinitionExpression, CompiledLambda> compiledLambdaMap = generateMethodsForLambda(classDefinition, callSiteBinder, cachedInstanceBinder, projection, metadata, sqlFunctionProperties);\n-        generateEvaluateMethod(sqlFunctionProperties, classDefinition, callSiteBinder, cachedInstanceBinder, compiledLambdaMap, projection, blockBuilderField);\n+        Map<LambdaDefinitionExpression, CompiledLambda> compiledLambdaMap = generateMethodsForLambda(classDefinition, callSiteBinder, cachedInstanceBinder, projections, metadata, sqlFunctionProperties, \"\");\n+        generateEvaluateMethod(sqlFunctionProperties, classDefinition, callSiteBinder, cachedInstanceBinder, compiledLambdaMap, projections, blockBuilderFields);\n \n         // constructor\n-        Parameter blockBuilder = arg(\"blockBuilder\", BlockBuilder.class);\n+        Parameter blockBuilders = arg(\"blockBuilders\", List.class);\n         Parameter properties = arg(\"properties\", SqlFunctionProperties.class);\n         Parameter page = arg(\"page\", Page.class);\n         Parameter selectedPositions = arg(\"selectedPositions\", SelectedPositions.class);\n \n-        MethodDefinition constructorDefinition = classDefinition.declareConstructor(a(PUBLIC), blockBuilder, properties, page, selectedPositions);\n+        MethodDefinition constructorDefinition = classDefinition.declareConstructor(a(PUBLIC), blockBuilders, properties, page, selectedPositions);\n \n         BytecodeBlock body = constructorDefinition.getBody();\n         Variable thisVariable = constructorDefinition.getThis();\n \n         body.comment(\"super();\")\n                 .append(thisVariable)\n                 .invokeConstructor(Object.class)\n-                .append(thisVariable.setField(blockBuilderField, blockBuilder))\n+                .append(thisVariable)\n+                .append(invokeStatic(ImmutableList.class, \"copyOf\", ImmutableList.class, blockBuilders.cast(Collection.class)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "790306ff807826122fd01f631f9b86667886d04e"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwMzMyNw==", "bodyText": "Can't tell whether it's immutable list from the interface. But I think it's safe to do. Should I just do this.blockbuilders = blockBuilders?", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r417003327", "createdAt": "2020-04-29T00:26:37Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -242,31 +249,33 @@ private ClassDefinition definePageProjectWorkClass(SqlFunctionProperties sqlFunc\n         CachedInstanceBinder cachedInstanceBinder = new CachedInstanceBinder(classDefinition, callSiteBinder);\n \n         // process\n-        generateProcessMethod(classDefinition, blockBuilderField, propertiesField, pageField, selectedPositionsField, nextIndexOrPositionField, resultField);\n+        generateProcessMethod(classDefinition, blockBuilderFields, projections.size(), propertiesField, pageField, selectedPositionsField, nextIndexOrPositionField, resultField);\n \n         // getResult\n         MethodDefinition method = classDefinition.declareMethod(a(PUBLIC), \"getResult\", type(Object.class), ImmutableList.of());\n         method.getBody().append(method.getThis().getField(resultField)).ret(Object.class);\n \n         // evaluate\n-        Map<LambdaDefinitionExpression, CompiledLambda> compiledLambdaMap = generateMethodsForLambda(classDefinition, callSiteBinder, cachedInstanceBinder, projection, metadata, sqlFunctionProperties);\n-        generateEvaluateMethod(sqlFunctionProperties, classDefinition, callSiteBinder, cachedInstanceBinder, compiledLambdaMap, projection, blockBuilderField);\n+        Map<LambdaDefinitionExpression, CompiledLambda> compiledLambdaMap = generateMethodsForLambda(classDefinition, callSiteBinder, cachedInstanceBinder, projections, metadata, sqlFunctionProperties, \"\");\n+        generateEvaluateMethod(sqlFunctionProperties, classDefinition, callSiteBinder, cachedInstanceBinder, compiledLambdaMap, projections, blockBuilderFields);\n \n         // constructor\n-        Parameter blockBuilder = arg(\"blockBuilder\", BlockBuilder.class);\n+        Parameter blockBuilders = arg(\"blockBuilders\", List.class);\n         Parameter properties = arg(\"properties\", SqlFunctionProperties.class);\n         Parameter page = arg(\"page\", Page.class);\n         Parameter selectedPositions = arg(\"selectedPositions\", SelectedPositions.class);\n \n-        MethodDefinition constructorDefinition = classDefinition.declareConstructor(a(PUBLIC), blockBuilder, properties, page, selectedPositions);\n+        MethodDefinition constructorDefinition = classDefinition.declareConstructor(a(PUBLIC), blockBuilders, properties, page, selectedPositions);\n \n         BytecodeBlock body = constructorDefinition.getBody();\n         Variable thisVariable = constructorDefinition.getThis();\n \n         body.comment(\"super();\")\n                 .append(thisVariable)\n                 .invokeConstructor(Object.class)\n-                .append(thisVariable.setField(blockBuilderField, blockBuilder))\n+                .append(thisVariable)\n+                .append(invokeStatic(ImmutableList.class, \"copyOf\", ImmutableList.class, blockBuilders.cast(Collection.class)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM4ODIzNQ=="}, "originalCommit": {"oid": "790306ff807826122fd01f631f9b86667886d04e"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzA1MjE0OnYy", "diffSide": "RIGHT", "path": "presto-benchmark/src/main/java/com/facebook/presto/benchmark/HandTpchQuery6.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDo0MToxOVrOGMmycg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDo0MToxOVrOGMmycg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg3MTYwMg==", "bodyText": "Please breakup complex expression for readability or one arg per line", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r415871602", "createdAt": "2020-04-27T14:41:19Z", "author": {"login": "kaikalur"}, "path": "presto-benchmark/src/main/java/com/facebook/presto/benchmark/HandTpchQuery6.java", "diffHunk": "@@ -71,12 +72,12 @@ public HandTpchQuery6(LocalQueryRunner localQueryRunner)\n         //    and quantity < 24;\n         OperatorFactory tableScanOperator = createTableScanOperator(0, new PlanNodeId(\"test\"), \"lineitem\", \"extendedprice\", \"discount\", \"shipdate\", \"quantity\");\n \n-        Supplier<PageProjection> projection = new PageFunctionCompiler(localQueryRunner.getMetadata(), 0).compileProjection(session.getSqlFunctionProperties(), field(0, BIGINT), Optional.empty());\n+        List<Supplier<PageProjectionWithOutputs>> projection = new PageFunctionCompiler(localQueryRunner.getMetadata(), 0).compileProjections(session.getSqlFunctionProperties(), ImmutableList.of(field(0, BIGINT)), false, Optional.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57269af89e11a5fed1657b1e462dea66ecbf913b"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzA4NjM0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/CommonSubExpressionRewriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDo0NzoxMlrOGMnGow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDo0NzoxMlrOGMnGow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg3Njc3MQ==", "bodyText": "Spelling", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r415876771", "createdAt": "2020-04-27T14:47:12Z", "author": {"login": "kaikalur"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/CommonSubExpressionRewriter.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.gen;\n+\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.InputReferenceExpression;\n+import com.facebook.presto.spi.relation.LambdaDefinitionExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionVisitor;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.PlanVariableAllocator;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.WHEN;\n+import static com.facebook.presto.sql.relational.Expressions.subExpressions;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static java.util.function.Function.identity;\n+\n+public class CommonSubExpressionRewriter\n+{\n+    private CommonSubExpressionRewriter() {}\n+\n+    public static Map<Integer, Map<RowExpression, VariableReferenceExpression>> collectCSEByLevel(List<? extends RowExpression> expressions)\n+    {\n+        if (expressions.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+\n+        CommonSubExpressionCollector expressionCollector = new CommonSubExpressionCollector();\n+        expressions.forEach(expression -> expression.accept(expressionCollector, null));\n+        if (expressionCollector.cseByLevel.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+\n+        Map<Integer, Map<RowExpression, Integer>> cseByLevel = removeRedundantCSE(expressionCollector.cseByLevel, expressionCollector.expressionCount);\n+\n+        PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n+        ImmutableMap.Builder<Integer, Map<RowExpression, VariableReferenceExpression>> commonSubExpressions = ImmutableMap.builder();\n+        Map<RowExpression, VariableReferenceExpression> rewriteWith = new HashMap<>();\n+        int startCSELevel = cseByLevel.keySet().stream().reduce(Math::min).get();\n+        int maxCSELevel = cseByLevel.keySet().stream().reduce(Math::max).get();\n+        for (int i = startCSELevel; i <= maxCSELevel; i++) {\n+            if (cseByLevel.containsKey(i)) {\n+                ExpressionRewritter rewritter = new ExpressionRewritter(rewriteWith);\n+                ImmutableMap.Builder<RowExpression, VariableReferenceExpression> expressionVariableMapBuilder = ImmutableMap.builder();\n+                for (Map.Entry<RowExpression, Integer> entry : cseByLevel.get(i).entrySet()) {\n+                    RowExpression rewrittenExpression = entry.getKey().accept(rewritter, null);\n+                    expressionVariableMapBuilder.put(rewrittenExpression, variableAllocator.newVariable(rewrittenExpression, \"cse\"));\n+                }\n+                Map<RowExpression, VariableReferenceExpression> expressionVariableMap = expressionVariableMapBuilder.build();\n+                commonSubExpressions.put(i, expressionVariableMap);\n+                rewriteWith.putAll(expressionVariableMap.entrySet().stream().collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue())));\n+            }\n+        }\n+        return commonSubExpressions.build();\n+    }\n+\n+    public static Map<Integer, Map<RowExpression, VariableReferenceExpression>> collectCSEByLevel(RowExpression expression)\n+    {\n+        return collectCSEByLevel(ImmutableList.of(expression));\n+    }\n+\n+    public static List<RowExpression> getExpressionsWithCSE(List<? extends RowExpression> expressions)\n+    {\n+        if (expressions.isEmpty()) {\n+            return ImmutableList.of();\n+        }\n+        CommonSubExpressionCollector expressionCollector = new CommonSubExpressionCollector();\n+        expressions.forEach(expression -> expression.accept(expressionCollector, null));\n+        Set<RowExpression> cse = expressionCollector.cseByLevel.values().stream().flatMap(Set::stream).collect(toImmutableSet());\n+        SubExpressionChecker subExpressionChecker = new SubExpressionChecker(cse);\n+        return expressions.stream().filter(expression -> expression.accept(subExpressionChecker, null)).collect(toImmutableList());\n+    }\n+\n+    public static RowExpression rewriteExpressionWithCSE(RowExpression expression, Map<RowExpression, VariableReferenceExpression> rewriteWith)\n+    {\n+        ExpressionRewritter rewritter = new ExpressionRewritter(rewriteWith);\n+        return expression.accept(rewritter, null);\n+    }\n+\n+    private static Map<Integer, Map<RowExpression, Integer>> removeRedundantCSE(Map<Integer, Set<RowExpression>> cseByLevel, Map<RowExpression, Integer> expressionCount)\n+    {\n+        Map<Integer, Map<RowExpression, Integer>> results = new HashMap<>();\n+        int startCSELevel = cseByLevel.keySet().stream().reduce(Math::max).get();\n+        int stopCSELevel = cseByLevel.keySet().stream().reduce(Math::min).get();\n+        for (int i = startCSELevel; i > stopCSELevel; i--) {\n+            Map<RowExpression, Integer> expressions = cseByLevel.get(i).stream().filter(expression -> expressionCount.get(expression) > 0).collect(toImmutableMap(identity(), expressionCount::get));\n+            if (!expressions.isEmpty()) {\n+                results.put(i, expressions);\n+            }\n+            for (RowExpression expression : expressions.keySet()) {\n+                int expressionOccurrence = expressionCount.get(expression);\n+                subExpressions(expression).stream()\n+                        .filter(subExpression -> !subExpression.equals(expression))\n+                        .forEach(subExpression -> {\n+                            if (expressionCount.containsKey(subExpression)) {\n+                                expressionCount.put(subExpression, expressionCount.get(subExpression) - expressionOccurrence);\n+                            }\n+                        });\n+            }\n+        }\n+        Map<RowExpression, Integer> expressions = cseByLevel.get(stopCSELevel).stream().filter(expression -> expressionCount.get(expression) > 0).collect(toImmutableMap(identity(), expression -> expressionCount.get(expression) + 1));\n+        if (!expressions.isEmpty()) {\n+            results.put(stopCSELevel, expressions);\n+        }\n+        return results;\n+    }\n+\n+    static class SubExpressionChecker\n+            implements RowExpressionVisitor<Boolean, Void>\n+    {\n+        private final Set<RowExpression> subExpressions;\n+\n+        SubExpressionChecker(Set<RowExpression> subExpressions)\n+        {\n+            this.subExpressions = subExpressions;\n+        }\n+\n+        @Override\n+        public Boolean visitCall(CallExpression call, Void context)\n+        {\n+            if (subExpressions.contains(call)) {\n+                return true;\n+            }\n+            if (call.getArguments().isEmpty()) {\n+                return false;\n+            }\n+            return call.getArguments().stream().anyMatch(expression -> expression.accept(this, null));\n+        }\n+\n+        @Override\n+        public Boolean visitInputReference(InputReferenceExpression reference, Void context)\n+        {\n+            return subExpressions.contains(reference);\n+        }\n+\n+        @Override\n+        public Boolean visitConstant(ConstantExpression literal, Void context)\n+        {\n+            return subExpressions.contains(literal);\n+        }\n+\n+        @Override\n+        public Boolean visitLambda(LambdaDefinitionExpression lambda, Void context)\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitVariableReference(VariableReferenceExpression reference, Void context)\n+        {\n+            return subExpressions.contains(reference);\n+        }\n+\n+        @Override\n+        public Boolean visitSpecialForm(SpecialFormExpression specialForm, Void context)\n+        {\n+            if (subExpressions.contains(specialForm)) {\n+                return true;\n+            }\n+            if (specialForm.getArguments().isEmpty()) {\n+                return false;\n+            }\n+            return specialForm.getArguments().stream().anyMatch(expression -> expression.accept(this, null));\n+        }\n+    }\n+\n+    static class ExpressionRewritter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57269af89e11a5fed1657b1e462dea66ecbf913b"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzE5ODM2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNTowNjozM1rOGMoJHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNTowNjozM1rOGMoJHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5Mzc5MQ==", "bodyText": "To maintain symmetry and clean logic, keep this check in the method itself.", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r415893791", "createdAt": "2020-04-27T15:06:33Z", "author": {"login": "kaikalur"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -597,15 +777,96 @@ private static void declareBlockVariables(RowExpression expression, Parameter pa\n                 callSiteBinder);\n     }\n \n+    private static class CommonSubExpressionFields\n+    {\n+        private final FieldDefinition evaluatedField;\n+        private final FieldDefinition resultField;\n+        private final Class<?> resultType;\n+        private final String methodName;\n+\n+        public CommonSubExpressionFields(FieldDefinition evaluatedField, FieldDefinition resultField, Class<?> resultType, String methodName)\n+        {\n+            this.evaluatedField = evaluatedField;\n+            this.resultField = resultField;\n+            this.resultType = resultType;\n+            this.methodName = methodName;\n+        }\n+    }\n+\n+    private static class CSEFieldAndVariableReferenceCompiler\n+            implements RowExpressionVisitor<BytecodeNode, Scope>\n+    {\n+        private final InputReferenceCompiler inputReferenceCompiler;\n+        private final Map<VariableReferenceExpression, CommonSubExpressionFields> variableMap;\n+        private final Variable thisVariable;\n+\n+        public CSEFieldAndVariableReferenceCompiler(CallSiteBinder callSiteBinder, Map<VariableReferenceExpression, CommonSubExpressionFields> variableMap, Variable thisVariable)\n+        {\n+            this.inputReferenceCompiler = new InputReferenceCompiler(\n+                    (scope, field) -> scope.getVariable(\"block_\" + field),\n+                    (scope, field) -> scope.getVariable(\"position\"),\n+                    callSiteBinder);\n+            this.variableMap = ImmutableMap.copyOf(variableMap);\n+            this.thisVariable = thisVariable;\n+        }\n+        @Override\n+        public BytecodeNode visitCall(CallExpression call, Scope context)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public BytecodeNode visitInputReference(InputReferenceExpression reference, Scope context)\n+        {\n+            return inputReferenceCompiler.visitInputReference(reference, context);\n+        }\n+\n+        @Override\n+        public BytecodeNode visitConstant(ConstantExpression literal, Scope context)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public BytecodeNode visitLambda(LambdaDefinitionExpression lambda, Scope context)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public BytecodeNode visitVariableReference(VariableReferenceExpression reference, Scope context)\n+        {\n+            CommonSubExpressionFields fields = variableMap.get(reference);\n+            IfStatement ifStatement = new IfStatement()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57269af89e11a5fed1657b1e462dea66ecbf913b"}, "originalPosition": 570}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzIwNDAyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNTowNzozOVrOGMoMig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNTowNzozOVrOGMoMig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5NDY2Ng==", "bodyText": "Can we guarantee this is invokespecial?", "url": "https://github.com/prestodb/presto/pull/14303#discussion_r415894666", "createdAt": "2020-04-27T15:07:39Z", "author": {"login": "kaikalur"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/gen/PageFunctionCompiler.java", "diffHunk": "@@ -597,15 +777,96 @@ private static void declareBlockVariables(RowExpression expression, Parameter pa\n                 callSiteBinder);\n     }\n \n+    private static class CommonSubExpressionFields\n+    {\n+        private final FieldDefinition evaluatedField;\n+        private final FieldDefinition resultField;\n+        private final Class<?> resultType;\n+        private final String methodName;\n+\n+        public CommonSubExpressionFields(FieldDefinition evaluatedField, FieldDefinition resultField, Class<?> resultType, String methodName)\n+        {\n+            this.evaluatedField = evaluatedField;\n+            this.resultField = resultField;\n+            this.resultType = resultType;\n+            this.methodName = methodName;\n+        }\n+    }\n+\n+    private static class CSEFieldAndVariableReferenceCompiler\n+            implements RowExpressionVisitor<BytecodeNode, Scope>\n+    {\n+        private final InputReferenceCompiler inputReferenceCompiler;\n+        private final Map<VariableReferenceExpression, CommonSubExpressionFields> variableMap;\n+        private final Variable thisVariable;\n+\n+        public CSEFieldAndVariableReferenceCompiler(CallSiteBinder callSiteBinder, Map<VariableReferenceExpression, CommonSubExpressionFields> variableMap, Variable thisVariable)\n+        {\n+            this.inputReferenceCompiler = new InputReferenceCompiler(\n+                    (scope, field) -> scope.getVariable(\"block_\" + field),\n+                    (scope, field) -> scope.getVariable(\"position\"),\n+                    callSiteBinder);\n+            this.variableMap = ImmutableMap.copyOf(variableMap);\n+            this.thisVariable = thisVariable;\n+        }\n+        @Override\n+        public BytecodeNode visitCall(CallExpression call, Scope context)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public BytecodeNode visitInputReference(InputReferenceExpression reference, Scope context)\n+        {\n+            return inputReferenceCompiler.visitInputReference(reference, context);\n+        }\n+\n+        @Override\n+        public BytecodeNode visitConstant(ConstantExpression literal, Scope context)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public BytecodeNode visitLambda(LambdaDefinitionExpression lambda, Scope context)\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public BytecodeNode visitVariableReference(VariableReferenceExpression reference, Scope context)\n+        {\n+            CommonSubExpressionFields fields = variableMap.get(reference);\n+            IfStatement ifStatement = new IfStatement()\n+                    .condition(thisVariable.getField(fields.evaluatedField))\n+                    .ifFalse(new BytecodeBlock()\n+                            .append(thisVariable.invoke(fields.methodName, void.class, context.getVariable(\"properties\"), context.getVariable(\"page\"), context.getVariable(\"position\"))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57269af89e11a5fed1657b1e462dea66ecbf913b"}, "originalPosition": 573}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2952, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}