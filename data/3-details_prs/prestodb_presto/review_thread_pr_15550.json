{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzNjY2NDc5", "number": 15550, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMjoyODowM1rOFH_8cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMjozMzo0OFrOFIAAWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTMyMDE3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMjoyODowM1rOIJsKRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QwMDozMjo0OVrOIaw2Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMTYyMg==", "bodyText": "Looking at visitFilter, do we need to handle DynamicFilterPlaceholderFunction in this case?", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r547031622", "createdAt": "2020-12-22T02:28:03Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java", "diffHunk": "@@ -53,11 +52,15 @@\n     private final PlanNodeIdAllocator planNodeidAllocator = new PlanNodeIdAllocator();\n     private final PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n \n-    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, PartitioningScheme partitioningScheme)\n+    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, List<VariableReferenceExpression> outputLayout)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb062fbbabd87a7437deea5e9c88d6fb0d341937"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQyOTQ1Mw==", "bodyText": "Good catch. I'm not aware of this. I'll put up a different PR for this. I guess the first step is to return Optional.empty() when dynamic filter is enabled :)", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r547429453", "createdAt": "2020-12-22T18:17:19Z", "author": {"login": "shixuan-fan"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java", "diffHunk": "@@ -53,11 +52,15 @@\n     private final PlanNodeIdAllocator planNodeidAllocator = new PlanNodeIdAllocator();\n     private final PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n \n-    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, PartitioningScheme partitioningScheme)\n+    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, List<VariableReferenceExpression> outputLayout)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMTYyMg=="}, "originalCommit": {"oid": "cb062fbbabd87a7437deea5e9c88d6fb0d341937"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDkzNDIzNA==", "bodyText": "@highker: I checked how dynamic filter is created in LocalExecutionPlanner, and it seems that it is only used in visitSemiJoin and visitJoin as part of lookup. Current we don't support FRC in those places, so there should not be DynamicFilterPlaceholderFunction in the first place.\nHandling DynamicFilterPlaceholderFunction in RowExpression is not easy as that means we would need a specific visitor to detect it. On the other hand, I think a better approach is that whenever we detect dynamic filters as we are creating drivers, we put empty FRC context in DriverContext.", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r564934234", "createdAt": "2021-01-27T00:32:49Z", "author": {"login": "shixuan-fan"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java", "diffHunk": "@@ -53,11 +52,15 @@\n     private final PlanNodeIdAllocator planNodeidAllocator = new PlanNodeIdAllocator();\n     private final PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n \n-    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, PartitioningScheme partitioningScheme)\n+    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, List<VariableReferenceExpression> outputLayout)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMTYyMg=="}, "originalCommit": {"oid": "cb062fbbabd87a7437deea5e9c88d6fb0d341937"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTMzMDE5OnYy", "diffSide": "LEFT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMjozMzo0OFrOIJsP-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxODoyNjoxOVrOIKE0cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMzA4Mg==", "bodyText": "Could you reminds me a bit on why we need partitioning scheme at the very first place? For outputLayout, would that be the same as canonicalPlan.get().getOutputVariables()?", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r547033082", "createdAt": "2020-12-22T02:33:48Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java", "diffHunk": "@@ -53,11 +52,15 @@\n     private final PlanNodeIdAllocator planNodeidAllocator = new PlanNodeIdAllocator();\n     private final PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n \n-    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, PartitioningScheme partitioningScheme)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb062fbbabd87a7437deea5e9c88d6fb0d341937"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQzNTYzNQ==", "bodyText": "We use partitioning scheme because if there is a mismatch between expected output layout and the output of the root node, we will add a layout enforce operation (e.g. \n  \n    \n      presto/presto-main/src/main/java/com/facebook/presto/sql/planner/LocalExecutionPlanner.java\n    \n    \n         Line 551\n      in\n      ab243b6\n    \n    \n    \n    \n\n        \n          \n           Function<Page, Page> pagePreprocessor = enforceLayoutProcessor(outputLayout, physicalOperation.getLayout()); \n        \n    \n  \n\n). If we don't take this into consideration, then there might be channel mismatch which would lead to correctness issue or query failure.\nThis outputLayout is not the same as canonicalPlan.get().getOutputVariables(), but rather the expected layout of the driver. At the beginning we are being conservative to ensure it is correct so we make sure everything in partitioning scheme is compared.\nIn fact, changing to outputLayout is not required for this PR, I could revert these changes and revisit this once we plan to support build side of join. What do you think?", "url": "https://github.com/prestodb/presto/pull/15550#discussion_r547435635", "createdAt": "2020-12-22T18:26:19Z", "author": {"login": "shixuan-fan"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPlanGenerator.java", "diffHunk": "@@ -53,11 +52,15 @@\n     private final PlanNodeIdAllocator planNodeidAllocator = new PlanNodeIdAllocator();\n     private final PlanVariableAllocator variableAllocator = new PlanVariableAllocator();\n \n-    public static Optional<CanonicalPlanFragment> generateCanonicalPlan(PlanNode root, PartitioningScheme partitioningScheme)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMzA4Mg=="}, "originalCommit": {"oid": "cb062fbbabd87a7437deea5e9c88d6fb0d341937"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3309, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}