{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5ODMyODMw", "number": 14845, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzoxMzo0MFrOESexKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzozOToyNlrOESfWxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODEzOTMxOnYy", "diffSide": "RIGHT", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzoxMzo0MFrOG3r1-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzoxMzo0MFrOG3r1-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0MzE5NA==", "bodyText": "Breakdown the params into multiple lines\n        queryRunner.execute(\n                shufflePartitionColumns,\n                \"CREATE TABLE test_metadata_aggregation_folding WITH (partitioned_by = ARRAY['ds']) AS \" +\n                        \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 7, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461043194", "createdAt": "2020-07-27T17:13:40Z", "author": {"login": "highker"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -277,6 +280,83 @@ public void testPartitionPruning()\n         }\n     }\n \n+    @Test\n+    public void testMetadataAggregationFolding()\n+    {\n+        QueryRunner queryRunner = getQueryRunner();\n+        Session optimizeMetadataQueries = Session.builder(this.getQueryRunner().getDefaultSession())\n+                .setSystemProperty(OPTIMIZE_METADATA_QUERIES, Boolean.toString(true))\n+                .build();\n+        Session shufflePartitionColumns = Session.builder(this.getQueryRunner().getDefaultSession())\n+                .setCatalogSessionProperty(HIVE_CATALOG, SHUFFLE_PARTITIONED_COLUMNS_FOR_TABLE_WRITE, Boolean.toString(true))\n+                .build();\n+\n+        queryRunner.execute(shufflePartitionColumns, \"CREATE TABLE test_metadata_aggregation_folding WITH (partitioned_by = ARRAY['ds']) AS \" +\n+                \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 7, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");\n+        queryRunner.execute(shufflePartitionColumns, \"CREATE TABLE test_metadata_aggregation_folding_more_partitions WITH (partitioned_by = ARRAY['ds']) AS \" +\n+                \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 200, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");\n+        queryRunner.execute(shufflePartitionColumns, \"CREATE TABLE test_metadata_aggregation_folding_null_partitions WITH (partitioned_by = ARRAY['ds']) AS \" +\n+                \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 7, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");\n+        queryRunner.execute(shufflePartitionColumns, \"INSERT INTO test_metadata_aggregation_folding_null_partitions SELECT 0 as orderkey, null AS ds\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODE3MzI2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzoyMjo0MlrOG3sLFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMDoyOTo1NFrOG3yZ8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0ODU5Nw==", "bodyText": "Maybe add a helper function when isReducible(node) is true and put the new logic there? This function is already pretty big.", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461048597", "createdAt": "2020-07-27T17:22:42Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1MDcwNA==", "bodyText": "I extracted the newly added code into reduce (after changing reduce to evaluateMinMax). Also flipped the if statement so it looks like early return pattern.", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461150704", "createdAt": "2020-07-27T20:29:54Z", "author": {"login": "shixuan-fan"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0ODU5Nw=="}, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODE4MTA5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzoyNDo0NFrOG3sP1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMDozMTo0NlrOG3yeJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0OTgxNA==", "bodyText": "if (domain.isNone()) {\n    continue;\n}", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461049814", "createdAt": "2020-07-27T17:24:44Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1MTc4MQ==", "bodyText": "This is following the existing code, but I agree with the proposed change. Also changed the original code as well.", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461151781", "createdAt": "2020-07-27T20:31:46Z", "author": {"login": "shixuan-fan"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0OTgxNA=="}, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODIwNjA3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzozMDo1OVrOG3se7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzozMDo1OVrOG3se7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1MzY3Ng==", "bodyText": "evaluateMinMax", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461053676", "createdAt": "2020-07-27T17:30:59Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODIyNjkyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzozNjo1M1rOG3ssDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMDozODoyOVrOG3yrtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1NzAzNw==", "bodyText": "Use the util in Expressions to build CallExpression", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461057037", "createdAt": "2020-07-27T17:36:53Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)\n+        {\n+            QualifiedFunctionName scalarFunctionName = AGGREGATION_SCALAR_MAPPING.get(aggregationFunctionMetadata.getName());\n+            Type returnType = metadata.getTypeManager().getType(aggregationFunctionMetadata.getReturnType());\n+            while (arguments.size() > 1) {\n+                List<RowExpression> reducedArguments = new ArrayList<>();\n+                // We fold for every 100 values because GREATEST/LEAST has argument count limit\n+                for (List<RowExpression> partitionedArguments : Lists.partition(arguments, 100)) {\n+                    List<TypeSignatureProvider> typeSignatureProviders = partitionedArguments.stream()\n+                            .map(RowExpression::getType)\n+                            .map(Type::getTypeSignature)\n+                            .map(TypeSignatureProvider::new)\n+                            .collect(toImmutableList());\n+                    Object reducedValue = evaluateConstantRowExpression(\n+                            new CallExpression(\n+                                    scalarFunctionName.getFunctionName(),\n+                                    metadata.getFunctionManager().resolveFunction(Optional.empty(), scalarFunctionName, typeSignatureProviders),\n+                                    returnType,\n+                                    partitionedArguments),\n+                            metadata,\n+                            session.toConnectorSession());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1NTI1Mg==", "bodyText": "Not aware of this. Looks so much better.", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461155252", "createdAt": "2020-07-27T20:38:29Z", "author": {"login": "shixuan-fan"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)\n+        {\n+            QualifiedFunctionName scalarFunctionName = AGGREGATION_SCALAR_MAPPING.get(aggregationFunctionMetadata.getName());\n+            Type returnType = metadata.getTypeManager().getType(aggregationFunctionMetadata.getReturnType());\n+            while (arguments.size() > 1) {\n+                List<RowExpression> reducedArguments = new ArrayList<>();\n+                // We fold for every 100 values because GREATEST/LEAST has argument count limit\n+                for (List<RowExpression> partitionedArguments : Lists.partition(arguments, 100)) {\n+                    List<TypeSignatureProvider> typeSignatureProviders = partitionedArguments.stream()\n+                            .map(RowExpression::getType)\n+                            .map(Type::getTypeSignature)\n+                            .map(TypeSignatureProvider::new)\n+                            .collect(toImmutableList());\n+                    Object reducedValue = evaluateConstantRowExpression(\n+                            new CallExpression(\n+                                    scalarFunctionName.getFunctionName(),\n+                                    metadata.getFunctionManager().resolveFunction(Optional.empty(), scalarFunctionName, typeSignatureProviders),\n+                                    returnType,\n+                                    partitionedArguments),\n+                            metadata,\n+                            session.toConnectorSession());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1NzAzNw=="}, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3ODIzNTU2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNzozOToyNlrOG3sxWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMDo0ODoyN1rOG3zAYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1ODM5Mg==", "bodyText": "When will the result be null?", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461058392", "createdAt": "2020-07-27T17:39:26Z", "author": {"login": "highker"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)\n+        {\n+            QualifiedFunctionName scalarFunctionName = AGGREGATION_SCALAR_MAPPING.get(aggregationFunctionMetadata.getName());\n+            Type returnType = metadata.getTypeManager().getType(aggregationFunctionMetadata.getReturnType());\n+            while (arguments.size() > 1) {\n+                List<RowExpression> reducedArguments = new ArrayList<>();\n+                // We fold for every 100 values because GREATEST/LEAST has argument count limit\n+                for (List<RowExpression> partitionedArguments : Lists.partition(arguments, 100)) {\n+                    List<TypeSignatureProvider> typeSignatureProviders = partitionedArguments.stream()\n+                            .map(RowExpression::getType)\n+                            .map(Type::getTypeSignature)\n+                            .map(TypeSignatureProvider::new)\n+                            .collect(toImmutableList());\n+                    Object reducedValue = evaluateConstantRowExpression(\n+                            new CallExpression(\n+                                    scalarFunctionName.getFunctionName(),\n+                                    metadata.getFunctionManager().resolveFunction(Optional.empty(), scalarFunctionName, typeSignatureProviders),\n+                                    returnType,\n+                                    partitionedArguments),\n+                            metadata,\n+                            session.toConnectorSession());\n+                    reducedArguments.add(constant(reducedValue, returnType));\n+                }\n+                arguments = reducedArguments;\n+            }\n+            if (arguments.isEmpty()) {\n+                return constant(null, returnType);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1Njk1Ng==", "bodyText": "The result would be null if all values are null.", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461156956", "createdAt": "2020-07-27T20:41:38Z", "author": {"login": "shixuan-fan"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)\n+        {\n+            QualifiedFunctionName scalarFunctionName = AGGREGATION_SCALAR_MAPPING.get(aggregationFunctionMetadata.getName());\n+            Type returnType = metadata.getTypeManager().getType(aggregationFunctionMetadata.getReturnType());\n+            while (arguments.size() > 1) {\n+                List<RowExpression> reducedArguments = new ArrayList<>();\n+                // We fold for every 100 values because GREATEST/LEAST has argument count limit\n+                for (List<RowExpression> partitionedArguments : Lists.partition(arguments, 100)) {\n+                    List<TypeSignatureProvider> typeSignatureProviders = partitionedArguments.stream()\n+                            .map(RowExpression::getType)\n+                            .map(Type::getTypeSignature)\n+                            .map(TypeSignatureProvider::new)\n+                            .collect(toImmutableList());\n+                    Object reducedValue = evaluateConstantRowExpression(\n+                            new CallExpression(\n+                                    scalarFunctionName.getFunctionName(),\n+                                    metadata.getFunctionManager().resolveFunction(Optional.empty(), scalarFunctionName, typeSignatureProviders),\n+                                    returnType,\n+                                    partitionedArguments),\n+                            metadata,\n+                            session.toConnectorSession());\n+                    reducedArguments.add(constant(reducedValue, returnType));\n+                }\n+                arguments = reducedArguments;\n+            }\n+            if (arguments.isEmpty()) {\n+                return constant(null, returnType);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1ODM5Mg=="}, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE2MDU0Nw==", "bodyText": "That being said, I should probably move this to be the first step of this function.", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461160547", "createdAt": "2020-07-27T20:48:27Z", "author": {"login": "shixuan-fan"}, "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)\n+        {\n+            QualifiedFunctionName scalarFunctionName = AGGREGATION_SCALAR_MAPPING.get(aggregationFunctionMetadata.getName());\n+            Type returnType = metadata.getTypeManager().getType(aggregationFunctionMetadata.getReturnType());\n+            while (arguments.size() > 1) {\n+                List<RowExpression> reducedArguments = new ArrayList<>();\n+                // We fold for every 100 values because GREATEST/LEAST has argument count limit\n+                for (List<RowExpression> partitionedArguments : Lists.partition(arguments, 100)) {\n+                    List<TypeSignatureProvider> typeSignatureProviders = partitionedArguments.stream()\n+                            .map(RowExpression::getType)\n+                            .map(Type::getTypeSignature)\n+                            .map(TypeSignatureProvider::new)\n+                            .collect(toImmutableList());\n+                    Object reducedValue = evaluateConstantRowExpression(\n+                            new CallExpression(\n+                                    scalarFunctionName.getFunctionName(),\n+                                    metadata.getFunctionManager().resolveFunction(Optional.empty(), scalarFunctionName, typeSignatureProviders),\n+                                    returnType,\n+                                    partitionedArguments),\n+                            metadata,\n+                            session.toConnectorSession());\n+                    reducedArguments.add(constant(reducedValue, returnType));\n+                }\n+                arguments = reducedArguments;\n+            }\n+            if (arguments.isEmpty()) {\n+                return constant(null, returnType);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1ODM5Mg=="}, "originalCommit": {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f"}, "originalPosition": 182}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2372, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}