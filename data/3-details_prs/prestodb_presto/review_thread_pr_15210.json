{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMjA1MTYx", "number": 15210, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDoyNzowN1rOEmxRrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDoyNzowN1rOEmxRrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDg4Njg3OnYy", "diffSide": "RIGHT", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDoyNzowN1rOHW_tLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNjoxNDozNFrOHXid9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA==", "bodyText": "We can also make taskContext itself to refresh the peak memory usage periodically. What do you think? @arhimondr , @tdcmeehan ?", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r493874478", "createdAt": "2020-09-23T20:27:07Z", "author": {"login": "wenleix"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NzM2MQ==", "bodyText": "How does it work in Presto classic? How is it getting refreshed?", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r493877361", "createdAt": "2020-09-23T20:32:34Z", "author": {"login": "arhimondr"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA=="}, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4NDA0MQ==", "bodyText": "From what I can tell, there's many ways it could be updated, but primarily it's done by TaskInfoFetcher calling into the tasks, which will call:\nTaskResource#getTaskInfo -> SqlTaskManager#getTaskInfo -> SqlTask#getTaskInfo -> SqlTask#createTaskInfo -> SqlTask#getTaskStats -> TaskContext#getTaskStats\nThe default interval there is 1s, but it could be quicker if the TaskStatus changes state before then (e.g. finishes).  I'm guessing here, there is nothing polling the info/status, hence the need to schedule this update from within the task?\nAlso, would it be inaccurate if the status transitions before the memoryUpdateExecutor executes its next update?  For example upon failure.", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r493884041", "createdAt": "2020-09-23T20:45:03Z", "author": {"login": "tdcmeehan"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA=="}, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4ODkyNA==", "bodyText": "I think the idea before was the stats were refreshed whenever there is a heartbeat from coordinator to worker/task.  Is there such a heartbeat in PoS we can piggy back off of?", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r493888924", "createdAt": "2020-09-23T20:54:13Z", "author": {"login": "tdcmeehan"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA=="}, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg5MDc1NA==", "bodyText": "@arhimondr :\n\nHow does it work in Presto classic? How is it getting refreshed?\n\nThe peak memory stats in TaskContext only get updated when\nTaskContext::getTaskStats(). Presto-on-Spark doesn't pull task stats\nactively so it needs to be updated explicitly.", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r493890754", "createdAt": "2020-09-23T20:57:35Z", "author": {"login": "wenleix"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA=="}, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg5MTM4NQ==", "bodyText": "@tdcmeehan  :\n\nI'm guessing here, there is nothing polling the info/status, hence the need to schedule this update from within the task?\n\nExactly.", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r493891385", "createdAt": "2020-09-23T20:58:50Z", "author": {"login": "wenleix"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA=="}, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg5MjUwNQ==", "bodyText": "If that's the case, could we add a listener to taskStateMachine, and just update the stats when the state changes (as I presume nothing is looking at the stats in-between state transitions?)", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r493892505", "createdAt": "2020-09-23T21:01:00Z", "author": {"login": "tdcmeehan"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA=="}, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNTg5Nw==", "bodyText": "@tdcmeehan : But peak memory only goes up and down when state is RUNNING right?", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r493905897", "createdAt": "2020-09-23T21:28:34Z", "author": {"login": "wenleix"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA=="}, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1MzgwNg==", "bodyText": "It feels like it is reasonable to add an explicit updatePeakMemory method to the TaskContext and call it periodically. Given it is not needed for classic Presto i would keep the responsibility of periodically calling it on Presto on Spark code.", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r494353806", "createdAt": "2020-09-24T14:13:25Z", "author": {"login": "arhimondr"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA=="}, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ0NDAyMA==", "bodyText": "@arhimondr : Agreed. That's why i did it in this way.\nAlthough I think make TaskContext do periodically update peak memory is not a bad idea (today in Presto classic it relies on periodic \"pull\" to get updated)... but i will leave as future disucssion/work", "url": "https://github.com/prestodb/presto/pull/15210#discussion_r494444020", "createdAt": "2020-09-24T16:14:34Z", "author": {"login": "wenleix"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkTaskExecution.java", "diffHunk": "@@ -138,6 +141,9 @@ public PrestoSparkTaskExecution(\n                 \"Fragment is partitioned, but not all partitioned drivers were found\");\n \n         taskHandle = createTaskHandle(taskStateMachine, taskContext, localExecutionPlan, taskExecutor);\n+\n+        requireNonNull(memoryUpdateExecutor, \"memoryUpdateExecutorService is null\");\n+        memoryUpdateExecutor.schedule(taskContext::updatePeakMemory, 5, SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NDQ3OA=="}, "originalCommit": {"oid": "112306ba775cffefaa516e49e7487d5a490bde3d"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3707, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}