{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5OTgwODY4", "number": 15195, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMzozNToyMVrOEo21kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNToxMjoyMFrOEo3ycg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjc2OTQ0OnYy", "diffSide": "RIGHT", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/DdlVerification.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMzozNToyMVrOHaMI6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOTozNDoxOFrOHcVCdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMzkxNQ==", "bodyText": "Do we not want a failureResolveManager like DataVerification?", "url": "https://github.com/prestodb/presto/pull/15195#discussion_r497223915", "createdAt": "2020-09-30T03:35:21Z", "author": {"login": "sujay-jain"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/DdlVerification.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.verifier.framework;\n+\n+import com.facebook.presto.jdbc.QueryStats;\n+import com.facebook.presto.sql.parser.ParsingException;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.facebook.presto.verifier.event.DeterminismAnalysisDetails;\n+import com.facebook.presto.verifier.prestoaction.PrestoAction.ResultSetConverter;\n+import com.facebook.presto.verifier.prestoaction.QueryActions;\n+import com.facebook.presto.verifier.prestoaction.SqlExceptionClassifier;\n+\n+import java.util.Optional;\n+\n+import static com.facebook.presto.verifier.framework.DdlMatchResult.MatchType.CONTROL_NOT_PARSABLE;\n+import static com.facebook.presto.verifier.framework.DdlMatchResult.MatchType.MATCH;\n+import static com.facebook.presto.verifier.framework.DdlMatchResult.MatchType.MISMATCH;\n+import static com.facebook.presto.verifier.framework.DdlMatchResult.MatchType.TEST_NOT_PARSABLE;\n+import static com.facebook.presto.verifier.framework.QueryStage.CONTROL_CHECKSUM;\n+import static com.facebook.presto.verifier.framework.QueryStage.TEST_CHECKSUM;\n+import static com.facebook.presto.verifier.framework.VerifierUtil.PARSING_OPTIONS;\n+import static com.facebook.presto.verifier.framework.VerifierUtil.callAndConsume;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.util.Objects.requireNonNull;\n+\n+public abstract class DdlVerification<S extends Statement>\n+        extends AbstractVerification<QueryObjectBundle, DdlMatchResult, Void>\n+{\n+    private final SqlParser sqlParser;\n+    private final ResultSetConverter<String> checksumConverter;\n+\n+    public DdlVerification(\n+            SqlParser sqlParser,\n+            QueryActions queryActions,\n+            SourceQuery sourceQuery,\n+            SqlExceptionClassifier exceptionClassifier,\n+            VerificationContext verificationContext,\n+            VerifierConfig verifierConfig,\n+            ResultSetConverter<String> checksumConverter)\n+    {\n+        super(queryActions, sourceQuery, exceptionClassifier, verificationContext, Optional.empty(), verifierConfig);\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser\");\n+        this.checksumConverter = requireNonNull(checksumConverter, \"checksumConverter is null\");\n+    }\n+\n+    protected abstract Statement getChecksumQuery(QueryObjectBundle queryBundle);\n+\n+    protected abstract boolean match(S controlObject, S testObject, QueryObjectBundle control, QueryObjectBundle test);\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected DdlMatchResult verify(\n+            QueryObjectBundle control,\n+            QueryObjectBundle test,\n+            Optional<QueryResult<Void>> controlQueryResult,\n+            Optional<QueryResult<Void>> testQueryResult,\n+            ChecksumQueryContext controlContext,\n+            ChecksumQueryContext testContext)\n+    {\n+        Statement controlChecksumQuery = getChecksumQuery(control);\n+        Statement testChecksumQuery = getChecksumQuery(test);\n+\n+        controlContext.setChecksumQuery(formatSql(controlChecksumQuery));\n+        testContext.setChecksumQuery(formatSql(testChecksumQuery));\n+\n+        String controlChecksum = getOnlyElement(callAndConsume(\n+                () -> getHelperAction().execute(controlChecksumQuery, CONTROL_CHECKSUM, checksumConverter),\n+                stats -> stats.getQueryStats().map(QueryStats::getQueryId).ifPresent(controlContext::setChecksumQueryId)).getResults());\n+        String testChecksum = getOnlyElement(callAndConsume(\n+                () -> getHelperAction().execute(testChecksumQuery, TEST_CHECKSUM, checksumConverter),\n+                stats -> stats.getQueryStats().map(QueryStats::getQueryId).ifPresent(testContext::setChecksumQueryId)).getResults());\n+\n+        S controlObject;\n+        S testObject;\n+\n+        try {\n+            controlObject = (S) sqlParser.createStatement(controlChecksum, PARSING_OPTIONS);\n+        }\n+        catch (ParsingException e) {\n+            return new DdlMatchResult(CONTROL_NOT_PARSABLE, Optional.of(e), controlChecksum, testChecksum);\n+        }\n+\n+        try {\n+            testObject = (S) sqlParser.createStatement(testChecksum, PARSING_OPTIONS);\n+        }\n+        catch (ParsingException e) {\n+            return new DdlMatchResult(TEST_NOT_PARSABLE, Optional.of(e), controlChecksum, testChecksum);\n+        }\n+\n+        return new DdlMatchResult(\n+                match(controlObject, testObject, control, test) ? MATCH : MISMATCH,\n+                Optional.empty(),\n+                controlChecksum,\n+                testChecksum);\n+    }\n+\n+    @Override\n+    protected DeterminismAnalysisDetails analyzeDeterminism(QueryObjectBundle control, DdlMatchResult matchResult)\n+    {\n+        throw new UnsupportedOperationException(\"analyzeDeterminism is not supported for DdlVerification\");\n+    }\n+\n+    @Override\n+    protected Optional<String> resolveFailure(Optional<QueryObjectBundle> control, Optional<QueryObjectBundle> test, QueryContext controlQueryContext, Optional<DdlMatchResult> matchResult, Optional<Throwable> throwable)\n+    {\n+        return Optional.empty();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f716f19bc3096bef54f0d0c3eb722e565a1b0ea8"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2Njg3MQ==", "bodyText": "Failure resolver is used to automatically resolve verification failures due to (test / checksum) query failures. For ddl verification, we can start with no auto resolution, and see if we actually see any query failures are actually false alerts.", "url": "https://github.com/prestodb/presto/pull/15195#discussion_r499466871", "createdAt": "2020-10-05T09:34:18Z", "author": {"login": "caithagoras"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/framework/DdlVerification.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.verifier.framework;\n+\n+import com.facebook.presto.jdbc.QueryStats;\n+import com.facebook.presto.sql.parser.ParsingException;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.facebook.presto.verifier.event.DeterminismAnalysisDetails;\n+import com.facebook.presto.verifier.prestoaction.PrestoAction.ResultSetConverter;\n+import com.facebook.presto.verifier.prestoaction.QueryActions;\n+import com.facebook.presto.verifier.prestoaction.SqlExceptionClassifier;\n+\n+import java.util.Optional;\n+\n+import static com.facebook.presto.verifier.framework.DdlMatchResult.MatchType.CONTROL_NOT_PARSABLE;\n+import static com.facebook.presto.verifier.framework.DdlMatchResult.MatchType.MATCH;\n+import static com.facebook.presto.verifier.framework.DdlMatchResult.MatchType.MISMATCH;\n+import static com.facebook.presto.verifier.framework.DdlMatchResult.MatchType.TEST_NOT_PARSABLE;\n+import static com.facebook.presto.verifier.framework.QueryStage.CONTROL_CHECKSUM;\n+import static com.facebook.presto.verifier.framework.QueryStage.TEST_CHECKSUM;\n+import static com.facebook.presto.verifier.framework.VerifierUtil.PARSING_OPTIONS;\n+import static com.facebook.presto.verifier.framework.VerifierUtil.callAndConsume;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.util.Objects.requireNonNull;\n+\n+public abstract class DdlVerification<S extends Statement>\n+        extends AbstractVerification<QueryObjectBundle, DdlMatchResult, Void>\n+{\n+    private final SqlParser sqlParser;\n+    private final ResultSetConverter<String> checksumConverter;\n+\n+    public DdlVerification(\n+            SqlParser sqlParser,\n+            QueryActions queryActions,\n+            SourceQuery sourceQuery,\n+            SqlExceptionClassifier exceptionClassifier,\n+            VerificationContext verificationContext,\n+            VerifierConfig verifierConfig,\n+            ResultSetConverter<String> checksumConverter)\n+    {\n+        super(queryActions, sourceQuery, exceptionClassifier, verificationContext, Optional.empty(), verifierConfig);\n+        this.sqlParser = requireNonNull(sqlParser, \"sqlParser\");\n+        this.checksumConverter = requireNonNull(checksumConverter, \"checksumConverter is null\");\n+    }\n+\n+    protected abstract Statement getChecksumQuery(QueryObjectBundle queryBundle);\n+\n+    protected abstract boolean match(S controlObject, S testObject, QueryObjectBundle control, QueryObjectBundle test);\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected DdlMatchResult verify(\n+            QueryObjectBundle control,\n+            QueryObjectBundle test,\n+            Optional<QueryResult<Void>> controlQueryResult,\n+            Optional<QueryResult<Void>> testQueryResult,\n+            ChecksumQueryContext controlContext,\n+            ChecksumQueryContext testContext)\n+    {\n+        Statement controlChecksumQuery = getChecksumQuery(control);\n+        Statement testChecksumQuery = getChecksumQuery(test);\n+\n+        controlContext.setChecksumQuery(formatSql(controlChecksumQuery));\n+        testContext.setChecksumQuery(formatSql(testChecksumQuery));\n+\n+        String controlChecksum = getOnlyElement(callAndConsume(\n+                () -> getHelperAction().execute(controlChecksumQuery, CONTROL_CHECKSUM, checksumConverter),\n+                stats -> stats.getQueryStats().map(QueryStats::getQueryId).ifPresent(controlContext::setChecksumQueryId)).getResults());\n+        String testChecksum = getOnlyElement(callAndConsume(\n+                () -> getHelperAction().execute(testChecksumQuery, TEST_CHECKSUM, checksumConverter),\n+                stats -> stats.getQueryStats().map(QueryStats::getQueryId).ifPresent(testContext::setChecksumQueryId)).getResults());\n+\n+        S controlObject;\n+        S testObject;\n+\n+        try {\n+            controlObject = (S) sqlParser.createStatement(controlChecksum, PARSING_OPTIONS);\n+        }\n+        catch (ParsingException e) {\n+            return new DdlMatchResult(CONTROL_NOT_PARSABLE, Optional.of(e), controlChecksum, testChecksum);\n+        }\n+\n+        try {\n+            testObject = (S) sqlParser.createStatement(testChecksum, PARSING_OPTIONS);\n+        }\n+        catch (ParsingException e) {\n+            return new DdlMatchResult(TEST_NOT_PARSABLE, Optional.of(e), controlChecksum, testChecksum);\n+        }\n+\n+        return new DdlMatchResult(\n+                match(controlObject, testObject, control, test) ? MATCH : MISMATCH,\n+                Optional.empty(),\n+                controlChecksum,\n+                testChecksum);\n+    }\n+\n+    @Override\n+    protected DeterminismAnalysisDetails analyzeDeterminism(QueryObjectBundle control, DdlMatchResult matchResult)\n+    {\n+        throw new UnsupportedOperationException(\"analyzeDeterminism is not supported for DdlVerification\");\n+    }\n+\n+    @Override\n+    protected Optional<String> resolveFailure(Optional<QueryObjectBundle> control, Optional<QueryObjectBundle> test, QueryContext controlQueryContext, Optional<DdlMatchResult> matchResult, Optional<Throwable> throwable)\n+    {\n+        return Optional.empty();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMzkxNQ=="}, "originalCommit": {"oid": "f716f19bc3096bef54f0d0c3eb722e565a1b0ea8"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjkyNTMwOnYy", "diffSide": "RIGHT", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/rewrite/QueryRewriter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNToxMjoyMFrOHaNigA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOTozODo1NVrOHcVNNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0Njg0OA==", "bodyText": "Should we extract this into a method? Feel like it would be easier to follow", "url": "https://github.com/prestodb/presto/pull/15195#discussion_r497246848", "createdAt": "2020-09-30T05:12:20Z", "author": {"login": "sujay-jain"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/rewrite/QueryRewriter.java", "diffHunk": "@@ -166,11 +173,43 @@ public QueryObjectBundle rewriteQuery(@Language(\"SQL\") String query, ClusterType\n                     ImmutableList.of(new DropTable(temporaryTableName, true)),\n                     clusterType);\n         }\n+        if (statement instanceof CreateView) {\n+            CreateView createView = (CreateView) statement;\n+            QualifiedName temporaryViewName = generateTemporaryName(Optional.empty(), prefix);\n+            ImmutableList.Builder<Statement> setupQueries = ImmutableList.builder();\n+\n+            // Check to see if there is an existing view with the specified view name.\n+            // If view exists, create a temporary view that are has the same definition as the existing view.\n+            // Otherwise, do not pre-create temporary view.\n+            try {\n+                CreateView createExistingView = (CreateView) sqlParser.createStatement(\n+                        getOnlyElement(prestoAction.execute(new ShowCreate(VIEW, createView.getName()), REWRITE, SHOW_CREATE_VIEW_CONVERTER).getResults()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f716f19bc3096bef54f0d0c3eb722e565a1b0ea8"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2OTYyMQ==", "bodyText": "This method would only be used once if we extract. I'm changing this to 2 statements - that might help readability.", "url": "https://github.com/prestodb/presto/pull/15195#discussion_r499469621", "createdAt": "2020-10-05T09:38:55Z", "author": {"login": "caithagoras"}, "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/rewrite/QueryRewriter.java", "diffHunk": "@@ -166,11 +173,43 @@ public QueryObjectBundle rewriteQuery(@Language(\"SQL\") String query, ClusterType\n                     ImmutableList.of(new DropTable(temporaryTableName, true)),\n                     clusterType);\n         }\n+        if (statement instanceof CreateView) {\n+            CreateView createView = (CreateView) statement;\n+            QualifiedName temporaryViewName = generateTemporaryName(Optional.empty(), prefix);\n+            ImmutableList.Builder<Statement> setupQueries = ImmutableList.builder();\n+\n+            // Check to see if there is an existing view with the specified view name.\n+            // If view exists, create a temporary view that are has the same definition as the existing view.\n+            // Otherwise, do not pre-create temporary view.\n+            try {\n+                CreateView createExistingView = (CreateView) sqlParser.createStatement(\n+                        getOnlyElement(prestoAction.execute(new ShowCreate(VIEW, createView.getName()), REWRITE, SHOW_CREATE_VIEW_CONVERTER).getResults()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0Njg0OA=="}, "originalCommit": {"oid": "f716f19bc3096bef54f0d0c3eb722e565a1b0ea8"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3693, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}