{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMTAyNDkw", "number": 14359, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTowMToxMFrODvmnMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowMjoxNFrODvwgfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjQyMjkxOnYy", "diffSide": "RIGHT", "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/StructSelectiveStreamReader.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNTowMToxMFrOGCH5Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowMTo0OFrOGCXw2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3OTY3NA==", "bodyText": "@bhhari What happens if fieldOutputType is empty?", "url": "https://github.com/prestodb/presto/pull/14359#discussion_r404879674", "createdAt": "2020-04-07T15:01:10Z", "author": {"login": "mbasmanova"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/StructSelectiveStreamReader.java", "diffHunk": "@@ -166,13 +166,16 @@ else if (outputRequired || !fieldsWithFilters.isEmpty()) {\n                 boolean requiredField = requiredFields.map(names -> names.containsKey(fieldName)).orElse(outputRequired);\n                 Optional<Type> fieldOutputType = Optional.ofNullable(nestedTypes.get(fieldName)).map(Field::getType);\n \n-                if (requiredField || fieldsWithFilters.contains(fieldName)) {\n-                    Map<Subfield, TupleDomainFilter> nestedFilters = filters.entrySet().stream()\n-                            .filter(entry -> entry.getKey().getPath().size() > 0)\n-                            .filter(entry -> ((Subfield.NestedField) entry.getKey().getPath().get(0)).getName().equalsIgnoreCase(fieldName))\n-                            .collect(toImmutableMap(entry -> entry.getKey().tail(fieldName), Map.Entry::getValue));\n-                    List<Subfield> nestedRequiredSubfields = requiredFields.map(names -> names.get(fieldName)).orElse(ImmutableList.of());\n-                    if (nestedStream != null) {\n+                if (nestedStream == null) {\n+                    nestedReaders.put(fieldName, new MissingFieldStreamReader(fieldOutputType.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31123f1efff06b18a6300c66ac9d1fc547308bc2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA0MjA5NA==", "bodyText": "We handle it in checkMissingFieldFilters. The outType is empty only in this case", "url": "https://github.com/prestodb/presto/pull/14359#discussion_r405042094", "createdAt": "2020-04-07T18:59:17Z", "author": {"login": "bhhari"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/StructSelectiveStreamReader.java", "diffHunk": "@@ -166,13 +166,16 @@ else if (outputRequired || !fieldsWithFilters.isEmpty()) {\n                 boolean requiredField = requiredFields.map(names -> names.containsKey(fieldName)).orElse(outputRequired);\n                 Optional<Type> fieldOutputType = Optional.ofNullable(nestedTypes.get(fieldName)).map(Field::getType);\n \n-                if (requiredField || fieldsWithFilters.contains(fieldName)) {\n-                    Map<Subfield, TupleDomainFilter> nestedFilters = filters.entrySet().stream()\n-                            .filter(entry -> entry.getKey().getPath().size() > 0)\n-                            .filter(entry -> ((Subfield.NestedField) entry.getKey().getPath().get(0)).getName().equalsIgnoreCase(fieldName))\n-                            .collect(toImmutableMap(entry -> entry.getKey().tail(fieldName), Map.Entry::getValue));\n-                    List<Subfield> nestedRequiredSubfields = requiredFields.map(names -> names.get(fieldName)).orElse(ImmutableList.of());\n-                    if (nestedStream != null) {\n+                if (nestedStream == null) {\n+                    nestedReaders.put(fieldName, new MissingFieldStreamReader(fieldOutputType.get()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3OTY3NA=="}, "originalCommit": {"oid": "31123f1efff06b18a6300c66ac9d1fc547308bc2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5NjA2OQ==", "bodyText": "fieldOutType can not be null, as the nestedStream is null only because we have the field from schema and missing from data", "url": "https://github.com/prestodb/presto/pull/14359#discussion_r405096069", "createdAt": "2020-04-07T20:36:10Z", "author": {"login": "bhhari"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/StructSelectiveStreamReader.java", "diffHunk": "@@ -166,13 +166,16 @@ else if (outputRequired || !fieldsWithFilters.isEmpty()) {\n                 boolean requiredField = requiredFields.map(names -> names.containsKey(fieldName)).orElse(outputRequired);\n                 Optional<Type> fieldOutputType = Optional.ofNullable(nestedTypes.get(fieldName)).map(Field::getType);\n \n-                if (requiredField || fieldsWithFilters.contains(fieldName)) {\n-                    Map<Subfield, TupleDomainFilter> nestedFilters = filters.entrySet().stream()\n-                            .filter(entry -> entry.getKey().getPath().size() > 0)\n-                            .filter(entry -> ((Subfield.NestedField) entry.getKey().getPath().get(0)).getName().equalsIgnoreCase(fieldName))\n-                            .collect(toImmutableMap(entry -> entry.getKey().tail(fieldName), Map.Entry::getValue));\n-                    List<Subfield> nestedRequiredSubfields = requiredFields.map(names -> names.get(fieldName)).orElse(ImmutableList.of());\n-                    if (nestedStream != null) {\n+                if (nestedStream == null) {\n+                    nestedReaders.put(fieldName, new MissingFieldStreamReader(fieldOutputType.get()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3OTY3NA=="}, "originalCommit": {"oid": "31123f1efff06b18a6300c66ac9d1fc547308bc2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzOTY3Mw==", "bodyText": "@bhhari Got it. If outputType is missing, we can't have nestedStream being null.\nSet<String> structFields = outputType.isPresent() ? nestedTypes.keySet() : nestedStreams.keySet();\nHence, if nestedStream is null, then outputType must be present. This invariant would be broken only if this method had a bug, hence, we should use verify. (checkState would be used if the caller invoked public methods in the wrong order.)\nverify(fieldOutputType.isPresent(), \"Missing output type for subfield \" + fieldName);", "url": "https://github.com/prestodb/presto/pull/14359#discussion_r405139673", "createdAt": "2020-04-07T22:01:48Z", "author": {"login": "mbasmanova"}, "path": "presto-orc/src/main/java/com/facebook/presto/orc/reader/StructSelectiveStreamReader.java", "diffHunk": "@@ -166,13 +166,16 @@ else if (outputRequired || !fieldsWithFilters.isEmpty()) {\n                 boolean requiredField = requiredFields.map(names -> names.containsKey(fieldName)).orElse(outputRequired);\n                 Optional<Type> fieldOutputType = Optional.ofNullable(nestedTypes.get(fieldName)).map(Field::getType);\n \n-                if (requiredField || fieldsWithFilters.contains(fieldName)) {\n-                    Map<Subfield, TupleDomainFilter> nestedFilters = filters.entrySet().stream()\n-                            .filter(entry -> entry.getKey().getPath().size() > 0)\n-                            .filter(entry -> ((Subfield.NestedField) entry.getKey().getPath().get(0)).getName().equalsIgnoreCase(fieldName))\n-                            .collect(toImmutableMap(entry -> entry.getKey().tail(fieldName), Map.Entry::getValue));\n-                    List<Subfield> nestedRequiredSubfields = requiredFields.map(names -> names.get(fieldName)).orElse(ImmutableList.of());\n-                    if (nestedStream != null) {\n+                if (nestedStream == null) {\n+                    nestedReaders.put(fieldName, new MissingFieldStreamReader(fieldOutputType.get()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3OTY3NA=="}, "originalCommit": {"oid": "31123f1efff06b18a6300c66ac9d1fc547308bc2"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDA0NDE1OnYy", "diffSide": "RIGHT", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHivePushdownFilterQueries.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowMjoxNFrOGCXxcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowMjoxNFrOGCXxcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzOTgyNw==", "bodyText": "@bhhari nit: extra space before \"FROM\"", "url": "https://github.com/prestodb/presto/pull/14359#discussion_r405139827", "createdAt": "2020-04-07T22:02:14Z", "author": {"login": "mbasmanova"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHivePushdownFilterQueries.java", "diffHunk": "@@ -875,6 +875,8 @@ public void testStructSchemaEvolution()\n         Path newDirectoryPath = getOnlyPath(\"test_struct_add_column\").getParent();\n         Files.move(oldFilePath, Paths.get(newDirectoryPath.toString(), \"old_file\"), ATOMIC_MOVE);\n         assertQuery(\"SELECT * FROM test_struct_add_column\", \"SELECT (1, 2, 3) UNION ALL SELECT (1, 2, null)\");\n+        assertQuery(\"SELECT x.a FROM test_struct_add_column\", \"SELECT 1 UNION ALL SELECT 1\");\n+        assertQuery(\"SELECT count(*)  FROM test_struct_add_column where x.c = 1\", \"SELECT 0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b97debaf46637783fa68c96a32d35899c2db75e9"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2759, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}