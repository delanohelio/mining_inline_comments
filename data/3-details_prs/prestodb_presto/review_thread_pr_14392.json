{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDYxNzQy", "number": 14392, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMToxMTo0OFrODz_iXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTowODowM1rOEEGz-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODQ0OTU3OnYy", "diffSide": "RIGHT", "path": "presto-docs/src/main/sphinx/functions/array.rst", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMToxMTo0OFrOGIuEQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjowNzozN1rOGO8BAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NjU0Nw==", "bodyText": "May be mention here that it's similar to the SUM aggregation.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r411796547", "createdAt": "2020-04-21T01:11:48Z", "author": {"login": "kaikalur"}, "path": "presto-docs/src/main/sphinx/functions/array.rst", "diffHunk": "@@ -102,6 +102,11 @@ Array Functions\n                                        -1,\n                                        IF(cardinality(x) = cardinality(y), 0, 1))); -- [[1, 2], [2, 3, 1], [4, 2, 1, 4]]\n \n+.. function:: array_sum(array(T)) -> T\n+\n+    Returns the sum of all non-null elements of the ``array``. If there is no non-null elements, returns ``0``.\n+    ``T`` must be coercible to ``double`` or ``bigint``.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dd63dfc53e86ae6c3c3df03cdf3af4576bd240d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2ODM5Ng==", "bodyText": "Added\nThe behavior is similar to aggregation function :func:`sum`.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r414168396", "createdAt": "2020-04-23T22:34:05Z", "author": {"login": "caithagoras"}, "path": "presto-docs/src/main/sphinx/functions/array.rst", "diffHunk": "@@ -102,6 +102,11 @@ Array Functions\n                                        -1,\n                                        IF(cardinality(x) = cardinality(y), 0, 1))); -- [[1, 2], [2, 3, 1], [4, 2, 1, 4]]\n \n+.. function:: array_sum(array(T)) -> T\n+\n+    Returns the sum of all non-null elements of the ``array``. If there is no non-null elements, returns ``0``.\n+    ``T`` must be coercible to ``double`` or ``bigint``.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NjU0Nw=="}, "originalCommit": {"oid": "5dd63dfc53e86ae6c3c3df03cdf3af4576bd240d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5NDgxMA==", "bodyText": "It should be T can only be double or bigint or you should write it as array_sum(array(T)) -> double / bigint If the array is array(int) the return type is not int. Or just write them as 2 functions.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r416894810", "createdAt": "2020-04-28T20:17:11Z", "author": {"login": "rongrong"}, "path": "presto-docs/src/main/sphinx/functions/array.rst", "diffHunk": "@@ -102,6 +102,11 @@ Array Functions\n                                        -1,\n                                        IF(cardinality(x) = cardinality(y), 0, 1))); -- [[1, 2], [2, 3, 1], [4, 2, 1, 4]]\n \n+.. function:: array_sum(array(T)) -> T\n+\n+    Returns the sum of all non-null elements of the ``array``. If there is no non-null elements, returns ``0``.\n+    ``T`` must be coercible to ``double`` or ``bigint``.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NjU0Nw=="}, "originalCommit": {"oid": "5dd63dfc53e86ae6c3c3df03cdf3af4576bd240d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5NjM3MA==", "bodyText": "It might worth looking into supporting generics in signatures for builtin sql functions.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r416896370", "createdAt": "2020-04-28T20:20:03Z", "author": {"login": "rongrong"}, "path": "presto-docs/src/main/sphinx/functions/array.rst", "diffHunk": "@@ -102,6 +102,11 @@ Array Functions\n                                        -1,\n                                        IF(cardinality(x) = cardinality(y), 0, 1))); -- [[1, 2], [2, 3, 1], [4, 2, 1, 4]]\n \n+.. function:: array_sum(array(T)) -> T\n+\n+    Returns the sum of all non-null elements of the ``array``. If there is no non-null elements, returns ``0``.\n+    ``T`` must be coercible to ``double`` or ``bigint``.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NjU0Nw=="}, "originalCommit": {"oid": "5dd63dfc53e86ae6c3c3df03cdf3af4576bd240d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNjU0NQ==", "bodyText": "Description updated.\n``T`` must be coercible to ``double``.\nReturns ``bigint`` if T is coercible to ``bigint``. Otherwise, returns ``double``.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418316545", "createdAt": "2020-04-30T22:07:37Z", "author": {"login": "caithagoras"}, "path": "presto-docs/src/main/sphinx/functions/array.rst", "diffHunk": "@@ -102,6 +102,11 @@ Array Functions\n                                        -1,\n                                        IF(cardinality(x) = cardinality(y), 0, 1))); -- [[1, 2], [2, 3, 1], [4, 2, 1, 4]]\n \n+.. function:: array_sum(array(T)) -> T\n+\n+    Returns the sum of all non-null elements of the ``array``. If there is no non-null elements, returns ``0``.\n+    ``T`` must be coercible to ``double`` or ``bigint``.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NjU0Nw=="}, "originalCommit": {"oid": "5dd63dfc53e86ae6c3c3df03cdf3af4576bd240d"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzgyMDQzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDoyMzowN1rOGNlcSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDowMjoxNlrOGhaKqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ==", "bodyText": "I think it's probably make sense to add language to SqlFunction. Implementation type is sort of a derived metadata from language. That could clean up some of the type checks you have in your code.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r416898121", "createdAt": "2020-04-28T20:23:07Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyOTU0Mg==", "bodyText": "If we add getLanguage to the SqlFunction interface, we can either make BUILTIN an enum of Language, or make getLanguage returns Optional. I'm not a fan for either of those choices.\n\"builtin\" is not really a \"language\". It's a way of implementation. IMO, language should be derived from the tuple (SqlFunction.getClass, SqlInvokedFunction.getLanguage).\nAlso, it's undefined for SqlFunction to have a language SQL, but having getLanguage method would allow so, and that's extra check rather than fewer check.\nHaving getLanguage method only affects this line. The 2 checks are line 810 and line 420-423, but making this change won't let those checks go away.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418329542", "createdAt": "2020-04-30T22:41:26Z", "author": {"login": "caithagoras"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NDY2Mg==", "bodyText": "For the builtin java functions, the language could be JAVA, for the builtin sql functions the language would be SQL. Presto can run JAVA and SQL language natively. JAVA => BUILTIN, SQL => SQL. And in the future when we introduce other languages, those would have an implementation type REMOTE.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418354662", "createdAt": "2020-05-01T00:02:05Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NDc2NQ==", "bodyText": "If you wonder what about Hive java functions, the language for that will be HIVE \ud83d\ude02", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418354765", "createdAt": "2020-05-01T00:02:27Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2Njc1Mg==", "bodyText": "My point is not about what enum names to use.\nAdding getLanguage to SqlFunction leaves a hole in the API. User will be allowed to define a SQL-invoked function (either through CREATE FUNCTION statement, or through plugin) with language Java. Similarly, SqlScalarFunction instance can have language SQL. In both cases, functions can be created but fails with internal error during execution.\nExample:\nCREATE FUNCTION dev.leiqing.rand()\nRETURNS double\nLANGUAGE JAVA\nRETURN rand()\nIt will succeeds, but execution will fail. We shouldn't allow the create function to work in the first place.\nSimilarly, one can also do:\npublic class XXXFunction extends SqlScalarFunction {\n   @Override\n   public Language getLanguage() {\n       return SQL;\n    }\n}\nAlthough this is clearly wrong and can be easily caught by test, but why test? We shouldn't allow it structurally in the first place.\nHopefully, this examples explain my concerns.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418366752", "createdAt": "2020-05-01T00:46:51Z", "author": {"login": "caithagoras"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcwMTAwNg==", "bodyText": "It's not a hole. CREATE FUNCTION would not support language Java. Language is a rightful metadata that every function should have. Please separate implementation from concept. Conceptually it's valid that every function should have a language. The the implementation type is a derived information from language, because the engine supports some languages not others.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418701006", "createdAt": "2020-05-01T19:31:45Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMjIwNQ==", "bodyText": "Practically you can override this in BuiltInFunction as final so all BuiltInFunctions has Language Java.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418732205", "createdAt": "2020-05-01T20:50:37Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Mjk0NA==", "bodyText": "Language is a rightful metadata that every function should have.\n\nWe need to clarify the meaning of \"language\" here.\nCurrently, the enum class Language represents a property of a SQL-invoked function, as defined in the Spec. \"Language\" in this context is either \"SQL\", if the SQL-invoked Function is a SQL-invoked Regular Function, or the programming language in which the external routine is implemented.\nWhat you've proposed is to \"repurpose\" or \"extends\" the enum \"Language\" to represent a different concept. I think repurposing something is total fine but the exact new definition of the enum Language is unknown to me. Maybe you can clarify this?\n\"If\" this new definition Language still represent the programming language in which a Presto function is implemented, then a user-defined SQL function implemented in \"Java\" should also have a language \"Java\", not \"Hive\". Hive is not language anyway, HQL is, but is not applicable in this context here.\nConsider those 3 categories of function:\n\nA scalar function implemented in Presto or Presto Plugin, using the annotation framework that Presto can understand. (SqlScalarFunction)\nA scalar function implemented in Hive code base, using the framework that Hive can understand.\nA scalar function implemented as a SQL-invoked external routine, with the routine name pointing to a file containing Java code in text. (SqlInvokedFunction).\nAll 3 of them are implemented in the Java programming language.\n\nI would say, even if we generalize the definition of language from SqlInvokedFunction to all SqlFunction in general, all 3 cases should have language Java. The suggestion that you made about assigning Language.Java to case 1, and Language.Hive to case 2 seems to me that you're looking to convey extra information with the \"language\" concept or the \"Language\" enum. The extra information is \"what framework that the Java implementation adheres to\" - does it use the Presto annotation (Can be parsed by Presto to create a SqlScalarFunction), or is it a Java class enclosing a Java method like the Hive-style.\nGoing back to what you say \"Language is a rightful metadata that every function should have.\" I agree if by saying \"language\", you actually mean the programming language in which the function is implemented, and in all of those 3 cases, \"Java\". I don't agree if the \"language\" you're talking about also conveys the extra information about the framework/assumption that the Java implementation uses, because\n\nThat should not be called \"language\".\nThat can be derived from the class object.\nThat's a special case for language Java because Presto and Hive happens to be implemented in Java, and therefore it should not be packed together with \"SQL\", \"Python\", \"JS\", etc., the one that actually only means programming language.\n\n\nPlease separate implementation from concept\n\nAlthough I gave code examples, I don't meant to discuss about implementation details at all. To validate whether a concept is valid, one of the ways would be have a thought experiment about whether there will be issues like conflicts or undefined/unclarified cases when the concept is introduced.\nLike I said above, if getLanguage returns the programming language. I don't see having that in SqlFunction would be a problem (but I don't think it's useful). However, if getLanguage returns differently for different types of Java implementation, then having getLanguage is not only not useful, but also require extra checks, which indicates a flawed OOP design.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418752944", "createdAt": "2020-05-01T21:49:51Z", "author": {"login": "caithagoras"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2MTYzMQ==", "bodyText": "@rongrong Sorry about the long post here. Just to make things clear, the first part is talking about the Language enum, and the second part is talking about getLanguage function.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418761631", "createdAt": "2020-05-01T22:19:43Z", "author": {"login": "caithagoras"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM3MTkxOQ==", "bodyText": "Yes, I'm suggesting extending the meaning of Language. You've already touched it. Builtin Java functions, Hive java functions, or java functions implemented with another API, are all JAVA functions. So we either repurpose the Language to give them different values, or we need to introduce another type of metadata (and it's not implementation type). I'd choose just repurpose the language, which is more compatible with SQL standard than introducing a new metadata.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r420371919", "createdAt": "2020-05-05T20:02:06Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NDkwNQ==", "bodyText": "Discussed offline.\nWe'll have a single enum type that can be used to derive all execution information, including language and the framework (e.g. Hive vs Java vs Presto) within the same language. FunctionMetadata will contains this enum, and the enum will be serialized between Presto server and remote UDF server (when we have that in the future). The enum does not need to be exposed in presto-spi, and enum Language will be kept as its original definition in the spec.\nBuiltInFunctionNamespaceManager.getFunctionMetadata will be the single place to figure out the value of this enum from other information.\nI think we can do this in a separate PR given that this enum is not exactly too useful until we have remote execution cases, and this PR has already been throughly reviewed.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r437684905", "createdAt": "2020-06-09T20:02:16Z", "author": {"login": "caithagoras"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -785,8 +801,13 @@ public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)\n             throw e;\n         }\n         SqlFunction function = functionKey.getFunction();\n+        FunctionImplementationType implementationType = function instanceof SqlInvokedFunction ? SQL : BUILTIN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5ODEyMQ=="}, "originalCommit": {"oid": "1a983095f24218ec1fea3c225d4ee1a36860c6b7"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Mzg2MTczOnYy", "diffSide": "RIGHT", "path": "presto-spi/src/main/java/com/facebook/presto/spi/function/Parameter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDozNDozNlrOGNl1-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMTozNjoxOVrOGO7M0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkwNDY5OA==", "bodyText": "Please try not to rename spi classes unless absolutely necessary.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r416904698", "createdAt": "2020-04-28T20:34:36Z", "author": {"login": "rongrong"}, "path": "presto-spi/src/main/java/com/facebook/presto/spi/function/Parameter.java", "diffHunk": "@@ -21,13 +21,13 @@\n \n import static java.util.Objects.requireNonNull;\n \n-public class SqlParameter\n+public class Parameter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a2db1f3a82ddcf94b541d7cdb0b18b13630fa7d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1OTM0NQ==", "bodyText": "I understand. The reason I'm renaming here is that I'm reserving the name SqlParameter for the new annotation. We have annotations like @SqlType, @SqlNullable, @SqlFunction and so on, to define functions. We need a few new annotation for SQL-invoked functions, and for consistency, I added @SqlParameter and @SqlParameters. Hence the rename.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418259345", "createdAt": "2020-04-30T20:08:29Z", "author": {"login": "caithagoras"}, "path": "presto-spi/src/main/java/com/facebook/presto/spi/function/Parameter.java", "diffHunk": "@@ -21,13 +21,13 @@\n \n import static java.util.Objects.requireNonNull;\n \n-public class SqlParameter\n+public class Parameter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkwNDY5OA=="}, "originalCommit": {"oid": "0a2db1f3a82ddcf94b541d7cdb0b18b13630fa7d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMzE4NQ==", "bodyText": "I understand the motivation. And for this specific case I think it's probably ok to break spi since I don't expect people to use it yet. But in general, having naming conventions consistent and nice is not enough reason to break backward compatibility.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r418303185", "createdAt": "2020-04-30T21:36:19Z", "author": {"login": "rongrong"}, "path": "presto-spi/src/main/java/com/facebook/presto/spi/function/Parameter.java", "diffHunk": "@@ -21,13 +21,13 @@\n \n import static java.util.Objects.requireNonNull;\n \n-public class SqlParameter\n+public class Parameter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkwNDY5OA=="}, "originalCommit": {"oid": "0a2db1f3a82ddcf94b541d7cdb0b18b13630fa7d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzM1NTE4OnYy", "diffSide": "RIGHT", "path": "presto-docs/src/main/sphinx/functions/array.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDozMToxNFrOGhg55A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDozMToxNFrOGhg55A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NTMwMA==", "bodyText": "You might want to just say array_average(array<double>) -> double instead, rather than saying it's a generic type T that's coercible to double. This would be more consistent with code. Also, for map_normalize you just used map<varchar,double> rather than saying map<varchar,T>. People should know that you can all a function that takes array<double> with array<T coercible with double>.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r437795300", "createdAt": "2020-06-10T00:31:14Z", "author": {"login": "rongrong"}, "path": "presto-docs/src/main/sphinx/functions/array.rst", "diffHunk": "@@ -35,6 +35,13 @@ Array Functions\n     array is empty); ``NULL`` if the predicate function returns ``NULL`` for one or more elements and ``false``\n     for all other elements.\n \n+.. function:: array_average(array(T)) -> double", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1de9e7e07d2fd7ade42b552a397f05f5a6aa2eb9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzM2MzExOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/metadata/FunctionExtractor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDozNjoyN1rOGhg-qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTowMzo1N1rOGhhZsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NjUyMQ==", "bodyText": "Can we combine the two? I don't see the point to have a different annotation for multiple functions and single function. We use @ScalarFunction to annotate both class and method. It's also quite confusing to user since it's very hard to notice the difference of the two (so very easily to use the wrong one).", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r437796521", "createdAt": "2020-06-10T00:36:27Z", "author": {"login": "rongrong"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/FunctionExtractor.java", "diffHunk": "@@ -55,6 +58,14 @@ private FunctionExtractor() {}\n             return ScalarFromAnnotationsParser.parseFunctionDefinition(clazz);\n         }\n \n+        if (clazz.isAnnotationPresent(SqlInvokedScalarFunctions.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1de9e7e07d2fd7ade42b552a397f05f5a6aa2eb9"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMzQ0Mg==", "bodyText": "Ok. Removed SqlInvokedScalarFunctions.\nIf a class is not annotated, FunctionExtractor will try to find all scalar and sql invoked scalar function that class.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r437803442", "createdAt": "2020-06-10T01:03:57Z", "author": {"login": "caithagoras"}, "path": "presto-main/src/main/java/com/facebook/presto/metadata/FunctionExtractor.java", "diffHunk": "@@ -55,6 +58,14 @@ private FunctionExtractor() {}\n             return ScalarFromAnnotationsParser.parseFunctionDefinition(clazz);\n         }\n \n+        if (clazz.isAnnotationPresent(SqlInvokedScalarFunctions.class)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5NjUyMQ=="}, "originalCommit": {"oid": "1de9e7e07d2fd7ade42b552a397f05f5a6aa2eb9"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzQxMzY4OnYy", "diffSide": "RIGHT", "path": "presto-docs/src/main/sphinx/functions/array.rst", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTowODowM1rOGhhdpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTowODowM1rOGhhdpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwNDQ1Mg==", "bodyText": "Remove this line.", "url": "https://github.com/prestodb/presto/pull/14392#discussion_r437804452", "createdAt": "2020-06-10T01:08:03Z", "author": {"login": "rongrong"}, "path": "presto-docs/src/main/sphinx/functions/array.rst", "diffHunk": "@@ -35,6 +35,13 @@ Array Functions\n     array is empty); ``NULL`` if the predicate function returns ``NULL`` for one or more elements and ``false``\n     for all other elements.\n \n+.. function:: array_average(array(double)) -> double\n+\n+    Returns the average of all non-null elements of the ``array``. If there is no non-null elements, returns\n+    ``null``.\n+\n+    ``T`` must be coercible to ``double``.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "001c5aee7a5c2e49c74cb20588276f06856845f8"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2791, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}