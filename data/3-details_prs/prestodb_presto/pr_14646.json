{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzODU3MDc2", "number": 14646, "title": "Adding time type support for Pinot predicate pushdown", "bodyText": "== RELEASE NOTES ==\n\nPinot Changes\n* Support predicate pushdown for literals of type `DATE`, `TIMESTAMP`, or `TIMESTAMP_WITH_TIME_ZONE`", "createdAt": "2020-06-12T19:49:00Z", "url": "https://github.com/prestodb/presto/pull/14646", "merged": true, "mergeCommit": {"oid": "74e0bf4f402dbce31d6f00af1011ae814f710439"}, "closed": true, "closedAt": "2020-06-23T22:11:00Z", "author": {"login": "xiangfu0"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcr464_AFqTQzMTczMDYzNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuEFbigBqjM0NzI1NTk2ODM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNzMwNjM3", "url": "https://github.com/prestodb/presto/pull/14646#pullrequestreview-431730637", "createdAt": "2020-06-16T17:23:34Z", "commit": {"oid": "c6d6bef91e8d0e6f719eb2d14ed729810911e607"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNzoyMzozNFrOGklofw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNzo0MjoxOVrOGkmTWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxODQ5NQ==", "bodyText": "I think I would prefer handleLogicalBinary to check for the presence of date/time etc and then delegate to a helper method instead of inlining the logic here. Here is what I mean in code:\nif (isDateTimeExpression(arguments)) {\n  return handleDateTimeBinaryExpression(operator, call, context) // or pass it arguments, context ..  whatever\n}\n// Continue normal handleLogicalBinary flow here", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441018495", "createdAt": "2020-06-16T17:23:34Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6bef91e8d0e6f719eb2d14ed729810911e607"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTUxMA==", "bodyText": "I didn't follow why handleTimeStampAndDateCast is not called from handleCast ? I don't understand why the codepath is entering handleLogicalBinary vs handleCast.", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441019510", "createdAt": "2020-06-16T17:25:22Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();\n+            String def1 = arguments.get(1).accept(this, context).getDefinition();\n+            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n+            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n+            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return definition;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6bef91e8d0e6f719eb2d14ed729810911e607"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMDQ3OQ==", "bodyText": "By having handleTimeStampAndDateCast as written, its not clear what definition means.", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441020479", "createdAt": "2020-06-16T17:26:58Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();\n+            String def1 = arguments.get(1).accept(this, context).getDefinition();\n+            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n+            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n+            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6bef91e8d0e6f719eb2d14ed729810911e607"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMTc4NA==", "bodyText": "Shouldn't we be returning output as a timestamp instead of number of days, if the expected type is a timestamp and input is a date ? We seem to be doing the opposite: returning the days when expected type is a timestamp.\nAlso what about timezone handling ?", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441021784", "createdAt": "2020-06-16T17:29:09Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();\n+            String def1 = arguments.get(1).accept(this, context).getDefinition();\n+            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n+            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n+            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return definition;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return definition;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return definition;\n+        }\n+        Type inputType = callExpr.getArguments().get(0).getType();\n+        Type expectedType = callExpr.getType();\n+        if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6bef91e8d0e6f719eb2d14ed729810911e607"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNTYzNA==", "bodyText": "Perhaps a comment here about why the substring offsets are chosen ?\nIs this branch about handling of literals / constants ? Is there another way to check for a RowExpression being a constant/literal rather than checking for its type ?", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441025634", "createdAt": "2020-06-16T17:35:39Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -141,6 +187,21 @@ private PinotExpression handleCast(CallExpression cast, Function<VariableReferen\n             if (typeManager.canCoerce(input.getType(), expectedType)) {\n                 return input.accept(this, context);\n             }\n+            if (expectedType == DateType.DATE) {\n+                try {\n+                    PinotExpression expression = input.accept(this, context);\n+                    if (input.getType() == TimestampType.TIMESTAMP || input.getType() == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) {\n+                        return expression;\n+                    }\n+                    if (input.getType() == VarcharType.VARCHAR) {\n+                        Integer daysSinceEpoch = (int) TimeUnit.MILLISECONDS.toDays(DATE_FORMATTER.parseMillis(expression.getDefinition().substring(1, expression.getDefinition().length() - 1)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6bef91e8d0e6f719eb2d14ed729810911e607"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNjU2NQ==", "bodyText": "definition is actually a PQL expression fragment corresponding to a whole expression subtree, and need not be a number. IMHO, Its a bit brittle to first cast an expression tree to a PQL expression-string and then assume that is parseable as a number.", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441026565", "createdAt": "2020-06-16T17:37:13Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();\n+            String def1 = arguments.get(1).accept(this, context).getDefinition();\n+            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n+            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n+            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return definition;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return definition;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return definition;\n+        }\n+        Type inputType = callExpr.getArguments().get(0).getType();\n+        Type expectedType = callExpr.getType();\n+        if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+            try {\n+                Long daysSinceEpoch = TimeUnit.MILLISECONDS.toDays(Long.parseLong(definition));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6bef91e8d0e6f719eb2d14ed729810911e607"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyODU4Ng==", "bodyText": "Since handleLogicalBinary is called here (above), I wonder if we can move all of the special logic around handling of date/timestamps into a separate function that is called here without dirtying up handleLogicalBinary, as we have already done so for some class of functions on line 235", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441028586", "createdAt": "2020-06-16T17:40:50Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -171,9 +232,26 @@ public PinotExpression visitCall(CallExpression call, Function<VariableReference\n                 return handleLogicalBinary(operatorType.getOperator(), call, context);\n             }\n         }\n+        if (functionMetadata.getName().getFunctionName().equalsIgnoreCase(\"$literal$timestamp\") ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6bef91e8d0e6f719eb2d14ed729810911e607"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyOTQ2NA==", "bodyText": "Where is this logic around rendering a json array to string used in this PR ?", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441029464", "createdAt": "2020-06-16T17:42:19Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -280,8 +281,18 @@ private int issuePqlAndPopulate(\n \n     private static String asText(JsonNode node)\n     {\n+        if (node.isNull()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d6bef91e8d0e6f719eb2d14ed729810911e607"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "79efe09049b5de263b10409ab70d5bf524766773", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/79efe09049b5de263b10409ab70d5bf524766773", "committedDate": "2020-06-17T09:14:20Z", "message": "Address comments"}, "afterCommit": {"oid": "fcf551edfa2f1b84d4e88d014674673fd969fc6a", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/fcf551edfa2f1b84d4e88d014674673fd969fc6a", "committedDate": "2020-06-17T09:23:55Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTUwODI1", "url": "https://github.com/prestodb/presto/pull/14646#pullrequestreview-432550825", "createdAt": "2020-06-17T16:02:25Z", "commit": {"oid": "fcf551edfa2f1b84d4e88d014674673fd969fc6a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowMjoyNVrOGlMpww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjowMjo1OFrOGlMrHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1Nzc5NQ==", "bodyText": "nit: swap the right and left to make it be consistent with above 2 lines", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441657795", "createdAt": "2020-06-17T16:02:25Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -100,48 +100,85 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            String def0 = arguments.get(0).accept(this, context).getDefinition();\n-            String def1 = arguments.get(1).accept(this, context).getDefinition();\n-            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n-            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n-            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n+            if (isDateTimeExpression(arguments)) {\n+                return handleDateTimeBinaryExpression(operator, arguments, context);\n+            }\n+            return derived(format(\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n-    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)\n+    private PinotExpression handleDateTimeBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcf551edfa2f1b84d4e88d014674673fd969fc6a"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1ODE0MQ==", "bodyText": "typo: trailing", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441658141", "createdAt": "2020-06-17T16:02:58Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -194,6 +231,7 @@ private PinotExpression handleCast(CallExpression cast, Function<VariableReferen\n                         return expression;\n                     }\n                     if (input.getType() == VarcharType.VARCHAR) {\n+                        // Remove the leading & tailing quote then parse", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcf551edfa2f1b84d4e88d014674673fd969fc6a"}, "originalPosition": 104}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e51c1e33e9c4941e2770c9da0f74338f83d131af", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/e51c1e33e9c4941e2770c9da0f74338f83d131af", "committedDate": "2020-06-18T00:07:26Z", "message": "Address comments"}, "afterCommit": {"oid": "ffdaa42e257a1294ce600658526065a2a1465988", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/ffdaa42e257a1294ce600658526065a2a1465988", "committedDate": "2020-06-18T00:12:19Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ffdaa42e257a1294ce600658526065a2a1465988", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/ffdaa42e257a1294ce600658526065a2a1465988", "committedDate": "2020-06-18T00:12:19Z", "message": "Address comments"}, "afterCommit": {"oid": "f4c2152772cf65635b3c6a20d0258b115efdb623", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/f4c2152772cf65635b3c6a20d0258b115efdb623", "committedDate": "2020-06-18T00:15:48Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f4c2152772cf65635b3c6a20d0258b115efdb623", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/f4c2152772cf65635b3c6a20d0258b115efdb623", "committedDate": "2020-06-18T00:15:48Z", "message": "Address comments"}, "afterCommit": {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/7329acd418feff6875ba7b5ab137a38f857bade0", "committedDate": "2020-06-18T00:21:32Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/7329acd418feff6875ba7b5ab137a38f857bade0", "committedDate": "2020-06-18T00:21:32Z", "message": "Address comments"}, "afterCommit": {"oid": "8e3ab8eb8b97e9e42c084d7e725a89706bbb7df0", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/8e3ab8eb8b97e9e42c084d7e725a89706bbb7df0", "committedDate": "2020-06-18T02:48:04Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODk4Nzky", "url": "https://github.com/prestodb/presto/pull/14646#pullrequestreview-432898792", "createdAt": "2020-06-18T02:31:03Z", "commit": {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMjozMTowM1rOGldfrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMjo0ODoxMFrOGldwqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzMzc0Mw==", "bodyText": "<binary ops> -> <binary  op>", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441933743", "createdAt": "2020-06-18T02:31:03Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {\n+            if (!(rowExpression instanceof CallExpression)) {\n+                continue;\n+            }\n+            CallExpression callExpr = (CallExpression) rowExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                continue;\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                continue;\n+            }\n+            Type inputType = callExpr.getArguments().get(0).getType();\n+            Type expectedType = callExpr.getType();\n+            if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+                return true;\n+            }\n+            if ((inputType == TimestampType.TIMESTAMP || inputType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) && expectedType == DateType.DATE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String timeStampOrDateString)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return timeStampOrDateString;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return timeStampOrDateString;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return timeStampOrDateString;\n+        }\n+\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary ops> <DATE/TIMESTAMP literal>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzMzkzMg==", "bodyText": "Pinot stores time as: (remove underlying)", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441933932", "createdAt": "2020-06-18T02:31:48Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {\n+            if (!(rowExpression instanceof CallExpression)) {\n+                continue;\n+            }\n+            CallExpression callExpr = (CallExpression) rowExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                continue;\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                continue;\n+            }\n+            Type inputType = callExpr.getArguments().get(0).getType();\n+            Type expectedType = callExpr.getType();\n+            if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+                return true;\n+            }\n+            if ((inputType == TimestampType.TIMESTAMP || inputType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) && expectedType == DateType.DATE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String timeStampOrDateString)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return timeStampOrDateString;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return timeStampOrDateString;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return timeStampOrDateString;\n+        }\n+\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary ops> <DATE/TIMESTAMP literal>.\n+        // Pinot underlying stores time as:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNjE1Nw==", "bodyText": "Should this comment be moved to handleDateOrTimestampBinaryExpression since it has a reference to the \"binary op\" ?", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441936157", "createdAt": "2020-06-18T02:40:38Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {\n+            if (!(rowExpression instanceof CallExpression)) {\n+                continue;\n+            }\n+            CallExpression callExpr = (CallExpression) rowExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                continue;\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                continue;\n+            }\n+            Type inputType = callExpr.getArguments().get(0).getType();\n+            Type expectedType = callExpr.getType();\n+            if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+                return true;\n+            }\n+            if ((inputType == TimestampType.TIMESTAMP || inputType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) && expectedType == DateType.DATE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String timeStampOrDateString)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return timeStampOrDateString;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return timeStampOrDateString;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return timeStampOrDateString;\n+        }\n+\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary ops> <DATE/TIMESTAMP literal>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNjgzMA==", "bodyText": "How about naming rowExpression to 'argument' ?\nCan you please add a Preconditions.checkState that arguments.size() == 2, I think this is only called in the binary codepath  ?\nI didn't follow why we return success right away when the first argument matches. It seems you want exactly one of these two cases:\n\nLeft should be a cast of the valid type, right should be a literal (ConstantExpression)\nRight should be a cast of the valid type, Left should be a literal (ConstantExpression)\n\nWhereas this function is being a bit more permissive than that. The reason I am concerned about that permissiveness is because then we will eventually crap out at line 185 or 194 below. Is it possible to tighten the check ?", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441936830", "createdAt": "2020-06-18T02:43:15Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNzMwMQ==", "bodyText": "This will enable to work inside Pinot.\nI think the use of the word underlying is superfluous.", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441937301", "createdAt": "2020-06-18T02:45:07Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {\n+            if (!(rowExpression instanceof CallExpression)) {\n+                continue;\n+            }\n+            CallExpression callExpr = (CallExpression) rowExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                continue;\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                continue;\n+            }\n+            Type inputType = callExpr.getArguments().get(0).getType();\n+            Type expectedType = callExpr.getType();\n+            if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+                return true;\n+            }\n+            if ((inputType == TimestampType.TIMESTAMP || inputType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) && expectedType == DateType.DATE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String timeStampOrDateString)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return timeStampOrDateString;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return timeStampOrDateString;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return timeStampOrDateString;\n+        }\n+\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary ops> <DATE/TIMESTAMP literal>.\n+        // Pinot underlying stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // So below code will convert `current_time` in `millisSinceEpoch` value to `daysSinceEpoch` value.\n+        // Then the comparison underlying inside Pinot will work.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzODA4OQ==", "bodyText": "I really liked the block comment you added on line 163: I am wondering if it is possible to add a similar level of explanation here ?\nAlso, we do special handling for date expectedType. I am not sure we need to handle timestamp types too ?", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441938089", "createdAt": "2020-06-18T02:48:10Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -141,6 +240,22 @@ private PinotExpression handleCast(CallExpression cast, Function<VariableReferen\n             if (typeManager.canCoerce(input.getType(), expectedType)) {\n                 return input.accept(this, context);\n             }\n+            if (expectedType == DateType.DATE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0"}, "originalPosition": 150}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e3ab8eb8b97e9e42c084d7e725a89706bbb7df0", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/8e3ab8eb8b97e9e42c084d7e725a89706bbb7df0", "committedDate": "2020-06-18T02:48:04Z", "message": "Address comments"}, "afterCommit": {"oid": "863ab2a47d7ff4a68379725e8ca858caf6d275c8", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/863ab2a47d7ff4a68379725e8ca858caf6d275c8", "committedDate": "2020-06-18T09:02:57Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "863ab2a47d7ff4a68379725e8ca858caf6d275c8", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/863ab2a47d7ff4a68379725e8ca858caf6d275c8", "committedDate": "2020-06-18T09:02:57Z", "message": "Address comments"}, "afterCommit": {"oid": "70729d5e98c63d0770f475fc52368032570d7f07", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/70729d5e98c63d0770f475fc52368032570d7f07", "committedDate": "2020-06-18T09:24:52Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70729d5e98c63d0770f475fc52368032570d7f07", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/70729d5e98c63d0770f475fc52368032570d7f07", "committedDate": "2020-06-18T09:24:52Z", "message": "Address comments"}, "afterCommit": {"oid": "916e095701ce9b4380f5df0b60fe8019a2ff0d57", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/916e095701ce9b4380f5df0b60fe8019a2ff0d57", "committedDate": "2020-06-19T02:49:32Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzcwNTUz", "url": "https://github.com/prestodb/presto/pull/14646#pullrequestreview-433770553", "createdAt": "2020-06-19T02:53:47Z", "commit": {"oid": "916e095701ce9b4380f5df0b60fe8019a2ff0d57"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjo1Mzo0N1rOGmGaFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjo1ODowM1rOGmGd0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNDA1NA==", "bodyText": "Small comment nit: Handle queries like millisSinceEpoch < 1391126400000", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442604054", "createdAt": "2020-06-19T02:53:47Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -171,9 +297,28 @@ public PinotExpression visitCall(CallExpression call, Function<VariableReference\n                 return handleLogicalBinary(operatorType.getOperator(), call, context);\n             }\n         }\n+        // This is the handling to allow queries like `millisSinceEpoch < 1391126400000` been handled correctly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "916e095701ce9b4380f5df0b60fe8019a2ff0d57"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNDQyOA==", "bodyText": "I am not sure where my previous comment went, but should we rename this method to handleDateAndTimestampMagicLiteralFunction ? (Magic literal function is how presto refers to them ... see LiteralEncoder)", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442604428", "createdAt": "2020-06-19T02:55:36Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -171,9 +297,28 @@ public PinotExpression visitCall(CallExpression call, Function<VariableReference\n                 return handleLogicalBinary(operatorType.getOperator(), call, context);\n             }\n         }\n+        // This is the handling to allow queries like `millisSinceEpoch < 1391126400000` been handled correctly.\n+        // Otherwise TypeManager.canCoerce(...) will return false and directly fail this query.\n+        if (functionMetadata.getName().getFunctionName().equalsIgnoreCase(\"$literal$timestamp\") ||\n+                    functionMetadata.getName().getFunctionName().equalsIgnoreCase(\"$literal$date\")) {\n+            return handleDateAndTimestamp(call, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "916e095701ce9b4380f5df0b60fe8019a2ff0d57"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTAxMA==", "bodyText": "Should the above comment read:\nExpression like DATE '2014-01-31' is not cast to a constant number (like days since epoch) and thus it needs to be specifically handled here.\nI feel that the daysSinceEpoch reference is ambiguous: Because you also refer it to mean a Pinot column name in other places.", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442605010", "createdAt": "2020-06-19T02:58:03Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -141,6 +246,27 @@ private PinotExpression handleCast(CallExpression cast, Function<VariableReferen\n             if (typeManager.canCoerce(input.getType(), expectedType)) {\n                 return input.accept(this, context);\n             }\n+            // Special handling for Date type casting. Expression like `DATE '2014-01-31'` is not cast to daysSinceEpoch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "916e095701ce9b4380f5df0b60fe8019a2ff0d57"}, "originalPosition": 157}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "916e095701ce9b4380f5df0b60fe8019a2ff0d57", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/916e095701ce9b4380f5df0b60fe8019a2ff0d57", "committedDate": "2020-06-19T02:49:32Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}, "afterCommit": {"oid": "24134fe9be4669768c233993d9caa7d082c3995c", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/24134fe9be4669768c233993d9caa7d082c3995c", "committedDate": "2020-06-19T03:56:43Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "24134fe9be4669768c233993d9caa7d082c3995c", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/24134fe9be4669768c233993d9caa7d082c3995c", "committedDate": "2020-06-19T03:56:43Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}, "afterCommit": {"oid": "05c03240fef4accf22745885103d166d9357cee3", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/05c03240fef4accf22745885103d166d9357cee3", "committedDate": "2020-06-19T05:28:48Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MzI5Njk5", "url": "https://github.com/prestodb/presto/pull/14646#pullrequestreview-434329699", "createdAt": "2020-06-19T20:36:38Z", "commit": {"oid": "05c03240fef4accf22745885103d166d9357cee3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMDozNjozOFrOGmgpwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMDozNjozOFrOGmgpwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNDA1MA==", "bodyText": "Should this comment be amended ? Perhaps something like: \"Check if call compares a date/time column with a date/time constant. Otherwise just treat it like a regular binary operator.\"", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443034050", "createdAt": "2020-06-19T20:36:38Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c03240fef4accf22745885103d166d9357cee3"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MzMwMTg1", "url": "https://github.com/prestodb/presto/pull/14646#pullrequestreview-434330185", "createdAt": "2020-06-19T20:37:47Z", "commit": {"oid": "05c03240fef4accf22745885103d166d9357cee3"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMDozNzo0N1rOGmgsdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQyMDo0MTo1N1rOGmgxnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNDc0MQ==", "bodyText": "I am sorry, I was wrong: I think this comment is really best suited now for handleTimeValueCast. There is no current_time/millisecondsSinceEpoch below.", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443034741", "createdAt": "2020-06-19T20:37:47Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c03240fef4accf22745885103d166d9357cee3"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNTAyNQ==", "bodyText": "Its just a little bit weird to have the \"left\" arguments at the end. I am wondering if it would be simpler to read by changing the order of arguments to:\n        Optional<String> left = handleTimeValueCast(arguments.get(0), leftDefinition, arguments.get(1));", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443035025", "createdAt": "2020-06-19T20:38:45Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        String leftDefinition = arguments.get(0).accept(this, context).getDefinition();\n+        String rightDefinition = arguments.get(1).accept(this, context).getDefinition();\n+        Optional<String> left = handleTimeValueCast(arguments.get(1), arguments.get(0), leftDefinition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c03240fef4accf22745885103d166d9357cee3"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNTExOQ==", "bodyText": "Can be private static", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443035119", "createdAt": "2020-06-19T20:39:03Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        String leftDefinition = arguments.get(0).accept(this, context).getDefinition();\n+        String rightDefinition = arguments.get(1).accept(this, context).getDefinition();\n+        Optional<String> left = handleTimeValueCast(arguments.get(1), arguments.get(0), leftDefinition);\n+        Optional<String> right = handleTimeValueCast(arguments.get(0), arguments.get(1), rightDefinition);\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private boolean isDateTimeConstantType(Type type)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c03240fef4accf22745885103d166d9357cee3"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNjA2MA==", "bodyText": "I think that giant block of comment makes more sense for this method. Perhaps also amend that block to inform what the Optional.empty return signifies", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443036060", "createdAt": "2020-06-19T20:41:57Z", "author": {"login": "agrawaldevesh"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        String leftDefinition = arguments.get(0).accept(this, context).getDefinition();\n+        String rightDefinition = arguments.get(1).accept(this, context).getDefinition();\n+        Optional<String> left = handleTimeValueCast(arguments.get(1), arguments.get(0), leftDefinition);\n+        Optional<String> right = handleTimeValueCast(arguments.get(0), arguments.get(1), rightDefinition);\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private boolean isDateTimeConstantType(Type type)\n+    {\n+        return type == DateType.DATE || type == TimestampType.TIMESTAMP || type == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+    }\n+\n+    private Optional<String> handleTimeValueCast(RowExpression timeFieldExpression, RowExpression timeValueExpression, String timeValueString)\n+    {\n+        Type inputType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05c03240fef4accf22745885103d166d9357cee3"}, "originalPosition": 93}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "05c03240fef4accf22745885103d166d9357cee3", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/05c03240fef4accf22745885103d166d9357cee3", "committedDate": "2020-06-19T05:28:48Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}, "afterCommit": {"oid": "0b163630dd0b47a9f574bcba83d7780ae88e893b", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/0b163630dd0b47a9f574bcba83d7780ae88e893b", "committedDate": "2020-06-19T20:58:49Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0b163630dd0b47a9f574bcba83d7780ae88e893b", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/0b163630dd0b47a9f574bcba83d7780ae88e893b", "committedDate": "2020-06-19T20:58:49Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}, "afterCommit": {"oid": "cde22b2b632a42255e21a5450169daf2fe072050", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/cde22b2b632a42255e21a5450169daf2fe072050", "committedDate": "2020-06-19T22:07:55Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cde22b2b632a42255e21a5450169daf2fe072050", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/cde22b2b632a42255e21a5450169daf2fe072050", "committedDate": "2020-06-19T22:07:55Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}, "afterCommit": {"oid": "006cb09b9c61852a36140d3340c7467ec35d8ac4", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/006cb09b9c61852a36140d3340c7467ec35d8ac4", "committedDate": "2020-06-20T00:04:30Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "006cb09b9c61852a36140d3340c7467ec35d8ac4", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/006cb09b9c61852a36140d3340c7467ec35d8ac4", "committedDate": "2020-06-20T00:04:30Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}, "afterCommit": {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/eeac2d1744b01f2233e41fbef704e6e09ac46e25", "committedDate": "2020-06-20T11:02:28Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDgzMTgz", "url": "https://github.com/prestodb/presto/pull/14646#pullrequestreview-434483183", "createdAt": "2020-06-21T08:58:33Z", "commit": {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwODo1ODozM1rOGmqq_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwOTowMDoxOFrOGmqrig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODIwNw==", "bodyText": "Directly return without else branch", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198207", "createdAt": "2020-06-21T08:58:33Z", "author": {"login": "highker"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Check if call compares a date/time column with a date/time constant. Otherwise just treat it like a regular binary operator.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        Optional<String> left = handleTimeValueCast(context, arguments.get(1), arguments.get(0));\n+        Optional<String> right = handleTimeValueCast(context, arguments.get(0), arguments.get(1));\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODIzNQ==", "bodyText": "callExpression", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198235", "createdAt": "2020-06-21T08:59:00Z", "author": {"login": "highker"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Check if call compares a date/time column with a date/time constant. Otherwise just treat it like a regular binary operator.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        Optional<String> left = handleTimeValueCast(context, arguments.get(1), arguments.get(0));\n+        Optional<String> right = handleTimeValueCast(context, arguments.get(0), arguments.get(1));\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean isDateTimeConstantType(Type type)\n+    {\n+        return type == DateType.DATE || type == TimestampType.TIMESTAMP || type == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+    }\n+\n+    private Optional<String> handleTimeValueCast(Function<VariableReferenceExpression, Selection> context, RowExpression timeFieldExpression, RowExpression timeValueExpression)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        //   - if not compatible time types, returns Optional.empty(), indicates no change has been made in this cast.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        Type inputType;\n+        Type expectedType;\n+        if (!isDateTimeConstantType(timeFieldExpression.getType()) || !isDateTimeConstantType(timeValueExpression.getType())) {\n+            return Optional.empty();\n+        }\n+        String timeValueString = timeValueExpression.accept(this, context).getDefinition();\n+        if (timeFieldExpression instanceof CallExpression) {\n+            // Handles cases like: `cast(eventDate as TIMESTAMP) <  DATE '2014-01-31'`\n+            // For cast function,\n+            // - inputType is the argument type,\n+            // - expectedType is the cast function return type.\n+            CallExpression callExpr = (CallExpression) timeFieldExpression;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODI1OA==", "bodyText": "same", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198258", "createdAt": "2020-06-21T08:59:18Z", "author": {"login": "highker"}, "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Check if call compares a date/time column with a date/time constant. Otherwise just treat it like a regular binary operator.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        Optional<String> left = handleTimeValueCast(context, arguments.get(1), arguments.get(0));\n+        Optional<String> right = handleTimeValueCast(context, arguments.get(0), arguments.get(1));\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean isDateTimeConstantType(Type type)\n+    {\n+        return type == DateType.DATE || type == TimestampType.TIMESTAMP || type == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+    }\n+\n+    private Optional<String> handleTimeValueCast(Function<VariableReferenceExpression, Selection> context, RowExpression timeFieldExpression, RowExpression timeValueExpression)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        //   - if not compatible time types, returns Optional.empty(), indicates no change has been made in this cast.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        Type inputType;\n+        Type expectedType;\n+        if (!isDateTimeConstantType(timeFieldExpression.getType()) || !isDateTimeConstantType(timeValueExpression.getType())) {\n+            return Optional.empty();\n+        }\n+        String timeValueString = timeValueExpression.accept(this, context).getDefinition();\n+        if (timeFieldExpression instanceof CallExpression) {\n+            // Handles cases like: `cast(eventDate as TIMESTAMP) <  DATE '2014-01-31'`\n+            // For cast function,\n+            // - inputType is the argument type,\n+            // - expectedType is the cast function return type.\n+            CallExpression callExpr = (CallExpression) timeFieldExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                return Optional.empty();\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                return Optional.empty();\n+            }\n+            inputType = callExpr.getArguments().get(0).getType();\n+            expectedType = callExpr.getType();\n+        }\n+        else if (timeFieldExpression instanceof VariableReferenceExpression) {\n+            // For VariableReferenceExpression,\n+            // Handles queries like: `eventDate <  TIMESTAMP '2014-01-31 00:00:00 UTC'`\n+            // - inputType is timeFieldExpression type,\n+            // - expectedType is the timeValueExpression type.\n+            inputType = timeFieldExpression.getType();\n+            expectedType = timeValueExpression.getType();\n+        }\n+        else if (timeFieldExpression instanceof ConstantExpression) {\n+            // timeFieldExpression is a ConstantExpression, directly return.\n+            return Optional.of(timeValueString);\n+        }\n+        else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODMxNg==", "bodyText": "planBuilder", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198316", "createdAt": "2020-06-21T08:59:56Z", "author": {"login": "highker"}, "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/query/TestPinotPlanOptimizer.java", "diffHunk": "@@ -207,6 +207,66 @@ public void testPartialPredicatePushdown()\n         assertPlanMatch(optimized, PlanMatchPattern.limit(50L, PlanMatchPattern.filter(\"lower(substr(city, 0, 3)) = 'del'\", tableScanMatcher)), typeProvider);\n     }\n \n+    @Test\n+    public void testDatePredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODM0MQ==", "bodyText": "same", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198341", "createdAt": "2020-06-21T09:00:14Z", "author": {"login": "highker"}, "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/query/TestPinotPlanOptimizer.java", "diffHunk": "@@ -207,6 +207,66 @@ public void testPartialPredicatePushdown()\n         assertPlanMatch(optimized, PlanMatchPattern.limit(50L, PlanMatchPattern.filter(\"lower(substr(city, 0, 3)) = 'del'\", tableScanMatcher)), typeProvider);\n     }\n \n+    @Test\n+    public void testDatePredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);\n+        FilterNode filter = filter(pb, tableScan(pb, pinotTable, regionId, city, fare, daysSinceEpoch), getRowExpression(\"dayssinceepoch < DATE '2014-01-31'\", defaultSessionHolder));\n+        PlanNode originalPlan = limit(pb, 50L, filter);\n+        PlanNode optimized = getOptimizedPlan(pb, originalPlan);\n+        assertPlanMatch(optimized, PinotTableScanMatcher.match(pinotTable, Optional.of(\"SELECT regionId, city, fare, daysSinceEpoch FROM hybrid WHERE \\\\(daysSinceEpoch < 16101\\\\) LIMIT 50\"), Optional.of(false), originalPlan.getOutputVariables()), typeProvider);\n+    }\n+\n+    @Test\n+    public void testDateCastingPredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODM0Ng==", "bodyText": "same and all other places", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198346", "createdAt": "2020-06-21T09:00:18Z", "author": {"login": "highker"}, "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/query/TestPinotPlanOptimizer.java", "diffHunk": "@@ -207,6 +207,66 @@ public void testPartialPredicatePushdown()\n         assertPlanMatch(optimized, PlanMatchPattern.limit(50L, PlanMatchPattern.filter(\"lower(substr(city, 0, 3)) = 'del'\", tableScanMatcher)), typeProvider);\n     }\n \n+    @Test\n+    public void testDatePredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);\n+        FilterNode filter = filter(pb, tableScan(pb, pinotTable, regionId, city, fare, daysSinceEpoch), getRowExpression(\"dayssinceepoch < DATE '2014-01-31'\", defaultSessionHolder));\n+        PlanNode originalPlan = limit(pb, 50L, filter);\n+        PlanNode optimized = getOptimizedPlan(pb, originalPlan);\n+        assertPlanMatch(optimized, PinotTableScanMatcher.match(pinotTable, Optional.of(\"SELECT regionId, city, fare, daysSinceEpoch FROM hybrid WHERE \\\\(daysSinceEpoch < 16101\\\\) LIMIT 50\"), Optional.of(false), originalPlan.getOutputVariables()), typeProvider);\n+    }\n+\n+    @Test\n+    public void testDateCastingPredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);\n+        FilterNode filter = filter(pb, tableScan(pb, pinotTable, regionId, city, fare, daysSinceEpoch), getRowExpression(\"cast(dayssinceepoch as timestamp) < TIMESTAMP '2014-01-31 00:00:00 UTC'\", defaultSessionHolder));\n+        PlanNode originalPlan = limit(pb, 50L, filter);\n+        PlanNode optimized = getOptimizedPlan(pb, originalPlan);\n+        assertPlanMatch(optimized, PinotTableScanMatcher.match(pinotTable, Optional.of(\"SELECT regionId, city, fare, daysSinceEpoch FROM hybrid WHERE \\\\(daysSinceEpoch < 16101\\\\) LIMIT 50\"), Optional.of(false), originalPlan.getOutputVariables()), typeProvider);\n+    }\n+\n+    @Test\n+    public void testTimestampPredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25"}, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/eeac2d1744b01f2233e41fbef704e6e09ac46e25", "committedDate": "2020-06-20T11:02:28Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}, "afterCommit": {"oid": "3507b3b0d1c8fd7000238b15f725cb838e7c98c5", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/3507b3b0d1c8fd7000238b15f725cb838e7c98c5", "committedDate": "2020-06-21T09:47:10Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3507b3b0d1c8fd7000238b15f725cb838e7c98c5", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/3507b3b0d1c8fd7000238b15f725cb838e7c98c5", "committedDate": "2020-06-21T09:47:10Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}, "afterCommit": {"oid": "33fac60ee6e81f29c2ec93b1ed59a1b43d8a994f", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/33fac60ee6e81f29c2ec93b1ed59a1b43d8a994f", "committedDate": "2020-06-21T10:31:30Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NDI2ODg4", "url": "https://github.com/prestodb/presto/pull/14646#pullrequestreview-435426888", "createdAt": "2020-06-23T04:14:06Z", "commit": {"oid": "33fac60ee6e81f29c2ec93b1ed59a1b43d8a994f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33fac60ee6e81f29c2ec93b1ed59a1b43d8a994f", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/33fac60ee6e81f29c2ec93b1ed59a1b43d8a994f", "committedDate": "2020-06-21T10:31:30Z", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals."}, "afterCommit": {"oid": "42dc4034eab75adadee8939bd2003e070a99ab09", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/42dc4034eab75adadee8939bd2003e070a99ab09", "committedDate": "2020-06-23T04:16:02Z", "message": "Adding time type support for Pinot predicate pushdown"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42dc4034eab75adadee8939bd2003e070a99ab09", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/42dc4034eab75adadee8939bd2003e070a99ab09", "committedDate": "2020-06-23T04:16:02Z", "message": "Adding time type support for Pinot predicate pushdown"}, "afterCommit": {"oid": "991dcb325da67bad5356e3581e4b065c793a0315", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/991dcb325da67bad5356e3581e4b065c793a0315", "committedDate": "2020-06-23T05:58:57Z", "message": "Adding time type support for Pinot predicate pushdown"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "991dcb325da67bad5356e3581e4b065c793a0315", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/991dcb325da67bad5356e3581e4b065c793a0315", "committedDate": "2020-06-23T05:58:57Z", "message": "Adding time type support for Pinot predicate pushdown"}, "afterCommit": {"oid": "e4863b029faed4f00482a9e86647a69747b51131", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/e4863b029faed4f00482a9e86647a69747b51131", "committedDate": "2020-06-23T07:23:28Z", "message": "Adding time type support for Pinot predicate pushdown"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e4863b029faed4f00482a9e86647a69747b51131", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/e4863b029faed4f00482a9e86647a69747b51131", "committedDate": "2020-06-23T07:23:28Z", "message": "Adding time type support for Pinot predicate pushdown"}, "afterCommit": {"oid": "18f2944946a3ded70efd81591aecc5af8c4daef4", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/18f2944946a3ded70efd81591aecc5af8c4daef4", "committedDate": "2020-06-23T10:27:49Z", "message": "Adding time type support for Pinot predicate pushdown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7720de564c2724171c4874f65aae9ef7b8c49b9", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/d7720de564c2724171c4874f65aae9ef7b8c49b9", "committedDate": "2020-06-23T11:51:55Z", "message": "Adding time type support for Pinot predicate pushdown"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "18f2944946a3ded70efd81591aecc5af8c4daef4", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/18f2944946a3ded70efd81591aecc5af8c4daef4", "committedDate": "2020-06-23T10:27:49Z", "message": "Adding time type support for Pinot predicate pushdown"}, "afterCommit": {"oid": "d7720de564c2724171c4874f65aae9ef7b8c49b9", "author": {"user": {"login": "xiangfu0", "name": "Xiang Fu"}}, "url": "https://github.com/prestodb/presto/commit/d7720de564c2724171c4874f65aae9ef7b8c49b9", "committedDate": "2020-06-23T11:51:55Z", "message": "Adding time type support for Pinot predicate pushdown"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1374, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}