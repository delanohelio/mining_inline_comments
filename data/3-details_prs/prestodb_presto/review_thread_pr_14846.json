{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwMjkzMDcy", "number": 14846, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNDozNVrOEPovCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNTo1OVrOEPowuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODMxNDk2OnYy", "diffSide": "RIGHT", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNDozNVrOGzdP4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTowMjowNlrOGzeCCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwOTc2MA==", "bodyText": "Is this a copy of what's in TestEventListenerPlugin?  You should be able to use those classes directly, e.g. like TestCompletedEventWarnings (maybe worth extracting all these TestingEventListener things to a top level class since it's used across multiple test classes", "url": "https://github.com/prestodb/presto/pull/14846#discussion_r456609760", "createdAt": "2020-07-17T18:34:35Z", "author": {"login": "rschlussel"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.StageId;\n+import com.facebook.presto.spi.Plugin;\n+import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.spi.eventlistener.EventListener;\n+import com.facebook.presto.spi.eventlistener.EventListenerFactory;\n+import com.facebook.presto.spi.eventlistener.QueryCompletedEvent;\n+import com.facebook.presto.spi.eventlistener.QueryCreatedEvent;\n+import com.facebook.presto.spi.eventlistener.QueryMetadata;\n+import com.facebook.presto.spi.eventlistener.SplitCompletedEvent;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.facebook.presto.tests.DistributedQueryRunner;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.facebook.presto.hive.HiveQueryRunner.createQueryRunner;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.tpch.TpchTable.getTables;\n+import static java.util.Objects.requireNonNull;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestEventListenerWithExchangeMaterialization\n+{\n+    private EventsBuilder generatedEvents = new EventsBuilder();\n+    private DistributedQueryRunner queryRunner;\n+    private Session session;\n+\n+    @BeforeClass\n+    private void setUp()\n+            throws Exception\n+    {\n+        queryRunner = createQueryRunner(\n+                getTables(),\n+                new ImmutableMap.Builder<String, String>()\n+                        .put(\"query.partitioning-provider-catalog\", \"hive\")\n+                        .put(\"query.exchange-materialization-strategy\", \"ALL\")\n+                        .put(\"experimental.runtime-optimizer-enabled\", \"true\")\n+                        .put(\"experimental.enable-stats-collection-for-temporary-table\", \"true\")\n+                        .put(\"join-distribution-type\", \"PARTITIONED\")\n+                        .put(\"query.hash-partition-count\", \"11\")\n+                        .put(\"colocated-joins-enabled\", \"true\")\n+                        .put(\"grouped-execution-for-aggregation-enabled\", \"true\")\n+                        .build(),\n+                Optional.empty());\n+        queryRunner.installPlugin(new TestingEventListenerPlugin(generatedEvents));\n+        session = queryRunner.getDefaultSession();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    private void tearDown()\n+    {\n+        queryRunner.close();\n+        queryRunner = null;\n+        session = null;\n+        generatedEvents = null;\n+    }\n+\n+    private MaterializedResult runQueryAndWaitForEvents(@Language(\"SQL\") String sql, int numEventsExpected)\n+            throws Exception\n+    {\n+        generatedEvents.initialize(numEventsExpected);\n+        MaterializedResult result = queryRunner.execute(session, sql);\n+        generatedEvents.waitForEvents(10);\n+        return result;\n+    }\n+\n+    @Test\n+    public void testRuntimeOptimizedStagesCorrectness()\n+            throws Exception\n+    {\n+        // We expect one runtime optimized stage: 1.\n+        int expectedEvents = 2;\n+        runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey\", expectedEvents);\n+        QueryCreatedEvent queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n+        QueryCompletedEvent queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n+        QueryMetadata queryMetadata = queryCompletedEvent.getMetadata();\n+        Optional<List<StageId>> runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n+\n+        assertTrue(runtimeOptimizedStages.isPresent() && !queryMetadata.getRuntimeOptimizedStages().isEmpty());\n+        assertTrue(queryMetadata.getRuntimeOptimizedStages().size() == 1 && runtimeOptimizedStages.get().size() == 1);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                .map(stageId -> String.valueOf(stageId.getId()))\n+                .collect(toImmutableList()));\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+\n+        // Now, the following query should not trigger runtime optimizations, so should have empty list of runtime optimized stages.\n+        runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM supplier INNER JOIN nation ON supplier.nationkey=nation.nationkey\", expectedEvents);\n+        queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n+        queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n+        runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n+\n+        assertFalse(runtimeOptimizedStages.isPresent());\n+        assertTrue(queryCompletedEvent.getMetadata().getRuntimeOptimizedStages().isEmpty());\n+\n+        // Now, the following query should have two optimized joins in a single stage (both on the same nationkey), therefore expect only one optimized stage: 1.\n+        runQueryAndWaitForEvents(\"SELECT supplier.phone, regionkey, custkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey INNER JOIN customer ON nation.nationkey=customer.nationkey\", expectedEvents);\n+        queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n+        queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n+        queryMetadata = queryCompletedEvent.getMetadata();\n+        runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n+\n+        assertTrue(runtimeOptimizedStages.isPresent() && !queryMetadata.getRuntimeOptimizedStages().isEmpty());\n+        assertTrue(queryMetadata.getRuntimeOptimizedStages().size() == 1 && runtimeOptimizedStages.get().size() == 1);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                .map(stageId -> String.valueOf(stageId.getId()))\n+                .collect(toImmutableList()));\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+\n+        // Now, the following query should have two runtime optimized stages: 1 and 4, corresponding to the two join operations (on regionkey and nationkey respectively).\n+        runQueryAndWaitForEvents(\"WITH natreg AS (SELECT nation.regionkey, nationkey, region.name FROM region INNER JOIN nation ON nation.regionkey=region.regionkey) SELECT phone, regionkey FROM natreg INNER JOIN supplier ON supplier.nationkey=natreg.nationkey\", expectedEvents);\n+        queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n+        queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n+        queryMetadata = queryCompletedEvent.getMetadata();\n+        runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n+\n+        assertTrue(runtimeOptimizedStages.isPresent() && !queryMetadata.getRuntimeOptimizedStages().isEmpty());\n+        assertTrue(queryMetadata.getRuntimeOptimizedStages().size() == 2 && runtimeOptimizedStages.get().size() == 2);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                .map(stageId -> String.valueOf(stageId.getId()))\n+                .collect(toImmutableList()));\n+        assertEquals(ImmutableSet.copyOf(queryMetadata.getRuntimeOptimizedStages()), ImmutableSet.of(\"1\", \"4\"));\n+    }\n+\n+    static class TestingEventListenerPlugin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "155d465b5d19b1982ef8867c38fa3fca21748197"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYyMjYwMA==", "bodyText": "Discussed offline that as this test has to be under presto-hive to naturally enable exchange materialization, it is ok to leave it as it is because it is not directly accessible to TestEventListenerPlugin class.", "url": "https://github.com/prestodb/presto/pull/14846#discussion_r456622600", "createdAt": "2020-07-17T19:02:06Z", "author": {"login": "pguofb"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.StageId;\n+import com.facebook.presto.spi.Plugin;\n+import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.spi.eventlistener.EventListener;\n+import com.facebook.presto.spi.eventlistener.EventListenerFactory;\n+import com.facebook.presto.spi.eventlistener.QueryCompletedEvent;\n+import com.facebook.presto.spi.eventlistener.QueryCreatedEvent;\n+import com.facebook.presto.spi.eventlistener.QueryMetadata;\n+import com.facebook.presto.spi.eventlistener.SplitCompletedEvent;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.facebook.presto.tests.DistributedQueryRunner;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.facebook.presto.hive.HiveQueryRunner.createQueryRunner;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.tpch.TpchTable.getTables;\n+import static java.util.Objects.requireNonNull;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestEventListenerWithExchangeMaterialization\n+{\n+    private EventsBuilder generatedEvents = new EventsBuilder();\n+    private DistributedQueryRunner queryRunner;\n+    private Session session;\n+\n+    @BeforeClass\n+    private void setUp()\n+            throws Exception\n+    {\n+        queryRunner = createQueryRunner(\n+                getTables(),\n+                new ImmutableMap.Builder<String, String>()\n+                        .put(\"query.partitioning-provider-catalog\", \"hive\")\n+                        .put(\"query.exchange-materialization-strategy\", \"ALL\")\n+                        .put(\"experimental.runtime-optimizer-enabled\", \"true\")\n+                        .put(\"experimental.enable-stats-collection-for-temporary-table\", \"true\")\n+                        .put(\"join-distribution-type\", \"PARTITIONED\")\n+                        .put(\"query.hash-partition-count\", \"11\")\n+                        .put(\"colocated-joins-enabled\", \"true\")\n+                        .put(\"grouped-execution-for-aggregation-enabled\", \"true\")\n+                        .build(),\n+                Optional.empty());\n+        queryRunner.installPlugin(new TestingEventListenerPlugin(generatedEvents));\n+        session = queryRunner.getDefaultSession();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    private void tearDown()\n+    {\n+        queryRunner.close();\n+        queryRunner = null;\n+        session = null;\n+        generatedEvents = null;\n+    }\n+\n+    private MaterializedResult runQueryAndWaitForEvents(@Language(\"SQL\") String sql, int numEventsExpected)\n+            throws Exception\n+    {\n+        generatedEvents.initialize(numEventsExpected);\n+        MaterializedResult result = queryRunner.execute(session, sql);\n+        generatedEvents.waitForEvents(10);\n+        return result;\n+    }\n+\n+    @Test\n+    public void testRuntimeOptimizedStagesCorrectness()\n+            throws Exception\n+    {\n+        // We expect one runtime optimized stage: 1.\n+        int expectedEvents = 2;\n+        runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey\", expectedEvents);\n+        QueryCreatedEvent queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n+        QueryCompletedEvent queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n+        QueryMetadata queryMetadata = queryCompletedEvent.getMetadata();\n+        Optional<List<StageId>> runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n+\n+        assertTrue(runtimeOptimizedStages.isPresent() && !queryMetadata.getRuntimeOptimizedStages().isEmpty());\n+        assertTrue(queryMetadata.getRuntimeOptimizedStages().size() == 1 && runtimeOptimizedStages.get().size() == 1);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                .map(stageId -> String.valueOf(stageId.getId()))\n+                .collect(toImmutableList()));\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+\n+        // Now, the following query should not trigger runtime optimizations, so should have empty list of runtime optimized stages.\n+        runQueryAndWaitForEvents(\"SELECT phone, regionkey FROM supplier INNER JOIN nation ON supplier.nationkey=nation.nationkey\", expectedEvents);\n+        queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n+        queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n+        runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n+\n+        assertFalse(runtimeOptimizedStages.isPresent());\n+        assertTrue(queryCompletedEvent.getMetadata().getRuntimeOptimizedStages().isEmpty());\n+\n+        // Now, the following query should have two optimized joins in a single stage (both on the same nationkey), therefore expect only one optimized stage: 1.\n+        runQueryAndWaitForEvents(\"SELECT supplier.phone, regionkey, custkey FROM nation INNER JOIN supplier ON supplier.nationkey=nation.nationkey INNER JOIN customer ON nation.nationkey=customer.nationkey\", expectedEvents);\n+        queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n+        queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n+        queryMetadata = queryCompletedEvent.getMetadata();\n+        runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n+\n+        assertTrue(runtimeOptimizedStages.isPresent() && !queryMetadata.getRuntimeOptimizedStages().isEmpty());\n+        assertTrue(queryMetadata.getRuntimeOptimizedStages().size() == 1 && runtimeOptimizedStages.get().size() == 1);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                .map(stageId -> String.valueOf(stageId.getId()))\n+                .collect(toImmutableList()));\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages().get(0), \"1\");\n+\n+        // Now, the following query should have two runtime optimized stages: 1 and 4, corresponding to the two join operations (on regionkey and nationkey respectively).\n+        runQueryAndWaitForEvents(\"WITH natreg AS (SELECT nation.regionkey, nationkey, region.name FROM region INNER JOIN nation ON nation.regionkey=region.regionkey) SELECT phone, regionkey FROM natreg INNER JOIN supplier ON supplier.nationkey=natreg.nationkey\", expectedEvents);\n+        queryCreatedEvent = getOnlyElement(generatedEvents.getQueryCreatedEvents());\n+        queryCompletedEvent = getOnlyElement(generatedEvents.getQueryCompletedEvents());\n+        queryMetadata = queryCompletedEvent.getMetadata();\n+        runtimeOptimizedStages = queryRunner.getCoordinator().getQueryManager().getFullQueryInfo(new QueryId(queryCreatedEvent.getMetadata().getQueryId())).getRuntimeOptimizedStages();\n+\n+        assertTrue(runtimeOptimizedStages.isPresent() && !queryMetadata.getRuntimeOptimizedStages().isEmpty());\n+        assertTrue(queryMetadata.getRuntimeOptimizedStages().size() == 2 && runtimeOptimizedStages.get().size() == 2);\n+        assertEquals(queryMetadata.getRuntimeOptimizedStages(), runtimeOptimizedStages.get().stream()\n+                .map(stageId -> String.valueOf(stageId.getId()))\n+                .collect(toImmutableList()));\n+        assertEquals(ImmutableSet.copyOf(queryMetadata.getRuntimeOptimizedStages()), ImmutableSet.of(\"1\", \"4\"));\n+    }\n+\n+    static class TestingEventListenerPlugin", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwOTc2MA=="}, "originalCommit": {"oid": "155d465b5d19b1982ef8867c38fa3fca21748197"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODMxOTI5OnYy", "diffSide": "RIGHT", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNTo1OVrOGzdSkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNTo1OVrOGzdSkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMDQ1MQ==", "bodyText": "you should also set \"optimizer.join-reordering-strategy\" to \"ELIMINATE_CROSS_JOINS\"", "url": "https://github.com/prestodb/presto/pull/14846#discussion_r456610451", "createdAt": "2020-07-17T18:35:59Z", "author": {"login": "rschlussel"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestEventListenerWithExchangeMaterialization.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.StageId;\n+import com.facebook.presto.spi.Plugin;\n+import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.spi.eventlistener.EventListener;\n+import com.facebook.presto.spi.eventlistener.EventListenerFactory;\n+import com.facebook.presto.spi.eventlistener.QueryCompletedEvent;\n+import com.facebook.presto.spi.eventlistener.QueryCreatedEvent;\n+import com.facebook.presto.spi.eventlistener.QueryMetadata;\n+import com.facebook.presto.spi.eventlistener.SplitCompletedEvent;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.facebook.presto.tests.DistributedQueryRunner;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.facebook.presto.hive.HiveQueryRunner.createQueryRunner;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.tpch.TpchTable.getTables;\n+import static java.util.Objects.requireNonNull;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestEventListenerWithExchangeMaterialization\n+{\n+    private EventsBuilder generatedEvents = new EventsBuilder();\n+    private DistributedQueryRunner queryRunner;\n+    private Session session;\n+\n+    @BeforeClass\n+    private void setUp()\n+            throws Exception\n+    {\n+        queryRunner = createQueryRunner(\n+                getTables(),\n+                new ImmutableMap.Builder<String, String>()\n+                        .put(\"query.partitioning-provider-catalog\", \"hive\")\n+                        .put(\"query.exchange-materialization-strategy\", \"ALL\")\n+                        .put(\"experimental.runtime-optimizer-enabled\", \"true\")\n+                        .put(\"experimental.enable-stats-collection-for-temporary-table\", \"true\")\n+                        .put(\"join-distribution-type\", \"PARTITIONED\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "155d465b5d19b1982ef8867c38fa3fca21748197"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2374, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}