{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExOTA2ODk0", "number": 15369, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzozNjowN1rOEzm2jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzo1NjozNlrOEznfAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTQ5Mzg4OnYy", "diffSide": "RIGHT", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzozNjowN1rOHq8E4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNToyMzo0N1rOHrT_0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc4NjUzMA==", "bodyText": "nextTimeoutInMillis variable can be removed.", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514786530", "createdAt": "2020-10-30T03:36:07Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        try {\n+            while (true) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE3ODQ0OA==", "bodyText": "This is actually a bug. The nextTimeoutInMillis has to be used in the next action.get", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515178448", "createdAt": "2020-10-30T15:23:47Z", "author": {"login": "arhimondr"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        try {\n+            while (true) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc4NjUzMA=="}, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTU2Mjk5OnYy", "diffSide": "RIGHT", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzo0OTo1NVrOHq82uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNTozMTo0MVrOHrUYGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc5OTI5MQ==", "bodyText": "queryCompletionDeadline can be initialized immediately after queryStateTimer is created.", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514799291", "createdAt": "2020-10-30T03:49:55Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -728,13 +746,16 @@ private PrestoSparkQueryExecution(\n             this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n             this.pagesSerde = requireNonNull(pagesSerde, \"pagesSerde is null\");\n             this.executionExceptionFactory = requireNonNull(executionExceptionFactory, \"executionExceptionFactory is null\");\n+            this.queryTimeout = requireNonNull(queryTimeout, \"queryTimeout is null\");\n             this.queryStatusInfoOutputPath = requireNonNull(queryStatusInfoOutputPath, \"queryStatusInfoOutputPath is null\");\n             this.queryDataOutputPath = requireNonNull(queryDataOutputPath, \"queryDataOutputPath is null\");\n         }\n \n         @Override\n         public List<List<Object>> execute()\n         {\n+            queryCompletionDeadline = System.currentTimeMillis() + queryTimeout.toMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE4NDY2Nw==", "bodyText": "Done", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515184667", "createdAt": "2020-10-30T15:31:41Z", "author": {"login": "arhimondr"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -728,13 +746,16 @@ private PrestoSparkQueryExecution(\n             this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n             this.pagesSerde = requireNonNull(pagesSerde, \"pagesSerde is null\");\n             this.executionExceptionFactory = requireNonNull(executionExceptionFactory, \"executionExceptionFactory is null\");\n+            this.queryTimeout = requireNonNull(queryTimeout, \"queryTimeout is null\");\n             this.queryStatusInfoOutputPath = requireNonNull(queryStatusInfoOutputPath, \"queryStatusInfoOutputPath is null\");\n             this.queryDataOutputPath = requireNonNull(queryDataOutputPath, \"queryDataOutputPath is null\");\n         }\n \n         @Override\n         public List<List<Object>> execute()\n         {\n+            queryCompletionDeadline = System.currentTimeMillis() + queryTimeout.toMillis();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc5OTI5MQ=="}, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTU3NTY2OnYy", "diffSide": "RIGHT", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzo1MjoyNFrOHq8_oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOTo0NTowM1rOHrdzuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ==", "bodyText": "Why private static,  we can always read queryCompletionDeadline directly, which is simpler and guaranteed to be accurate.  Parameters timeout, timeUnit can be calculated from queryCompletionDeadline  and current time.", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514801569", "createdAt": "2020-10-30T03:52:24Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5MjU0MQ==", "bodyText": "Same question :)", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514892541", "createdAt": "2020-10-30T06:20:09Z", "author": {"login": "wenleix"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ=="}, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE4MjUzMQ==", "bodyText": "How strongly do you feel about that? I just thought that with encapsulation it will be more readable. Basically the logic in the PrestoSparkQueryExecution is responsible for determining now much time we need to wait for the next operation to finish, and this method simply implements waiting.", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515182531", "createdAt": "2020-10-30T15:29:23Z", "author": {"login": "arhimondr"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ=="}, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMzOTE5Mg==", "bodyText": "Maybe we can reuse this static function later", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515339192", "createdAt": "2020-10-30T19:45:03Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ=="}, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTU4MDUxOnYy", "diffSide": "RIGHT", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzo1MzoyN1rOHq9DKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNToyNzozNlrOHrUJzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMjQ3Mg==", "bodyText": "Curious, when would this scenario happens?", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514802472", "createdAt": "2020-10-30T03:53:27Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        try {\n+            while (true) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n+                }\n+                try {\n+                    return action.get(timeout, timeUnit);\n+                }\n+                catch (TimeoutException e) {\n+                    // guard against spurious wakeup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE4MTAwNg==", "bodyText": "I'm just being paranoid, in case the timeout mechanism in Spark is buggy. If you feel strongly about removing it - I can, i don't feel very strong.", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515181006", "createdAt": "2020-10-30T15:27:36Z", "author": {"login": "arhimondr"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        try {\n+            while (true) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n+                }\n+                try {\n+                    return action.get(timeout, timeUnit);\n+                }\n+                catch (TimeoutException e) {\n+                    // guard against spurious wakeup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMjQ3Mg=="}, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTU5NzQ3OnYy", "diffSide": "RIGHT", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzo1NjozNlrOHq9PTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNToyMjo1M1rOHrT8bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwNTU4Mw==", "bodyText": "Same comment as  waitForActionsCompletionWithTimeout", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514805583", "createdAt": "2020-10-30T03:56:36Z", "author": {"login": "viczhang861"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE3NzU4MA==", "bodyText": "getActionResultWithTimeout  is used by the RddAndMore#collectAndDestroyDependenciesWithTimeout", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515177580", "createdAt": "2020-10-30T15:22:53Z", "author": {"login": "arhimondr"}, "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwNTU4Mw=="}, "originalCommit": {"oid": "690225f1ef49eaf39f783ea176e15f8f01a3435e"}, "originalPosition": 217}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3347, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}