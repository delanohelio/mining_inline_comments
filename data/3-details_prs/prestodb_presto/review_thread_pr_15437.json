{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwNjg5Mjcx", "number": 15437, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODoxODo0OFrOE4x5TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo1MDoxMVrOFFwCIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTczMTk2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODoxODo0OFrOHy55ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODoxODo0OFrOHy55ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEzOTQzNA==", "bodyText": "Nit: add the units to the names (e.g., bytes, millis)", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523139434", "createdAt": "2020-11-13T18:18:48Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -79,19 +103,33 @@ private NodeTasks addNodeTask(InternalNode node)\n     private static class NodeTasks\n     {\n         private final Set<RemoteTask> remoteTasks = Sets.newConcurrentHashSet();\n-        private final AtomicInteger nodeTotalPartitionedSplitCount = new AtomicInteger();\n+        private final AtomicLong nodeTotalPartitionedSplitCount = new AtomicLong();\n+        private final AtomicLong nodeTotalMemoryUsage = new AtomicLong();\n+        private final AtomicLong nodeTotalCpuUsage = new AtomicLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTczNTgzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODoxOToyNlrOHy571w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODoyOTo1MVrOHy6URA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MDA1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private class TaskCumulativeStatsTracker\n          \n          \n            \n                    private class CumulativeTaskStatsTracker", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523140055", "createdAt": "2020-11-13T18:19:26Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +146,161 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsage);\n+            TaskCumulativeStatsTracker cpuUsageTracker = new TaskCumulativeStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuUsage, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        @ThreadSafe\n+        private class TaskCumulativeStatsTracker", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NjMwOA==", "bodyText": "Can you comment what this class is trying to do?  The class name doesn't seem to describe it well.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523146308", "createdAt": "2020-11-13T18:29:51Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +146,161 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsage);\n+            TaskCumulativeStatsTracker cpuUsageTracker = new TaskCumulativeStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuUsage, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        @ThreadSafe\n+        private class TaskCumulativeStatsTracker", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MDA1NQ=="}, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTc3MTA1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODoyODo1M1rOHy6SKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODoyODo1M1rOHy6SKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NTc3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (delta >= 0 && duration > 0) {\n          \n          \n            \n                                        return delta / duration;\n          \n          \n            \n                                    }\n          \n          \n            \n                                    else {\n          \n          \n            \n                                        throw new IllegalArgumentException(stat + \"delta is negative\");\n          \n          \n            \n                                    }\n          \n          \n            \n                                    checkArgument(delta >= 0 && duration > 0, \"stat + \"delta is negative\");\n          \n          \n            \n                                    return delta / duration;", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523145771", "createdAt": "2020-11-13T18:28:53Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +146,161 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsage);\n+            TaskCumulativeStatsTracker cpuUsageTracker = new TaskCumulativeStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuUsage, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        @ThreadSafe\n+        private class TaskCumulativeStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMilis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public TaskCumulativeStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMilis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.stat = requireNonNull(stat, \"stat is null\");\n+                this.windowSizeInMilis = windowSizeInMilis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAge, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAge, value);\n+                    values = values.tailMap(values.lastKey() - windowSizeInMilis);\n+                    if (values.size() > 1) {\n+                        Long firstReporting = values.firstKey();\n+                        Long lastAge = values.lastKey();\n+                        long delta = (value - values.get(firstReporting)) * 100;\n+                        long duration = lastAge - firstReporting;\n+                        if (delta >= 0 && duration > 0) {\n+                            return delta / duration;\n+                        }\n+                        else {\n+                            throw new IllegalArgumentException(stat + \"delta is negative\");\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTc4MDc1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODozMTo0MVrOHy6YAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODozMTo0MVrOHy6YAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NzI2Nw==", "bodyText": "Please add units to all names.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523147267", "createdAt": "2020-11-13T18:31:41Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -243,6 +244,20 @@ public long getPeakNodeTotalMemoryReservationInBytes()\n         return peakNodeTotalMemoryReservationInBytes;\n     }\n \n+    @JsonProperty\n+    @ThriftField(18)\n+    public long getTotalCpuTimeInNanos()\n+    {\n+        return totalCpuTimeInNanos;\n+    }\n+\n+    @JsonProperty\n+    @ThriftField(19)\n+    public long getTaskAge()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTc4NzgyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODozMzo0N1rOHy6cvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODozMzo0N1rOHy6cvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0ODQ3Ng==", "bodyText": "Unrelated change?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523148476", "createdAt": "2020-11-13T18:33:47Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -57,22 +57,19 @@\n     private final TaskState state;\n     private final URI self;\n     private final Set<Lifespan> completedDriverGroups;\n-\n+    private final List<ExecutionFailureInfo> failures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjY5MDM2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyNzoyN1rOH8IFIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyNzoyN1rOH8IFIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwODk5Mg==", "bodyText": "this is usually used for package private level access.\nCan we make the constructor package private if it is only used for testing.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532808992", "createdAt": "2020-11-30T18:27:27Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -35,11 +41,20 @@\n     private static final Logger log = Logger.get(NodeTaskMap.class);\n     private final ConcurrentHashMap<InternalNode, NodeTasks> nodeTasksMap = new ConcurrentHashMap<>();\n     private final FinalizerService finalizerService;\n+    private final long cpuStatsWindowSizeInMillis;\n \n     @Inject\n+    public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n+    {\n+        this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n+    }\n+\n+    @VisibleForTesting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjY5ODMwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyOTozMFrOH8IJ5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyOTozMFrOH8IJ5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMDIxNA==", "bodyText": "just say 10_000 without using Duration class?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532810214", "createdAt": "2020-11-30T18:29:30Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -35,11 +41,20 @@\n     private static final Logger log = Logger.get(NodeTaskMap.class);\n     private final ConcurrentHashMap<InternalNode, NodeTasks> nodeTasksMap = new ConcurrentHashMap<>();\n     private final FinalizerService finalizerService;\n+    private final long cpuStatsWindowSizeInMillis;\n \n     @Inject\n+    public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n+    {\n+        this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n+    }\n+\n+    @VisibleForTesting\n     public NodeTaskMap(FinalizerService finalizerService)\n     {\n         this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = Duration.valueOf(\"10s\").toMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjcxNjQzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNDowMFrOH8IUjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNDowMFrOH8IUjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMjk0Mg==", "bodyText": "can we use something like nodeTasksMap.computeIfAbsent here instead of the get and null check", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532812942", "createdAt": "2020-11-30T18:34:00Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -49,12 +64,22 @@ public void addTask(InternalNode node, RemoteTask task)\n \n     public int getPartitionedSplitsOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).getPartitionedSplitCount();\n+        return (int) createOrGetNodeTasks(node).getPartitionedSplitCount();\n+    }\n+\n+    public long getMemoryUsageInBytesOnNode(InternalNode node)\n+    {\n+        return createOrGetNodeTasks(node).getTotalMemoryUsageInBytes();\n+    }\n+\n+    public long getCpuTimePerMillisOnNode(InternalNode node)\n+    {\n+        return createOrGetNodeTasks(node).getTotalCpuTimePerMillis();\n     }\n \n-    public PartitionedSplitCountTracker createPartitionedSplitCountTracker(InternalNode node, TaskId taskId)\n+    public NodeStatsTracker createTaskStatsTrackers(InternalNode node, TaskId taskId)\n     {\n-        return createOrGetNodeTasks(node).createPartitionedSplitCountTracker(taskId);\n+        return createOrGetNodeTasks(node).createTaskStatsTrackers(taskId);\n     }\n \n     private NodeTasks createOrGetNodeTasks(InternalNode node)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjcyMTk2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNToyOVrOH8IX2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNToyOVrOH8IX2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMzc4Ng==", "bodyText": "createTaskStatsTrackers drop the trailing s maybe since we are returning a singular NodeStatsTracker .?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532813786", "createdAt": "2020-11-30T18:35:29Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +147,158 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MjcyNjM1OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNjo0MFrOH8IadA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMzo0NjoxMFrOIBFpTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNDQ1Mg==", "bodyText": "keep split count as AtomicInt maybe to prevent the unsafe cast to int ?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532814452", "createdAt": "2020-11-30T18:36:40Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -49,12 +64,22 @@ public void addTask(InternalNode node, RemoteTask task)\n \n     public int getPartitionedSplitsOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).getPartitionedSplitCount();\n+        return (int) createOrGetNodeTasks(node).getPartitionedSplitCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxMTk4MA==", "bodyText": "TaskStatsTracker is using AtomicLong. This would require another class definition.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r538011980", "createdAt": "2020-12-08T03:46:10Z", "author": {"login": "cemcayiroglu"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -49,12 +64,22 @@ public void addTask(InternalNode node, RemoteTask task)\n \n     public int getPartitionedSplitsOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).getPartitionedSplitCount();\n+        return (int) createOrGetNodeTasks(node).getPartitionedSplitCount();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNDQ1Mg=="}, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjc1OTExOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0NTozNFrOH8IuWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMzo0Nzo0OVrOIBFrnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxOTU0Nw==", "bodyText": "Can you help me understand the logic here .\nIf we are throwing an IllegalArg exception wondering why we need to set a negative value and then throw, shouldn't we just throw immediately.?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532819547", "createdAt": "2020-11-30T18:45:34Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +147,158 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxMjU3Mw==", "bodyText": "The value is invalid. We need to fix the accumulated (per node) value for this task first and throw an exception.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r538012573", "createdAt": "2020-12-08T03:47:49Z", "author": {"login": "cemcayiroglu"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +147,158 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxOTU0Nw=="}, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjc3MjQ0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0ODo1NVrOH8I2Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0ODo1NVrOH8I2Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyMTUzNQ==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532821535", "createdAt": "2020-11-30T18:48:55Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -243,6 +246,20 @@ public long getPeakNodeTotalMemoryReservationInBytes()\n         return peakNodeTotalMemoryReservationInBytes;\n     }\n \n+    @JsonProperty\n+    @ThriftField(18)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwOTQ2MDQ2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTowMTo1MlrOIFg48g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTowMTo1MlrOIFg48g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY1MjY1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n          \n          \n            \n                {\n          \n          \n            \n                    this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n          \n          \n            \n                    this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService)\n          \n          \n            \n                {\n          \n          \n            \n                    this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n          \n          \n            \n                    this.cpuStatsWindowSizeInMillis = 10_000_000;\n          \n          \n            \n                }\n          \n          \n            \n                @Inject\n          \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n          \n          \n            \n                {\n          \n          \n            \n                    this(\n          \n          \n            \n                            finalizerService,\n          \n          \n            \n                            requireNonNull(taskConfig, \"taskConfig is null\").getStatusRefreshMaxWait());\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService, Duration statusRefreshMaxWait)\n          \n          \n            \n                {\n          \n          \n            \n                    this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n          \n          \n            \n                    this.cpuStatsWindowSizeInMillis = requireNonNull(statusRefreshMaxWait, \"statusRefreshMaxWait is null\").toMillis();\n          \n          \n            \n                }", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542652658", "createdAt": "2020-12-14T19:01:52Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -35,11 +38,19 @@\n     private static final Logger log = Logger.get(NodeTaskMap.class);\n     private final ConcurrentHashMap<InternalNode, NodeTasks> nodeTasksMap = new ConcurrentHashMap<>();\n     private final FinalizerService finalizerService;\n+    private final long cpuStatsWindowSizeInMillis;\n \n     @Inject\n+    public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n+    {\n+        this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n+    }\n+\n     public NodeTaskMap(FinalizerService finalizerService)\n     {\n         this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = 10_000_000;\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwOTUwMjIxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTowODowMVrOIFhTBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTowODowMVrOIFhTBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY1OTMzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public long getMemoryUsageInBytesOnNode(InternalNode node)\n          \n          \n            \n                public long getNodeTotalMemoryUsageInBytes(InternalNode node)", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542659332", "createdAt": "2020-12-14T19:08:01Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -52,44 +63,54 @@ public int getPartitionedSplitsOnNode(InternalNode node)\n         return createOrGetNodeTasks(node).getPartitionedSplitCount();\n     }\n \n-    public PartitionedSplitCountTracker createPartitionedSplitCountTracker(InternalNode node, TaskId taskId)\n+    public long getMemoryUsageInBytesOnNode(InternalNode node)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwOTUwNzU5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTowODo1NVrOIFhWwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTowODo1NVrOIFhWwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY2MDI5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public long getCpuTimePerMillisOnNode(InternalNode node)\n          \n          \n            \n                public long getNodeCpuTimePerMillis(InternalNode node)", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542660290", "createdAt": "2020-12-14T19:08:55Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -52,44 +63,54 @@ public int getPartitionedSplitsOnNode(InternalNode node)\n         return createOrGetNodeTasks(node).getPartitionedSplitCount();\n     }\n \n-    public PartitionedSplitCountTracker createPartitionedSplitCountTracker(InternalNode node, TaskId taskId)\n+    public long getMemoryUsageInBytesOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).createPartitionedSplitCountTracker(taskId);\n+        return createOrGetNodeTasks(node).getTotalMemoryUsageInBytes();\n     }\n \n-    private NodeTasks createOrGetNodeTasks(InternalNode node)\n+    public long getCpuTimePerMillisOnNode(InternalNode node)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDE3MzQwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMDo0OToxOVrOIFn7xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo1Njo0OVrOIGa7-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA==", "bodyText": "Missing visibility?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542768068", "createdAt": "2020-12-14T20:49:19Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4MzE0NA==", "bodyText": "Where do we clear this map?  Or is it expected that it continuously grows during the lifetime of the task?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542783144", "createdAt": "2020-12-14T21:03:22Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4ODQ4Mw==", "bodyText": "I wonder if the keys will come into this class in time-order (and hence already sorted).  In which case we could use a LinkedHashMap instead.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542788483", "createdAt": "2020-12-14T21:08:21Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MDgwOQ==", "bodyText": "I added the following to avoid memory leak. There is a chance that It can be out of order since updateTaskStats in HttpRemoteTask being called from several places.\nvalues.headMap(values.lastKey() - windowSizeInMillis).clear();", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542970809", "createdAt": "2020-12-15T01:17:18Z", "author": {"login": "cemcayiroglu"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5MjYzNw==", "bodyText": "It's still missing the visibility modifier.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543592637", "createdAt": "2020-12-15T18:41:15Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYwMzcwNQ==", "bodyText": "Also, do you want to use a fastutil Long2LongSortedMap to avoid boxing?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543603705", "createdAt": "2020-12-15T18:56:49Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDI4MDgwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTowNTo0NVrOIFpARw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTowNTo0NVrOIFpARw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4NTYwNw==", "bodyText": "The tail map is just a view over the original.  I think this is a memory leak.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542785607", "createdAt": "2020-12-14T21:05:45Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.stat = requireNonNull(stat, \"stat is null\");\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    values = values.tailMap(values.lastKey() - windowSizeInMillis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDMwMTYwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/RemoteTaskFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTowODo1MFrOIFpNkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTowODo1MFrOIFpNkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4OTAxMA==", "bodyText": "Please static import", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542789010", "createdAt": "2020-12-14T21:08:50Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/RemoteTaskFactory.java", "diffHunk": "@@ -31,7 +30,7 @@ RemoteTask createRemoteTask(Session session,\n             PlanFragment fragment,\n             Multimap<PlanNodeId, Split> initialSplits,\n             OutputBuffers outputBuffers,\n-            PartitionedSplitCountTracker partitionedSplitCountTracker,\n+            NodeTaskMap.NodeStatsTracker nodeStatsTracker,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDMxMDk3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMToxMDoxNFrOIFpTVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMToxMDoxNFrOIFpTVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MDQ4Nw==", "bodyText": "MILLISECONDS.toNanos", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542790487", "createdAt": "2020-12-14T21:10:14Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlTask.java", "diffHunk": "@@ -237,6 +240,7 @@ public TaskStatus getTaskStatus()\n \n     private TaskStatus createTaskStatus(TaskHolder taskHolder)\n     {\n+        long taskStatusAgeInMilis = MILLISECONDS.convert(System.nanoTime() - creationTime, NANOSECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDMxNjMwOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMToxMTowMlrOIFpWxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMToxMTowMlrOIFpWxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MTM2NQ==", "bodyText": "Unrelated whitespace change?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542791365", "createdAt": "2020-12-14T21:11:02Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -57,23 +57,22 @@\n     private final TaskState state;\n     private final URI self;\n     private final Set<Lifespan> completedDriverGroups;\n-\n     private final int queuedPartitionedDrivers;\n     private final int runningPartitionedDrivers;\n-\n     private final double outputBufferUtilization;\n     private final boolean outputBufferOverutilized;\n-\n     private final long physicalWrittenDataSizeInBytes;\n     private final long memoryReservationInBytes;\n     private final long systemMemoryReservationInBytes;\n     private final long peakNodeTotalMemoryReservationInBytes;\n-\n     private final long fullGcCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDMyOTE0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMToxMjo1OVrOIFpfDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMToxMjo1OVrOIFpfDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MzQ4Ng==", "bodyText": "Nit: testCpuUsage", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542793486", "createdAt": "2020-12-14T21:12:59Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java", "diffHunk": "@@ -518,6 +518,86 @@ public void testSplitCount()\n         assertEquals(nodeTaskMap.getPartitionedSplitsOnNode(chosenNode), 0);\n     }\n \n+    @Test\n+    public void testCPUUsage()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTcwODIyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo0Mjo1N1rOIGaWVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMTowMToyMVrOIGfyhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDA3MA==", "bodyText": "Why multiply by 100?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543594070", "createdAt": "2020-12-15T18:42:57Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYwNzE3Ng==", "bodyText": "This was there from the initial implementation. It was helping to calculate a percentage. I will remove.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543607176", "createdAt": "2020-12-15T19:01:58Z", "author": {"login": "cemcayiroglu"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDA3MA=="}, "originalCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYxODU4OQ==", "bodyText": "Actually, using percentage as utilization unit is a common practice. I will keep 100 and change the of the method to get CPU utilization.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543618589", "createdAt": "2020-12-15T19:16:23Z", "author": {"login": "cemcayiroglu"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDA3MA=="}, "originalCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4MzIwNQ==", "bodyText": "There's methods which don't require boxing: e.g. lastLongKey, firstLongKey", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543683205", "createdAt": "2020-12-15T21:01:21Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDA3MA=="}, "originalCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTc0MTc2OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo1MDoxMVrOIGaqaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTowMjo0OFrOIGbLqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTIwOQ==", "bodyText": "Can you help me understand why this would return 0 here?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543599209", "createdAt": "2020-12-15T18:50:11Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;\n+                        long deltaDuration = values.lastKey() - values.firstKey();\n+                        return deltaDuration >= 0 && deltaValue > 0 ? deltaValue / deltaDuration : 0;\n+                    }\n+                }\n+                return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYwNzcyMw==", "bodyText": "We are return 0 if the reporting is not valid or we dont have enough data points.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543607723", "createdAt": "2020-12-15T19:02:48Z", "author": {"login": "cemcayiroglu"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;\n+                        long deltaDuration = values.lastKey() - values.firstKey();\n+                        return deltaDuration >= 0 && deltaValue > 0 ? deltaValue / deltaDuration : 0;\n+                    }\n+                }\n+                return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTIwOQ=="}, "originalCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4"}, "originalPosition": 238}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3392, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}