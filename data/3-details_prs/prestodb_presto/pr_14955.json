{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMDM3OTQ3", "number": 14955, "title": "Push dereferences into table scan for parquet tables", "bodyText": "Remaining patches to resolve  #14517. It works on top of #14829\n== RELEASE NOTES ==\n\nHive Changes\n* This change adds planner side support for pushing dereferences into Parquet table scan. Pushing deferences into table scan enables efficient scans as only the required nested column is read when required independent of the other projected nested columns in the same base column. Currently this functionality is behind a configuration variable `hive.enable-parquet-dereference-pushdown`", "createdAt": "2020-08-04T22:14:31Z", "url": "https://github.com/prestodb/presto/pull/14955", "merged": true, "mergeCommit": {"oid": "99c0d2a123f31586afd7f349633e98dcc123b2b4"}, "closed": true, "closedAt": "2020-08-15T02:01:05Z", "author": {"login": "vkorukanti"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7ylH8gFqTQ2MTMxMDgyMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-7iEiABqjM2NTc3NTY1NTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMzEwODIz", "url": "https://github.com/prestodb/presto/pull/14955#pullrequestreview-461310823", "createdAt": "2020-08-05T03:15:57Z", "commit": {"oid": "300cd8e153b2e187373baa732bc3c183191fb692"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxNTo1N1rOG74odw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxODozMVrOG74q1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzAzMQ==", "bodyText": "static import checkArgument", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465447031", "createdAt": "2020-08-05T03:15:57Z", "author": {"login": "zhenxiao"}, "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/HiveType.java", "diffHunk": "@@ -303,4 +304,15 @@ public int getEstimatedRetainedSizeInBytes()\n         // Size of TypeInfo is not accounted as TypeInfo's are cached and retained by the TypeInfoFactory\n         return INSTANCE_SIZE + hiveTypeName.getEstimatedSizeInBytes();\n     }\n+\n+    public Optional<HiveType> findChildType(List<String> childPath)\n+    {\n+        TypeInfo typeInfo = getTypeInfo();\n+        for (String part : childPath) {\n+            Preconditions.checkArgument(typeInfo instanceof StructTypeInfo, \"typeinfo is not struct type\", typeInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "300cd8e153b2e187373baa732bc3c183191fb692"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzI5Mw==", "bodyText": "how about HiveDereferencePushDown? I think this is general for all formats, right?", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465447293", "createdAt": "2020-08-05T03:17:06Z", "author": {"login": "zhenxiao"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.hive.NestedColumn;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.NESTED_COLUMN;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "300cd8e153b2e187373baa732bc3c183191fb692"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzYzOA==", "bodyText": "improve the error message with \"expecting dereference expression, of type SpecialFormExpression with form DEREFERENCE\"", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465447638", "createdAt": "2020-08-05T03:18:31Z", "author": {"login": "zhenxiao"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.hive.NestedColumn;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.NESTED_COLUMN;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown\n+        implements ConnectorPlanOptimizer\n+{\n+    private final HiveTransactionManager transactionManager;\n+    private final RowExpressionService rowExpressionService;\n+\n+    public HiveParquetDereferencePushDown(HiveTransactionManager transactionManager, RowExpressionService rowExpressionService)\n+    {\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.rowExpressionService = requireNonNull(rowExpressionService, \"rowExpressionService is null\");\n+    }\n+\n+    private static Map<RowExpression, NestedColumn> extractDereferences(ConnectorSession session, ExpressionOptimizer expressionOptimizer, Set<RowExpression> expressions)\n+    {\n+        Set<RowExpression> dereferenceAndVariableExprs = new HashSet<>();\n+        expressions.forEach(expr -> expr.accept(new ExtractDereferenceAndVariables(session, expressionOptimizer), dereferenceAndVariableExprs));\n+\n+        // keep prefix only expressions\n+        List<RowExpression> dereferences = dereferenceAndVariableExprs.stream()\n+                .filter(expression -> !prefixExists(expression, dereferenceAndVariableExprs))\n+                .filter(expression -> expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE)\n+                .collect(Collectors.toList());\n+\n+        return dereferences.stream().collect(toMap(identity(), dereference -> createNestedColumn(dereference, expressionOptimizer, session)));\n+    }\n+\n+    private static boolean prefixExists(RowExpression expression, Set<RowExpression> allExpressions)\n+    {\n+        int[] referenceCount = {0};\n+        expression.accept(\n+                new DefaultRowExpressionTraversalVisitor<int[]>()\n+                {\n+                    @Override\n+                    public Void visitSpecialForm(SpecialFormExpression specialForm, int[] context)\n+                    {\n+                        if (specialForm.getForm() != DEREFERENCE) {\n+                            return super.visitSpecialForm(specialForm, context);\n+                        }\n+\n+                        if (allExpressions.contains(specialForm)) {\n+                            referenceCount[0] += 1;\n+                        }\n+\n+                        RowExpression base = specialForm.getArguments().get(0);\n+                        base.accept(this, context);\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitVariableReference(VariableReferenceExpression reference, int[] context)\n+                    {\n+                        if (allExpressions.contains(reference)) {\n+                            referenceCount[0] += 1;\n+                        }\n+                        return null;\n+                    }\n+                }, referenceCount);\n+\n+        return referenceCount[0] > 1;\n+    }\n+\n+    private static NestedColumn createNestedColumn(RowExpression rowExpression, ExpressionOptimizer expressionOptimizer, ConnectorSession session)\n+    {\n+        if (!(rowExpression instanceof SpecialFormExpression) || ((SpecialFormExpression) rowExpression).getForm() != DEREFERENCE) {\n+            throw new IllegalArgumentException(\"invalid expression: \" + rowExpression);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "300cd8e153b2e187373baa732bc3c183191fb692"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMzIwODQz", "url": "https://github.com/prestodb/presto/pull/14955#pullrequestreview-461320843", "createdAt": "2020-08-05T03:51:40Z", "commit": {"oid": "300cd8e153b2e187373baa732bc3c183191fb692"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo1MTo0MFrOG75LGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo1MTo0MFrOG75LGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTg5Ng==", "bodyText": "I don't think we need this class as we already have Subfield", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465455896", "createdAt": "2020-08-05T03:51:40Z", "author": {"login": "highker"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/NestedColumn.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class NestedColumn", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "300cd8e153b2e187373baa732bc3c183191fb692"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "300cd8e153b2e187373baa732bc3c183191fb692", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/300cd8e153b2e187373baa732bc3c183191fb692", "committedDate": "2020-08-04T22:09:37Z", "message": "Pushdown dereferences into table scan for parquet tables\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}, "afterCommit": {"oid": "48594d2b3865dc4994909f6fd85b2039324dfb5e", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/48594d2b3865dc4994909f6fd85b2039324dfb5e", "committedDate": "2020-08-05T05:09:42Z", "message": "Pushdown dereferences into table scan for parquet tables\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "48594d2b3865dc4994909f6fd85b2039324dfb5e", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/48594d2b3865dc4994909f6fd85b2039324dfb5e", "committedDate": "2020-08-05T05:09:42Z", "message": "Pushdown dereferences into table scan for parquet tables\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}, "afterCommit": {"oid": "d4b3ccd6729e6863f96861df31d7faa7da4ebc26", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/d4b3ccd6729e6863f96861df31d7faa7da4ebc26", "committedDate": "2020-08-12T07:07:48Z", "message": "RowGroup pruning using the filter on pushed down subfield\n\nOnce the dereference is pushed down to tablescan, filters on the dereference column\nare automatically pushed down to tablescan as the pushed down dereference column is\nexposed as a column directly coming from the tablescan. In the reader (this case\nParquet), interpret pushed down dereference columns and convert them to column paths\nto look up the stats in footer.\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzM5Nzcz", "url": "https://github.com/prestodb/presto/pull/14955#pullrequestreview-467339773", "createdAt": "2020-08-14T06:39:40Z", "commit": {"oid": "ce75db45cfddd2fe6d378b354bb2822efa3674de"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNjozOTo0MFrOHApRlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNjo1MTo0M1rOHAph2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzODI5NA==", "bodyText": "line 313 to 317 could be:\ncheckArgument(pathElement instanceof Subfield.NestedField, ...);\nnestedColumnPathBuilder.add(((Subfield.NestedField) pathElement).getName());", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470438294", "createdAt": "2020-08-14T06:39:40Z", "author": {"login": "zhenxiao"}, "path": "presto-parquet/src/main/java/com/facebook/presto/parquet/ParquetTypeUtils.java", "diffHunk": "@@ -304,4 +305,26 @@ public static MessageType getSubfieldType(GroupType baseType, Subfield subfield)\n         }\n         return new MessageType(rootName, ImmutableList.of(type));\n     }\n+\n+    public static List<String> nestedColumnPath(Subfield subfield)\n+    {\n+        ImmutableList.Builder<String> nestedColumnPathBuilder = ImmutableList.builder();\n+        for (Subfield.PathElement pathElement : subfield.getPath()) {\n+            if (pathElement instanceof Subfield.NestedField) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce75db45cfddd2fe6d378b354bb2822efa3674de"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0MTY3MA==", "bodyText": "similar, line 635 to line 639:\ncheckArgument(pathElement instanceof NestedField, ...);\nnestedColumnPathBuilder.add(((NestedField) pathElement).getName());", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470441670", "createdAt": "2020-08-14T06:49:33Z", "author": {"login": "zhenxiao"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/HivePageSourceProvider.java", "diffHunk": "@@ -613,6 +627,20 @@ public int getIndex()\n             return columnMappings.build();\n         }\n \n+        private static Optional<HiveType> getHiveType(Optional<HiveType> baseType, Subfield subfield)\n+        {\n+            List<PathElement> pathElements = subfield.getPath();\n+            ImmutableList.Builder<String> nestedColumnPathBuilder = ImmutableList.builder();\n+            for (PathElement pathElement : pathElements) {\n+                if (pathElement instanceof NestedField) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c10790683a35e12f4cbdd7ee670a7b7680fedce"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0MjQ1OA==", "bodyText": "simplify the logic, line 96 to 100:\nif (columnIO.isPresent()) {\n    fieldsBuilder.add(constructField(type, columnIO.get()));\n}\nelse {\n    fieldsBuilder.add(Optional.empty());\n}", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470442458", "createdAt": "2020-08-14T06:51:43Z", "author": {"login": "zhenxiao"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/parquet/ParquetPageSource.java", "diffHunk": "@@ -77,15 +81,25 @@ public ParquetPageSource(\n         ImmutableList.Builder<Type> typesBuilder = ImmutableList.builder();\n         ImmutableList.Builder<Optional<Field>> fieldsBuilder = ImmutableList.builder();\n         for (HiveColumnHandle column : columns) {\n-            checkState(column.getColumnType() == REGULAR, \"column type must be regular\");\n+            checkState(column.getColumnType() == REGULAR, \"column type must be regular column\");\n \n             String name = column.getName();\n             Type type = typeManager.getType(column.getTypeSignature());\n \n             namesBuilder.add(name);\n             typesBuilder.add(type);\n \n-            if (getParquetType(type, fileSchema, useParquetColumnNames, column, tableName, path).isPresent()) {\n+            if (column.getPushdownSubfield().isPresent()) {\n+                Subfield pushdownSubfield = column.getPushdownSubfield().get();\n+                List<String> nestedColumnPath = nestedColumnPath(pushdownSubfield);\n+                Optional<ColumnIO> columnIO = findNestedColumnIO(lookupColumnByName(messageColumnIO, pushdownSubfield.getRootName()), nestedColumnPath);\n+                if (!columnIO.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c10790683a35e12f4cbdd7ee670a7b7680fedce"}, "originalPosition": 46}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d4b3ccd6729e6863f96861df31d7faa7da4ebc26", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/d4b3ccd6729e6863f96861df31d7faa7da4ebc26", "committedDate": "2020-08-12T07:07:48Z", "message": "RowGroup pruning using the filter on pushed down subfield\n\nOnce the dereference is pushed down to tablescan, filters on the dereference column\nare automatically pushed down to tablescan as the pushed down dereference column is\nexposed as a column directly coming from the tablescan. In the reader (this case\nParquet), interpret pushed down dereference columns and convert them to column paths\nto look up the stats in footer.\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}, "afterCommit": {"oid": "526d917e4dbc1ad8f8769f8c72e7afb2c5f10577", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/526d917e4dbc1ad8f8769f8c72e7afb2c5f10577", "committedDate": "2020-08-14T15:26:28Z", "message": "RowGroup pruning using the filter on pushed down subfield\n\nOnce the dereference is pushed down to tablescan, filters on the dereference column\nare automatically pushed down to tablescan as the pushed down dereference column is\nexposed as a column directly coming from the tablescan. In the reader (this case\nParquet), interpret pushed down dereference columns and convert them to column paths\nto look up the stats in footer.\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NTE5NTIy", "url": "https://github.com/prestodb/presto/pull/14955#pullrequestreview-466519522", "createdAt": "2020-08-13T07:45:24Z", "commit": {"oid": "d4b3ccd6729e6863f96861df31d7faa7da4ebc26"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwNzo0NToyNFrOG__3Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNjo0NjowNFrOHA7hoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1OTgwMg==", "bodyText": "keep as is", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r469759802", "createdAt": "2020-08-13T07:45:24Z", "author": {"login": "highker"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveColumnHandle.java", "diffHunk": "@@ -57,7 +57,7 @@\n     {\n         PARTITION_KEY,\n         REGULAR,\n-        SYNTHESIZED,\n+        SYNTHESIZED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4b3ccd6729e6863f96861df31d7faa7da4ebc26"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyMTA0MQ==", "bodyText": "spell out Exprs", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470721041", "createdAt": "2020-08-14T16:13:57Z", "author": {"login": "highker"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.Subfield;\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.REGULAR;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.parquet.ParquetTypeUtils.pushdownColumnNameForSubfield;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown\n+        implements ConnectorPlanOptimizer\n+{\n+    private final HiveTransactionManager transactionManager;\n+    private final RowExpressionService rowExpressionService;\n+\n+    public HiveParquetDereferencePushDown(HiveTransactionManager transactionManager, RowExpressionService rowExpressionService)\n+    {\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.rowExpressionService = requireNonNull(rowExpressionService, \"rowExpressionService is null\");\n+    }\n+\n+    private static Map<RowExpression, Subfield> extractDereferences(ConnectorSession session, ExpressionOptimizer expressionOptimizer, Set<RowExpression> expressions)\n+    {\n+        Set<RowExpression> dereferenceAndVariableExprs = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27f57a371c8e70df0b02b1e78840dc832197b5e3"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNjMyMw==", "bodyText": "I was under the impression that we gonna make such column \"SYNTHESIZED\"?", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470736323", "createdAt": "2020-08-14T16:44:09Z", "author": {"login": "highker"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.Subfield;\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.REGULAR;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.parquet.ParquetTypeUtils.pushdownColumnNameForSubfield;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown\n+        implements ConnectorPlanOptimizer\n+{\n+    private final HiveTransactionManager transactionManager;\n+    private final RowExpressionService rowExpressionService;\n+\n+    public HiveParquetDereferencePushDown(HiveTransactionManager transactionManager, RowExpressionService rowExpressionService)\n+    {\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.rowExpressionService = requireNonNull(rowExpressionService, \"rowExpressionService is null\");\n+    }\n+\n+    private static Map<RowExpression, Subfield> extractDereferences(ConnectorSession session, ExpressionOptimizer expressionOptimizer, Set<RowExpression> expressions)\n+    {\n+        Set<RowExpression> dereferenceAndVariableExprs = new HashSet<>();\n+        expressions.forEach(expr -> expr.accept(new ExtractDereferenceAndVariables(session, expressionOptimizer), dereferenceAndVariableExprs));\n+\n+        // keep prefix only expressions\n+        List<RowExpression> dereferences = dereferenceAndVariableExprs.stream()\n+                .filter(expression -> !prefixExists(expression, dereferenceAndVariableExprs))\n+                .filter(expression -> expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE)\n+                .collect(Collectors.toList());\n+\n+        return dereferences.stream().collect(toMap(identity(), dereference -> createNestedColumn(dereference, expressionOptimizer, session)));\n+    }\n+\n+    private static boolean prefixExists(RowExpression expression, Set<RowExpression> allExpressions)\n+    {\n+        int[] referenceCount = {0};\n+        expression.accept(\n+                new DefaultRowExpressionTraversalVisitor<int[]>()\n+                {\n+                    @Override\n+                    public Void visitSpecialForm(SpecialFormExpression specialForm, int[] context)\n+                    {\n+                        if (specialForm.getForm() != DEREFERENCE) {\n+                            return super.visitSpecialForm(specialForm, context);\n+                        }\n+\n+                        if (allExpressions.contains(specialForm)) {\n+                            referenceCount[0] += 1;\n+                        }\n+\n+                        RowExpression base = specialForm.getArguments().get(0);\n+                        base.accept(this, context);\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitVariableReference(VariableReferenceExpression reference, int[] context)\n+                    {\n+                        if (allExpressions.contains(reference)) {\n+                            referenceCount[0] += 1;\n+                        }\n+                        return null;\n+                    }\n+                }, referenceCount);\n+\n+        return referenceCount[0] > 1;\n+    }\n+\n+    private static Subfield createNestedColumn(RowExpression rowExpression, ExpressionOptimizer expressionOptimizer, ConnectorSession session)\n+    {\n+        if (!(rowExpression instanceof SpecialFormExpression) || ((SpecialFormExpression) rowExpression).getForm() != DEREFERENCE) {\n+            throw new IllegalArgumentException(\"expecting SpecialFormExpression(DEREFERENCE), but got: \" + rowExpression);\n+        }\n+\n+        List<Subfield.PathElement> elements = new ArrayList<>();\n+        while (true) {\n+            if (rowExpression instanceof VariableReferenceExpression) {\n+                Collections.reverse(elements);\n+                return new Subfield(((VariableReferenceExpression) rowExpression).getName(), unmodifiableList(elements));\n+            }\n+\n+            if (rowExpression instanceof SpecialFormExpression && ((SpecialFormExpression) rowExpression).getForm() == DEREFERENCE) {\n+                SpecialFormExpression dereferenceExpression = (SpecialFormExpression) rowExpression;\n+                RowExpression base = dereferenceExpression.getArguments().get(0);\n+                RowType baseType = (RowType) base.getType();\n+\n+                RowExpression indexExpression = expressionOptimizer.optimize(\n+                        dereferenceExpression.getArguments().get(1),\n+                        ExpressionOptimizer.Level.OPTIMIZED,\n+                        session);\n+\n+                if (indexExpression instanceof ConstantExpression) {\n+                    Object index = ((ConstantExpression) indexExpression).getValue();\n+                    if (index instanceof Number) {\n+                        Optional<String> fieldName = baseType.getFields().get(((Number) index).intValue()).getName();\n+                        if (fieldName.isPresent()) {\n+                            elements.add(new Subfield.NestedField(fieldName.get()));\n+                            rowExpression = base;\n+                            continue;\n+                        }\n+                    }\n+                }\n+            }\n+            break;\n+        }\n+\n+        throw new IllegalArgumentException(\"expecting SpecialFormExpression(DEREFERENCE) with constants for indices, but got: \" + rowExpression);\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan, ConnectorSession session, VariableAllocator variableAllocator, PlanNodeIdAllocator idAllocator)\n+    {\n+        return maxSubplan.accept(new Visitor(session, variableAllocator, idAllocator), null);\n+    }\n+\n+    private boolean isParquetDereferenceEnabled(ConnectorSession session, TableHandle tableHandle)\n+    {\n+        checkArgument(tableHandle.getConnectorHandle() instanceof HiveTableHandle, \"Dereference pushdown into reader is not supported on a non-hive TableHandle\");\n+\n+        if (!isParquetDereferencePushdownEnabled(session)) {\n+            return false;\n+        }\n+\n+        return PARQUET == getHiveStorageFormat(getMetadata(tableHandle).getTableMetadata(session, tableHandle.getConnectorHandle()).getProperties());\n+    }\n+\n+    protected HiveMetadata getMetadata(TableHandle tableHandle)\n+    {\n+        ConnectorMetadata metadata = transactionManager.get(tableHandle.getTransaction());\n+        checkState(metadata instanceof HiveMetadata, \"metadata must be HiveMetadata\");\n+        return (HiveMetadata) metadata;\n+    }\n+\n+    /**\n+     * Visitor to extract all dereference expressions and variable references.\n+     * <p>\n+     * If a dereference expression contains dereference expression, inner dereference expression are not returned\n+     * * sub(deref(deref(x, 1), 2)) --> deref(deref(x,1), 2)\n+     * Variable expressions returned are the ones not referenced by the dereference expressions\n+     * * sub(x + 1) --> x\n+     * * sub(deref(x, 1)) -> deref(x,1)\n+     */\n+    private static class ExtractDereferenceAndVariables\n+            extends DefaultRowExpressionTraversalVisitor<Set<RowExpression>>\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final ExpressionOptimizer expressionOptimizer;\n+\n+        public ExtractDereferenceAndVariables(ConnectorSession connectorSession, ExpressionOptimizer expressionOptimizer)\n+        {\n+            this.connectorSession = connectorSession;\n+            this.expressionOptimizer = expressionOptimizer;\n+        }\n+\n+        @Override\n+        public Void visitSpecialForm(SpecialFormExpression specialForm, Set<RowExpression> context)\n+        {\n+            if (specialForm.getForm() != DEREFERENCE) {\n+                return super.visitSpecialForm(specialForm, context);\n+            }\n+\n+            RowExpression expression = specialForm;\n+            while (true) {\n+                if (expression instanceof VariableReferenceExpression) {\n+                    context.add(specialForm);\n+                    return null;\n+                }\n+\n+                if (expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE) {\n+                    SpecialFormExpression dereferenceExpression = (SpecialFormExpression) expression;\n+                    RowExpression base = dereferenceExpression.getArguments().get(0);\n+                    RowType baseType = (RowType) base.getType();\n+\n+                    RowExpression indexExpression = expressionOptimizer.optimize(\n+                            dereferenceExpression.getArguments().get(1),\n+                            ExpressionOptimizer.Level.OPTIMIZED,\n+                            connectorSession);\n+\n+                    if (indexExpression instanceof ConstantExpression) {\n+                        Object index = ((ConstantExpression) indexExpression).getValue();\n+                        if (index instanceof Number) {\n+                            Optional<String> fieldName = baseType.getFields().get(((Number) index).intValue()).getName();\n+                            if (fieldName.isPresent()) {\n+                                expression = base;\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+            }\n+\n+            return super.visitSpecialForm(specialForm, context);\n+        }\n+\n+        @Override\n+        public Void visitVariableReference(VariableReferenceExpression reference, Set<RowExpression> context)\n+        {\n+            context.add(reference);\n+            return null;\n+        }\n+    }\n+\n+    private static class DereferenceExpressionRewriter\n+            extends RowExpressionRewriter<Void>\n+    {\n+        private final Map<RowExpression, VariableReferenceExpression> dereferenceMap;\n+\n+        public DereferenceExpressionRewriter(Map<RowExpression, VariableReferenceExpression> dereferenceMap)\n+        {\n+            this.dereferenceMap = dereferenceMap;\n+        }\n+\n+        @Override\n+        public RowExpression rewriteSpecialForm(SpecialFormExpression node, Void context, RowExpressionTreeRewriter<Void> treeRewriter)\n+        {\n+            return dereferenceMap.get(node);\n+        }\n+    }\n+\n+    /**\n+     * Looks for ProjectNode -> TableScanNode patterns. Goes through the project expressions to extract out the DEREFERENCE expressions,\n+     * pushes the dereferences down to TableScan and creates new project expressions with the pushed down column coming from the TableScan.\n+     * Returned plan nodes could contain unreferenced outputs which will be pruned later in the planning process.\n+     */\n+    private class Visitor\n+            extends PlanVisitor<PlanNode, Void>\n+    {\n+        private final ConnectorSession session;\n+        private final VariableAllocator variableAllocator;\n+        private final PlanNodeIdAllocator idAllocator;\n+\n+        Visitor(ConnectorSession session, VariableAllocator variableAllocator, PlanNodeIdAllocator idAllocator)\n+        {\n+            this.session = requireNonNull(session, \"session is null\");\n+            this.variableAllocator = requireNonNull(variableAllocator, \"variableAllocator is null\");\n+            this.idAllocator = requireNonNull(idAllocator, \"idAllocator is null\");\n+        }\n+\n+        @Override\n+        public PlanNode visitPlan(PlanNode node, Void context)\n+        {\n+            ImmutableList.Builder<PlanNode> children = ImmutableList.builder();\n+            boolean changed = false;\n+            for (PlanNode child : node.getSources()) {\n+                PlanNode newChild = child.accept(this, null);\n+                if (newChild != child) {\n+                    changed = true;\n+                }\n+                children.add(newChild);\n+            }\n+\n+            if (!changed) {\n+                return node;\n+            }\n+            return node.replaceChildren(children.build());\n+        }\n+\n+        @Override\n+        public PlanNode visitProject(ProjectNode project, Void context)\n+        {\n+            if (!(project.getSource() instanceof TableScanNode)) {\n+                return visitPlan(project, context);\n+            }\n+\n+            TableScanNode tableScan = (TableScanNode) project.getSource();\n+            if (!isParquetDereferenceEnabled(session, tableScan.getTable())) {\n+                return visitPlan(project, context);\n+            }\n+\n+            Map<RowExpression, Subfield> dereferenceToNestedColumnMap = extractDereferences(\n+                    session,\n+                    rowExpressionService.getExpressionOptimizer(),\n+                    new HashSet<>(project.getAssignments().getExpressions()));\n+            if (dereferenceToNestedColumnMap.isEmpty()) {\n+                return visitPlan(project, context);\n+            }\n+\n+            Map<String, HiveColumnHandle> regularHiveColumnHandles = tableScan.getAssignments().values().stream()\n+                    .map(columnHandle -> (HiveColumnHandle) columnHandle)\n+                    .collect(toMap(HiveColumnHandle::getName, identity()));\n+\n+            List<VariableReferenceExpression> newOutputVariables = new ArrayList<>(tableScan.getOutputVariables());\n+            Map<VariableReferenceExpression, ColumnHandle> newAssignments = new HashMap<>(tableScan.getAssignments());\n+\n+            Map<RowExpression, VariableReferenceExpression> dereferenceToVariableMap = new HashMap<>();\n+\n+            for (Map.Entry<RowExpression, Subfield> dereference : dereferenceToNestedColumnMap.entrySet()) {\n+                Subfield nestedColumn = dereference.getValue();\n+                RowExpression dereferenceExpression = dereference.getKey();\n+\n+                // Find the nested column Hive Type\n+                HiveColumnHandle regularColumnHandle = regularHiveColumnHandles.get(nestedColumn.getRootName());\n+                if (regularColumnHandle == null) {\n+                    throw new IllegalArgumentException(\"nested column [\" + nestedColumn + \"]'s base column \" + nestedColumn.getRootName() + \" is not present in table scan output\");\n+                }\n+\n+                Optional<HiveType> nestedColumnHiveType = regularHiveColumnHandles.get(nestedColumn.getRootName())\n+                        .getHiveType()\n+                        .findChildType(\n+                                nestedColumn.getPath().stream()\n+                                        .map(p -> ((Subfield.NestedField) p).getName())\n+                                        .collect(Collectors.toList()));\n+\n+                if (!nestedColumnHiveType.isPresent()) {\n+                    throw new IllegalArgumentException(\"nested column [\" + nestedColumn + \"] type is not present in Hive column type\");\n+                }\n+\n+                String pushdownColumnName = pushdownColumnNameForSubfield(nestedColumn);\n+                // Create column handle for nested column\n+                HiveColumnHandle nestedColumnHandle = new HiveColumnHandle(\n+                        pushdownColumnName,\n+                        nestedColumnHiveType.get(),\n+                        dereferenceExpression.getType().getTypeSignature(),\n+                        -1,\n+                        REGULAR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "526d917e4dbc1ad8f8769f8c72e7afb2c5f10577"}, "originalPosition": 378}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNjg0MA==", "bodyText": "If we have this to be \"SYNTHESIZED\", then we don't need two subfields variables here. We just use one. The SYNTHESIZED one is to denote parquet pushdown and the regular one for selective page source.", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470736840", "createdAt": "2020-08-14T16:45:10Z", "author": {"login": "highker"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.Subfield;\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.REGULAR;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.parquet.ParquetTypeUtils.pushdownColumnNameForSubfield;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown\n+        implements ConnectorPlanOptimizer\n+{\n+    private final HiveTransactionManager transactionManager;\n+    private final RowExpressionService rowExpressionService;\n+\n+    public HiveParquetDereferencePushDown(HiveTransactionManager transactionManager, RowExpressionService rowExpressionService)\n+    {\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.rowExpressionService = requireNonNull(rowExpressionService, \"rowExpressionService is null\");\n+    }\n+\n+    private static Map<RowExpression, Subfield> extractDereferences(ConnectorSession session, ExpressionOptimizer expressionOptimizer, Set<RowExpression> expressions)\n+    {\n+        Set<RowExpression> dereferenceAndVariableExprs = new HashSet<>();\n+        expressions.forEach(expr -> expr.accept(new ExtractDereferenceAndVariables(session, expressionOptimizer), dereferenceAndVariableExprs));\n+\n+        // keep prefix only expressions\n+        List<RowExpression> dereferences = dereferenceAndVariableExprs.stream()\n+                .filter(expression -> !prefixExists(expression, dereferenceAndVariableExprs))\n+                .filter(expression -> expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE)\n+                .collect(Collectors.toList());\n+\n+        return dereferences.stream().collect(toMap(identity(), dereference -> createNestedColumn(dereference, expressionOptimizer, session)));\n+    }\n+\n+    private static boolean prefixExists(RowExpression expression, Set<RowExpression> allExpressions)\n+    {\n+        int[] referenceCount = {0};\n+        expression.accept(\n+                new DefaultRowExpressionTraversalVisitor<int[]>()\n+                {\n+                    @Override\n+                    public Void visitSpecialForm(SpecialFormExpression specialForm, int[] context)\n+                    {\n+                        if (specialForm.getForm() != DEREFERENCE) {\n+                            return super.visitSpecialForm(specialForm, context);\n+                        }\n+\n+                        if (allExpressions.contains(specialForm)) {\n+                            referenceCount[0] += 1;\n+                        }\n+\n+                        RowExpression base = specialForm.getArguments().get(0);\n+                        base.accept(this, context);\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitVariableReference(VariableReferenceExpression reference, int[] context)\n+                    {\n+                        if (allExpressions.contains(reference)) {\n+                            referenceCount[0] += 1;\n+                        }\n+                        return null;\n+                    }\n+                }, referenceCount);\n+\n+        return referenceCount[0] > 1;\n+    }\n+\n+    private static Subfield createNestedColumn(RowExpression rowExpression, ExpressionOptimizer expressionOptimizer, ConnectorSession session)\n+    {\n+        if (!(rowExpression instanceof SpecialFormExpression) || ((SpecialFormExpression) rowExpression).getForm() != DEREFERENCE) {\n+            throw new IllegalArgumentException(\"expecting SpecialFormExpression(DEREFERENCE), but got: \" + rowExpression);\n+        }\n+\n+        List<Subfield.PathElement> elements = new ArrayList<>();\n+        while (true) {\n+            if (rowExpression instanceof VariableReferenceExpression) {\n+                Collections.reverse(elements);\n+                return new Subfield(((VariableReferenceExpression) rowExpression).getName(), unmodifiableList(elements));\n+            }\n+\n+            if (rowExpression instanceof SpecialFormExpression && ((SpecialFormExpression) rowExpression).getForm() == DEREFERENCE) {\n+                SpecialFormExpression dereferenceExpression = (SpecialFormExpression) rowExpression;\n+                RowExpression base = dereferenceExpression.getArguments().get(0);\n+                RowType baseType = (RowType) base.getType();\n+\n+                RowExpression indexExpression = expressionOptimizer.optimize(\n+                        dereferenceExpression.getArguments().get(1),\n+                        ExpressionOptimizer.Level.OPTIMIZED,\n+                        session);\n+\n+                if (indexExpression instanceof ConstantExpression) {\n+                    Object index = ((ConstantExpression) indexExpression).getValue();\n+                    if (index instanceof Number) {\n+                        Optional<String> fieldName = baseType.getFields().get(((Number) index).intValue()).getName();\n+                        if (fieldName.isPresent()) {\n+                            elements.add(new Subfield.NestedField(fieldName.get()));\n+                            rowExpression = base;\n+                            continue;\n+                        }\n+                    }\n+                }\n+            }\n+            break;\n+        }\n+\n+        throw new IllegalArgumentException(\"expecting SpecialFormExpression(DEREFERENCE) with constants for indices, but got: \" + rowExpression);\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan, ConnectorSession session, VariableAllocator variableAllocator, PlanNodeIdAllocator idAllocator)\n+    {\n+        return maxSubplan.accept(new Visitor(session, variableAllocator, idAllocator), null);\n+    }\n+\n+    private boolean isParquetDereferenceEnabled(ConnectorSession session, TableHandle tableHandle)\n+    {\n+        checkArgument(tableHandle.getConnectorHandle() instanceof HiveTableHandle, \"Dereference pushdown into reader is not supported on a non-hive TableHandle\");\n+\n+        if (!isParquetDereferencePushdownEnabled(session)) {\n+            return false;\n+        }\n+\n+        return PARQUET == getHiveStorageFormat(getMetadata(tableHandle).getTableMetadata(session, tableHandle.getConnectorHandle()).getProperties());\n+    }\n+\n+    protected HiveMetadata getMetadata(TableHandle tableHandle)\n+    {\n+        ConnectorMetadata metadata = transactionManager.get(tableHandle.getTransaction());\n+        checkState(metadata instanceof HiveMetadata, \"metadata must be HiveMetadata\");\n+        return (HiveMetadata) metadata;\n+    }\n+\n+    /**\n+     * Visitor to extract all dereference expressions and variable references.\n+     * <p>\n+     * If a dereference expression contains dereference expression, inner dereference expression are not returned\n+     * * sub(deref(deref(x, 1), 2)) --> deref(deref(x,1), 2)\n+     * Variable expressions returned are the ones not referenced by the dereference expressions\n+     * * sub(x + 1) --> x\n+     * * sub(deref(x, 1)) -> deref(x,1)\n+     */\n+    private static class ExtractDereferenceAndVariables\n+            extends DefaultRowExpressionTraversalVisitor<Set<RowExpression>>\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final ExpressionOptimizer expressionOptimizer;\n+\n+        public ExtractDereferenceAndVariables(ConnectorSession connectorSession, ExpressionOptimizer expressionOptimizer)\n+        {\n+            this.connectorSession = connectorSession;\n+            this.expressionOptimizer = expressionOptimizer;\n+        }\n+\n+        @Override\n+        public Void visitSpecialForm(SpecialFormExpression specialForm, Set<RowExpression> context)\n+        {\n+            if (specialForm.getForm() != DEREFERENCE) {\n+                return super.visitSpecialForm(specialForm, context);\n+            }\n+\n+            RowExpression expression = specialForm;\n+            while (true) {\n+                if (expression instanceof VariableReferenceExpression) {\n+                    context.add(specialForm);\n+                    return null;\n+                }\n+\n+                if (expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE) {\n+                    SpecialFormExpression dereferenceExpression = (SpecialFormExpression) expression;\n+                    RowExpression base = dereferenceExpression.getArguments().get(0);\n+                    RowType baseType = (RowType) base.getType();\n+\n+                    RowExpression indexExpression = expressionOptimizer.optimize(\n+                            dereferenceExpression.getArguments().get(1),\n+                            ExpressionOptimizer.Level.OPTIMIZED,\n+                            connectorSession);\n+\n+                    if (indexExpression instanceof ConstantExpression) {\n+                        Object index = ((ConstantExpression) indexExpression).getValue();\n+                        if (index instanceof Number) {\n+                            Optional<String> fieldName = baseType.getFields().get(((Number) index).intValue()).getName();\n+                            if (fieldName.isPresent()) {\n+                                expression = base;\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+            }\n+\n+            return super.visitSpecialForm(specialForm, context);\n+        }\n+\n+        @Override\n+        public Void visitVariableReference(VariableReferenceExpression reference, Set<RowExpression> context)\n+        {\n+            context.add(reference);\n+            return null;\n+        }\n+    }\n+\n+    private static class DereferenceExpressionRewriter\n+            extends RowExpressionRewriter<Void>\n+    {\n+        private final Map<RowExpression, VariableReferenceExpression> dereferenceMap;\n+\n+        public DereferenceExpressionRewriter(Map<RowExpression, VariableReferenceExpression> dereferenceMap)\n+        {\n+            this.dereferenceMap = dereferenceMap;\n+        }\n+\n+        @Override\n+        public RowExpression rewriteSpecialForm(SpecialFormExpression node, Void context, RowExpressionTreeRewriter<Void> treeRewriter)\n+        {\n+            return dereferenceMap.get(node);\n+        }\n+    }\n+\n+    /**\n+     * Looks for ProjectNode -> TableScanNode patterns. Goes through the project expressions to extract out the DEREFERENCE expressions,\n+     * pushes the dereferences down to TableScan and creates new project expressions with the pushed down column coming from the TableScan.\n+     * Returned plan nodes could contain unreferenced outputs which will be pruned later in the planning process.\n+     */\n+    private class Visitor\n+            extends PlanVisitor<PlanNode, Void>\n+    {\n+        private final ConnectorSession session;\n+        private final VariableAllocator variableAllocator;\n+        private final PlanNodeIdAllocator idAllocator;\n+\n+        Visitor(ConnectorSession session, VariableAllocator variableAllocator, PlanNodeIdAllocator idAllocator)\n+        {\n+            this.session = requireNonNull(session, \"session is null\");\n+            this.variableAllocator = requireNonNull(variableAllocator, \"variableAllocator is null\");\n+            this.idAllocator = requireNonNull(idAllocator, \"idAllocator is null\");\n+        }\n+\n+        @Override\n+        public PlanNode visitPlan(PlanNode node, Void context)\n+        {\n+            ImmutableList.Builder<PlanNode> children = ImmutableList.builder();\n+            boolean changed = false;\n+            for (PlanNode child : node.getSources()) {\n+                PlanNode newChild = child.accept(this, null);\n+                if (newChild != child) {\n+                    changed = true;\n+                }\n+                children.add(newChild);\n+            }\n+\n+            if (!changed) {\n+                return node;\n+            }\n+            return node.replaceChildren(children.build());\n+        }\n+\n+        @Override\n+        public PlanNode visitProject(ProjectNode project, Void context)\n+        {\n+            if (!(project.getSource() instanceof TableScanNode)) {\n+                return visitPlan(project, context);\n+            }\n+\n+            TableScanNode tableScan = (TableScanNode) project.getSource();\n+            if (!isParquetDereferenceEnabled(session, tableScan.getTable())) {\n+                return visitPlan(project, context);\n+            }\n+\n+            Map<RowExpression, Subfield> dereferenceToNestedColumnMap = extractDereferences(\n+                    session,\n+                    rowExpressionService.getExpressionOptimizer(),\n+                    new HashSet<>(project.getAssignments().getExpressions()));\n+            if (dereferenceToNestedColumnMap.isEmpty()) {\n+                return visitPlan(project, context);\n+            }\n+\n+            Map<String, HiveColumnHandle> regularHiveColumnHandles = tableScan.getAssignments().values().stream()\n+                    .map(columnHandle -> (HiveColumnHandle) columnHandle)\n+                    .collect(toMap(HiveColumnHandle::getName, identity()));\n+\n+            List<VariableReferenceExpression> newOutputVariables = new ArrayList<>(tableScan.getOutputVariables());\n+            Map<VariableReferenceExpression, ColumnHandle> newAssignments = new HashMap<>(tableScan.getAssignments());\n+\n+            Map<RowExpression, VariableReferenceExpression> dereferenceToVariableMap = new HashMap<>();\n+\n+            for (Map.Entry<RowExpression, Subfield> dereference : dereferenceToNestedColumnMap.entrySet()) {\n+                Subfield nestedColumn = dereference.getValue();\n+                RowExpression dereferenceExpression = dereference.getKey();\n+\n+                // Find the nested column Hive Type\n+                HiveColumnHandle regularColumnHandle = regularHiveColumnHandles.get(nestedColumn.getRootName());\n+                if (regularColumnHandle == null) {\n+                    throw new IllegalArgumentException(\"nested column [\" + nestedColumn + \"]'s base column \" + nestedColumn.getRootName() + \" is not present in table scan output\");\n+                }\n+\n+                Optional<HiveType> nestedColumnHiveType = regularHiveColumnHandles.get(nestedColumn.getRootName())\n+                        .getHiveType()\n+                        .findChildType(\n+                                nestedColumn.getPath().stream()\n+                                        .map(p -> ((Subfield.NestedField) p).getName())\n+                                        .collect(Collectors.toList()));\n+\n+                if (!nestedColumnHiveType.isPresent()) {\n+                    throw new IllegalArgumentException(\"nested column [\" + nestedColumn + \"] type is not present in Hive column type\");\n+                }\n+\n+                String pushdownColumnName = pushdownColumnNameForSubfield(nestedColumn);\n+                // Create column handle for nested column\n+                HiveColumnHandle nestedColumnHandle = new HiveColumnHandle(\n+                        pushdownColumnName,\n+                        nestedColumnHiveType.get(),\n+                        dereferenceExpression.getType().getTypeSignature(),\n+                        -1,\n+                        REGULAR,\n+                        Optional.of(\"nested column pushdown\"),\n+                        ImmutableList.of(),\n+                        Optional.of(nestedColumn));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "526d917e4dbc1ad8f8769f8c72e7afb2c5f10577"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNzMxMw==", "bodyText": "We can reuse requiredSubfields instead of introducing a new field. Use SYNTHESIZED to distinguish the difference. Let me know if this approach will miss anything.", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470737313", "createdAt": "2020-08-14T16:46:04Z", "author": {"login": "highker"}, "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveColumnHandle.java", "diffHunk": "@@ -67,6 +67,7 @@\n     private final ColumnType columnType;\n     private final Optional<String> comment;\n     private final List<Subfield> requiredSubfields;\n+    private final Optional<Subfield> pushdownSubfield;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "526d917e4dbc1ad8f8769f8c72e7afb2c5f10577"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbbfb72ee480ca9cd01532649b3daa3de3af0a59", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/fbbfb72ee480ca9cd01532649b3daa3de3af0a59", "committedDate": "2020-08-14T19:05:47Z", "message": "Add an option to control Parquet dereferance pushdown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cfdd172065bebb8b47e34597811cbc435670995", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/6cfdd172065bebb8b47e34597811cbc435670995", "committedDate": "2020-08-14T19:05:47Z", "message": "Pushdown dereferences into table scan for parquet tables\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "526d917e4dbc1ad8f8769f8c72e7afb2c5f10577", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/526d917e4dbc1ad8f8769f8c72e7afb2c5f10577", "committedDate": "2020-08-14T15:26:28Z", "message": "RowGroup pruning using the filter on pushed down subfield\n\nOnce the dereference is pushed down to tablescan, filters on the dereference column\nare automatically pushed down to tablescan as the pushed down dereference column is\nexposed as a column directly coming from the tablescan. In the reader (this case\nParquet), interpret pushed down dereference columns and convert them to column paths\nto look up the stats in footer.\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}, "afterCommit": {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "committedDate": "2020-08-14T19:05:47Z", "message": "Use SYNTHESIZED type to represent pushed down Subfield in HiveColumnHandle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODY5MDky", "url": "https://github.com/prestodb/presto/pull/14955#pullrequestreview-467869092", "createdAt": "2020-08-14T20:54:03Z", "commit": {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDo1NDowM1rOHBDB6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDo1NjozMlrOHBDF0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDI2NQ==", "bodyText": "one param per line and leave the first line empty", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470860265", "createdAt": "2020-08-14T20:54:03Z", "author": {"login": "highker"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -1079,6 +1243,17 @@ private static PlanMatchPattern tableScan(String expectedTableName, Map<String,\n         return PlanMatchPattern.tableScan(expectedTableName).with(new HiveTableScanMatcher(expectedRequiredSubfields));\n     }\n \n+    private static PlanMatchPattern tableScanParquetDeferencePushDowns(String expectedTableName, Map<String, Subfield> expectedDeferencePushDowns)\n+    {\n+        return PlanMatchPattern.tableScan(expectedTableName).with(new HiveParquetDereferencePushdownMatcher(expectedDeferencePushDowns, TupleDomain.all(), ImmutableSet.of(), TRUE_CONSTANT));\n+    }\n+\n+    private static PlanMatchPattern tableScanParquetDeferencePushDowns(String expectedTableName, Map<String, Subfield> expectedDeferencePushDowns,\n+            TupleDomain<String> domainPredicate, Set<String> predicateColumns, RowExpression remainingPredicate)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDM3Mw==", "bodyText": "same", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470860373", "createdAt": "2020-08-14T20:54:23Z", "author": {"login": "highker"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -1097,6 +1272,23 @@ private void assertPushdownFilterOnSubfields(String query, Map<Subfield, Domain>\n                         predicateDomains.keySet().stream().map(Subfield::getRootName).collect(toImmutableSet())));\n     }\n \n+    private void assertParquetDereferencePushDown(String query, String tableName, Map<String, Subfield> expectedDeferencePushDowns)\n+    {\n+        assertParquetDereferencePushDown(withParquetDereferencePushDownEnabled(), query, tableName, expectedDeferencePushDowns);\n+    }\n+\n+    private void assertParquetDereferencePushDown(String query, String tableName, Map<String, Subfield> expectedDeferencePushDowns, TupleDomain<String> domainPredicate,\n+            Set<String> predicateColumns, RowExpression remainingPredicate)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDQyNA==", "bodyText": "same", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470860424", "createdAt": "2020-08-14T20:54:30Z", "author": {"login": "highker"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -1097,6 +1272,23 @@ private void assertPushdownFilterOnSubfields(String query, Map<Subfield, Domain>\n                         predicateDomains.keySet().stream().map(Subfield::getRootName).collect(toImmutableSet())));\n     }\n \n+    private void assertParquetDereferencePushDown(String query, String tableName, Map<String, Subfield> expectedDeferencePushDowns)\n+    {\n+        assertParquetDereferencePushDown(withParquetDereferencePushDownEnabled(), query, tableName, expectedDeferencePushDowns);\n+    }\n+\n+    private void assertParquetDereferencePushDown(String query, String tableName, Map<String, Subfield> expectedDeferencePushDowns, TupleDomain<String> domainPredicate,\n+            Set<String> predicateColumns, RowExpression remainingPredicate)\n+    {\n+        assertPlan(withParquetDereferencePushDownEnabled(), query,\n+                anyTree(tableScanParquetDeferencePushDowns(tableName, expectedDeferencePushDowns, domainPredicate, predicateColumns, remainingPredicate)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDcyMw==", "bodyText": "Make sure all these functions are with one parameter per line with the first line empty.", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470860723", "createdAt": "2020-08-14T20:55:07Z", "author": {"login": "highker"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -953,6 +963,160 @@ public void testPushdownSubfieldsAndJoinReordering()\n         }\n     }\n \n+    @Test\n+    public void testParquetDereferencePushDown()\n+    {\n+        assertUpdate(\"CREATE TABLE test_pushdown_nestedcolumn_parquet(\" +\n+                \"id bigint, \" +\n+                \"x row(a bigint, b varchar, c double, d row(d1 bigint, d2 double)),\" +\n+                \"y array(row(a bigint, b varchar, c double, d row(d1 bigint, d2 double)))) \" +\n+                \"with (format = 'PARQUET')\");\n+\n+        assertParquetDereferencePushDown(\"SELECT x.a FROM test_pushdown_nestedcolumn_parquet\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT x.a, mod(x.d.d1, 2) FROM test_pushdown_nestedcolumn_parquet\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.d.d1\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT x.d, mod(x.d.d1, 2), x.d.d2 FROM test_pushdown_nestedcolumn_parquet\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT x.a FROM test_pushdown_nestedcolumn_parquet WHERE x.b LIKE 'abc%'\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.b\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT x.a FROM test_pushdown_nestedcolumn_parquet WHERE x.a > 10 AND x.b LIKE 'abc%'\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.b\"),\n+                withColumnDomains(ImmutableMap.of(pushdownColumnNameForSubfield(nestedColumn(\"x.a\")), create(ofRanges(greaterThan(BIGINT, 10L)), false))),\n+                ImmutableSet.of(pushdownColumnNameForSubfield(nestedColumn(\"x.a\"))),\n+                TRUE_CONSTANT);\n+\n+        // Join\n+        assertPlan(withParquetDereferencePushDownEnabled(), \"SELECT l.orderkey, x.a, mod(x.d.d1, 2) FROM lineitem l, test_pushdown_nestedcolumn_parquet a WHERE l.linenumber = a.id\",\n+                anyTree(\n+                        node(JoinNode.class,\n+                                anyTree(tableScan(\"lineitem\", ImmutableMap.of())),\n+                                anyTree(tableScanParquetDeferencePushDowns(\"test_pushdown_nestedcolumn_parquet\", nestedColumnMap(\"x.a\", \"x.d.d1\"))))));\n+\n+        assertPlan(withParquetDereferencePushDownEnabled(), \"SELECT l.orderkey, x.a, mod(x.d.d1, 2) FROM lineitem l, test_pushdown_nestedcolumn_parquet a WHERE l.linenumber = a.id AND x.a > 10\",\n+                anyTree(\n+                        node(JoinNode.class,\n+                                anyTree(tableScan(\"lineitem\", ImmutableMap.of())),\n+                                anyTree(tableScanParquetDeferencePushDowns(\n+                                        \"test_pushdown_nestedcolumn_parquet\",\n+                                        nestedColumnMap(\"x.a\", \"x.d.d1\"),\n+                                        withColumnDomains(ImmutableMap.of(pushdownColumnNameForSubfield(nestedColumn(\"x.a\")), create(ofRanges(greaterThan(BIGINT, 10L)), false))),\n+                                        ImmutableSet.of(pushdownColumnNameForSubfield(nestedColumn(\"x.a\"))),\n+                                        TRUE_CONSTANT)))));\n+        // Aggregation\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.a) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, min(mod(x.a, 3)) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.a) FILTER (WHERE x.b LIKE 'abc%') FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.b\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.a + 1) * avg(x.d.d1) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.d.d1\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, arbitrary(x.a) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        // Dereference can't be pushed down, but the subfield pushdown will help in pruning the number of columns to read\n+        assertPushdownSubfields(\"SELECT id, arbitrary(x.a) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                ImmutableMap.of(\"x\", toSubfields(\"x.a\")));\n+\n+        // Dereference can't be pushed down, but the subfield pushdown will help in pruning the number of columns to read\n+        assertPushdownSubfields(\"SELECT id, arbitrary(x).d.d1 FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                ImmutableMap.of(\"x\", toSubfields(\"x.d.d1\")));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, arbitrary(x.d).d1 FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, arbitrary(x.d.d2) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d.d2\"));\n+\n+        // Unnest\n+        assertParquetDereferencePushDown(\"SELECT t.a, t.d.d1, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(a, b, c, d)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT t.*, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(a, b, c, d)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(a, b, c, d)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        // Legacy unnest\n+        Session legacyUnnest = Session.builder(withParquetDereferencePushDownEnabled())\n+                .setSystemProperty(\"legacy_unnest\", \"true\")\n+                .build();\n+        assertParquetDereferencePushDown(legacyUnnest, \"SELECT t.y.a, t.y.d.d1, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(y)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(legacyUnnest, \"SELECT t.*, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(y)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(legacyUnnest, \"SELECT id, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(y)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        // Case sensitivity\n+        assertParquetDereferencePushDown(\"SELECT x.a, x.b, x.A + 2 FROM test_pushdown_nestedcolumn_parquet WHERE x.B LIKE 'abc%'\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.b\"));\n+\n+        // No pass-through nested column pruning\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.d).d1 FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.d).d1, min(x.d.d2) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d\"));\n+\n+        // Test pushdown of filters on dereference columns\n+        assertParquetDereferencePushDown(\"SELECT id, x.d.d1 FROM test_pushdown_nestedcolumn_parquet WHERE x.d.d1 = 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d.d1\"),\n+                withColumnDomains(ImmutableMap.of(\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d1\")), singleValue(BIGINT, 1L))),\n+                ImmutableSet.of(pushdownColumnNameForSubfield(nestedColumn(\"x.d.d1\"))),\n+                TRUE_CONSTANT);\n+\n+        assertParquetDereferencePushDown(\"SELECT id, x.d.d1 FROM test_pushdown_nestedcolumn_parquet WHERE x.d.d1 = 1 and x.d.d2 = 5.0\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d.d1\", \"x.d.d2\"),\n+                withColumnDomains(ImmutableMap.of(\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d1\")), singleValue(BIGINT, 1L),\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d2\")), singleValue(DOUBLE, 5.0))),\n+                ImmutableSet.of(\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d1\")),\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d2\"))),\n+                TRUE_CONSTANT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MTA3MQ==", "bodyText": "TestHiveLogicalPlanner::nestedColumn", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470861071", "createdAt": "2020-08-14T20:56:03Z", "author": {"login": "highker"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -1271,4 +1471,97 @@ public String toString()\n                     .toString();\n         }\n     }\n+\n+    private static final class HiveParquetDereferencePushdownMatcher\n+            implements Matcher\n+    {\n+        private final Map<String, Subfield> dereferenceColumns;\n+        private final TupleDomain<String> domainPredicate;\n+        private final Set<String> predicateColumns;\n+        private final RowExpression remainingPredicate;\n+\n+        private HiveParquetDereferencePushdownMatcher(\n+                Map<String, Subfield> dereferenceColumns,\n+                TupleDomain<String> domainPredicate,\n+                Set<String> predicateColumns,\n+                RowExpression remainingPredicate)\n+        {\n+            this.dereferenceColumns = requireNonNull(dereferenceColumns, \"dereferenceColumns is null\");\n+            this.domainPredicate = requireNonNull(domainPredicate, \"domainPredicate is null\");\n+            this.predicateColumns = requireNonNull(predicateColumns, \"predicateColumns is null\");\n+            this.remainingPredicate = requireNonNull(remainingPredicate, \"remainingPredicate is null\");\n+        }\n+\n+        @Override\n+        public boolean shapeMatches(PlanNode node)\n+        {\n+            return node instanceof TableScanNode;\n+        }\n+\n+        @Override\n+        public MatchResult detailMatches(PlanNode node, StatsProvider stats, Session session, Metadata metadata, SymbolAliases symbolAliases)\n+        {\n+            TableScanNode tableScan = (TableScanNode) node;\n+            for (ColumnHandle column : tableScan.getAssignments().values()) {\n+                HiveColumnHandle hiveColumn = (HiveColumnHandle) column;\n+                String columnName = hiveColumn.getName();\n+                if (dereferenceColumns.containsKey(columnName)) {\n+                    if (hiveColumn.getColumnType() != SYNTHESIZED ||\n+                            hiveColumn.getRequiredSubfields().size() != 1 ||\n+                            !hiveColumn.getRequiredSubfields().get(0).equals(dereferenceColumns.get(columnName))) {\n+                        return NO_MATCH;\n+                    }\n+                    dereferenceColumns.remove(columnName);\n+                }\n+                else {\n+                    if (isPushedDownSubfield(hiveColumn)) {\n+                        return NO_MATCH;\n+                    }\n+                }\n+            }\n+\n+            if (!dereferenceColumns.isEmpty()) {\n+                return NO_MATCH;\n+            }\n+\n+            Optional<ConnectorTableLayoutHandle> layout = tableScan.getTable().getLayout();\n+\n+            if (!layout.isPresent()) {\n+                return NO_MATCH;\n+            }\n+\n+            HiveTableLayoutHandle layoutHandle = (HiveTableLayoutHandle) layout.get();\n+\n+            if (!Objects.equals(layoutHandle.getPredicateColumns().keySet(), predicateColumns) ||\n+                    !Objects.equals(layoutHandle.getDomainPredicate(), domainPredicate.transform(Subfield::new)) ||\n+                    !Objects.equals(layoutHandle.getRemainingPredicate(), remainingPredicate)) {\n+                return NO_MATCH;\n+            }\n+\n+            return match();\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return toStringHelper(this)\n+                    .add(\"dereferenceColumns\", dereferenceColumns)\n+                    .add(\"domainPredicate\", domainPredicate)\n+                    .add(\"predicateColumns\", predicateColumns)\n+                    .add(\"remainingPredicate\", remainingPredicate)\n+                    .toString();\n+        }\n+    }\n+\n+    private static Map<String, Subfield> nestedColumnMap(String... columns)\n+    {\n+        return Arrays.stream(columns).collect(Collectors.toMap(\n+                column -> pushdownColumnNameForSubfield(nestedColumn(column)),\n+                column -> nestedColumn(column)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MTI2Ng==", "bodyText": "leave the first line empty", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470861266", "createdAt": "2020-08-14T20:56:32Z", "author": {"login": "highker"}, "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestParquetDistributedQueries.java", "diffHunk": "@@ -42,9 +42,11 @@ private static QueryRunner createQueryRunner()\n                 .put(\"hive.storage-format\", \"PARQUET\")\n                 .put(\"hive.parquet.use-column-names\", \"true\")\n                 .put(\"hive.compression-codec\", \"GZIP\")\n+                .put(\"hive.enable-parquet-dereference-pushdown\", \"true\")\n                 .build();\n         return HiveQueryRunner.createQueryRunner(getTables(),\n-                ImmutableMap.of(\"experimental.pushdown-subfields-enabled\", \"true\"),\n+                ImmutableMap.of(\"experimental.pushdown-subfields-enabled\", \"true\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "407ef3f1eaa07745c5070bd7474b772cb5dc3fb1", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/407ef3f1eaa07745c5070bd7474b772cb5dc3fb1", "committedDate": "2020-08-14T21:10:09Z", "message": "Update Parquet reader to read pushed down dereference columns\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c3c49cade0eb140ead2dc58ff09e2ec05279018", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/3c3c49cade0eb140ead2dc58ff09e2ec05279018", "committedDate": "2020-08-14T21:10:09Z", "message": "Fix the dereference validity check in PushdownDeferences rule"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13eb102416a2536483fdaffa82a451c4baa8204c", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/13eb102416a2536483fdaffa82a451c4baa8204c", "committedDate": "2020-08-14T21:10:09Z", "message": "RowGroup pruning using the filter on pushed down subfield\n\nOnce the dereference is pushed down to tablescan, filters on the dereference column\nare automatically pushed down to tablescan as the pushed down dereference column is\nexposed as a column directly coming from the tablescan. In the reader (this case\nParquet), interpret pushed down dereference columns and convert them to column paths\nto look up the stats in footer.\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9fa931ba4636ae66f3f39fd23b4473a27ad521f", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/a9fa931ba4636ae66f3f39fd23b4473a27ad521f", "committedDate": "2020-08-14T21:10:09Z", "message": "Use SYNTHESIZED type to represent pushed down Subfield in HiveColumnHandle"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "committedDate": "2020-08-14T19:05:47Z", "message": "Use SYNTHESIZED type to represent pushed down Subfield in HiveColumnHandle"}, "afterCommit": {"oid": "a9fa931ba4636ae66f3f39fd23b4473a27ad521f", "author": {"user": {"login": "vkorukanti", "name": "Venki Korukanti"}}, "url": "https://github.com/prestodb/presto/commit/a9fa931ba4636ae66f3f39fd23b4473a27ad521f", "committedDate": "2020-08-14T21:10:09Z", "message": "Use SYNTHESIZED type to represent pushed down Subfield in HiveColumnHandle"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 422, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}