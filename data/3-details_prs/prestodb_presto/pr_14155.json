{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5MzQ4NDk0", "number": 14155, "title": "Predicate Pushdown for Druid connector", "bodyText": "== RELEASE NOTES ==\n\nDruid Changes\n* Add filter pushdown for Druid connector to improve query performance.", "createdAt": "2020-02-25T03:42:06Z", "url": "https://github.com/prestodb/presto/pull/14155", "merged": true, "mergeCommit": {"oid": "d2cb512894abe9f6f47da5469e1bc1458e0836f8"}, "closed": true, "closedAt": "2020-02-26T21:54:19Z", "author": {"login": "zhenxiao"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHpzF8AH2gAyMzc5MzQ4NDk0OjgzZmY4YWRiZTk2MjNlNDU1YmZlZWIyNzU2MTQ2YjkzY2Q0M2Q3M2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcINKEBAFqTM2NTIzNTk3NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "83ff8adbe9623e455bfeeb2756146b93cd43d73d", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/83ff8adbe9623e455bfeeb2756146b93cd43d73d", "committedDate": "2020-02-25T03:45:28Z", "message": "Druid Connector PlanOptimizer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50ef836520bce0d8cb55907d722ef69a2a9833b6", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/50ef836520bce0d8cb55907d722ef69a2a9833b6", "committedDate": "2020-02-25T03:52:26Z", "message": "Predicate Pushdown for Druid connector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/2a2513b4d7a23179c5cc6ef36474ea99081aa400", "committedDate": "2020-02-25T03:52:36Z", "message": "Add Testcase for Druid connector"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8846801e36fdba2601acb385389b37fa51e41063", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/8846801e36fdba2601acb385389b37fa51e41063", "committedDate": "2020-02-25T03:40:59Z", "message": "Add Testcase for Druid connector"}, "afterCommit": {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/2a2513b4d7a23179c5cc6ef36474ea99081aa400", "committedDate": "2020-02-25T03:52:36Z", "message": "Add Testcase for Druid connector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzOTAzNzQ4", "url": "https://github.com/prestodb/presto/pull/14155#pullrequestreview-363903748", "createdAt": "2020-02-25T06:51:09Z", "commit": {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNjo1MTowOVrOFt6aWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNzowMDo1MFrOFt6mHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NzI1Nw==", "bodyText": "this doesn't look right...", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r383687257", "createdAt": "2020-02-25T06:51:09Z", "author": {"login": "highker"}, "path": "presto-druid/pom.xml", "diffHunk": "@@ -182,6 +182,11 @@\n             <artifactId>joda-time</artifactId>\n         </dependency>\n \n+        <dependency>\n+            <groupId>com.facebook.presto</groupId>\n+            <artifactId>presto-main</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4ODAxMQ==", "bodyText": "If it is only filter pushdown, getPhysicalPlanOptimizers is the better place to put the optimizer.", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r383688011", "createdAt": "2020-02-25T06:53:33Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnector.java", "diffHunk": "@@ -74,6 +82,25 @@ public ConnectorPageSourceProvider getPageSourceProvider()\n         return pageSourceProvider;\n     }\n \n+    @Override\n+    public ConnectorPlanOptimizerProvider getConnectorPlanOptimizerProvider()\n+    {\n+        return new ConnectorPlanOptimizerProvider()\n+        {\n+            @Override\n+            public Set<ConnectorPlanOptimizer> getLogicalPlanOptimizers()\n+            {\n+                return ImmutableSet.of(planOptimizer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY5MDI2OQ==", "bodyText": "This patch has many pinot-related concept. Is broker something for druid as well?", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r383690269", "createdAt": "2020-02-25T07:00:50Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.facebook.presto.util.DateTimeZoneIndex.getChronology;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();\n+    private final ConnectorSession session;\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "committedDate": "2020-02-25T09:10:16Z", "message": "Get rid of presto util dependency in Druid connector"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0Mjc5NTY3", "url": "https://github.com/prestodb/presto/pull/14155#pullrequestreview-364279567", "createdAt": "2020-02-25T16:21:30Z", "commit": {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNjoyMTozMFrOFuMwXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNjoyMTozMFrOFuMwXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk4NzgwNg==", "bodyText": "I wonder why this code looks so familiar :-)", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r383987806", "createdAt": "2020-02-25T16:21:30Z", "author": {"login": "agrawaldevesh"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(GENERIC_INTERNAL_ERROR,\n+                        \"Expected to find druid table handle for the scan node\"));\n+        return maxSubplan.accept(new Visitor(druidTableScanNode, session, idAllocator), null);\n+    }\n+\n+    private static Optional<DruidTableHandle> getDruidTableHandle(TableScanNode tableScanNode)\n+    {\n+        TableHandle table = tableScanNode.getTable();\n+        if (table != null) {\n+            ConnectorTableHandle connectorHandle = table.getConnectorHandle();\n+            if (connectorHandle instanceof DruidTableHandle) {\n+                return Optional.of((DruidTableHandle) connectorHandle);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<TableScanNode> getOnlyDruidTable(Map<TableScanNode, Void> scanNodes)\n+    {\n+        if (scanNodes.size() == 1) {\n+            TableScanNode tableScanNode = scanNodes.keySet().iterator().next();\n+            if (getDruidTableHandle(tableScanNode).isPresent()) {\n+                return Optional.of(tableScanNode);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static PlanNode replaceChildren(PlanNode node, List<PlanNode> children)\n+    {\n+        for (int i = 0; i < node.getSources().size(); i++) {\n+            if (children.get(i) != node.getSources().get(i)) {\n+                return node.replaceChildren(children);\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private static class TableFindingVisitor\n+            extends PlanVisitor<Map<TableScanNode, Void>, Void>\n+    {\n+        @Override\n+        public Map<TableScanNode, Void> visitPlan(PlanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();\n+            node.getSources().forEach(source -> ret.putAll(source.accept(this, context)));\n+            return ret;\n+        }\n+\n+        @Override\n+        public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();\n+            ret.put(node, null);\n+            return ret;\n+        }\n+    }\n+\n+    private class Visitor\n+            extends PlanVisitor<PlanNode, Void>\n+    {\n+        private final PlanNodeIdAllocator idAllocator;\n+        private final ConnectorSession session;\n+        private final TableScanNode tableScanNode;\n+        private final IdentityHashMap<FilterNode, Void> filtersSplitUp = new IdentityHashMap<>();\n+\n+        public Visitor(TableScanNode tableScanNode, ConnectorSession session, PlanNodeIdAllocator idAllocator)\n+        {\n+            this.session = session;\n+            this.idAllocator = idAllocator;\n+            this.tableScanNode = tableScanNode;\n+            // Just making sure that the table exists\n+            getDruidTableHandle(this.tableScanNode).get().getTableName();\n+        }\n+\n+        private Optional<PlanNode> tryCreatingNewScanNode(PlanNode plan)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzYyMTY5", "url": "https://github.com/prestodb/presto/pull/14155#pullrequestreview-364362169", "createdAt": "2020-02-25T18:50:56Z", "commit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MDo1NlrOFuQ-Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxMDo0MlrOFuRoZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1Njg4Ng==", "bodyText": "typo and make it static", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384056886", "createdAt": "2020-02-25T18:50:56Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1Njk3Mw==", "bodyText": "convert to local var", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384056973", "createdAt": "2020-02-25T18:51:05Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();\n+    private final ConnectorSession session;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1NzE4NA==", "bodyText": "requireNonNull on columnHandles", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384057184", "createdAt": "2020-02-25T18:51:29Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();\n+    private final ConnectorSession session;\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            ConnectorSession session,\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(columnHandles);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MDAzMw==", "bodyText": "Let's get the instance size of this class", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384060033", "createdAt": "2020-02-25T18:56:31Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();\n+    private final ConnectorSession session;\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            ConnectorSession session,\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(columnHandles);\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());\n+\n+            List<Type> columnTypes = handles.stream()\n+                    .map(DruidColumnHandle::getColumnType)\n+                    .collect(Collectors.toList());\n+\n+            PageBuilder pageBuilder = new PageBuilder(columnTypes);\n+\n+            String data = druidClient.getData(brokerDql.getDql());\n+            JsonNode rootNode;\n+            try {\n+                rootNode = objecMapper.readTree(data);\n+                checkArgument(rootNode.isArray(), \"broker Druid query should return Json Array\");\n+                ArrayNode arrayNode = (ArrayNode) rootNode;\n+                Iterator<JsonNode> iterator = arrayNode.elements();\n+                while (iterator.hasNext()) {\n+                    JsonNode node = iterator.next();\n+                    for (int i = 0; i < columnHandles.size(); i++) {\n+                        Type type = columnTypes.get(i);\n+                        BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(i);\n+                        JsonNode value = node.get(handles.get(i).getColumnName());\n+                        if (type instanceof BigintType) {\n+                            type.writeLong(blockBuilder, value.longValue());\n+                        }\n+                        if (type instanceof DoubleType) {\n+                            type.writeDouble(blockBuilder, value.doubleValue());\n+                        }\n+                        if (type instanceof RealType) {\n+                            type.writeDouble(blockBuilder, value.doubleValue());\n+                        }\n+                        else if (type instanceof TimestampType) {\n+                            DateTimeFormatter formatter = ISODateTimeFormat.dateTimeParser()\n+                                    .withChronology(ISOChronology.getInstanceUTC())\n+                                    .withOffsetParsed();\n+                            DateTime dateTime = formatter.parseDateTime(value.textValue());\n+                            type.writeLong(blockBuilder, dateTime.getMillis());\n+                        }\n+                        else {\n+                            Slice slice = Slices.utf8Slice(value.textValue());\n+                            blockBuilder.writeBytes(slice, 0, slice.length()).closeEntry();\n+                            completedBytes += slice.length();\n+                        }\n+                    }\n+                }\n+            }\n+            catch (IOException e) {\n+                throw new PrestoException(DRUID_BROKER_RESULT_ERROR, e);\n+            }\n+            pageBuilder.declarePositions(rootNode.size());\n+            Page page = pageBuilder.build();\n+            completedPositions += page.getPositionCount();\n+            finished = true;\n+            return page;\n+        }\n+        finally {\n+            readTimeNanos += System.nanoTime() - start;\n+        }\n+    }\n+\n+    @Override\n+    public long getSystemMemoryUsage()\n+    {\n+        return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NDQ2Nw==", "bodyText": "add it to equals as well maybe", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384064467", "createdAt": "2020-02-25T19:04:24Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidColumnHandle.java", "diffHunk": "@@ -76,6 +100,13 @@ public String toString()\n         return toStringHelper(this)\n                 .add(\"columnName\", columnName)\n                 .add(\"columnType\", columnType)\n+                .add(\"type\", type)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NDk1OQ==", "bodyText": "maybe create a new class", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384064959", "createdAt": "2020-02-25T19:05:25Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnector.java", "diffHunk": "@@ -74,6 +82,25 @@ public ConnectorPageSourceProvider getPageSourceProvider()\n         return pageSourceProvider;\n     }\n \n+    @Override\n+    public ConnectorPlanOptimizerProvider getConnectorPlanOptimizerProvider()\n+    {\n+        return new ConnectorPlanOptimizerProvider()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTM3OA==", "bodyText": "Kinda weird. LogicalRowExpressions can be created anytime than an injected singleton", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384065378", "createdAt": "2020-02-25T19:06:12Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorFactory.java", "diffHunk": "@@ -48,7 +53,13 @@ public Connector create(String catalogName, Map<String, String> config, Connecto\n         try {\n             Bootstrap app = new Bootstrap(\n                     new JsonModule(),\n-                    new DruidModule(context.getTypeManager()));\n+                    new DruidModule(), binder -> {\n+                binder.bind(TypeManager.class).toInstance(context.getTypeManager());\n+                binder.bind(FunctionMetadataManager.class).toInstance(context.getFunctionMetadataManager());\n+                binder.bind(RowExpressionService.class).toInstance(context.getRowExpressionService());\n+                binder.bind(LogicalRowExpressions.class).toInstance(new LogicalRowExpressions(context.getRowExpressionService().getDeterminismEvaluator(), context.getStandardFunctionResolution(), context.getFunctionMetadataManager()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTc3OQ==", "bodyText": "nit: put GENERIC_INTERNAL_ERROR to its own line", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384065779", "createdAt": "2020-02-25T19:06:59Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(GENERIC_INTERNAL_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NjAxMw==", "bodyText": "spell out ret", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384066013", "createdAt": "2020-02-25T19:07:23Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(GENERIC_INTERNAL_ERROR,\n+                        \"Expected to find druid table handle for the scan node\"));\n+        return maxSubplan.accept(new Visitor(druidTableScanNode, session, idAllocator), null);\n+    }\n+\n+    private static Optional<DruidTableHandle> getDruidTableHandle(TableScanNode tableScanNode)\n+    {\n+        TableHandle table = tableScanNode.getTable();\n+        if (table != null) {\n+            ConnectorTableHandle connectorHandle = table.getConnectorHandle();\n+            if (connectorHandle instanceof DruidTableHandle) {\n+                return Optional.of((DruidTableHandle) connectorHandle);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<TableScanNode> getOnlyDruidTable(Map<TableScanNode, Void> scanNodes)\n+    {\n+        if (scanNodes.size() == 1) {\n+            TableScanNode tableScanNode = scanNodes.keySet().iterator().next();\n+            if (getDruidTableHandle(tableScanNode).isPresent()) {\n+                return Optional.of(tableScanNode);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static PlanNode replaceChildren(PlanNode node, List<PlanNode> children)\n+    {\n+        for (int i = 0; i < node.getSources().size(); i++) {\n+            if (children.get(i) != node.getSources().get(i)) {\n+                return node.replaceChildren(children);\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private static class TableFindingVisitor\n+            extends PlanVisitor<Map<TableScanNode, Void>, Void>\n+    {\n+        @Override\n+        public Map<TableScanNode, Void> visitPlan(PlanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();\n+            node.getSources().forEach(source -> ret.putAll(source.accept(this, context)));\n+            return ret;\n+        }\n+\n+        @Override\n+        public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NjE1MQ==", "bodyText": "same", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384066151", "createdAt": "2020-02-25T19:07:41Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(GENERIC_INTERNAL_ERROR,\n+                        \"Expected to find druid table handle for the scan node\"));\n+        return maxSubplan.accept(new Visitor(druidTableScanNode, session, idAllocator), null);\n+    }\n+\n+    private static Optional<DruidTableHandle> getDruidTableHandle(TableScanNode tableScanNode)\n+    {\n+        TableHandle table = tableScanNode.getTable();\n+        if (table != null) {\n+            ConnectorTableHandle connectorHandle = table.getConnectorHandle();\n+            if (connectorHandle instanceof DruidTableHandle) {\n+                return Optional.of((DruidTableHandle) connectorHandle);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<TableScanNode> getOnlyDruidTable(Map<TableScanNode, Void> scanNodes)\n+    {\n+        if (scanNodes.size() == 1) {\n+            TableScanNode tableScanNode = scanNodes.keySet().iterator().next();\n+            if (getDruidTableHandle(tableScanNode).isPresent()) {\n+                return Optional.of(tableScanNode);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static PlanNode replaceChildren(PlanNode node, List<PlanNode> children)\n+    {\n+        for (int i = 0; i < node.getSources().size(); i++) {\n+            if (children.get(i) != node.getSources().get(i)) {\n+                return node.replaceChildren(children);\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private static class TableFindingVisitor\n+            extends PlanVisitor<Map<TableScanNode, Void>, Void>\n+    {\n+        @Override\n+        public Map<TableScanNode, Void> visitPlan(PlanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NjUzMA==", "bodyText": "not used", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384066530", "createdAt": "2020-02-25T19:08:25Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.druid.DruidQueryGeneratorContext.Selection;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.inject.Inject;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGenerator\n+{\n+    private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+\n+    private final DruidConfig druidConfig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NjY4Ng==", "bodyText": "remove stream()", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384066686", "createdAt": "2020-02-25T19:08:41Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGeneratorContext\n+{\n+    private final LinkedHashMap<VariableReferenceExpression, Selection> selections;\n+    private final Optional<String> from;\n+    private final Optional<String> filter;\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)\n+                .add(\"selections\", selections)\n+                .add(\"from\", from)\n+                .add(\"filter\", filter)\n+                .toString();\n+    }\n+\n+    DruidQueryGeneratorContext()\n+    {\n+        this(new LinkedHashMap<>(), null);\n+    }\n+\n+    DruidQueryGeneratorContext(\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections,\n+            String from)\n+    {\n+        this(\n+                selections,\n+                Optional.ofNullable(from),\n+                Optional.empty());\n+    }\n+\n+    private DruidQueryGeneratorContext(\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections,\n+            Optional<String> from,\n+            Optional<String> filter)\n+    {\n+        this.selections = new LinkedHashMap<>(requireNonNull(selections, \"selections can't be null\"));\n+        this.from = requireNonNull(from, \"source can't be null\");\n+        this.filter = requireNonNull(filter, \"filter is null\");\n+    }\n+\n+    public DruidQueryGeneratorContext withFilter(String filter)\n+    {\n+        checkArgument(!hasFilter(), \"Druid doesn't support filters at multiple levels\");\n+        return new DruidQueryGeneratorContext(\n+                selections,\n+                from,\n+                Optional.of(filter));\n+    }\n+\n+    public DruidQueryGeneratorContext withProject(LinkedHashMap<VariableReferenceExpression, Selection> newSelections)\n+    {\n+        return new DruidQueryGeneratorContext(\n+                newSelections,\n+                from,\n+                filter);\n+    }\n+\n+    private boolean hasFilter()\n+    {\n+        return filter.isPresent();\n+    }\n+\n+    public LinkedHashMap<VariableReferenceExpression, Selection> getSelections()\n+    {\n+        return selections;\n+    }\n+\n+    public DruidQueryGenerator.GeneratedDql toQuery()\n+    {\n+        String expressions = selections.entrySet().stream()\n+                .map(s -> s.getValue().getDefinition())\n+                .collect(Collectors.joining(\", \"));\n+        if (expressions.isEmpty()) {\n+            throw new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Empty Druid query\");\n+        }\n+\n+        String tableName = from.orElseThrow(() -> new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Table name missing in Druid query\"));\n+        String query = \"SELECT \" + expressions + \" FROM \" + tableName;\n+        if (filter.isPresent()) {\n+            String filterString = filter.get();\n+            // this is hack!!!. Ideally we want to clone the scan pipeline and create/update the filter in the scan pipeline to contain this filter and\n+            // at the same time add the time column to scan so that the query generator doesn't fail when it looks up the time column in scan output columns\n+            query += \" WHERE \" + filterString;\n+        }\n+        return new DruidQueryGenerator.GeneratedDql(tableName, query);\n+    }\n+\n+    public LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> getAssignments()\n+    {\n+        LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> result = new LinkedHashMap<>();\n+        selections.entrySet().stream().forEach(entry -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NzM4Mw==", "bodyText": "return address.map(ImmutableList::of).orElse(ImmutableList.of());", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384067383", "createdAt": "2020-02-25T19:10:04Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidSplit.java", "diffHunk": "@@ -62,12 +108,32 @@ public NodeSelectionStrategy getNodeSelectionStrategy()\n     @Override\n     public List<HostAddress> getPreferredNodes(List<HostAddress> sortedCandidates)\n     {\n-        return ImmutableList.of(address);\n+        if (address.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NzQxOQ==", "bodyText": "remove", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384067419", "createdAt": "2020-02-25T19:10:08Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidSplit.java", "diffHunk": "@@ -22,33 +22,79 @@\n import com.google.common.collect.ImmutableList;\n \n import java.util.List;\n+import java.util.Optional;\n \n import static com.facebook.presto.spi.schedule.NodeSelectionStrategy.NO_PREFERENCE;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n public class DruidSplit\n         implements ConnectorSplit\n {\n-    private final DruidSegmentInfo segmentInfo;\n-    private final HostAddress address;\n+    private final SplitType splitType;\n+    private final Optional<DruidQueryGenerator.GeneratedDql> brokerDql;\n+    private final Optional<DruidSegmentInfo> segmentInfo;\n+    private final Optional<HostAddress> address;\n \n     @JsonCreator\n     public DruidSplit(\n-            @JsonProperty(\"segmentInfo\") DruidSegmentInfo segmentInfo,\n-            @JsonProperty(\"address\") HostAddress address)\n+            @JsonProperty(\"splitType\") SplitType splitType,\n+            @JsonProperty(\"brokerDql\") Optional<DruidQueryGenerator.GeneratedDql> brokerDql,\n+            @JsonProperty(\"segmentInfo\") Optional<DruidSegmentInfo> segmentInfo,\n+            @JsonProperty(\"address\") Optional<HostAddress> address)\n     {\n+        this.splitType = requireNonNull(splitType, \"splitType id is null\");\n+        this.brokerDql = requireNonNull(brokerDql, \"brokerDql is null\");\n         this.segmentInfo = requireNonNull(segmentInfo, \"segment info is null\");\n         this.address = requireNonNull(address, \"address info is null\");\n+        if (splitType == SplitType.SEGMENT) {\n+            checkArgument(segmentInfo.isPresent(), \"SegmentInfo is missing from split\");\n+            checkArgument(address.isPresent(), \"Address is missing from split\");\n+        }\n+        else {\n+            checkArgument(brokerDql.isPresent(), \"brokerDql is missing from the split\");\n+        }\n+    }\n+\n+    public static DruidSplit createBrokerSplit(DruidQueryGenerator.GeneratedDql brokerDql)\n+    {\n+        return new DruidSplit(\n+                SplitType.BROKER,\n+                Optional.of(requireNonNull(brokerDql, \"brokerDql is null\")),\n+                Optional.empty(),\n+                Optional.empty());\n+    }\n+\n+    public static DruidSplit createSegmentSplit(DruidSegmentInfo segmentInfo, HostAddress address)\n+    {\n+        return new DruidSplit(\n+                SplitType.SEGMENT,\n+                Optional.empty(),\n+                Optional.of(requireNonNull(segmentInfo, \"segmentInfo are null\")),\n+                Optional.of(requireNonNull(address, \"address is null\")));\n     }\n \n     @JsonProperty\n-    public DruidSegmentInfo getSegmentInfo()\n+    public SplitType getSplitType()\n+    {\n+        return splitType;\n+    }\n+\n+    @JsonProperty\n+    public Optional<DruidQueryGenerator.GeneratedDql> getBrokerDql()\n+    {\n+        return brokerDql;\n+    }\n+\n+    @JsonProperty\n+    public Optional<DruidSegmentInfo> getSegmentInfo()\n     {\n         return segmentInfo;\n     }\n \n     @JsonProperty\n-    public HostAddress getAddress()\n+    public Optional<HostAddress> getAddress()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NzY4NQ==", "bodyText": "TestingMetadataUtil", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384067685", "createdAt": "2020-02-25T19:10:42Z", "author": {"login": "highker"}, "path": "presto-druid/src/test/java/com/facebook/presto/druid/MetadataUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.JsonCodec;\n+import com.facebook.airlift.json.JsonCodecFactory;\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.spi.type.StandardTypes;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.util.Map;\n+\n+import static com.facebook.presto.spi.type.BigintType.BIGINT;\n+import static com.facebook.presto.spi.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.spi.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.spi.type.IntegerType.INTEGER;\n+import static com.facebook.presto.spi.type.VarcharType.VARCHAR;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class MetadataUtil", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NDg5MzUy", "url": "https://github.com/prestodb/presto/pull/14155#pullrequestreview-364489352", "createdAt": "2020-02-25T22:14:49Z", "commit": {"oid": "2571a68788cfe5176ade1e9a8cfd4122853f58ac"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjoxNDo1MFrOFuXONQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjo0MjowMlrOFuX9DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1OTI4NQ==", "bodyText": "All uppercase with underscores. Break a line after this.", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384159285", "createdAt": "2020-02-25T22:14:50Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2571a68788cfe5176ade1e9a8cfd4122853f58ac"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MDg4OA==", "bodyText": "toImmutableList", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384170888", "createdAt": "2020-02-25T22:41:16Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(requireNonNull(columnHandles, \"columnHandles is null\"));\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2571a68788cfe5176ade1e9a8cfd4122853f58ac"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MDkyMA==", "bodyText": "toImmutableList", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384170920", "createdAt": "2020-02-25T22:41:19Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(requireNonNull(columnHandles, \"columnHandles is null\"));\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());\n+\n+            List<Type> columnTypes = handles.stream()\n+                    .map(DruidColumnHandle::getColumnType)\n+                    .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2571a68788cfe5176ade1e9a8cfd4122853f58ac"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MTI0OA==", "bodyText": "else if", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384171248", "createdAt": "2020-02-25T22:41:58Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(requireNonNull(columnHandles, \"columnHandles is null\"));\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());\n+\n+            List<Type> columnTypes = handles.stream()\n+                    .map(DruidColumnHandle::getColumnType)\n+                    .collect(Collectors.toList());\n+\n+            PageBuilder pageBuilder = new PageBuilder(columnTypes);\n+\n+            String data = druidClient.getData(brokerDql.getDql());\n+            JsonNode rootNode;\n+            try {\n+                rootNode = objectMapper.readTree(data);\n+                checkArgument(rootNode.isArray(), \"broker Druid query should return Json Array\");\n+                ArrayNode arrayNode = (ArrayNode) rootNode;\n+                Iterator<JsonNode> iterator = arrayNode.elements();\n+                while (iterator.hasNext()) {\n+                    JsonNode node = iterator.next();\n+                    for (int i = 0; i < columnHandles.size(); i++) {\n+                        Type type = columnTypes.get(i);\n+                        BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(i);\n+                        JsonNode value = node.get(handles.get(i).getColumnName());\n+                        if (type instanceof BigintType) {\n+                            type.writeLong(blockBuilder, value.longValue());\n+                        }\n+                        if (type instanceof DoubleType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2571a68788cfe5176ade1e9a8cfd4122853f58ac"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MTI3Nw==", "bodyText": "else if", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384171277", "createdAt": "2020-02-25T22:42:02Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(requireNonNull(columnHandles, \"columnHandles is null\"));\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());\n+\n+            List<Type> columnTypes = handles.stream()\n+                    .map(DruidColumnHandle::getColumnType)\n+                    .collect(Collectors.toList());\n+\n+            PageBuilder pageBuilder = new PageBuilder(columnTypes);\n+\n+            String data = druidClient.getData(brokerDql.getDql());\n+            JsonNode rootNode;\n+            try {\n+                rootNode = objectMapper.readTree(data);\n+                checkArgument(rootNode.isArray(), \"broker Druid query should return Json Array\");\n+                ArrayNode arrayNode = (ArrayNode) rootNode;\n+                Iterator<JsonNode> iterator = arrayNode.elements();\n+                while (iterator.hasNext()) {\n+                    JsonNode node = iterator.next();\n+                    for (int i = 0; i < columnHandles.size(); i++) {\n+                        Type type = columnTypes.get(i);\n+                        BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(i);\n+                        JsonNode value = node.get(handles.get(i).getColumnName());\n+                        if (type instanceof BigintType) {\n+                            type.writeLong(blockBuilder, value.longValue());\n+                        }\n+                        if (type instanceof DoubleType) {\n+                            type.writeDouble(blockBuilder, value.doubleValue());\n+                        }\n+                        if (type instanceof RealType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2571a68788cfe5176ade1e9a8cfd4122853f58ac"}, "originalPosition": 134}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2571a68788cfe5176ade1e9a8cfd4122853f58ac", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/2571a68788cfe5176ade1e9a8cfd4122853f58ac", "committedDate": "2020-02-25T21:05:40Z", "message": "Code cleanup for Druid predicate pushdown"}, "afterCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/fd87a7008690d955e28be03aac725936c3d30fe5", "committedDate": "2020-02-26T03:55:41Z", "message": "Code cleanup for Druid predicate pushdown"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NjM5NDk4", "url": "https://github.com/prestodb/presto/pull/14155#pullrequestreview-364639498", "createdAt": "2020-02-26T06:00:12Z", "commit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNjowMDoxM1rOFufHRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwNjoyNTowMVrOFuffhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODU4Mw==", "bodyText": "move binder -> { to its own line", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288583", "createdAt": "2020-02-26T06:00:13Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorFactory.java", "diffHunk": "@@ -48,7 +53,13 @@ public Connector create(String catalogName, Map<String, String> config, Connecto\n         try {\n             Bootstrap app = new Bootstrap(\n                     new JsonModule(),\n-                    new DruidModule(context.getTypeManager()));\n+                    new DruidModule(), binder -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODYxNQ==", "bodyText": "Comment not addressed?", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288615", "createdAt": "2020-02-26T06:00:22Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnector.java", "diffHunk": "@@ -74,6 +82,25 @@ public ConnectorPageSourceProvider getPageSourceProvider()\n         return pageSourceProvider;\n     }\n \n+    @Override\n+    public ConnectorPlanOptimizerProvider getConnectorPlanOptimizerProvider()\n+    {\n+        return new ConnectorPlanOptimizerProvider()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NDk1OQ=="}, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODYzOQ==", "bodyText": "Comment not addressed?", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288639", "createdAt": "2020-02-26T06:00:26Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorFactory.java", "diffHunk": "@@ -48,7 +53,13 @@ public Connector create(String catalogName, Map<String, String> config, Connecto\n         try {\n             Bootstrap app = new Bootstrap(\n                     new JsonModule(),\n-                    new DruidModule(context.getTypeManager()));\n+                    new DruidModule(), binder -> {\n+                binder.bind(TypeManager.class).toInstance(context.getTypeManager());\n+                binder.bind(FunctionMetadataManager.class).toInstance(context.getFunctionMetadataManager());\n+                binder.bind(RowExpressionService.class).toInstance(context.getRowExpressionService());\n+                binder.bind(LogicalRowExpressions.class).toInstance(new LogicalRowExpressions(context.getRowExpressionService().getDeterminismEvaluator(), context.getStandardFunctionResolution(), context.getFunctionMetadataManager()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTM3OA=="}, "originalCommit": {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODcwMQ==", "bodyText": "create it instead of inject it", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288701", "createdAt": "2020-02-26T06:00:45Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODgxNg==", "bodyText": "combine this line with the previous line", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288816", "createdAt": "2020-02-26T06:01:17Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MDg0MA==", "bodyText": "Map", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384290840", "createdAt": "2020-02-26T06:09:16Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(\n+                        GENERIC_INTERNAL_ERROR,\n+                        \"Expected to find druid table handle for the scan node\"));\n+        return maxSubplan.accept(new Visitor(druidTableScanNode, session, idAllocator), null);\n+    }\n+\n+    private static Optional<DruidTableHandle> getDruidTableHandle(TableScanNode tableScanNode)\n+    {\n+        TableHandle table = tableScanNode.getTable();\n+        if (table != null) {\n+            ConnectorTableHandle connectorHandle = table.getConnectorHandle();\n+            if (connectorHandle instanceof DruidTableHandle) {\n+                return Optional.of((DruidTableHandle) connectorHandle);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<TableScanNode> getOnlyDruidTable(Map<TableScanNode, Void> scanNodes)\n+    {\n+        if (scanNodes.size() == 1) {\n+            TableScanNode tableScanNode = scanNodes.keySet().iterator().next();\n+            if (getDruidTableHandle(tableScanNode).isPresent()) {\n+                return Optional.of(tableScanNode);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static PlanNode replaceChildren(PlanNode node, List<PlanNode> children)\n+    {\n+        for (int i = 0; i < node.getSources().size(); i++) {\n+            if (children.get(i) != node.getSources().get(i)) {\n+                return node.replaceChildren(children);\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private static class TableFindingVisitor\n+            extends PlanVisitor<Map<TableScanNode, Void>, Void>\n+    {\n+        @Override\n+        public Map<TableScanNode, Void> visitPlan(PlanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> result = new IdentityHashMap<>();\n+            node.getSources().forEach(source -> result.putAll(source.accept(this, context)));\n+            return result;\n+        }\n+\n+        @Override\n+        public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> result = new IdentityHashMap<>();\n+            result.put(node, null);\n+            return result;\n+        }\n+    }\n+\n+    private class Visitor\n+            extends PlanVisitor<PlanNode, Void>\n+    {\n+        private final PlanNodeIdAllocator idAllocator;\n+        private final ConnectorSession session;\n+        private final TableScanNode tableScanNode;\n+        private final IdentityHashMap<FilterNode, Void> filtersSplitUp = new IdentityHashMap<>();\n+\n+        public Visitor(TableScanNode tableScanNode, ConnectorSession session, PlanNodeIdAllocator idAllocator)\n+        {\n+            this.session = session;\n+            this.idAllocator = idAllocator;\n+            this.tableScanNode = tableScanNode;\n+            // Just making sure that the table exists\n+            getDruidTableHandle(this.tableScanNode).get().getTableName();\n+        }\n+\n+        private Optional<PlanNode> tryCreatingNewScanNode(PlanNode plan)\n+        {\n+            Optional<DruidQueryGenerator.DruidQueryGeneratorResult> dql = druidQueryGenerator.generate(plan, session);\n+            if (!dql.isPresent()) {\n+                return Optional.empty();\n+            }\n+            DruidTableHandle druidTableHandle = getDruidTableHandle(tableScanNode).orElseThrow(() -> new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Expected to find a druid table handle\"));\n+            DruidQueryGeneratorContext context = dql.get().getContext();\n+            TableHandle oldTableHandle = tableScanNode.getTable();\n+            LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> assignments = context.getAssignments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDA2OQ==", "bodyText": "private", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294069", "createdAt": "2020-02-26T06:22:21Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.druid.DruidQueryGeneratorContext.Selection;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.inject.Inject;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGenerator\n+{\n+    private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+    private final DruidProjectExpressionConverter druidProjectExpressionConverter;\n+\n+    @Inject\n+    public DruidQueryGenerator(\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function metadata manager is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standardFunctionResolution is null\");\n+        this.druidProjectExpressionConverter = new DruidProjectExpressionConverter(typeManager, standardFunctionResolution);\n+    }\n+\n+    public static class DruidQueryGeneratorResult\n+    {\n+        private final GeneratedDql generateddql;\n+        private final DruidQueryGeneratorContext context;\n+\n+        public DruidQueryGeneratorResult(\n+                GeneratedDql generateddql,\n+                DruidQueryGeneratorContext context)\n+        {\n+            this.generateddql = requireNonNull(generateddql, \"generateddql is null\");\n+            this.context = requireNonNull(context, \"context is null\");\n+        }\n+\n+        public GeneratedDql getGeneratedDql()\n+        {\n+            return generateddql;\n+        }\n+\n+        public DruidQueryGeneratorContext getContext()\n+        {\n+            return context;\n+        }\n+    }\n+\n+    public Optional<DruidQueryGeneratorResult> generate(PlanNode plan, ConnectorSession session)\n+    {\n+        try {\n+            DruidQueryGeneratorContext context = requireNonNull(plan.accept(\n+                    new DruidQueryPlanVisitor(session),\n+                    new DruidQueryGeneratorContext()),\n+                    \"Resulting context is null\");\n+            return Optional.of(new DruidQueryGeneratorResult(context.toQuery(), context));\n+        }\n+        catch (PrestoException e) {\n+            log.debug(e, \"Possibly benign error when pushing plan into scan node %s\", plan);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static class GeneratedDql\n+    {\n+        final String table;\n+        final String dql;\n+\n+        @JsonCreator\n+        public GeneratedDql(\n+                @JsonProperty(\"table\") String table,\n+                @JsonProperty(\"dql\") String dql)\n+        {\n+            this.table = table;\n+            this.dql = dql;\n+        }\n+\n+        @JsonProperty(\"dql\")\n+        public String getDql()\n+        {\n+            return dql;\n+        }\n+\n+        @JsonProperty(\"table\")\n+        public String getTable()\n+        {\n+            return table;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return toStringHelper(this)\n+                    .add(\"dql\", dql)\n+                    .add(\"table\", table)\n+                    .toString();\n+        }\n+    }\n+\n+    class DruidQueryPlanVisitor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDExNA==", "bodyText": "Map", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294114", "createdAt": "2020-02-26T06:22:35Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.druid.DruidQueryGeneratorContext.Selection;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.inject.Inject;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGenerator\n+{\n+    private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+    private final DruidProjectExpressionConverter druidProjectExpressionConverter;\n+\n+    @Inject\n+    public DruidQueryGenerator(\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function metadata manager is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standardFunctionResolution is null\");\n+        this.druidProjectExpressionConverter = new DruidProjectExpressionConverter(typeManager, standardFunctionResolution);\n+    }\n+\n+    public static class DruidQueryGeneratorResult\n+    {\n+        private final GeneratedDql generateddql;\n+        private final DruidQueryGeneratorContext context;\n+\n+        public DruidQueryGeneratorResult(\n+                GeneratedDql generateddql,\n+                DruidQueryGeneratorContext context)\n+        {\n+            this.generateddql = requireNonNull(generateddql, \"generateddql is null\");\n+            this.context = requireNonNull(context, \"context is null\");\n+        }\n+\n+        public GeneratedDql getGeneratedDql()\n+        {\n+            return generateddql;\n+        }\n+\n+        public DruidQueryGeneratorContext getContext()\n+        {\n+            return context;\n+        }\n+    }\n+\n+    public Optional<DruidQueryGeneratorResult> generate(PlanNode plan, ConnectorSession session)\n+    {\n+        try {\n+            DruidQueryGeneratorContext context = requireNonNull(plan.accept(\n+                    new DruidQueryPlanVisitor(session),\n+                    new DruidQueryGeneratorContext()),\n+                    \"Resulting context is null\");\n+            return Optional.of(new DruidQueryGeneratorResult(context.toQuery(), context));\n+        }\n+        catch (PrestoException e) {\n+            log.debug(e, \"Possibly benign error when pushing plan into scan node %s\", plan);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static class GeneratedDql\n+    {\n+        final String table;\n+        final String dql;\n+\n+        @JsonCreator\n+        public GeneratedDql(\n+                @JsonProperty(\"table\") String table,\n+                @JsonProperty(\"dql\") String dql)\n+        {\n+            this.table = table;\n+            this.dql = dql;\n+        }\n+\n+        @JsonProperty(\"dql\")\n+        public String getDql()\n+        {\n+            return dql;\n+        }\n+\n+        @JsonProperty(\"table\")\n+        public String getTable()\n+        {\n+            return table;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return toStringHelper(this)\n+                    .add(\"dql\", dql)\n+                    .add(\"table\", table)\n+                    .toString();\n+        }\n+    }\n+\n+    class DruidQueryPlanVisitor\n+            extends PlanVisitor<DruidQueryGeneratorContext, DruidQueryGeneratorContext>\n+    {\n+        private final ConnectorSession session;\n+\n+        protected DruidQueryPlanVisitor(ConnectorSession session)\n+        {\n+            this.session = session;\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitPlan(PlanNode node, DruidQueryGeneratorContext context)\n+        {\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector with plan node of type \" + node);\n+        }\n+\n+        protected VariableReferenceExpression getVariableReference(RowExpression expression)\n+        {\n+            if (expression instanceof VariableReferenceExpression) {\n+                return ((VariableReferenceExpression) expression);\n+            }\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Expect variable reference, but get: \" + expression);\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitFilter(FilterNode node, DruidQueryGeneratorContext context)\n+        {\n+            context = node.getSource().accept(this, context);\n+            requireNonNull(context, \"context is null\");\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections();\n+            DruidFilterExpressionConverter druidFilterExpressionConverter = new DruidFilterExpressionConverter(typeManager, functionMetadataManager, standardFunctionResolution, session);\n+            String filter = node.getPredicate().accept(druidFilterExpressionConverter, selections::get).getDefinition();\n+            return context.withFilter(filter).withOutputColumns(node.getOutputVariables());\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitProject(ProjectNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            DruidQueryGeneratorContext context = node.getSource().accept(this, contextIn);\n+            requireNonNull(context, \"context is null\");\n+            LinkedHashMap<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();\n+\n+            node.getOutputVariables().forEach(variable -> {\n+                RowExpression expression = node.getAssignments().get(variable);\n+                DruidExpression druidExpression = expression.accept(\n+                        druidProjectExpressionConverter,\n+                        context.getSelections());\n+                newSelections.put(\n+                        variable,\n+                        new Selection(druidExpression.getDefinition(), druidExpression.getOrigin()));\n+            });\n+            return context.withProject(newSelections);\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            DruidTableHandle tableHandle = (DruidTableHandle) node.getTable().getConnectorHandle();\n+            checkArgument(!tableHandle.getDql().isPresent(), \"Druid tableHandle should not have dql before pushdown\");\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDIxOA==", "bodyText": "Map", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294218", "createdAt": "2020-02-26T06:22:51Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.druid.DruidQueryGeneratorContext.Selection;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.inject.Inject;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGenerator\n+{\n+    private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+    private final DruidProjectExpressionConverter druidProjectExpressionConverter;\n+\n+    @Inject\n+    public DruidQueryGenerator(\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function metadata manager is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standardFunctionResolution is null\");\n+        this.druidProjectExpressionConverter = new DruidProjectExpressionConverter(typeManager, standardFunctionResolution);\n+    }\n+\n+    public static class DruidQueryGeneratorResult\n+    {\n+        private final GeneratedDql generateddql;\n+        private final DruidQueryGeneratorContext context;\n+\n+        public DruidQueryGeneratorResult(\n+                GeneratedDql generateddql,\n+                DruidQueryGeneratorContext context)\n+        {\n+            this.generateddql = requireNonNull(generateddql, \"generateddql is null\");\n+            this.context = requireNonNull(context, \"context is null\");\n+        }\n+\n+        public GeneratedDql getGeneratedDql()\n+        {\n+            return generateddql;\n+        }\n+\n+        public DruidQueryGeneratorContext getContext()\n+        {\n+            return context;\n+        }\n+    }\n+\n+    public Optional<DruidQueryGeneratorResult> generate(PlanNode plan, ConnectorSession session)\n+    {\n+        try {\n+            DruidQueryGeneratorContext context = requireNonNull(plan.accept(\n+                    new DruidQueryPlanVisitor(session),\n+                    new DruidQueryGeneratorContext()),\n+                    \"Resulting context is null\");\n+            return Optional.of(new DruidQueryGeneratorResult(context.toQuery(), context));\n+        }\n+        catch (PrestoException e) {\n+            log.debug(e, \"Possibly benign error when pushing plan into scan node %s\", plan);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static class GeneratedDql\n+    {\n+        final String table;\n+        final String dql;\n+\n+        @JsonCreator\n+        public GeneratedDql(\n+                @JsonProperty(\"table\") String table,\n+                @JsonProperty(\"dql\") String dql)\n+        {\n+            this.table = table;\n+            this.dql = dql;\n+        }\n+\n+        @JsonProperty(\"dql\")\n+        public String getDql()\n+        {\n+            return dql;\n+        }\n+\n+        @JsonProperty(\"table\")\n+        public String getTable()\n+        {\n+            return table;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return toStringHelper(this)\n+                    .add(\"dql\", dql)\n+                    .add(\"table\", table)\n+                    .toString();\n+        }\n+    }\n+\n+    class DruidQueryPlanVisitor\n+            extends PlanVisitor<DruidQueryGeneratorContext, DruidQueryGeneratorContext>\n+    {\n+        private final ConnectorSession session;\n+\n+        protected DruidQueryPlanVisitor(ConnectorSession session)\n+        {\n+            this.session = session;\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitPlan(PlanNode node, DruidQueryGeneratorContext context)\n+        {\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector with plan node of type \" + node);\n+        }\n+\n+        protected VariableReferenceExpression getVariableReference(RowExpression expression)\n+        {\n+            if (expression instanceof VariableReferenceExpression) {\n+                return ((VariableReferenceExpression) expression);\n+            }\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Expect variable reference, but get: \" + expression);\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitFilter(FilterNode node, DruidQueryGeneratorContext context)\n+        {\n+            context = node.getSource().accept(this, context);\n+            requireNonNull(context, \"context is null\");\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDI3NQ==", "bodyText": "Map", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294275", "createdAt": "2020-02-26T06:23:03Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGeneratorContext\n+{\n+    private final LinkedHashMap<VariableReferenceExpression, Selection> selections;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDQyMw==", "bodyText": "Can we replace all these to map?", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294423", "createdAt": "2020-02-26T06:23:32Z", "author": {"login": "highker"}, "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGeneratorContext\n+{\n+    private final LinkedHashMap<VariableReferenceExpression, Selection> selections;\n+    private final Optional<String> from;\n+    private final Optional<String> filter;\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)\n+                .add(\"selections\", selections)\n+                .add(\"from\", from)\n+                .add(\"filter\", filter)\n+                .toString();\n+    }\n+\n+    DruidQueryGeneratorContext()\n+    {\n+        this(new LinkedHashMap<>(), null);\n+    }\n+\n+    DruidQueryGeneratorContext(\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections,\n+            String from)\n+    {\n+        this(\n+                selections,\n+                Optional.ofNullable(from),\n+                Optional.empty());\n+    }\n+\n+    private DruidQueryGeneratorContext(\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections,\n+            Optional<String> from,\n+            Optional<String> filter)\n+    {\n+        this.selections = new LinkedHashMap<>(requireNonNull(selections, \"selections can't be null\"));\n+        this.from = requireNonNull(from, \"source can't be null\");\n+        this.filter = requireNonNull(filter, \"filter is null\");\n+    }\n+\n+    public DruidQueryGeneratorContext withFilter(String filter)\n+    {\n+        checkArgument(!hasFilter(), \"Druid doesn't support filters at multiple levels\");\n+        return new DruidQueryGeneratorContext(\n+                selections,\n+                from,\n+                Optional.of(filter));\n+    }\n+\n+    public DruidQueryGeneratorContext withProject(LinkedHashMap<VariableReferenceExpression, Selection> newSelections)\n+    {\n+        return new DruidQueryGeneratorContext(\n+                newSelections,\n+                from,\n+                filter);\n+    }\n+\n+    private boolean hasFilter()\n+    {\n+        return filter.isPresent();\n+    }\n+\n+    public LinkedHashMap<VariableReferenceExpression, Selection> getSelections()\n+    {\n+        return selections;\n+    }\n+\n+    public DruidQueryGenerator.GeneratedDql toQuery()\n+    {\n+        String expressions = selections.entrySet().stream()\n+                .map(s -> s.getValue().getDefinition())\n+                .collect(Collectors.joining(\", \"));\n+        if (expressions.isEmpty()) {\n+            throw new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Empty Druid query\");\n+        }\n+\n+        String tableName = from.orElseThrow(() -> new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Table name missing in Druid query\"));\n+        String query = \"SELECT \" + expressions + \" FROM \" + tableName;\n+        if (filter.isPresent()) {\n+            String filterString = filter.get();\n+            // this is hack!!!. Ideally we want to clone the scan pipeline and create/update the filter in the scan pipeline to contain this filter and\n+            // at the same time add the time column to scan so that the query generator doesn't fail when it looks up the time column in scan output columns\n+            query += \" WHERE \" + filterString;\n+        }\n+        return new DruidQueryGenerator.GeneratedDql(tableName, query);\n+    }\n+\n+    public LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> getAssignments()\n+    {\n+        LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> result = new LinkedHashMap<>();\n+        selections.entrySet().forEach(entry -> {\n+            VariableReferenceExpression variable = entry.getKey();\n+            Selection selection = entry.getValue();\n+            DruidColumnHandle handle = selection.getOrigin() == Origin.TABLE_COLUMN ? new DruidColumnHandle(selection.getDefinition(), variable.getType(), DruidColumnHandle.DruidColumnType.REGULAR) : new DruidColumnHandle(variable, DruidColumnHandle.DruidColumnType.DERIVED);\n+            result.put(variable, handle);\n+        });\n+        return result;\n+    }\n+\n+    public DruidQueryGeneratorContext withOutputColumns(List<VariableReferenceExpression> outputColumns)\n+    {\n+        LinkedHashMap<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDc5MQ==", "bodyText": "Do we really need both sessions?", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294791", "createdAt": "2020-02-26T06:25:01Z", "author": {"login": "highker"}, "path": "presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryBase.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.SystemSessionProperties;\n+import com.facebook.presto.block.BlockEncodingManager;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.metadata.FunctionManager;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.metadata.MetadataManager;\n+import com.facebook.presto.metadata.SessionPropertyManager;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorId;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.block.SortOrder;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.LimitNode;\n+import com.facebook.presto.spi.plan.Ordering;\n+import com.facebook.presto.spi.plan.OrderingScheme;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.plan.TopNNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.Type;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.facebook.presto.sql.ExpressionUtils;\n+import com.facebook.presto.sql.analyzer.FeaturesConfig;\n+import com.facebook.presto.sql.parser.ParsingOptions;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.planner.TypeProvider;\n+import com.facebook.presto.sql.planner.iterative.rule.test.PlanBuilder;\n+import com.facebook.presto.sql.relational.FunctionResolution;\n+import com.facebook.presto.sql.relational.SqlToRowExpressionTranslator;\n+import com.facebook.presto.sql.tree.Expression;\n+import com.facebook.presto.sql.tree.NodeRef;\n+import com.facebook.presto.testing.TestingSession;\n+import com.facebook.presto.testing.TestingTransactionHandle;\n+import com.facebook.presto.type.TypeRegistry;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.facebook.presto.druid.DruidColumnHandle.DruidColumnType.REGULAR;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.DERIVED;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.facebook.presto.spi.plan.LimitNode.Step.FINAL;\n+import static com.facebook.presto.spi.type.BigintType.BIGINT;\n+import static com.facebook.presto.spi.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.spi.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.sql.analyzer.ExpressionAnalyzer.getExpressionTypes;\n+import static com.facebook.presto.testing.TestingConnectorSession.SESSION;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class TestDruidQueryBase\n+{\n+    protected static final TypeManager typeManager = new TypeRegistry();\n+    protected static final FunctionManager functionMetadataManager = new FunctionManager(typeManager, new BlockEncodingManager(typeManager), new FeaturesConfig());\n+    protected static final StandardFunctionResolution standardFunctionResolution = new FunctionResolution(functionMetadataManager);\n+\n+    protected static ConnectorId druidConnectorId = new ConnectorId(\"id\");\n+    protected static DruidTableHandle realtimeOnlyTable = new DruidTableHandle(\"schema\", \"realtimeOnly\", Optional.empty());\n+    protected static DruidTableHandle hybridTable = new DruidTableHandle(\"schema\", \"hybrid\", Optional.empty());\n+    protected static DruidColumnHandle regionId = new DruidColumnHandle(\"regionId\", BIGINT, REGULAR);\n+    protected static DruidColumnHandle city = new DruidColumnHandle(\"city\", VARCHAR, REGULAR);\n+    protected static final DruidColumnHandle fare = new DruidColumnHandle(\"fare\", DOUBLE, REGULAR);\n+    protected static final DruidColumnHandle secondsSinceEpoch = new DruidColumnHandle(\"secondsSinceEpoch\", BIGINT, REGULAR);\n+\n+    protected static final Metadata metadata = MetadataManager.createTestMetadataManager();\n+\n+    protected final DruidConfig druidConfig = new DruidConfig();\n+\n+    protected static final Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> testInput = ImmutableMap.of(\n+            new VariableReferenceExpression(\"regionid\", BIGINT), new DruidQueryGeneratorContext.Selection(\"regionId\", TABLE_COLUMN),\n+            new VariableReferenceExpression(\"city\", VARCHAR), new DruidQueryGeneratorContext.Selection(\"city\", TABLE_COLUMN),\n+            new VariableReferenceExpression(\"fare\", DOUBLE), new DruidQueryGeneratorContext.Selection(\"fare\", TABLE_COLUMN),\n+            new VariableReferenceExpression(\"totalfare\", DOUBLE), new DruidQueryGeneratorContext.Selection(\"(fare + trip)\", DERIVED),\n+            new VariableReferenceExpression(\"secondssinceepoch\", BIGINT), new DruidQueryGeneratorContext.Selection(\"secondsSinceEpoch\", TABLE_COLUMN));\n+\n+    protected final TypeProvider typeProvider = TypeProvider.fromVariables(testInput.keySet());\n+\n+    protected static class SessionHolder\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final Session session;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5"}, "originalPosition": 112}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/fd87a7008690d955e28be03aac725936c3d30fe5", "committedDate": "2020-02-26T03:55:41Z", "message": "Code cleanup for Druid predicate pushdown"}, "afterCommit": {"oid": "b180aa4350c052143bcbfce6a841229658f11904", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/b180aa4350c052143bcbfce6a841229658f11904", "committedDate": "2020-02-26T07:25:40Z", "message": "Code cleanup for Druid predicate pushdown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fe8ad3269fb85f615bb21ac3a998dd19fd6efe5", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/1fe8ad3269fb85f615bb21ac3a998dd19fd6efe5", "committedDate": "2020-02-26T20:44:16Z", "message": "Code cleanup for Druid predicate pushdown"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b180aa4350c052143bcbfce6a841229658f11904", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/b180aa4350c052143bcbfce6a841229658f11904", "committedDate": "2020-02-26T07:25:40Z", "message": "Code cleanup for Druid predicate pushdown"}, "afterCommit": {"oid": "1fe8ad3269fb85f615bb21ac3a998dd19fd6efe5", "author": {"user": {"login": "zhenxiao", "name": "Zhenxiao Luo"}}, "url": "https://github.com/prestodb/presto/commit/1fe8ad3269fb85f615bb21ac3a998dd19fd6efe5", "committedDate": "2020-02-26T20:44:16Z", "message": "Code cleanup for Druid predicate pushdown"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjM1OTc1", "url": "https://github.com/prestodb/presto/pull/14155#pullrequestreview-365235975", "createdAt": "2020-02-26T20:57:14Z", "commit": {"oid": "b180aa4350c052143bcbfce6a841229658f11904"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2337, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}