{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwNjg5Mjcx", "number": 15437, "title": "Add cpu and memory stats to NodeTaskMap", "bodyText": "NodeTaskMap holds the worker level aggregated split stats which is used by NodeSelectors. NodeSelector accesses to NodeTaskMap via NodeAssignmentStats. CPU and Memory stats are added to NodeTaskMap. CPU and Memory stats will used in planed new feature \"workload placement\".", "createdAt": "2020-11-13T16:40:38Z", "url": "https://github.com/prestodb/presto/pull/15437", "merged": true, "mergeCommit": {"oid": "adaa2574364bb08f12e1c070fb779338ead8dbb8"}, "closed": true, "closedAt": "2021-01-27T18:39:33Z", "author": {"login": "cemcayiroglu"}, "timelineItems": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdcJ8XqABqjM5OTQzMTY4NTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdvk8O_gFqTU2NjgxNjg0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64921c42d22cdec3e0d2a1b803f2bf8b7e605100", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/64921c42d22cdec3e0d2a1b803f2bf8b7e605100", "committedDate": "2020-11-13T16:28:06Z", "message": "Adding cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/93fc71a82159422114e0d9f32845792ef2df28f3", "committedDate": "2020-11-13T16:41:45Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMzAxMzUz", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-530301353", "createdAt": "2020-11-13T18:18:48Z", "commit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODoxODo0OFrOHy55ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxODozMzo0N1rOHy6cvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEzOTQzNA==", "bodyText": "Nit: add the units to the names (e.g., bytes, millis)", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523139434", "createdAt": "2020-11-13T18:18:48Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -79,19 +103,33 @@ private NodeTasks addNodeTask(InternalNode node)\n     private static class NodeTasks\n     {\n         private final Set<RemoteTask> remoteTasks = Sets.newConcurrentHashSet();\n-        private final AtomicInteger nodeTotalPartitionedSplitCount = new AtomicInteger();\n+        private final AtomicLong nodeTotalPartitionedSplitCount = new AtomicLong();\n+        private final AtomicLong nodeTotalMemoryUsage = new AtomicLong();\n+        private final AtomicLong nodeTotalCpuUsage = new AtomicLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MDA1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private class TaskCumulativeStatsTracker\n          \n          \n            \n                    private class CumulativeTaskStatsTracker", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523140055", "createdAt": "2020-11-13T18:19:26Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +146,161 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsage);\n+            TaskCumulativeStatsTracker cpuUsageTracker = new TaskCumulativeStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuUsage, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        @ThreadSafe\n+        private class TaskCumulativeStatsTracker", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NTc3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (delta >= 0 && duration > 0) {\n          \n          \n            \n                                        return delta / duration;\n          \n          \n            \n                                    }\n          \n          \n            \n                                    else {\n          \n          \n            \n                                        throw new IllegalArgumentException(stat + \"delta is negative\");\n          \n          \n            \n                                    }\n          \n          \n            \n                                    checkArgument(delta >= 0 && duration > 0, \"stat + \"delta is negative\");\n          \n          \n            \n                                    return delta / duration;", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523145771", "createdAt": "2020-11-13T18:28:53Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +146,161 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsage);\n+            TaskCumulativeStatsTracker cpuUsageTracker = new TaskCumulativeStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuUsage, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        @ThreadSafe\n+        private class TaskCumulativeStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMilis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public TaskCumulativeStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMilis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.stat = requireNonNull(stat, \"stat is null\");\n+                this.windowSizeInMilis = windowSizeInMilis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAge, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAge, value);\n+                    values = values.tailMap(values.lastKey() - windowSizeInMilis);\n+                    if (values.size() > 1) {\n+                        Long firstReporting = values.firstKey();\n+                        Long lastAge = values.lastKey();\n+                        long delta = (value - values.get(firstReporting)) * 100;\n+                        long duration = lastAge - firstReporting;\n+                        if (delta >= 0 && duration > 0) {\n+                            return delta / duration;\n+                        }\n+                        else {\n+                            throw new IllegalArgumentException(stat + \"delta is negative\");\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NjMwOA==", "bodyText": "Can you comment what this class is trying to do?  The class name doesn't seem to describe it well.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523146308", "createdAt": "2020-11-13T18:29:51Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +146,161 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsage);\n+            TaskCumulativeStatsTracker cpuUsageTracker = new TaskCumulativeStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuUsage, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        @ThreadSafe\n+        private class TaskCumulativeStatsTracker", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MDA1NQ=="}, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NzI2Nw==", "bodyText": "Please add units to all names.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523147267", "createdAt": "2020-11-13T18:31:41Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -243,6 +244,20 @@ public long getPeakNodeTotalMemoryReservationInBytes()\n         return peakNodeTotalMemoryReservationInBytes;\n     }\n \n+    @JsonProperty\n+    @ThriftField(18)\n+    public long getTotalCpuTimeInNanos()\n+    {\n+        return totalCpuTimeInNanos;\n+    }\n+\n+    @JsonProperty\n+    @ThriftField(19)\n+    public long getTaskAge()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0ODQ3Ng==", "bodyText": "Unrelated change?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523148476", "createdAt": "2020-11-13T18:33:47Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -57,22 +57,19 @@\n     private final TaskState state;\n     private final URI self;\n     private final Set<Lifespan> completedDriverGroups;\n-\n+    private final List<ExecutionFailureInfo> failures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93fc71a82159422114e0d9f32845792ef2df28f3", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/93fc71a82159422114e0d9f32845792ef2df28f3", "committedDate": "2020-11-13T16:41:45Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "bef23cb40992d75e3983939f72d6f7cae5116326", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/bef23cb40992d75e3983939f72d6f7cae5116326", "committedDate": "2020-11-18T23:04:36Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bef23cb40992d75e3983939f72d6f7cae5116326", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/bef23cb40992d75e3983939f72d6f7cae5116326", "committedDate": "2020-11-18T23:04:36Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "24db1948bf08b3b61e082e9194fb6325cd72f67f", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/24db1948bf08b3b61e082e9194fb6325cd72f67f", "committedDate": "2020-11-18T23:27:37Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "24db1948bf08b3b61e082e9194fb6325cd72f67f", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/24db1948bf08b3b61e082e9194fb6325cd72f67f", "committedDate": "2020-11-18T23:27:37Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "b021e6e576e819227996f2f5d47144cac5c63d8f", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/b021e6e576e819227996f2f5d47144cac5c63d8f", "committedDate": "2020-11-19T03:24:36Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b021e6e576e819227996f2f5d47144cac5c63d8f", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/b021e6e576e819227996f2f5d47144cac5c63d8f", "committedDate": "2020-11-19T03:24:36Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/17155253987ac3bc9ee7787157c2749f1809ef09", "committedDate": "2020-11-20T02:56:20Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTc5NjIy", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-541179622", "createdAt": "2020-11-30T18:27:26Z", "commit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyNzoyN1rOH8IFIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyNzoyN1rOH8IFIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwODk5Mg==", "bodyText": "this is usually used for package private level access.\nCan we make the constructor package private if it is only used for testing.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532808992", "createdAt": "2020-11-30T18:27:27Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -35,11 +41,20 @@\n     private static final Logger log = Logger.get(NodeTaskMap.class);\n     private final ConcurrentHashMap<InternalNode, NodeTasks> nodeTasksMap = new ConcurrentHashMap<>();\n     private final FinalizerService finalizerService;\n+    private final long cpuStatsWindowSizeInMillis;\n \n     @Inject\n+    public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n+    {\n+        this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n+    }\n+\n+    @VisibleForTesting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTgxMTk0", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-541181194", "createdAt": "2020-11-30T18:29:30Z", "commit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyOTozMFrOH8IJ5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODoyOTozMFrOH8IJ5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMDIxNA==", "bodyText": "just say 10_000 without using Duration class?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532810214", "createdAt": "2020-11-30T18:29:30Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -35,11 +41,20 @@\n     private static final Logger log = Logger.get(NodeTaskMap.class);\n     private final ConcurrentHashMap<InternalNode, NodeTasks> nodeTasksMap = new ConcurrentHashMap<>();\n     private final FinalizerService finalizerService;\n+    private final long cpuStatsWindowSizeInMillis;\n \n     @Inject\n+    public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n+    {\n+        this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n+    }\n+\n+    @VisibleForTesting\n     public NodeTaskMap(FinalizerService finalizerService)\n     {\n         this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = Duration.valueOf(\"10s\").toMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTg0NjA2", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-541184606", "createdAt": "2020-11-30T18:34:00Z", "commit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNDowMFrOH8IUjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNDowMFrOH8IUjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMjk0Mg==", "bodyText": "can we use something like nodeTasksMap.computeIfAbsent here instead of the get and null check", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532812942", "createdAt": "2020-11-30T18:34:00Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -49,12 +64,22 @@ public void addTask(InternalNode node, RemoteTask task)\n \n     public int getPartitionedSplitsOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).getPartitionedSplitCount();\n+        return (int) createOrGetNodeTasks(node).getPartitionedSplitCount();\n+    }\n+\n+    public long getMemoryUsageInBytesOnNode(InternalNode node)\n+    {\n+        return createOrGetNodeTasks(node).getTotalMemoryUsageInBytes();\n+    }\n+\n+    public long getCpuTimePerMillisOnNode(InternalNode node)\n+    {\n+        return createOrGetNodeTasks(node).getTotalCpuTimePerMillis();\n     }\n \n-    public PartitionedSplitCountTracker createPartitionedSplitCountTracker(InternalNode node, TaskId taskId)\n+    public NodeStatsTracker createTaskStatsTrackers(InternalNode node, TaskId taskId)\n     {\n-        return createOrGetNodeTasks(node).createPartitionedSplitCountTracker(taskId);\n+        return createOrGetNodeTasks(node).createTaskStatsTrackers(taskId);\n     }\n \n     private NodeTasks createOrGetNodeTasks(InternalNode node)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTg1NzA5", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-541185709", "createdAt": "2020-11-30T18:35:29Z", "commit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNToyOVrOH8IX2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNToyOVrOH8IX2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMzc4Ng==", "bodyText": "createTaskStatsTrackers drop the trailing s maybe since we are returning a singular NodeStatsTracker .?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532813786", "createdAt": "2020-11-30T18:35:29Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +147,158 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTg2NTQx", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-541186541", "createdAt": "2020-11-30T18:36:40Z", "commit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNjo0MFrOH8IadA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNjo0MFrOH8IadA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNDQ1Mg==", "bodyText": "keep split count as AtomicInt maybe to prevent the unsafe cast to int ?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532814452", "createdAt": "2020-11-30T18:36:40Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -49,12 +64,22 @@ public void addTask(InternalNode node, RemoteTask task)\n \n     public int getPartitionedSplitsOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).getPartitionedSplitCount();\n+        return (int) createOrGetNodeTasks(node).getPartitionedSplitCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTkyODMw", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-541192830", "createdAt": "2020-11-30T18:45:34Z", "commit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0NTozNFrOH8IuWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0NTozNFrOH8IuWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxOTU0Nw==", "bodyText": "Can you help me understand the logic here .\nIf we are throwing an IllegalArg exception wondering why we need to set a negative value and then throw, shouldn't we just throw immediately.?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532819547", "createdAt": "2020-11-30T18:45:34Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +147,158 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTk1MTgw", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-541195180", "createdAt": "2020-11-30T18:48:55Z", "commit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0ODo1NVrOH8I2Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0ODo1NVrOH8I2Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyMTUzNQ==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532821535", "createdAt": "2020-11-30T18:48:55Z", "author": {"login": "ajaygeorge"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -243,6 +246,20 @@ public long getPeakNodeTotalMemoryReservationInBytes()\n         return peakNodeTotalMemoryReservationInBytes;\n     }\n \n+    @JsonProperty\n+    @ThriftField(18)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/17155253987ac3bc9ee7787157c2749f1809ef09", "committedDate": "2020-11-20T02:56:20Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "f1ca39a3605e6e899e04b68f58dc86439262c8d8", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/f1ca39a3605e6e899e04b68f58dc86439262c8d8", "committedDate": "2020-12-08T04:01:11Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1ca39a3605e6e899e04b68f58dc86439262c8d8", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/f1ca39a3605e6e899e04b68f58dc86439262c8d8", "committedDate": "2020-12-08T04:01:11Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "170c5152efae77d381ae18b49c3bea05b7dc8ca5", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/170c5152efae77d381ae18b49c3bea05b7dc8ca5", "committedDate": "2020-12-08T17:00:36Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "170c5152efae77d381ae18b49c3bea05b7dc8ca5", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/170c5152efae77d381ae18b49c3bea05b7dc8ca5", "committedDate": "2020-12-08T17:00:36Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "63b7ec3e62ec245fe087ce21a96b87c43ff62d3e", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/63b7ec3e62ec245fe087ce21a96b87c43ff62d3e", "committedDate": "2020-12-08T17:33:39Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63b7ec3e62ec245fe087ce21a96b87c43ff62d3e", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/63b7ec3e62ec245fe087ce21a96b87c43ff62d3e", "committedDate": "2020-12-08T17:33:39Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "565077a85b396072c1b4c6c8e5352f9966dacc1c", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/565077a85b396072c1b4c6c8e5352f9966dacc1c", "committedDate": "2020-12-08T17:55:19Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "565077a85b396072c1b4c6c8e5352f9966dacc1c", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/565077a85b396072c1b4c6c8e5352f9966dacc1c", "committedDate": "2020-12-08T17:55:19Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "dca91925979431dbc9018cb6bf59e9a8a2dfa596", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/dca91925979431dbc9018cb6bf59e9a8a2dfa596", "committedDate": "2020-12-08T18:33:30Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dca91925979431dbc9018cb6bf59e9a8a2dfa596", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/dca91925979431dbc9018cb6bf59e9a8a2dfa596", "committedDate": "2020-12-08T18:33:30Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "76509cd84b16ebd31187fd15f698fa2336a558a0", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/76509cd84b16ebd31187fd15f698fa2336a558a0", "committedDate": "2020-12-08T20:06:17Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "76509cd84b16ebd31187fd15f698fa2336a558a0", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/76509cd84b16ebd31187fd15f698fa2336a558a0", "committedDate": "2020-12-08T20:06:17Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "3fb5d68a7336fce4f6a015438c88db87a4ca7b48", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/3fb5d68a7336fce4f6a015438c88db87a4ca7b48", "committedDate": "2020-12-09T04:25:31Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3fb5d68a7336fce4f6a015438c88db87a4ca7b48", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/3fb5d68a7336fce4f6a015438c88db87a4ca7b48", "committedDate": "2020-12-09T04:25:31Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "49f150c05b4b1556b91db2558144269e132be4f6", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/49f150c05b4b1556b91db2558144269e132be4f6", "committedDate": "2020-12-09T04:34:06Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "49f150c05b4b1556b91db2558144269e132be4f6", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/49f150c05b4b1556b91db2558144269e132be4f6", "committedDate": "2020-12-09T04:34:06Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "0012fe5ea51715e2b73c7fe9a1dab885ca11dfe3", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/0012fe5ea51715e2b73c7fe9a1dab885ca11dfe3", "committedDate": "2020-12-09T05:10:13Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0012fe5ea51715e2b73c7fe9a1dab885ca11dfe3", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/0012fe5ea51715e2b73c7fe9a1dab885ca11dfe3", "committedDate": "2020-12-09T05:10:13Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "a88d6c0f0f6b2077ebbf96e2a4811065cf19d8be", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/a88d6c0f0f6b2077ebbf96e2a4811065cf19d8be", "committedDate": "2020-12-09T05:18:39Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a88d6c0f0f6b2077ebbf96e2a4811065cf19d8be", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/a88d6c0f0f6b2077ebbf96e2a4811065cf19d8be", "committedDate": "2020-12-09T05:18:39Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "8034d96bd408b5a41e3ebba04d8fd01a21231809", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/8034d96bd408b5a41e3ebba04d8fd01a21231809", "committedDate": "2020-12-09T05:20:01Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8034d96bd408b5a41e3ebba04d8fd01a21231809", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/8034d96bd408b5a41e3ebba04d8fd01a21231809", "committedDate": "2020-12-09T05:20:01Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "c3e44415dbadbdc3cab7c1d32c769ecc142b0bd5", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/c3e44415dbadbdc3cab7c1d32c769ecc142b0bd5", "committedDate": "2020-12-09T05:29:47Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3e44415dbadbdc3cab7c1d32c769ecc142b0bd5", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/c3e44415dbadbdc3cab7c1d32c769ecc142b0bd5", "committedDate": "2020-12-09T05:29:47Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "ebf2876f8d14c44774ab28794ca8c86806e6ae14", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/ebf2876f8d14c44774ab28794ca8c86806e6ae14", "committedDate": "2020-12-09T05:59:45Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ebf2876f8d14c44774ab28794ca8c86806e6ae14", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/ebf2876f8d14c44774ab28794ca8c86806e6ae14", "committedDate": "2020-12-09T05:59:45Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "5082119be836994b70731b0daf7a2d569ebac93e", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/5082119be836994b70731b0daf7a2d569ebac93e", "committedDate": "2020-12-10T20:18:23Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5082119be836994b70731b0daf7a2d569ebac93e", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/5082119be836994b70731b0daf7a2d569ebac93e", "committedDate": "2020-12-10T20:18:23Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "3877274fb7fbfe15400bc81b6c6d75da43aee859", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/3877274fb7fbfe15400bc81b6c6d75da43aee859", "committedDate": "2020-12-10T20:49:04Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3877274fb7fbfe15400bc81b6c6d75da43aee859", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/3877274fb7fbfe15400bc81b6c6d75da43aee859", "committedDate": "2020-12-10T20:49:04Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "455444da15878190d647bc065374cec705d738ec", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/455444da15878190d647bc065374cec705d738ec", "committedDate": "2020-12-11T17:44:39Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxODAzMjcw", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-551803270", "createdAt": "2020-12-14T19:01:52Z", "commit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTowMTo1MlrOIFg48g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMToxMjo1OVrOIFpfDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY1MjY1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n          \n          \n            \n                {\n          \n          \n            \n                    this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n          \n          \n            \n                    this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService)\n          \n          \n            \n                {\n          \n          \n            \n                    this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n          \n          \n            \n                    this.cpuStatsWindowSizeInMillis = 10_000_000;\n          \n          \n            \n                }\n          \n          \n            \n                @Inject\n          \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n          \n          \n            \n                {\n          \n          \n            \n                    this(\n          \n          \n            \n                            finalizerService,\n          \n          \n            \n                            requireNonNull(taskConfig, \"taskConfig is null\").getStatusRefreshMaxWait());\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService, Duration statusRefreshMaxWait)\n          \n          \n            \n                {\n          \n          \n            \n                    this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n          \n          \n            \n                    this.cpuStatsWindowSizeInMillis = requireNonNull(statusRefreshMaxWait, \"statusRefreshMaxWait is null\").toMillis();\n          \n          \n            \n                }", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542652658", "createdAt": "2020-12-14T19:01:52Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -35,11 +38,19 @@\n     private static final Logger log = Logger.get(NodeTaskMap.class);\n     private final ConcurrentHashMap<InternalNode, NodeTasks> nodeTasksMap = new ConcurrentHashMap<>();\n     private final FinalizerService finalizerService;\n+    private final long cpuStatsWindowSizeInMillis;\n \n     @Inject\n+    public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n+    {\n+        this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n+    }\n+\n     public NodeTaskMap(FinalizerService finalizerService)\n     {\n         this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = 10_000_000;\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY1OTMzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public long getMemoryUsageInBytesOnNode(InternalNode node)\n          \n          \n            \n                public long getNodeTotalMemoryUsageInBytes(InternalNode node)", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542659332", "createdAt": "2020-12-14T19:08:01Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -52,44 +63,54 @@ public int getPartitionedSplitsOnNode(InternalNode node)\n         return createOrGetNodeTasks(node).getPartitionedSplitCount();\n     }\n \n-    public PartitionedSplitCountTracker createPartitionedSplitCountTracker(InternalNode node, TaskId taskId)\n+    public long getMemoryUsageInBytesOnNode(InternalNode node)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY2MDI5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public long getCpuTimePerMillisOnNode(InternalNode node)\n          \n          \n            \n                public long getNodeCpuTimePerMillis(InternalNode node)", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542660290", "createdAt": "2020-12-14T19:08:55Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -52,44 +63,54 @@ public int getPartitionedSplitsOnNode(InternalNode node)\n         return createOrGetNodeTasks(node).getPartitionedSplitCount();\n     }\n \n-    public PartitionedSplitCountTracker createPartitionedSplitCountTracker(InternalNode node, TaskId taskId)\n+    public long getMemoryUsageInBytesOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).createPartitionedSplitCountTracker(taskId);\n+        return createOrGetNodeTasks(node).getTotalMemoryUsageInBytes();\n     }\n \n-    private NodeTasks createOrGetNodeTasks(InternalNode node)\n+    public long getCpuTimePerMillisOnNode(InternalNode node)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA==", "bodyText": "Missing visibility?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542768068", "createdAt": "2020-12-14T20:49:19Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4MzE0NA==", "bodyText": "Where do we clear this map?  Or is it expected that it continuously grows during the lifetime of the task?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542783144", "createdAt": "2020-12-14T21:03:22Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4NTYwNw==", "bodyText": "The tail map is just a view over the original.  I think this is a memory leak.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542785607", "createdAt": "2020-12-14T21:05:45Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.stat = requireNonNull(stat, \"stat is null\");\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    values = values.tailMap(values.lastKey() - windowSizeInMillis);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4ODQ4Mw==", "bodyText": "I wonder if the keys will come into this class in time-order (and hence already sorted).  In which case we could use a LinkedHashMap instead.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542788483", "createdAt": "2020-12-14T21:08:21Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4OTAxMA==", "bodyText": "Please static import", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542789010", "createdAt": "2020-12-14T21:08:50Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/RemoteTaskFactory.java", "diffHunk": "@@ -31,7 +30,7 @@ RemoteTask createRemoteTask(Session session,\n             PlanFragment fragment,\n             Multimap<PlanNodeId, Split> initialSplits,\n             OutputBuffers outputBuffers,\n-            PartitionedSplitCountTracker partitionedSplitCountTracker,\n+            NodeTaskMap.NodeStatsTracker nodeStatsTracker,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MDQ4Nw==", "bodyText": "MILLISECONDS.toNanos", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542790487", "createdAt": "2020-12-14T21:10:14Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlTask.java", "diffHunk": "@@ -237,6 +240,7 @@ public TaskStatus getTaskStatus()\n \n     private TaskStatus createTaskStatus(TaskHolder taskHolder)\n     {\n+        long taskStatusAgeInMilis = MILLISECONDS.convert(System.nanoTime() - creationTime, NANOSECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MTM2NQ==", "bodyText": "Unrelated whitespace change?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542791365", "createdAt": "2020-12-14T21:11:02Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -57,23 +57,22 @@\n     private final TaskState state;\n     private final URI self;\n     private final Set<Lifespan> completedDriverGroups;\n-\n     private final int queuedPartitionedDrivers;\n     private final int runningPartitionedDrivers;\n-\n     private final double outputBufferUtilization;\n     private final boolean outputBufferOverutilized;\n-\n     private final long physicalWrittenDataSizeInBytes;\n     private final long memoryReservationInBytes;\n     private final long systemMemoryReservationInBytes;\n     private final long peakNodeTotalMemoryReservationInBytes;\n-\n     private final long fullGcCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MzQ4Ng==", "bodyText": "Nit: testCpuUsage", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542793486", "createdAt": "2020-12-14T21:12:59Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java", "diffHunk": "@@ -518,6 +518,86 @@ public void testSplitCount()\n         assertEquals(nodeTaskMap.getPartitionedSplitsOnNode(chosenNode), 0);\n     }\n \n+    @Test\n+    public void testCPUUsage()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 70}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "455444da15878190d647bc065374cec705d738ec", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/455444da15878190d647bc065374cec705d738ec", "committedDate": "2020-12-11T17:44:39Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "e6b70e5e90048961cdf7ca065a113bd2e10b0d1f", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/e6b70e5e90048961cdf7ca065a113bd2e10b0d1f", "committedDate": "2020-12-15T01:13:17Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6b70e5e90048961cdf7ca065a113bd2e10b0d1f", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/e6b70e5e90048961cdf7ca065a113bd2e10b0d1f", "committedDate": "2020-12-15T01:13:17Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "14ceffa597230e234430ef1a9c05fbb1d186d7b0", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/14ceffa597230e234430ef1a9c05fbb1d186d7b0", "committedDate": "2020-12-15T01:18:34Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "14ceffa597230e234430ef1a9c05fbb1d186d7b0", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/14ceffa597230e234430ef1a9c05fbb1d186d7b0", "committedDate": "2020-12-15T01:18:34Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "6501c8563a16196e18ec48ac3da3d4c8ffa8a739", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/6501c8563a16196e18ec48ac3da3d4c8ffa8a739", "committedDate": "2020-12-15T01:19:30Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6501c8563a16196e18ec48ac3da3d4c8ffa8a739", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/6501c8563a16196e18ec48ac3da3d4c8ffa8a739", "committedDate": "2020-12-15T01:19:30Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/c718bff7b23b42f3eacb3acd75107e9cf01e80b4", "committedDate": "2020-12-15T01:20:20Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNzU3NzE0", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-552757714", "createdAt": "2020-12-15T18:41:14Z", "commit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo0MToxNVrOIGaQvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo1Njo0OVrOIGa7-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5MjYzNw==", "bodyText": "It's still missing the visibility modifier.", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543592637", "createdAt": "2020-12-15T18:41:15Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDA3MA==", "bodyText": "Why multiply by 100?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543594070", "createdAt": "2020-12-15T18:42:57Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTIwOQ==", "bodyText": "Can you help me understand why this would return 0 here?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543599209", "createdAt": "2020-12-15T18:50:11Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;\n+                        long deltaDuration = values.lastKey() - values.firstKey();\n+                        return deltaDuration >= 0 && deltaValue > 0 ? deltaValue / deltaDuration : 0;\n+                    }\n+                }\n+                return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYwMzcwNQ==", "bodyText": "Also, do you want to use a fastutil Long2LongSortedMap to avoid boxing?", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543603705", "createdAt": "2020-12-15T18:56:49Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, "originalCommit": {"oid": "455444da15878190d647bc065374cec705d738ec"}, "originalPosition": 212}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/c718bff7b23b42f3eacb3acd75107e9cf01e80b4", "committedDate": "2020-12-15T01:20:20Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "91a933be1fe5250bcd1db335f7331bc5049f7206", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/91a933be1fe5250bcd1db335f7331bc5049f7206", "committedDate": "2020-12-15T19:26:45Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "91a933be1fe5250bcd1db335f7331bc5049f7206", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/91a933be1fe5250bcd1db335f7331bc5049f7206", "committedDate": "2020-12-15T19:26:45Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "5e3cb6639a02e4400bff0a2fe88409669e29679a", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/5e3cb6639a02e4400bff0a2fe88409669e29679a", "committedDate": "2020-12-15T21:09:42Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61d16946b5a7e636974ee56afbab387ae5010048", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/61d16946b5a7e636974ee56afbab387ae5010048", "committedDate": "2021-01-04T20:26:58Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e3cb6639a02e4400bff0a2fe88409669e29679a", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/5e3cb6639a02e4400bff0a2fe88409669e29679a", "committedDate": "2020-12-15T21:09:42Z", "message": "Add cpu and memory stats to NodeTaskMap"}, "afterCommit": {"oid": "61d16946b5a7e636974ee56afbab387ae5010048", "author": {"user": {"login": "cemcayiroglu", "name": "cem cayiroglu"}}, "url": "https://github.com/prestodb/presto/commit/61d16946b5a7e636974ee56afbab387ae5010048", "committedDate": "2021-01-04T20:26:58Z", "message": "Add cpu and memory stats to NodeTaskMap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2ODE2ODQx", "url": "https://github.com/prestodb/presto/pull/15437#pullrequestreview-566816841", "createdAt": "2021-01-13T00:54:03Z", "commit": {"oid": "61d16946b5a7e636974ee56afbab387ae5010048"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4707, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}