{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MjU2NDc3", "number": 14104, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNToyMTo1OVrODkhL7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDozMzo1NFrODlovUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjE5MDU0OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNToyMTo1OVrOFw4r8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNToyMTo1OVrOFw4r8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwNDcyMQ==", "bodyText": "note this line get removed in bfa2524 :)", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386804721", "createdAt": "2020-03-03T05:21:59Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java", "diffHunk": "@@ -174,6 +171,8 @@ public SqlQueryManager(\n \n         this.clusterSizeMonitor = requireNonNull(clusterSizeMonitor, \"clusterSizeMonitor is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de474765992817101620820a20b9d4bb55cd9220"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjI4MjgxOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/QueuedStatementResource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNjoyMDowNlrOFw5iWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxODoxNjoyNlrOFzCjNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxODY1MA==", "bodyText": "Just double check: now slug is provided as a parameter, while in the old PR, slug is part of the path? (See b846616#diff-ef10213de38c18dc49c5303d7eea77a4R234)", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386818650", "createdAt": "2020-03-03T06:20:06Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/QueuedStatementResource.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.client.QueryError;\n+import com.facebook.presto.client.QueryResults;\n+import com.facebook.presto.client.StatementStats;\n+import com.facebook.presto.execution.ExecutionFailureInfo;\n+import com.facebook.presto.execution.QueryState;\n+import com.facebook.presto.server.ForStatementResource;\n+import com.facebook.presto.server.HttpRequestSessionContext;\n+import com.facebook.presto.server.SessionContext;\n+import com.facebook.presto.spi.ErrorCode;\n+import com.facebook.presto.spi.QueryId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.units.Duration;\n+\n+import javax.annotation.PreDestroy;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.inject.Inject;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.WebApplicationException;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.container.Suspended;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.net.URI;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.facebook.airlift.concurrent.MoreFutures.addTimeout;\n+import static com.facebook.airlift.concurrent.Threads.threadsNamed;\n+import static com.facebook.airlift.http.client.HttpUriBuilder.uriBuilderFrom;\n+import static com.facebook.airlift.http.server.AsyncResponseHandler.bindAsyncResponse;\n+import static com.facebook.presto.execution.QueryState.FAILED;\n+import static com.facebook.presto.execution.QueryState.QUEUED;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static com.google.common.net.HttpHeaders.X_FORWARDED_PROTO;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.UUID.randomUUID;\n+import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static javax.ws.rs.core.MediaType.APPLICATION_JSON;\n+import static javax.ws.rs.core.MediaType.TEXT_PLAIN_TYPE;\n+import static javax.ws.rs.core.Response.Status.BAD_REQUEST;\n+import static javax.ws.rs.core.Response.Status.NOT_FOUND;\n+\n+@Path(\"/\")\n+public class QueuedStatementResource\n+{\n+    private static final Logger log = Logger.get(QueuedStatementResource.class);\n+    private static final Duration MAX_WAIT_TIME = new Duration(1, SECONDS);\n+    private static final Ordering<Comparable<Duration>> WAIT_ORDERING = Ordering.natural().nullsLast();\n+    private static final Duration NO_DURATION = new Duration(0, MILLISECONDS);\n+\n+    private final DispatchManager dispatchManager;\n+\n+    private final BoundedExecutor responseExecutor;\n+    private final ScheduledExecutorService timeoutExecutor;\n+\n+    private final ConcurrentMap<QueryId, Query> queries = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService queryPurger = newSingleThreadScheduledExecutor(threadsNamed(\"query-purger\"));\n+\n+    @Inject\n+    public QueuedStatementResource(\n+            DispatchManager dispatchManager,\n+            @ForStatementResource BoundedExecutor responseExecutor,\n+            @ForStatementResource ScheduledExecutorService timeoutExecutor)\n+    {\n+        this.dispatchManager = requireNonNull(dispatchManager, \"dispatchManager is null\");\n+\n+        this.responseExecutor = requireNonNull(responseExecutor, \"responseExecutor is null\");\n+        this.timeoutExecutor = requireNonNull(timeoutExecutor, \"timeoutExecutor is null\");\n+\n+        queryPurger.scheduleWithFixedDelay(\n+                () -> {\n+                    try {\n+                        // snapshot the queries before checking states to avoid registration race\n+                        for (Entry<QueryId, Query> entry : ImmutableSet.copyOf(queries.entrySet())) {\n+                            if (!entry.getValue().isSubmissionFinished()) {\n+                                continue;\n+                            }\n+\n+                            // forget about this query if the query manager is no longer tracking it\n+                            if (!dispatchManager.getDispatchInfo(entry.getKey()).isPresent()) {\n+                                queries.remove(entry.getKey());\n+                            }\n+                        }\n+                    }\n+                    catch (Throwable e) {\n+                        log.warn(e, \"Error removing old queries\");\n+                    }\n+                },\n+                200,\n+                200,\n+                MILLISECONDS);\n+    }\n+\n+    @PreDestroy\n+    public void stop()\n+    {\n+        queryPurger.shutdownNow();\n+    }\n+\n+    @POST\n+    @Path(\"/v1/statement\")\n+    @Produces(APPLICATION_JSON)\n+    public Response postStatement(\n+            String statement,\n+            @HeaderParam(X_FORWARDED_PROTO) String xForwardedProto,\n+            @Context HttpServletRequest servletRequest,\n+            @Context UriInfo uriInfo)\n+    {\n+        if (isNullOrEmpty(statement)) {\n+            throw badRequest(BAD_REQUEST, \"SQL statement is empty\");\n+        }\n+\n+        SessionContext sessionContext = new HttpRequestSessionContext(servletRequest);\n+        Query query = new Query(statement, sessionContext, dispatchManager);\n+        queries.put(query.getQueryId(), query);\n+\n+        return Response.ok(query.getQueryResults(query.getLastToken(), uriInfo, xForwardedProto)).build();\n+    }\n+\n+    @GET\n+    @Path(\"/v1/statement/queued/{queryId}/{token}\")\n+    @Produces(APPLICATION_JSON)\n+    public void getStatus(\n+            @PathParam(\"queryId\") QueryId queryId,\n+            @PathParam(\"token\") long token,\n+            @QueryParam(\"slug\") String slug,\n+            @QueryParam(\"maxWait\") Duration maxWait,\n+            @HeaderParam(X_FORWARDED_PROTO) String xForwardedProto,\n+            @Context UriInfo uriInfo,\n+            @Suspended AsyncResponse asyncResponse)\n+    {\n+        Query query = getQuery(queryId, slug);\n+\n+        // wait for query to be dispatched, up to the wait timeout\n+        ListenableFuture<?> futureStateChange = addTimeout(\n+                query.waitForDispatched(),\n+                () -> null,\n+                WAIT_ORDERING.min(MAX_WAIT_TIME, maxWait),\n+                timeoutExecutor);\n+\n+        // when state changes, fetch the next result\n+        ListenableFuture<QueryResults> queryResultsFuture = Futures.transform(\n+                futureStateChange,\n+                ignored -> query.getQueryResults(token, uriInfo, xForwardedProto),\n+                responseExecutor);\n+\n+        // transform to Response\n+        ListenableFuture<Response> response = Futures.transform(\n+                queryResultsFuture,\n+                queryResults -> Response.ok(queryResults).build(),\n+                directExecutor());\n+        bindAsyncResponse(asyncResponse, response, responseExecutor);\n+    }\n+\n+    @DELETE\n+    @Path(\"/v1/statement/queued/{queryId}/{token}\")\n+    @Produces(APPLICATION_JSON)\n+    public Response cancelQuery(\n+            @PathParam(\"queryId\") QueryId queryId,\n+            @PathParam(\"token\") long token,\n+            @QueryParam(\"slug\") String slug)\n+    {\n+        getQuery(queryId, slug)\n+                .cancel();\n+        return Response.noContent().build();\n+    }\n+\n+    private Query getQuery(QueryId queryId, String slug)\n+    {\n+        Query query = queries.get(queryId);\n+        if (query == null || !query.getSlug().equals(slug)) {\n+            throw badRequest(NOT_FOUND, \"Query not found\");\n+        }\n+        return query;\n+    }\n+\n+    private static URI getQueryHtmlUri(QueryId queryId, UriInfo uriInfo, String xForwardedProto)\n+    {\n+        return uriInfo.getRequestUriBuilder()\n+                .scheme(getScheme(xForwardedProto, uriInfo))\n+                .replacePath(\"ui/query.html\")\n+                .replaceQuery(queryId.toString())\n+                .build();\n+    }\n+\n+    private static URI getQueuedUri(QueryId queryId, String slug, long token, UriInfo uriInfo, String xForwardedProto)\n+    {\n+        return uriInfo.getBaseUriBuilder()\n+                .scheme(getScheme(xForwardedProto, uriInfo))\n+                .replacePath(\"/v1/statement/queued/\")\n+                .path(queryId.toString())\n+                .path(String.valueOf(token))\n+                .replaceQuery(\"\")\n+                .queryParam(\"slug\", slug)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2MzQ3OA==", "bodyText": "Yes, I saw from our commit history we did this because our HTTP logging seems to exclude query params from the logs.", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389063478", "createdAt": "2020-03-06T18:16:26Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/QueuedStatementResource.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.client.QueryError;\n+import com.facebook.presto.client.QueryResults;\n+import com.facebook.presto.client.StatementStats;\n+import com.facebook.presto.execution.ExecutionFailureInfo;\n+import com.facebook.presto.execution.QueryState;\n+import com.facebook.presto.server.ForStatementResource;\n+import com.facebook.presto.server.HttpRequestSessionContext;\n+import com.facebook.presto.server.SessionContext;\n+import com.facebook.presto.spi.ErrorCode;\n+import com.facebook.presto.spi.QueryId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Ordering;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.units.Duration;\n+\n+import javax.annotation.PreDestroy;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.inject.Inject;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.WebApplicationException;\n+import javax.ws.rs.container.AsyncResponse;\n+import javax.ws.rs.container.Suspended;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.net.URI;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.facebook.airlift.concurrent.MoreFutures.addTimeout;\n+import static com.facebook.airlift.concurrent.Threads.threadsNamed;\n+import static com.facebook.airlift.http.client.HttpUriBuilder.uriBuilderFrom;\n+import static com.facebook.airlift.http.server.AsyncResponseHandler.bindAsyncResponse;\n+import static com.facebook.presto.execution.QueryState.FAILED;\n+import static com.facebook.presto.execution.QueryState.QUEUED;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static com.google.common.net.HttpHeaders.X_FORWARDED_PROTO;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.UUID.randomUUID;\n+import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static javax.ws.rs.core.MediaType.APPLICATION_JSON;\n+import static javax.ws.rs.core.MediaType.TEXT_PLAIN_TYPE;\n+import static javax.ws.rs.core.Response.Status.BAD_REQUEST;\n+import static javax.ws.rs.core.Response.Status.NOT_FOUND;\n+\n+@Path(\"/\")\n+public class QueuedStatementResource\n+{\n+    private static final Logger log = Logger.get(QueuedStatementResource.class);\n+    private static final Duration MAX_WAIT_TIME = new Duration(1, SECONDS);\n+    private static final Ordering<Comparable<Duration>> WAIT_ORDERING = Ordering.natural().nullsLast();\n+    private static final Duration NO_DURATION = new Duration(0, MILLISECONDS);\n+\n+    private final DispatchManager dispatchManager;\n+\n+    private final BoundedExecutor responseExecutor;\n+    private final ScheduledExecutorService timeoutExecutor;\n+\n+    private final ConcurrentMap<QueryId, Query> queries = new ConcurrentHashMap<>();\n+    private final ScheduledExecutorService queryPurger = newSingleThreadScheduledExecutor(threadsNamed(\"query-purger\"));\n+\n+    @Inject\n+    public QueuedStatementResource(\n+            DispatchManager dispatchManager,\n+            @ForStatementResource BoundedExecutor responseExecutor,\n+            @ForStatementResource ScheduledExecutorService timeoutExecutor)\n+    {\n+        this.dispatchManager = requireNonNull(dispatchManager, \"dispatchManager is null\");\n+\n+        this.responseExecutor = requireNonNull(responseExecutor, \"responseExecutor is null\");\n+        this.timeoutExecutor = requireNonNull(timeoutExecutor, \"timeoutExecutor is null\");\n+\n+        queryPurger.scheduleWithFixedDelay(\n+                () -> {\n+                    try {\n+                        // snapshot the queries before checking states to avoid registration race\n+                        for (Entry<QueryId, Query> entry : ImmutableSet.copyOf(queries.entrySet())) {\n+                            if (!entry.getValue().isSubmissionFinished()) {\n+                                continue;\n+                            }\n+\n+                            // forget about this query if the query manager is no longer tracking it\n+                            if (!dispatchManager.getDispatchInfo(entry.getKey()).isPresent()) {\n+                                queries.remove(entry.getKey());\n+                            }\n+                        }\n+                    }\n+                    catch (Throwable e) {\n+                        log.warn(e, \"Error removing old queries\");\n+                    }\n+                },\n+                200,\n+                200,\n+                MILLISECONDS);\n+    }\n+\n+    @PreDestroy\n+    public void stop()\n+    {\n+        queryPurger.shutdownNow();\n+    }\n+\n+    @POST\n+    @Path(\"/v1/statement\")\n+    @Produces(APPLICATION_JSON)\n+    public Response postStatement(\n+            String statement,\n+            @HeaderParam(X_FORWARDED_PROTO) String xForwardedProto,\n+            @Context HttpServletRequest servletRequest,\n+            @Context UriInfo uriInfo)\n+    {\n+        if (isNullOrEmpty(statement)) {\n+            throw badRequest(BAD_REQUEST, \"SQL statement is empty\");\n+        }\n+\n+        SessionContext sessionContext = new HttpRequestSessionContext(servletRequest);\n+        Query query = new Query(statement, sessionContext, dispatchManager);\n+        queries.put(query.getQueryId(), query);\n+\n+        return Response.ok(query.getQueryResults(query.getLastToken(), uriInfo, xForwardedProto)).build();\n+    }\n+\n+    @GET\n+    @Path(\"/v1/statement/queued/{queryId}/{token}\")\n+    @Produces(APPLICATION_JSON)\n+    public void getStatus(\n+            @PathParam(\"queryId\") QueryId queryId,\n+            @PathParam(\"token\") long token,\n+            @QueryParam(\"slug\") String slug,\n+            @QueryParam(\"maxWait\") Duration maxWait,\n+            @HeaderParam(X_FORWARDED_PROTO) String xForwardedProto,\n+            @Context UriInfo uriInfo,\n+            @Suspended AsyncResponse asyncResponse)\n+    {\n+        Query query = getQuery(queryId, slug);\n+\n+        // wait for query to be dispatched, up to the wait timeout\n+        ListenableFuture<?> futureStateChange = addTimeout(\n+                query.waitForDispatched(),\n+                () -> null,\n+                WAIT_ORDERING.min(MAX_WAIT_TIME, maxWait),\n+                timeoutExecutor);\n+\n+        // when state changes, fetch the next result\n+        ListenableFuture<QueryResults> queryResultsFuture = Futures.transform(\n+                futureStateChange,\n+                ignored -> query.getQueryResults(token, uriInfo, xForwardedProto),\n+                responseExecutor);\n+\n+        // transform to Response\n+        ListenableFuture<Response> response = Futures.transform(\n+                queryResultsFuture,\n+                queryResults -> Response.ok(queryResults).build(),\n+                directExecutor());\n+        bindAsyncResponse(asyncResponse, response, responseExecutor);\n+    }\n+\n+    @DELETE\n+    @Path(\"/v1/statement/queued/{queryId}/{token}\")\n+    @Produces(APPLICATION_JSON)\n+    public Response cancelQuery(\n+            @PathParam(\"queryId\") QueryId queryId,\n+            @PathParam(\"token\") long token,\n+            @QueryParam(\"slug\") String slug)\n+    {\n+        getQuery(queryId, slug)\n+                .cancel();\n+        return Response.noContent().build();\n+    }\n+\n+    private Query getQuery(QueryId queryId, String slug)\n+    {\n+        Query query = queries.get(queryId);\n+        if (query == null || !query.getSlug().equals(slug)) {\n+            throw badRequest(NOT_FOUND, \"Query not found\");\n+        }\n+        return query;\n+    }\n+\n+    private static URI getQueryHtmlUri(QueryId queryId, UriInfo uriInfo, String xForwardedProto)\n+    {\n+        return uriInfo.getRequestUriBuilder()\n+                .scheme(getScheme(xForwardedProto, uriInfo))\n+                .replacePath(\"ui/query.html\")\n+                .replaceQuery(queryId.toString())\n+                .build();\n+    }\n+\n+    private static URI getQueuedUri(QueryId queryId, String slug, long token, UriInfo uriInfo, String xForwardedProto)\n+    {\n+        return uriInfo.getBaseUriBuilder()\n+                .scheme(getScheme(xForwardedProto, uriInfo))\n+                .replacePath(\"/v1/statement/queued/\")\n+                .path(queryId.toString())\n+                .path(String.valueOf(token))\n+                .replaceQuery(\"\")\n+                .queryParam(\"slug\", slug)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxODY1MA=="}, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjI5MDIxOnYy", "diffSide": "LEFT", "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNjoyNDoyN1rOFw5mpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxODo1NDowNFrOFzDqHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxOTc1MQ==", "bodyText": "hmm? :)", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386819751", "createdAt": "2020-03-03T06:24:27Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java", "diffHunk": "@@ -210,7 +125,6 @@ public void stop()\n     {\n         queryTracker.stop();\n         queryManagementExecutor.shutdownNow();\n-        unboundedExecutorService.shutdownNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYyOA==", "bodyText": "This is not just a rebase conflict, looks like all references to unboundedExecutorService (was: queryExecutor) should have been removed entirely.", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389081628", "createdAt": "2020-03-06T18:54:04Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlQueryManager.java", "diffHunk": "@@ -210,7 +125,6 @@ public void stop()\n     {\n         queryTracker.stop();\n         queryManagementExecutor.shutdownNow();\n-        unboundedExecutorService.shutdownNow();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxOTc1MQ=="}, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjI5NjQzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNjoyODoxMVrOFw5qXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxODo1ODozNFrOFzDySw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDcwMg==", "bodyText": "Didn't see \"slugValid\" related method in this commit? (see b846616#diff-d65ad4547dcbc09fc621ac2ceddce6cdR217)", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386820702", "createdAt": "2020-03-03T06:28:11Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java", "diffHunk": "@@ -294,14 +263,12 @@ public synchronized boolean isClearTransactionId()\n         return clearTransactionId;\n     }\n \n-    public synchronized ListenableFuture<QueryResults> waitForResults(OptionalLong token, UriInfo uriInfo, String scheme, Duration wait, DataSize targetResultSize)\n+    public synchronized ListenableFuture<QueryResults> waitForResults(long token, UriInfo uriInfo, String scheme, Duration wait, DataSize targetResultSize)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MzcyMw==", "bodyText": "This is because we cherry picked this earlier in #13110", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389083723", "createdAt": "2020-03-06T18:58:34Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java", "diffHunk": "@@ -294,14 +263,12 @@ public synchronized boolean isClearTransactionId()\n         return clearTransactionId;\n     }\n \n-    public synchronized ListenableFuture<QueryResults> waitForResults(OptionalLong token, UriInfo uriInfo, String scheme, Duration wait, DataSize targetResultSize)\n+    public synchronized ListenableFuture<QueryResults> waitForResults(long token, UriInfo uriInfo, String scheme, Duration wait, DataSize targetResultSize)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDcwMg=="}, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjI5NzgzOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwNjoyOToxM1rOFw5rQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOTowNzoyN1rOFzECIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDkzMA==", "bodyText": "Why change this to nextToken?  :)", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r386820930", "createdAt": "2020-03-03T06:29:13Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java", "diffHunk": "@@ -570,9 +502,9 @@ private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo)\n     {\n         return uriInfo.getBaseUriBuilder()\n                 .scheme(scheme)\n-                .replacePath(\"/v1/statement\")\n+                .replacePath(\"/v1/statement/executing\")\n                 .path(queryId.toString())\n-                .path(String.valueOf(resultId.incrementAndGet()))\n+                .path(String.valueOf(nextToken))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4Nzc3OQ==", "bodyText": "This was supposed to happen in a later commit.  Fixed it.", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389087779", "createdAt": "2020-03-06T19:07:27Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/Query.java", "diffHunk": "@@ -570,9 +502,9 @@ private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo)\n     {\n         return uriInfo.getBaseUriBuilder()\n                 .scheme(scheme)\n-                .replacePath(\"/v1/statement\")\n+                .replacePath(\"/v1/statement/executing\")\n                 .path(queryId.toString())\n-                .path(String.valueOf(resultId.incrementAndGet()))\n+                .path(String.valueOf(nextToken))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgyMDkzMA=="}, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjk1NjY5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxODo1NzozMVrOFx5lhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwNzoyMDoyNlrOFzcz2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2ODAzNw==", "bodyText": "Why is this needed? Why not simply Futures.nonCancellationPropagating()?", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r387868037", "createdAt": "2020-03-04T18:57:31Z", "author": {"login": "arhimondr"}, "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.QueryIdGenerator;\n+import com.facebook.presto.execution.QueryInfo;\n+import com.facebook.presto.execution.QueryManagerConfig;\n+import com.facebook.presto.execution.QueryPreparer;\n+import com.facebook.presto.execution.QueryPreparer.PreparedQuery;\n+import com.facebook.presto.execution.QueryTracker;\n+import com.facebook.presto.execution.SqlQueryManagerStats;\n+import com.facebook.presto.execution.resourceGroups.ResourceGroupManager;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.execution.warnings.WarningCollectorFactory;\n+import com.facebook.presto.metadata.SessionPropertyManager;\n+import com.facebook.presto.security.AccessControl;\n+import com.facebook.presto.server.BasicQueryInfo;\n+import com.facebook.presto.server.SessionContext;\n+import com.facebook.presto.server.SessionPropertyDefaults;\n+import com.facebook.presto.server.SessionSupplier;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.spi.resourceGroups.QueryType;\n+import com.facebook.presto.spi.resourceGroups.SelectionContext;\n+import com.facebook.presto.spi.resourceGroups.SelectionCriteria;\n+import com.facebook.presto.sql.SqlPath;\n+import com.facebook.presto.transaction.TransactionManager;\n+import com.google.common.util.concurrent.AbstractFuture;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import io.airlift.concurrent.ThreadPoolExecutorMBean;\n+import org.weakref.jmx.Flatten;\n+import org.weakref.jmx.Managed;\n+import org.weakref.jmx.Nested;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static com.facebook.presto.spi.StandardErrorCode.QUERY_TEXT_TOO_LARGE;\n+import static com.facebook.presto.util.StatementUtils.getQueryType;\n+import static com.facebook.presto.util.StatementUtils.isTransactionControlStatement;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n+import static io.airlift.concurrent.Threads.threadsNamed;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+\n+public class DispatchManager\n+{\n+    private final QueryIdGenerator queryIdGenerator;\n+    private final QueryPreparer queryPreparer;\n+    private final ResourceGroupManager<?> resourceGroupManager;\n+    private final WarningCollector warningCollector;\n+    private final DispatchQueryFactory dispatchQueryFactory;\n+    private final FailedDispatchQueryFactory failedDispatchQueryFactory;\n+    private final TransactionManager transactionManager;\n+    private final AccessControl accessControl;\n+    private final SessionSupplier sessionSupplier;\n+    private final SessionPropertyDefaults sessionPropertyDefaults;\n+\n+    private final int maxQueryLength;\n+\n+    private final ListeningScheduledExecutorService queryManagementExecutor;\n+    private final ThreadPoolExecutorMBean queryManagementExecutorMBean;\n+\n+    private final QueryTracker<DispatchQuery> queryTracker;\n+\n+    private final SqlQueryManagerStats stats = new SqlQueryManagerStats();\n+\n+    @Inject\n+    public DispatchManager(\n+            QueryIdGenerator queryIdGenerator,\n+            QueryPreparer queryPreparer,\n+            @SuppressWarnings(\"rawtypes\") ResourceGroupManager resourceGroupManager,\n+            WarningCollectorFactory warningCollectorFactory,\n+            DispatchQueryFactory dispatchQueryFactory,\n+            FailedDispatchQueryFactory failedDispatchQueryFactory,\n+            TransactionManager transactionManager,\n+            AccessControl accessControl,\n+            SessionSupplier sessionSupplier,\n+            SessionPropertyDefaults sessionPropertyDefaults,\n+            QueryManagerConfig queryManagerConfig)\n+    {\n+        this.queryIdGenerator = requireNonNull(queryIdGenerator, \"queryIdGenerator is null\");\n+        this.queryPreparer = requireNonNull(queryPreparer, \"queryPreparer is null\");\n+        this.resourceGroupManager = requireNonNull(resourceGroupManager, \"resourceGroupManager is null\");\n+        this.warningCollector = warningCollectorFactory.create();\n+        this.dispatchQueryFactory = requireNonNull(dispatchQueryFactory, \"dispatchQueryFactory is null\");\n+        this.failedDispatchQueryFactory = requireNonNull(failedDispatchQueryFactory, \"failedDispatchQueryFactory is null\");\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.sessionSupplier = requireNonNull(sessionSupplier, \"sessionSupplier is null\");\n+        this.sessionPropertyDefaults = requireNonNull(sessionPropertyDefaults, \"sessionPropertyDefaults is null\");\n+\n+        this.maxQueryLength = queryManagerConfig.getMaxQueryLength();\n+\n+        ScheduledExecutorService scheduledExecutorService = newScheduledThreadPool(queryManagerConfig.getQueryManagerExecutorPoolSize(), threadsNamed(\"query-dispatch-%s\"));\n+        queryManagementExecutor = listeningDecorator(scheduledExecutorService);\n+        queryManagementExecutorMBean = new ThreadPoolExecutorMBean((ThreadPoolExecutor) scheduledExecutorService);\n+\n+        this.queryTracker = new QueryTracker<>(queryManagerConfig, queryManagementExecutor);\n+    }\n+\n+    @Managed(description = \"Query dispatch executor\")\n+    @Nested\n+    public ThreadPoolExecutorMBean getExecutor()\n+    {\n+        return queryManagementExecutorMBean;\n+    }\n+\n+    @Managed\n+    @Flatten\n+    public SqlQueryManagerStats getStats()\n+    {\n+        return stats;\n+    }\n+\n+    public QueryId createQueryId()\n+    {\n+        return queryIdGenerator.createNextQueryId();\n+    }\n+\n+    public ListenableFuture<?> createQuery(QueryId queryId, String slug, SessionContext sessionContext, String query)\n+    {\n+        DispatchQueryCreationFuture queryCreationFuture = new DispatchQueryCreationFuture();\n+        queryManagementExecutor.submit(() -> {\n+            try {\n+                createQueryInternal(queryId, slug, sessionContext, query, resourceGroupManager);\n+                queryCreationFuture.set(null);\n+            }\n+            catch (Throwable e) {\n+                queryCreationFuture.setException(e);\n+            }\n+        });\n+        return queryCreationFuture;\n+    }\n+\n+    private <C> void createQueryInternal(QueryId queryId, String slug, SessionContext sessionContext, String query, ResourceGroupManager<C> resourceGroupManager)\n+    {\n+        requireNonNull(queryId, \"queryId is null\");\n+        requireNonNull(sessionContext, \"sessionFactory is null\");\n+        requireNonNull(query, \"query is null\");\n+        checkArgument(!query.isEmpty(), \"query must not be empty string\");\n+        checkArgument(!queryTracker.tryGetQuery(queryId).isPresent(), \"query %s already exists\", queryId);\n+\n+        Session session = null;\n+        SelectionContext<C> selectionContext = null;\n+        PreparedQuery preparedQuery;\n+        DispatchQuery dispatchQuery;\n+        try {\n+            if (query.length() > maxQueryLength) {\n+                int queryLength = query.length();\n+                query = query.substring(0, maxQueryLength);\n+                throw new PrestoException(QUERY_TEXT_TOO_LARGE, format(\"Query text length (%s) exceeds the maximum length (%s)\", queryLength, maxQueryLength));\n+            }\n+\n+            // decode session\n+            session = sessionSupplier.createSession(queryId, sessionContext);\n+\n+            // prepare query\n+            preparedQuery = queryPreparer.prepareQuery(session, query, warningCollector);\n+\n+            // select resource group\n+            Optional<QueryType> queryType = getQueryType(preparedQuery.getStatement().getClass());\n+            selectionContext = resourceGroupManager.selectGroup(new SelectionCriteria(\n+                    sessionContext.getIdentity().getPrincipal().isPresent(),\n+                    sessionContext.getIdentity().getUser(),\n+                    Optional.ofNullable(sessionContext.getSource()),\n+                    sessionContext.getClientTags(),\n+                    sessionContext.getResourceEstimates(),\n+                    queryType.map(Enum::name)));\n+\n+            // apply system default session properties (does not override user set properties)\n+            session = sessionPropertyDefaults.newSessionWithDefaultProperties(session, queryType.map(Enum::name), selectionContext.getResourceGroupId());\n+\n+            // mark existing transaction as active\n+            transactionManager.activateTransaction(session, isTransactionControlStatement(preparedQuery.getStatement()), accessControl);\n+\n+            dispatchQuery = dispatchQueryFactory.createDispatchQuery(session, query, preparedQuery, slug, selectionContext.getResourceGroupId(), queryType, warningCollector, queryManagementExecutor);\n+        }\n+        catch (RuntimeException e) {\n+            // This is intentionally not a method, since after the state change listener is registered\n+            // it's not safe to do any of this, and we had bugs before where people reused this code in a method\n+            // if session creation failed, create a minimal session object\n+            if (session == null) {\n+                session = Session.builder(new SessionPropertyManager())\n+                        .setQueryId(queryId)\n+                        .setIdentity(sessionContext.getIdentity())\n+                        .setSource(sessionContext.getSource())\n+                        .setPath(new SqlPath(Optional.empty()))\n+                        .build();\n+            }\n+\n+            // create and immediately fail the query\n+            DispatchQuery failedDispatchQuery = failedDispatchQueryFactory.createFailedDispatchQuery(\n+                    session,\n+                    query,\n+                    Optional.ofNullable(selectionContext).map(SelectionContext::getResourceGroupId),\n+                    e);\n+\n+            try {\n+                queryCreated(failedDispatchQuery);\n+            }\n+            finally {\n+                handleQueryFailure(failedDispatchQuery);\n+            }\n+            return;\n+        }\n+\n+        try {\n+            queryCreated(dispatchQuery);\n+            dispatchQuery.addStateChangeListener(newState -> {\n+                if (newState.isDone()) {\n+                    stats.queryFinished(dispatchQuery.getBasicQueryInfo());\n+                }\n+            });\n+\n+            resourceGroupManager.submit(preparedQuery.getStatement(), dispatchQuery, selectionContext, queryManagementExecutor);\n+        }\n+        catch (RuntimeException e) {\n+            dispatchQuery.fail(e);\n+        }\n+    }\n+\n+    private void queryCreated(DispatchQuery dispatchQuery)\n+    {\n+        queryTracker.addQuery(dispatchQuery);\n+        stats.queryQueued();\n+    }\n+\n+    private void handleQueryFailure(DispatchQuery dispatchQuery)\n+    {\n+        try {\n+            stats.queryStarted();\n+            stats.queryStopped();\n+            BasicQueryInfo queryInfo = dispatchQuery.getBasicQueryInfo();\n+            stats.queuedQueryFailed(queryInfo.getQueryStats().getQueuedTime(), Optional.ofNullable(queryInfo.getErrorCode()));\n+        }\n+        finally {\n+            // execution MUST be added to the expiration queue or there will be a leak\n+            queryTracker.expireQuery(dispatchQuery.getQueryId());\n+        }\n+    }\n+\n+    public ListenableFuture<?> waitForDispatched(QueryId queryId)\n+    {\n+        return queryTracker.tryGetQuery(queryId)\n+                .map(dispatchQuery -> {\n+                    dispatchQuery.recordHeartbeat();\n+                    return dispatchQuery.getDispatchedFuture();\n+                })\n+                .orElseGet(() -> immediateFuture(null));\n+    }\n+\n+    public List<BasicQueryInfo> getQueries()\n+    {\n+        return queryTracker.getAllQueries().stream()\n+                .map(DispatchQuery::getBasicQueryInfo)\n+                .collect(toImmutableList());\n+    }\n+\n+    public BasicQueryInfo getQueryInfo(QueryId queryId)\n+    {\n+        return queryTracker.getQuery(queryId).getBasicQueryInfo();\n+    }\n+\n+    public Optional<DispatchInfo> getDispatchInfo(QueryId queryId)\n+    {\n+        return queryTracker.tryGetQuery(queryId)\n+                .map(dispatchQuery -> {\n+                    dispatchQuery.recordHeartbeat();\n+                    return dispatchQuery.getDispatchInfo();\n+                });\n+    }\n+\n+    public void cancelQuery(QueryId queryId)\n+    {\n+        queryTracker.tryGetQuery(queryId)\n+                .ifPresent(DispatchQuery::cancel);\n+    }\n+\n+    private static class DispatchQueryCreationFuture", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ5MzcyMw==", "bodyText": "Turns out it's a different semantic.  An attempt to cancel this future has no effect, whereas cancelling the returned future from nonCancellationPropagating may be cancelled (however this will not be propagated to the inner future).", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389493723", "createdAt": "2020-03-09T07:20:26Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchManager.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.execution.QueryIdGenerator;\n+import com.facebook.presto.execution.QueryInfo;\n+import com.facebook.presto.execution.QueryManagerConfig;\n+import com.facebook.presto.execution.QueryPreparer;\n+import com.facebook.presto.execution.QueryPreparer.PreparedQuery;\n+import com.facebook.presto.execution.QueryTracker;\n+import com.facebook.presto.execution.SqlQueryManagerStats;\n+import com.facebook.presto.execution.resourceGroups.ResourceGroupManager;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.execution.warnings.WarningCollectorFactory;\n+import com.facebook.presto.metadata.SessionPropertyManager;\n+import com.facebook.presto.security.AccessControl;\n+import com.facebook.presto.server.BasicQueryInfo;\n+import com.facebook.presto.server.SessionContext;\n+import com.facebook.presto.server.SessionPropertyDefaults;\n+import com.facebook.presto.server.SessionSupplier;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.QueryId;\n+import com.facebook.presto.spi.resourceGroups.QueryType;\n+import com.facebook.presto.spi.resourceGroups.SelectionContext;\n+import com.facebook.presto.spi.resourceGroups.SelectionCriteria;\n+import com.facebook.presto.sql.SqlPath;\n+import com.facebook.presto.transaction.TransactionManager;\n+import com.google.common.util.concurrent.AbstractFuture;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import io.airlift.concurrent.ThreadPoolExecutorMBean;\n+import org.weakref.jmx.Flatten;\n+import org.weakref.jmx.Managed;\n+import org.weakref.jmx.Nested;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static com.facebook.presto.spi.StandardErrorCode.QUERY_TEXT_TOO_LARGE;\n+import static com.facebook.presto.util.StatementUtils.getQueryType;\n+import static com.facebook.presto.util.StatementUtils.isTransactionControlStatement;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n+import static io.airlift.concurrent.Threads.threadsNamed;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+\n+public class DispatchManager\n+{\n+    private final QueryIdGenerator queryIdGenerator;\n+    private final QueryPreparer queryPreparer;\n+    private final ResourceGroupManager<?> resourceGroupManager;\n+    private final WarningCollector warningCollector;\n+    private final DispatchQueryFactory dispatchQueryFactory;\n+    private final FailedDispatchQueryFactory failedDispatchQueryFactory;\n+    private final TransactionManager transactionManager;\n+    private final AccessControl accessControl;\n+    private final SessionSupplier sessionSupplier;\n+    private final SessionPropertyDefaults sessionPropertyDefaults;\n+\n+    private final int maxQueryLength;\n+\n+    private final ListeningScheduledExecutorService queryManagementExecutor;\n+    private final ThreadPoolExecutorMBean queryManagementExecutorMBean;\n+\n+    private final QueryTracker<DispatchQuery> queryTracker;\n+\n+    private final SqlQueryManagerStats stats = new SqlQueryManagerStats();\n+\n+    @Inject\n+    public DispatchManager(\n+            QueryIdGenerator queryIdGenerator,\n+            QueryPreparer queryPreparer,\n+            @SuppressWarnings(\"rawtypes\") ResourceGroupManager resourceGroupManager,\n+            WarningCollectorFactory warningCollectorFactory,\n+            DispatchQueryFactory dispatchQueryFactory,\n+            FailedDispatchQueryFactory failedDispatchQueryFactory,\n+            TransactionManager transactionManager,\n+            AccessControl accessControl,\n+            SessionSupplier sessionSupplier,\n+            SessionPropertyDefaults sessionPropertyDefaults,\n+            QueryManagerConfig queryManagerConfig)\n+    {\n+        this.queryIdGenerator = requireNonNull(queryIdGenerator, \"queryIdGenerator is null\");\n+        this.queryPreparer = requireNonNull(queryPreparer, \"queryPreparer is null\");\n+        this.resourceGroupManager = requireNonNull(resourceGroupManager, \"resourceGroupManager is null\");\n+        this.warningCollector = warningCollectorFactory.create();\n+        this.dispatchQueryFactory = requireNonNull(dispatchQueryFactory, \"dispatchQueryFactory is null\");\n+        this.failedDispatchQueryFactory = requireNonNull(failedDispatchQueryFactory, \"failedDispatchQueryFactory is null\");\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.sessionSupplier = requireNonNull(sessionSupplier, \"sessionSupplier is null\");\n+        this.sessionPropertyDefaults = requireNonNull(sessionPropertyDefaults, \"sessionPropertyDefaults is null\");\n+\n+        this.maxQueryLength = queryManagerConfig.getMaxQueryLength();\n+\n+        ScheduledExecutorService scheduledExecutorService = newScheduledThreadPool(queryManagerConfig.getQueryManagerExecutorPoolSize(), threadsNamed(\"query-dispatch-%s\"));\n+        queryManagementExecutor = listeningDecorator(scheduledExecutorService);\n+        queryManagementExecutorMBean = new ThreadPoolExecutorMBean((ThreadPoolExecutor) scheduledExecutorService);\n+\n+        this.queryTracker = new QueryTracker<>(queryManagerConfig, queryManagementExecutor);\n+    }\n+\n+    @Managed(description = \"Query dispatch executor\")\n+    @Nested\n+    public ThreadPoolExecutorMBean getExecutor()\n+    {\n+        return queryManagementExecutorMBean;\n+    }\n+\n+    @Managed\n+    @Flatten\n+    public SqlQueryManagerStats getStats()\n+    {\n+        return stats;\n+    }\n+\n+    public QueryId createQueryId()\n+    {\n+        return queryIdGenerator.createNextQueryId();\n+    }\n+\n+    public ListenableFuture<?> createQuery(QueryId queryId, String slug, SessionContext sessionContext, String query)\n+    {\n+        DispatchQueryCreationFuture queryCreationFuture = new DispatchQueryCreationFuture();\n+        queryManagementExecutor.submit(() -> {\n+            try {\n+                createQueryInternal(queryId, slug, sessionContext, query, resourceGroupManager);\n+                queryCreationFuture.set(null);\n+            }\n+            catch (Throwable e) {\n+                queryCreationFuture.setException(e);\n+            }\n+        });\n+        return queryCreationFuture;\n+    }\n+\n+    private <C> void createQueryInternal(QueryId queryId, String slug, SessionContext sessionContext, String query, ResourceGroupManager<C> resourceGroupManager)\n+    {\n+        requireNonNull(queryId, \"queryId is null\");\n+        requireNonNull(sessionContext, \"sessionFactory is null\");\n+        requireNonNull(query, \"query is null\");\n+        checkArgument(!query.isEmpty(), \"query must not be empty string\");\n+        checkArgument(!queryTracker.tryGetQuery(queryId).isPresent(), \"query %s already exists\", queryId);\n+\n+        Session session = null;\n+        SelectionContext<C> selectionContext = null;\n+        PreparedQuery preparedQuery;\n+        DispatchQuery dispatchQuery;\n+        try {\n+            if (query.length() > maxQueryLength) {\n+                int queryLength = query.length();\n+                query = query.substring(0, maxQueryLength);\n+                throw new PrestoException(QUERY_TEXT_TOO_LARGE, format(\"Query text length (%s) exceeds the maximum length (%s)\", queryLength, maxQueryLength));\n+            }\n+\n+            // decode session\n+            session = sessionSupplier.createSession(queryId, sessionContext);\n+\n+            // prepare query\n+            preparedQuery = queryPreparer.prepareQuery(session, query, warningCollector);\n+\n+            // select resource group\n+            Optional<QueryType> queryType = getQueryType(preparedQuery.getStatement().getClass());\n+            selectionContext = resourceGroupManager.selectGroup(new SelectionCriteria(\n+                    sessionContext.getIdentity().getPrincipal().isPresent(),\n+                    sessionContext.getIdentity().getUser(),\n+                    Optional.ofNullable(sessionContext.getSource()),\n+                    sessionContext.getClientTags(),\n+                    sessionContext.getResourceEstimates(),\n+                    queryType.map(Enum::name)));\n+\n+            // apply system default session properties (does not override user set properties)\n+            session = sessionPropertyDefaults.newSessionWithDefaultProperties(session, queryType.map(Enum::name), selectionContext.getResourceGroupId());\n+\n+            // mark existing transaction as active\n+            transactionManager.activateTransaction(session, isTransactionControlStatement(preparedQuery.getStatement()), accessControl);\n+\n+            dispatchQuery = dispatchQueryFactory.createDispatchQuery(session, query, preparedQuery, slug, selectionContext.getResourceGroupId(), queryType, warningCollector, queryManagementExecutor);\n+        }\n+        catch (RuntimeException e) {\n+            // This is intentionally not a method, since after the state change listener is registered\n+            // it's not safe to do any of this, and we had bugs before where people reused this code in a method\n+            // if session creation failed, create a minimal session object\n+            if (session == null) {\n+                session = Session.builder(new SessionPropertyManager())\n+                        .setQueryId(queryId)\n+                        .setIdentity(sessionContext.getIdentity())\n+                        .setSource(sessionContext.getSource())\n+                        .setPath(new SqlPath(Optional.empty()))\n+                        .build();\n+            }\n+\n+            // create and immediately fail the query\n+            DispatchQuery failedDispatchQuery = failedDispatchQueryFactory.createFailedDispatchQuery(\n+                    session,\n+                    query,\n+                    Optional.ofNullable(selectionContext).map(SelectionContext::getResourceGroupId),\n+                    e);\n+\n+            try {\n+                queryCreated(failedDispatchQuery);\n+            }\n+            finally {\n+                handleQueryFailure(failedDispatchQuery);\n+            }\n+            return;\n+        }\n+\n+        try {\n+            queryCreated(dispatchQuery);\n+            dispatchQuery.addStateChangeListener(newState -> {\n+                if (newState.isDone()) {\n+                    stats.queryFinished(dispatchQuery.getBasicQueryInfo());\n+                }\n+            });\n+\n+            resourceGroupManager.submit(preparedQuery.getStatement(), dispatchQuery, selectionContext, queryManagementExecutor);\n+        }\n+        catch (RuntimeException e) {\n+            dispatchQuery.fail(e);\n+        }\n+    }\n+\n+    private void queryCreated(DispatchQuery dispatchQuery)\n+    {\n+        queryTracker.addQuery(dispatchQuery);\n+        stats.queryQueued();\n+    }\n+\n+    private void handleQueryFailure(DispatchQuery dispatchQuery)\n+    {\n+        try {\n+            stats.queryStarted();\n+            stats.queryStopped();\n+            BasicQueryInfo queryInfo = dispatchQuery.getBasicQueryInfo();\n+            stats.queuedQueryFailed(queryInfo.getQueryStats().getQueuedTime(), Optional.ofNullable(queryInfo.getErrorCode()));\n+        }\n+        finally {\n+            // execution MUST be added to the expiration queue or there will be a leak\n+            queryTracker.expireQuery(dispatchQuery.getQueryId());\n+        }\n+    }\n+\n+    public ListenableFuture<?> waitForDispatched(QueryId queryId)\n+    {\n+        return queryTracker.tryGetQuery(queryId)\n+                .map(dispatchQuery -> {\n+                    dispatchQuery.recordHeartbeat();\n+                    return dispatchQuery.getDispatchedFuture();\n+                })\n+                .orElseGet(() -> immediateFuture(null));\n+    }\n+\n+    public List<BasicQueryInfo> getQueries()\n+    {\n+        return queryTracker.getAllQueries().stream()\n+                .map(DispatchQuery::getBasicQueryInfo)\n+                .collect(toImmutableList());\n+    }\n+\n+    public BasicQueryInfo getQueryInfo(QueryId queryId)\n+    {\n+        return queryTracker.getQuery(queryId).getBasicQueryInfo();\n+    }\n+\n+    public Optional<DispatchInfo> getDispatchInfo(QueryId queryId)\n+    {\n+        return queryTracker.tryGetQuery(queryId)\n+                .map(dispatchQuery -> {\n+                    dispatchQuery.recordHeartbeat();\n+                    return dispatchQuery.getDispatchInfo();\n+                });\n+    }\n+\n+    public void cancelQuery(QueryId queryId)\n+    {\n+        queryTracker.tryGetQuery(queryId)\n+                .ifPresent(DispatchQuery::cancel);\n+    }\n+\n+    private static class DispatchQueryCreationFuture", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2ODAzNw=="}, "originalCommit": {"oid": "b473cdd820f7d0b1861f0bd7e4948b95fcdf44bd"}, "originalPosition": 301}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzA3NDI3OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTozMzoxMFrOFx6xnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTozMzoxMFrOFx6xnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4NzUxNw==", "bodyText": "Since PurgeQueriesRunnable is gone who's responsible for cleaning up the queries map?", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r387887517", "createdAt": "2020-03-04T19:33:10Z", "author": {"login": "arhimondr"}, "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java", "diffHunk": "@@ -95,83 +85,30 @@\n     private static final DataSize MAX_TARGET_RESULT_SIZE = new DataSize(128, MEGABYTE);\n \n     private final QueryManager queryManager;\n-    private final SessionPropertyManager sessionPropertyManager;\n     private final ExchangeClientSupplier exchangeClientSupplier;\n     private final BlockEncodingSerde blockEncodingSerde;\n     private final BoundedExecutor responseExecutor;\n     private final ScheduledExecutorService timeoutExecutor;\n \n     private final ConcurrentMap<QueryId, Query> queries = new ConcurrentHashMap<>();\n-    private final ScheduledExecutorService queryPurger = newSingleThreadScheduledExecutor(threadsNamed(\"query-purger\"));\n-\n-    private final CounterStat createQueryRequests = new CounterStat();\n \n     @Inject\n-    public StatementResource(\n+    public ExecutingStatementResource(\n             QueryManager queryManager,\n-            SessionPropertyManager sessionPropertyManager,\n             ExchangeClientSupplier exchangeClientSupplier,\n             BlockEncodingSerde blockEncodingSerde,\n             @ForStatementResource BoundedExecutor responseExecutor,\n             @ForStatementResource ScheduledExecutorService timeoutExecutor)\n     {\n         this.queryManager = requireNonNull(queryManager, \"queryManager is null\");\n-        this.sessionPropertyManager = requireNonNull(sessionPropertyManager, \"sessionPropertyManager is null\");\n         this.exchangeClientSupplier = requireNonNull(exchangeClientSupplier, \"exchangeClientSupplier is null\");\n         this.blockEncodingSerde = requireNonNull(blockEncodingSerde, \"blockEncodingSerde is null\");\n         this.responseExecutor = requireNonNull(responseExecutor, \"responseExecutor is null\");\n         this.timeoutExecutor = requireNonNull(timeoutExecutor, \"timeoutExecutor is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b254b1563b6cbcbb9047c72d35761bf00bc49fc"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzA4MDYyOnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTozNToxMVrOFx61rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMDo0Nzo0OFrOFzG-4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4ODU1OA==", "bodyText": "How about calling it notFound? badRequest implies 400 status.", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r387888558", "createdAt": "2020-03-04T19:35:11Z", "author": {"login": "arhimondr"}, "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java", "diffHunk": "@@ -273,19 +232,42 @@ private static Response toResponse(Query query, QueryResults queryResults)\n     }\n \n     @DELETE\n-    @Path(\"{queryId}/{token}\")\n+    @Path(\"/v1/statement/executing/{queryId}/{token}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public Response cancelQuery(\n             @PathParam(\"queryId\") QueryId queryId,\n             @PathParam(\"token\") long token,\n             @QueryParam(\"slug\") String slug)\n     {\n-        Query query = getQuery(queryId, slug);\n-        if (query == null) {\n-            return Response.status(Status.NOT_FOUND).build();\n+        Query query = queries.get(queryId);\n+        if (query != null) {\n+            if (!query.isSlugValid(slug)) {\n+                throw badRequest(NOT_FOUND, \"Query not found\");\n+            }\n+            query.cancel();\n+            return Response.noContent().build();\n+        }\n+\n+        // cancel the query execution directly instead of creating the statement client\n+        try {\n+            if (!queryManager.isQuerySlugValid(queryId, slug)) {\n+                throw badRequest(NOT_FOUND, \"Query not found\");\n+            }\n+            queryManager.cancelQuery(queryId);\n+            return Response.noContent().build();\n+        }\n+        catch (NoSuchElementException e) {\n+            throw badRequest(NOT_FOUND, \"Query not found\");\n         }\n-        query.cancel();\n-        return Response.noContent().build();\n+    }\n+\n+    private static WebApplicationException badRequest(Status status, String message)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b254b1563b6cbcbb9047c72d35761bf00bc49fc"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzNjA5OQ==", "bodyText": "What I'll do is, because every method that calls this passes in NOT_FOUND for the status, is I'll hardcode that NOT_FOUND and rename to notFound.", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389136099", "createdAt": "2020-03-06T20:47:48Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/server/protocol/ExecutingStatementResource.java", "diffHunk": "@@ -273,19 +232,42 @@ private static Response toResponse(Query query, QueryResults queryResults)\n     }\n \n     @DELETE\n-    @Path(\"{queryId}/{token}\")\n+    @Path(\"/v1/statement/executing/{queryId}/{token}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public Response cancelQuery(\n             @PathParam(\"queryId\") QueryId queryId,\n             @PathParam(\"token\") long token,\n             @QueryParam(\"slug\") String slug)\n     {\n-        Query query = getQuery(queryId, slug);\n-        if (query == null) {\n-            return Response.status(Status.NOT_FOUND).build();\n+        Query query = queries.get(queryId);\n+        if (query != null) {\n+            if (!query.isSlugValid(slug)) {\n+                throw badRequest(NOT_FOUND, \"Query not found\");\n+            }\n+            query.cancel();\n+            return Response.noContent().build();\n+        }\n+\n+        // cancel the query execution directly instead of creating the statement client\n+        try {\n+            if (!queryManager.isQuerySlugValid(queryId, slug)) {\n+                throw badRequest(NOT_FOUND, \"Query not found\");\n+            }\n+            queryManager.cancelQuery(queryId);\n+            return Response.noContent().build();\n+        }\n+        catch (NoSuchElementException e) {\n+            throw badRequest(NOT_FOUND, \"Query not found\");\n         }\n-        query.cancel();\n-        return Response.noContent().build();\n+    }\n+\n+    private static WebApplicationException badRequest(Status status, String message)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4ODU1OA=="}, "originalCommit": {"oid": "8b254b1563b6cbcbb9047c72d35761bf00bc49fc"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzkxMzc5OnYy", "diffSide": "RIGHT", "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchExecutor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDozMzo1NFrOFypBfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMzozMTowN1rOFzKb_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NTI0NA==", "bodyText": "hmm. \ud83d\ude03", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r388645244", "createdAt": "2020-03-06T00:33:54Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchExecutor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.airlift.concurrent.BoundedExecutor;\n+import com.facebook.airlift.concurrent.ThreadPoolExecutorMBean;\n+import com.facebook.presto.execution.QueryManagerConfig;\n+import com.google.common.io.Closer;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import org.weakref.jmx.Flatten;\n+import org.weakref.jmx.Managed;\n+import org.weakref.jmx.Nested;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+\n+public class DispatchExecutor\n+{\n+    private final Closer closer = Closer.create();\n+\n+    private final ListeningExecutorService executor;\n+    private final BoundedExecutor boundedExecutor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eab1523ca0a838052bbd117b21058f1332f60ca"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxOTE5MA==", "bodyText": "Is it possible to also export the number of active threads in BoundedExecutor? -- this has been an operation pain when we want to monitor when BoundedExecutor is full.", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r388719190", "createdAt": "2020-03-06T05:27:19Z", "author": {"login": "wenleix"}, "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchExecutor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.airlift.concurrent.BoundedExecutor;\n+import com.facebook.airlift.concurrent.ThreadPoolExecutorMBean;\n+import com.facebook.presto.execution.QueryManagerConfig;\n+import com.google.common.io.Closer;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import org.weakref.jmx.Flatten;\n+import org.weakref.jmx.Managed;\n+import org.weakref.jmx.Nested;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+\n+public class DispatchExecutor\n+{\n+    private final Closer closer = Closer.create();\n+\n+    private final ListeningExecutorService executor;\n+    private final BoundedExecutor boundedExecutor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NTI0NA=="}, "originalCommit": {"oid": "1eab1523ca0a838052bbd117b21058f1332f60ca"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MjcwMw==", "bodyText": "BoundedExecutor does not expose the number of active threads, however the underlying executor itself does export itself as an MBean via ThreadPoolExecutorMBean", "url": "https://github.com/prestodb/presto/pull/14104#discussion_r389192703", "createdAt": "2020-03-06T23:31:07Z", "author": {"login": "tdcmeehan"}, "path": "presto-main/src/main/java/com/facebook/presto/dispatcher/DispatchExecutor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.dispatcher;\n+\n+import com.facebook.airlift.concurrent.BoundedExecutor;\n+import com.facebook.airlift.concurrent.ThreadPoolExecutorMBean;\n+import com.facebook.presto.execution.QueryManagerConfig;\n+import com.google.common.io.Closer;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import org.weakref.jmx.Flatten;\n+import org.weakref.jmx.Managed;\n+import org.weakref.jmx.Nested;\n+\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+\n+public class DispatchExecutor\n+{\n+    private final Closer closer = Closer.create();\n+\n+    private final ListeningExecutorService executor;\n+    private final BoundedExecutor boundedExecutor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NTI0NA=="}, "originalCommit": {"oid": "1eab1523ca0a838052bbd117b21058f1332f60ca"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3015, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}