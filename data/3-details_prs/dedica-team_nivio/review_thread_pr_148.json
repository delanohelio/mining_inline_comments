{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NDM1MTQy", "number": 148, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDoyMTozOFrOECldEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTo0MTo0OFrOECnzeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTQ2MjU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/FileChangeProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDoyMTozOFrOGfIaoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOTowOTo1NFrOGfUMLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5NjkyOA==", "bodyText": "Should be renamed to isReference or something similar because process is already a method in our class", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435296928", "createdAt": "2020-06-04T14:21:38Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/FileChangeProcessor.java", "diffHunk": "@@ -1,65 +1,69 @@\n package de.bonndan.nivio.input;\n \n+import de.bonndan.nivio.IndexEvent;\n import de.bonndan.nivio.ProcessingException;\n import de.bonndan.nivio.input.dto.LandscapeDescription;\n import de.bonndan.nivio.model.LandscapeRepository;\n+import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.context.ApplicationListener;\n import org.springframework.stereotype.Component;\n import org.springframework.util.StringUtils;\n \n import java.io.File;\n-import java.util.Optional;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n+/**\n+ * This class handles local file changes to tries to find the landscape belonging to the file, then trigger an indexing.\n+ *\n+ *\n+ */\n @Component\n public class FileChangeProcessor implements ApplicationListener<FSChangeEvent> {\n \n-    private final Indexer indexer;\n     private final LandscapeRepository landscapeRepository;\n+    private final ApplicationEventPublisher applicationEventPublisher;\n \n-    public FileChangeProcessor(Indexer indexer, LandscapeRepository landscapeRepository) {\n-        this.indexer = indexer;\n+    public FileChangeProcessor(LandscapeRepository landscapeRepository,\n+                               ApplicationEventPublisher applicationEventPublisher\n+    ) {\n         this.landscapeRepository = landscapeRepository;\n+        this.applicationEventPublisher = applicationEventPublisher;\n     }\n \n     @Override\n     public void onApplicationEvent(FSChangeEvent fsChangeEvent) {\n-        process(fsChangeEvent.getChangedFile());\n-    }\n \n-    public ProcessLog process(File envFile) {\n-        LandscapeDescription landscapeDescription = LandscapeDescriptionFactory.fromYaml(envFile);\n+        File changedFile = fsChangeEvent.getChangedFile();\n+        LandscapeDescription landscapeDescription = LandscapeDescriptionFactory.fromYaml(changedFile);\n         if (landscapeDescription == null) {\n-            return new ProcessLog(new ProcessingException(\"Could not read environment from \" + envFile, new RuntimeException()));\n+            new ProcessLog(new ProcessingException(\"Could not read environment from \" + changedFile, new RuntimeException()));\n+            return;\n         }\n \n         //this is not an environment file, but likely a service description file\n         if (landscapeDescription.getIdentifier() == null && !StringUtils.isEmpty(landscapeDescription.getSource())) {\n-            return handleServiceDescriptionFileChange(landscapeDescription).orElse(\n-                    new ProcessLog(new ProcessingException(\"Could not read environment from \" + envFile, new RuntimeException()))\n-            );\n+            if (handleServiceDescriptionFileChange(landscapeDescription, changedFile)) {\n+                return;\n+            }\n         }\n-        return process(landscapeDescription);\n+        process(landscapeDescription, changedFile);\n     }\n \n-    private Optional<ProcessLog> handleServiceDescriptionFileChange(LandscapeDescription landscapeDescription) {\n-\n-        AtomicReference<ProcessLog> process = new AtomicReference<>();\n+    private boolean handleServiceDescriptionFileChange(LandscapeDescription landscapeDescription,\n+                                                                    File changedFile\n+    ) {\n+        AtomicBoolean process = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4OTgzNw==", "bodyText": "done", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435489837", "createdAt": "2020-06-04T19:09:54Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/input/FileChangeProcessor.java", "diffHunk": "@@ -1,65 +1,69 @@\n package de.bonndan.nivio.input;\n \n+import de.bonndan.nivio.IndexEvent;\n import de.bonndan.nivio.ProcessingException;\n import de.bonndan.nivio.input.dto.LandscapeDescription;\n import de.bonndan.nivio.model.LandscapeRepository;\n+import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.context.ApplicationListener;\n import org.springframework.stereotype.Component;\n import org.springframework.util.StringUtils;\n \n import java.io.File;\n-import java.util.Optional;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n+/**\n+ * This class handles local file changes to tries to find the landscape belonging to the file, then trigger an indexing.\n+ *\n+ *\n+ */\n @Component\n public class FileChangeProcessor implements ApplicationListener<FSChangeEvent> {\n \n-    private final Indexer indexer;\n     private final LandscapeRepository landscapeRepository;\n+    private final ApplicationEventPublisher applicationEventPublisher;\n \n-    public FileChangeProcessor(Indexer indexer, LandscapeRepository landscapeRepository) {\n-        this.indexer = indexer;\n+    public FileChangeProcessor(LandscapeRepository landscapeRepository,\n+                               ApplicationEventPublisher applicationEventPublisher\n+    ) {\n         this.landscapeRepository = landscapeRepository;\n+        this.applicationEventPublisher = applicationEventPublisher;\n     }\n \n     @Override\n     public void onApplicationEvent(FSChangeEvent fsChangeEvent) {\n-        process(fsChangeEvent.getChangedFile());\n-    }\n \n-    public ProcessLog process(File envFile) {\n-        LandscapeDescription landscapeDescription = LandscapeDescriptionFactory.fromYaml(envFile);\n+        File changedFile = fsChangeEvent.getChangedFile();\n+        LandscapeDescription landscapeDescription = LandscapeDescriptionFactory.fromYaml(changedFile);\n         if (landscapeDescription == null) {\n-            return new ProcessLog(new ProcessingException(\"Could not read environment from \" + envFile, new RuntimeException()));\n+            new ProcessLog(new ProcessingException(\"Could not read environment from \" + changedFile, new RuntimeException()));\n+            return;\n         }\n \n         //this is not an environment file, but likely a service description file\n         if (landscapeDescription.getIdentifier() == null && !StringUtils.isEmpty(landscapeDescription.getSource())) {\n-            return handleServiceDescriptionFileChange(landscapeDescription).orElse(\n-                    new ProcessLog(new ProcessingException(\"Could not read environment from \" + envFile, new RuntimeException()))\n-            );\n+            if (handleServiceDescriptionFileChange(landscapeDescription, changedFile)) {\n+                return;\n+            }\n         }\n-        return process(landscapeDescription);\n+        process(landscapeDescription, changedFile);\n     }\n \n-    private Optional<ProcessLog> handleServiceDescriptionFileChange(LandscapeDescription landscapeDescription) {\n-\n-        AtomicReference<ProcessLog> process = new AtomicReference<>();\n+    private boolean handleServiceDescriptionFileChange(LandscapeDescription landscapeDescription,\n+                                                                    File changedFile\n+    ) {\n+        AtomicBoolean process = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5NjkyOA=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTUyMzgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/LandscapeDescriptionFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDozNDoxMFrOGfJBfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOTo0MzoyNVrOGfVO8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMwNjg3Ng==", "bodyText": "Objects.requireNonNull throws a nullPointer exception on failur but wont be caught", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435306876", "createdAt": "2020-06-04T14:34:10Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/LandscapeDescriptionFactory.java", "diffHunk": "@@ -2,25 +2,95 @@\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import de.bonndan.nivio.ProcessingErrorEvent;\n+import de.bonndan.nivio.ProcessingException;\n import de.bonndan.nivio.input.dto.LandscapeDescription;\n import de.bonndan.nivio.util.Mappers;\n+import de.bonndan.nivio.util.URLHelper;\n import org.apache.commons.text.StringSubstitutor;\n import org.apache.commons.text.lookup.StringLookupFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.stereotype.Component;\n import org.springframework.util.StringUtils;\n \n import java.io.File;\n import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URISyntaxException;\n import java.net.URL;\n import java.nio.file.Files;\n import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n \n+@Component\n public class LandscapeDescriptionFactory {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(LandscapeDescriptionFactory.class);\n     private static final ObjectMapper mapper = Mappers.gracefulYamlMapper;\n \n+    private final ApplicationEventPublisher publisher;\n+    private final FileFetcher fileFetcher;\n+\n+    public LandscapeDescriptionFactory(ApplicationEventPublisher publisher, FileFetcher fileFetcher) {\n+        this.publisher = publisher;\n+        this.fileFetcher = fileFetcher;\n+    }\n+\n+    public List<LandscapeDescription> getDescriptions(Seed seed) {\n+\n+        List<URL> locations = new ArrayList<>();\n+        try {\n+            if (seed.hasValue()) {\n+                locations = seed.getLocations();\n+            }\n+            if (!StringUtils.isEmpty(System.getenv(Seed.DEMO))) {\n+                locations.addAll(seed.getDemoFiles());\n+            }\n+        } catch (MalformedURLException e) {\n+            ProcessingException processingException = new ProcessingException(\"Failed to initialize watchers from seed\", e);\n+            publisher.publishEvent(new ProcessingErrorEvent(this, processingException));\n+        }\n+\n+        List<LandscapeDescription> descriptions = new ArrayList<>();\n+\n+        locations.forEach(url -> {\n+            LandscapeDescription env = null;\n+            if (URLHelper.isLocal(url)) {\n+                File file;\n+                try {\n+                    file = Paths.get(url.toURI()).toFile();\n+                } catch (URISyntaxException e) {\n+                    throw new ProcessingException(\"Failed to initialize watchers from seed\", e);\n+                }\n+                LOGGER.info(\"Created directory watcher for url \" + url);\n+                try {\n+                    env = LandscapeDescriptionFactory.fromYaml(file);\n+                } catch (ReadingException ex) {\n+                    publisher.publishEvent(new ProcessingErrorEvent(this, ex));\n+                    LOGGER.error(\"Failed to parse file {}\", file);\n+                }\n+            } else {\n+                try {\n+                    env = LandscapeDescriptionFactory.fromString(fileFetcher.get(url), url);\n+                    Objects.requireNonNull(env);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUwNjkzMQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435506931", "createdAt": "2020-06-04T19:43:25Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/input/LandscapeDescriptionFactory.java", "diffHunk": "@@ -2,25 +2,95 @@\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import de.bonndan.nivio.ProcessingErrorEvent;\n+import de.bonndan.nivio.ProcessingException;\n import de.bonndan.nivio.input.dto.LandscapeDescription;\n import de.bonndan.nivio.util.Mappers;\n+import de.bonndan.nivio.util.URLHelper;\n import org.apache.commons.text.StringSubstitutor;\n import org.apache.commons.text.lookup.StringLookupFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.stereotype.Component;\n import org.springframework.util.StringUtils;\n \n import java.io.File;\n import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URISyntaxException;\n import java.net.URL;\n import java.nio.file.Files;\n import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n \n+@Component\n public class LandscapeDescriptionFactory {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(LandscapeDescriptionFactory.class);\n     private static final ObjectMapper mapper = Mappers.gracefulYamlMapper;\n \n+    private final ApplicationEventPublisher publisher;\n+    private final FileFetcher fileFetcher;\n+\n+    public LandscapeDescriptionFactory(ApplicationEventPublisher publisher, FileFetcher fileFetcher) {\n+        this.publisher = publisher;\n+        this.fileFetcher = fileFetcher;\n+    }\n+\n+    public List<LandscapeDescription> getDescriptions(Seed seed) {\n+\n+        List<URL> locations = new ArrayList<>();\n+        try {\n+            if (seed.hasValue()) {\n+                locations = seed.getLocations();\n+            }\n+            if (!StringUtils.isEmpty(System.getenv(Seed.DEMO))) {\n+                locations.addAll(seed.getDemoFiles());\n+            }\n+        } catch (MalformedURLException e) {\n+            ProcessingException processingException = new ProcessingException(\"Failed to initialize watchers from seed\", e);\n+            publisher.publishEvent(new ProcessingErrorEvent(this, processingException));\n+        }\n+\n+        List<LandscapeDescription> descriptions = new ArrayList<>();\n+\n+        locations.forEach(url -> {\n+            LandscapeDescription env = null;\n+            if (URLHelper.isLocal(url)) {\n+                File file;\n+                try {\n+                    file = Paths.get(url.toURI()).toFile();\n+                } catch (URISyntaxException e) {\n+                    throw new ProcessingException(\"Failed to initialize watchers from seed\", e);\n+                }\n+                LOGGER.info(\"Created directory watcher for url \" + url);\n+                try {\n+                    env = LandscapeDescriptionFactory.fromYaml(file);\n+                } catch (ReadingException ex) {\n+                    publisher.publishEvent(new ProcessingErrorEvent(this, ex));\n+                    LOGGER.error(\"Failed to parse file {}\", file);\n+                }\n+            } else {\n+                try {\n+                    env = LandscapeDescriptionFactory.fromString(fileFetcher.get(url), url);\n+                    Objects.requireNonNull(env);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMwNjg3Ng=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTU1MDUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/Seed.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo0MDowN1rOGfJTCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOToxNzoxOVrOGfUbOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMxMTM3MQ==", "bodyText": "DemoFiles shouldn't throw a MalformedURLException", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435311371", "createdAt": "2020-06-04T14:40:07Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/Seed.java", "diffHunk": "@@ -23,12 +23,12 @@\n     static final String NIVIO_ENV_DIRECTORY = \"file:/opt/nivio/environments\";\n     static boolean ESCAPE_AUTHORITY = SystemUtils.IS_OS_WINDOWS;\n \n-    public static List<File> getDemoFiles() {\n+    public List<URL> getDemoFiles() throws MalformedURLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5MzY4OA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435493688", "createdAt": "2020-06-04T19:17:19Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/input/Seed.java", "diffHunk": "@@ -23,12 +23,12 @@\n     static final String NIVIO_ENV_DIRECTORY = \"file:/opt/nivio/environments\";\n     static boolean ESCAPE_AUTHORITY = SystemUtils.IS_OS_WINDOWS;\n \n-    public static List<File> getDemoFiles() {\n+    public List<URL> getDemoFiles() throws MalformedURLException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMxMTM3MQ=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTYwMDg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/WatcherFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo1MDo1N1rOGfJzQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOTo0Mzo0NlrOGfVPrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMxOTYxNw==", "bodyText": "Same as LandscapeDescriptionFactory", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435319617", "createdAt": "2020-06-04T14:50:57Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/WatcherFactory.java", "diffHunk": "@@ -4,80 +4,75 @@\n import de.bonndan.nivio.ProcessingException;\n import de.bonndan.nivio.input.dto.LandscapeDescription;\n import de.bonndan.nivio.util.URLHelper;\n-import org.apache.commons.lang3.SystemUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.stereotype.Component;\n \n import java.io.File;\n-import java.net.MalformedURLException;\n import java.net.URISyntaxException;\n+import java.net.URL;\n import java.nio.file.Paths;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n \n+@Deprecated\n @Component\n public class WatcherFactory {\n \n     private static final Logger logger = LoggerFactory.getLogger(WatcherFactory.class);\n \n-    private final Seed seed;\n-\n     private final ApplicationEventPublisher publisher;\n \n     private final FileFetcher fileFetcher;\n     private final Indexer indexer;\n \n-    public WatcherFactory(Seed seed, ApplicationEventPublisher publisher, FileFetcher fileFetcher, Indexer indexer) {\n-        this.seed = seed;\n+    public WatcherFactory(ApplicationEventPublisher publisher, FileFetcher fileFetcher, Indexer indexer) {\n         this.publisher = publisher;\n         this.fileFetcher = fileFetcher;\n         this.indexer = indexer;\n     }\n \n-    public List<Runnable> getWatchers() {\n+    public List<Runnable> getWatchers(List<URL> locations) {\n \n         List<Runnable> runnables = new ArrayList<>();\n-        try {\n-            seed.getLocations().forEach(url -> {\n-                LandscapeDescription env = null;\n-                if (URLHelper.isLocal(url)) {\n-                    DirectoryWatcher directoryWatcher;\n-                    File file;\n-                    try {\n-                        file = Paths.get(url.toURI()).toFile();\n-                        directoryWatcher = new DirectoryWatcher(publisher, file);\n-                    } catch (URISyntaxException e) {\n-                        throw new ProcessingException(\"Failed to initialize watchers from seed\", e);\n-                    }\n-                    runnables.add(directoryWatcher);\n-                    logger.info(\"Created directory watcher for url \" + url);\n-                    try {\n-                        env = LandscapeDescriptionFactory.fromYaml(file);\n-                    } catch (ReadingException ex) {\n-                        publisher.publishEvent(new ProcessingErrorEvent(this, ex));\n-                        logger.error(\"Failed to parse file {}\", file);\n-                    }\n-                } else {\n-                    try {\n-                        env = LandscapeDescriptionFactory.fromString(fileFetcher.get(url), url);\n-                        Objects.requireNonNull(env);\n-                    } catch (ReadingException ex) {\n-                        publisher.publishEvent(new ProcessingErrorEvent(this, ex));\n-                        logger.error(\"Failed to parse file {}\", url);\n-                    }\n+\n+        logger.info(\"getWatchers {}\", locations);\n+\n+        locations.forEach(url -> {\n+            LandscapeDescription env = null;\n+            if (URLHelper.isLocal(url)) {\n+                DirectoryWatcher directoryWatcher;\n+                File file;\n+                try {\n+                    file = Paths.get(url.toURI()).toFile();\n+                    directoryWatcher = new DirectoryWatcher(publisher, file);\n+                } catch (URISyntaxException e) {\n+                    throw new ProcessingException(\"Failed to initialize watchers from seed\", e);\n                 }\n-                if (env != null) {\n-                    indexer.reIndex(env);\n+                runnables.add(directoryWatcher);\n+                logger.info(\"Created directory watcher for url \" + url);\n+                try {\n+                    env = LandscapeDescriptionFactory.fromYaml(file);\n+                } catch (ReadingException ex) {\n+                    publisher.publishEvent(new ProcessingErrorEvent(this, ex));\n+                    logger.error(\"Failed to parse file {}\", file);\n                 }\n-            });\n-        } catch (MalformedURLException e) {\n-            ProcessingException processingException = new ProcessingException(\"Failed to initialize watchers from seed\", e);\n-            publisher.publishEvent(new ProcessingErrorEvent(this, processingException));\n-        }\n+            } else {\n+                try {\n+                    env = LandscapeDescriptionFactory.fromString(fileFetcher.get(url), url);\n+                    Objects.requireNonNull(env);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUwNzExOA==", "bodyText": "wont fix, is deprecated", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435507118", "createdAt": "2020-06-04T19:43:46Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/input/WatcherFactory.java", "diffHunk": "@@ -4,80 +4,75 @@\n import de.bonndan.nivio.ProcessingException;\n import de.bonndan.nivio.input.dto.LandscapeDescription;\n import de.bonndan.nivio.util.URLHelper;\n-import org.apache.commons.lang3.SystemUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.context.ApplicationEventPublisher;\n import org.springframework.stereotype.Component;\n \n import java.io.File;\n-import java.net.MalformedURLException;\n import java.net.URISyntaxException;\n+import java.net.URL;\n import java.nio.file.Paths;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Objects;\n \n+@Deprecated\n @Component\n public class WatcherFactory {\n \n     private static final Logger logger = LoggerFactory.getLogger(WatcherFactory.class);\n \n-    private final Seed seed;\n-\n     private final ApplicationEventPublisher publisher;\n \n     private final FileFetcher fileFetcher;\n     private final Indexer indexer;\n \n-    public WatcherFactory(Seed seed, ApplicationEventPublisher publisher, FileFetcher fileFetcher, Indexer indexer) {\n-        this.seed = seed;\n+    public WatcherFactory(ApplicationEventPublisher publisher, FileFetcher fileFetcher, Indexer indexer) {\n         this.publisher = publisher;\n         this.fileFetcher = fileFetcher;\n         this.indexer = indexer;\n     }\n \n-    public List<Runnable> getWatchers() {\n+    public List<Runnable> getWatchers(List<URL> locations) {\n \n         List<Runnable> runnables = new ArrayList<>();\n-        try {\n-            seed.getLocations().forEach(url -> {\n-                LandscapeDescription env = null;\n-                if (URLHelper.isLocal(url)) {\n-                    DirectoryWatcher directoryWatcher;\n-                    File file;\n-                    try {\n-                        file = Paths.get(url.toURI()).toFile();\n-                        directoryWatcher = new DirectoryWatcher(publisher, file);\n-                    } catch (URISyntaxException e) {\n-                        throw new ProcessingException(\"Failed to initialize watchers from seed\", e);\n-                    }\n-                    runnables.add(directoryWatcher);\n-                    logger.info(\"Created directory watcher for url \" + url);\n-                    try {\n-                        env = LandscapeDescriptionFactory.fromYaml(file);\n-                    } catch (ReadingException ex) {\n-                        publisher.publishEvent(new ProcessingErrorEvent(this, ex));\n-                        logger.error(\"Failed to parse file {}\", file);\n-                    }\n-                } else {\n-                    try {\n-                        env = LandscapeDescriptionFactory.fromString(fileFetcher.get(url), url);\n-                        Objects.requireNonNull(env);\n-                    } catch (ReadingException ex) {\n-                        publisher.publishEvent(new ProcessingErrorEvent(this, ex));\n-                        logger.error(\"Failed to parse file {}\", url);\n-                    }\n+\n+        logger.info(\"getWatchers {}\", locations);\n+\n+        locations.forEach(url -> {\n+            LandscapeDescription env = null;\n+            if (URLHelper.isLocal(url)) {\n+                DirectoryWatcher directoryWatcher;\n+                File file;\n+                try {\n+                    file = Paths.get(url.toURI()).toFile();\n+                    directoryWatcher = new DirectoryWatcher(publisher, file);\n+                } catch (URISyntaxException e) {\n+                    throw new ProcessingException(\"Failed to initialize watchers from seed\", e);\n                 }\n-                if (env != null) {\n-                    indexer.reIndex(env);\n+                runnables.add(directoryWatcher);\n+                logger.info(\"Created directory watcher for url \" + url);\n+                try {\n+                    env = LandscapeDescriptionFactory.fromYaml(file);\n+                } catch (ReadingException ex) {\n+                    publisher.publishEvent(new ProcessingErrorEvent(this, ex));\n+                    logger.error(\"Failed to parse file {}\", file);\n                 }\n-            });\n-        } catch (MalformedURLException e) {\n-            ProcessingException processingException = new ProcessingException(\"Failed to initialize watchers from seed\", e);\n-            publisher.publishEvent(new ProcessingErrorEvent(this, processingException));\n-        }\n+            } else {\n+                try {\n+                    env = LandscapeDescriptionFactory.fromString(fileFetcher.get(url), url);\n+                    Objects.requireNonNull(env);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMxOTYxNw=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTYwOTgxOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDo1Mjo1MlrOGfJ5Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOToyMToxOVrOGfUjMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyMTEwNg==", "bodyText": "used for groupname but this is not obvious", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435321106", "createdAt": "2020-06-04T14:52:52Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -1,28 +1,39 @@\n package de.bonndan.nivio.input.kubernetes;\n \n+import de.bonndan.nivio.ProcessingException;\n+import de.bonndan.nivio.assessment.StatusValue;\n import de.bonndan.nivio.input.ItemDescriptionFactory;\n import de.bonndan.nivio.input.dto.ItemDescription;\n+import de.bonndan.nivio.input.dto.RelationDescription;\n import de.bonndan.nivio.input.dto.SourceReference;\n import de.bonndan.nivio.model.Label;\n import de.bonndan.nivio.model.LandscapeItem;\n+import de.bonndan.nivio.model.RelationType;\n import de.bonndan.nivio.util.URLHelper;\n import io.fabric8.kubernetes.api.model.HasMetadata;\n import io.fabric8.kubernetes.api.model.Pod;\n+import io.fabric8.kubernetes.api.model.PodStatus;\n import io.fabric8.kubernetes.api.model.Service;\n import io.fabric8.kubernetes.client.Config;\n import io.fabric8.kubernetes.client.DefaultKubernetesClient;\n import io.fabric8.kubernetes.client.KubernetesClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.util.StringUtils;\n \n import java.net.MalformedURLException;\n import java.net.URL;\n import java.util.*;\n+import java.util.stream.Collectors;\n \n @org.springframework.stereotype.Service\n public class ItemDescriptionFactoryKubernetes implements ItemDescriptionFactory {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(ItemDescriptionFactoryKubernetes.class);\n+\n     public static final String NAMESPACE = \"namespace\";\n     public static final String GROUP_LABEL = \"groupLabel\";\n+    public static final String APP_KUBERNETES_IO_INSTANCE_LABEL = \"app.kubernetes.io/instance\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5NTcyOA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435495728", "createdAt": "2020-06-04T19:21:19Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -1,28 +1,39 @@\n package de.bonndan.nivio.input.kubernetes;\n \n+import de.bonndan.nivio.ProcessingException;\n+import de.bonndan.nivio.assessment.StatusValue;\n import de.bonndan.nivio.input.ItemDescriptionFactory;\n import de.bonndan.nivio.input.dto.ItemDescription;\n+import de.bonndan.nivio.input.dto.RelationDescription;\n import de.bonndan.nivio.input.dto.SourceReference;\n import de.bonndan.nivio.model.Label;\n import de.bonndan.nivio.model.LandscapeItem;\n+import de.bonndan.nivio.model.RelationType;\n import de.bonndan.nivio.util.URLHelper;\n import io.fabric8.kubernetes.api.model.HasMetadata;\n import io.fabric8.kubernetes.api.model.Pod;\n+import io.fabric8.kubernetes.api.model.PodStatus;\n import io.fabric8.kubernetes.api.model.Service;\n import io.fabric8.kubernetes.client.Config;\n import io.fabric8.kubernetes.client.DefaultKubernetesClient;\n import io.fabric8.kubernetes.client.KubernetesClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.util.StringUtils;\n \n import java.net.MalformedURLException;\n import java.net.URL;\n import java.util.*;\n+import java.util.stream.Collectors;\n \n @org.springframework.stereotype.Service\n public class ItemDescriptionFactoryKubernetes implements ItemDescriptionFactory {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(ItemDescriptionFactoryKubernetes.class);\n+\n     public static final String NAMESPACE = \"namespace\";\n     public static final String GROUP_LABEL = \"groupLabel\";\n+    public static final String APP_KUBERNETES_IO_INSTANCE_LABEL = \"app.kubernetes.io/instance\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyMTEwNg=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTY2ODMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowNTowN1rOGfKd9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowNTowN1rOGfKd9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMDU0OQ==", "bodyText": "Returning a list is not necessary", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435330549", "createdAt": "2020-06-04T15:05:07Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -60,26 +76,62 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n         KubernetesClient client = getClient(reference.getUrl());\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n-        client.pods().list().getItems().stream()\n-                .filter(pod -> {\n-                    if (namespace == null)\n-                        return true;\n-                    return namespace.equals(pod.getMetadata().getNamespace());\n-                })\n-                .forEach(pod -> descriptions.addAll(createDescriptionFromService(pod)));\n+        final List<ItemDescription> pods = new ArrayList<>();\n+        getPods().forEach(pod -> {\n+            ItemDescription podItem = createPodItemDescription(pod);\n+            descriptions.add(podItem);\n+            pods.add(podItem);\n+            List<ItemDescription> descriptionsFromPod = createDescriptionsFromPod(pod, podItem);\n+            descriptions.addAll(descriptionsFromPod);\n+        });\n \n-        client.services().list().getItems().stream()\n+        List<Service> services = client.services().list().getItems();\n+        LOGGER.info(\"Found services: {}\", services.stream().map(service -> service.getMetadata().getName()).collect(Collectors.toList()));\n+        services.stream()\n                 .filter(service -> {\n                     if (namespace == null)\n                         return true;\n                     return namespace.equals(service.getMetadata().getNamespace());\n                 })\n-                .forEach(service -> descriptions.addAll(createDescriptionFromService(service, descriptions)));\n+                .forEach(service -> descriptions.addAll(createDescriptionFromService(service, pods)));\n \n         return descriptions;\n     }\n \n-    private Collection<? extends ItemDescription> createDescriptionFromService(Service kubernetesService, List<ItemDescription> items) {\n+    /**\n+     * Creates a pod item\n+     *\n+     * @param pod k8s pod object\n+     * @return pod (yet ungrouped)\n+     */\n+    private ItemDescription createPodItemDescription(Pod pod) {\n+        ItemDescription itemDescription = new ItemDescription();\n+        itemDescription.setName(pod.getMetadata().getName());\n+        itemDescription.setIdentifier(pod.getMetadata().getName());\n+        itemDescription.setType(\"pod\");\n+        pod.getMetadata().getLabels().forEach((s, s2) -> itemDescription.setLabel(s, s2));\n+        return itemDescription;\n+    }\n+\n+    /**\n+     * @return all pods in the namespace\n+     */\n+    private List<Pod> getPods() {\n+        try {\n+            List<Pod> pods = client.pods().list().getItems();\n+            LOGGER.info(\"Found pods: {}\", pods.stream().map(pod -> pod.getMetadata().getName()).collect(Collectors.toList()));\n+            return pods.stream()\n+                    .filter(pod -> {\n+                        if (namespace == null)\n+                            return true;\n+                        return namespace.equals(pod.getMetadata().getNamespace());\n+                    }).collect(Collectors.toList());\n+        } catch (Exception ex) {\n+            throw new ProcessingException(\"Failed to load pods \", ex);\n+        }\n+    }\n+\n+    private Collection<? extends ItemDescription> createDescriptionFromService(Service kubernetesService, List<ItemDescription> pods) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTY4NjE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowOToxNVrOGfKpZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowOToxNVrOGfKpZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMzQ3Ng==", "bodyText": "maybe add a type enum", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435333476", "createdAt": "2020-06-04T15:09:15Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTY5MzcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToxMDo1NVrOGfKuNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOToyMTo0OVrOGfUkIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzNDcwOQ==", "bodyText": "reverse direction", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435334709", "createdAt": "2020-06-04T15:10:55Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");\n+        descriptions.add(node);\n+        podItem.addRelation(new RelationDescription(node.getIdentifier(), podItem.getIdentifier()));\n+\n         String group = getGroup(pod);\n         pod.getSpec().getContainers().forEach(container -> {\n-            ItemDescription description = new ItemDescription();\n-            description.setGroup(group);\n-            description.setName(container.getName());\n-            description.setIdentifier(container.getName());\n-            description.setLabel(Label.SOFTWARE, container.getImage());\n-            description.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n-            pod.getMetadata().getLabels().forEach((s, s2) -> description.setLabel(s, s2));\n+            ItemDescription containerDesc = new ItemDescription();\n+            containerDesc.setGroup(group);\n+            containerDesc.setName(container.getName());\n+            containerDesc.setIdentifier(podItem.getName() + \"-\" + container.getName());\n+            containerDesc.setLabel(Label.SOFTWARE, container.getImage());\n+            containerDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            containerDesc.setType(\"container\");\n+            pod.getMetadata().getLabels().forEach((s, s2) -> containerDesc.setLabel(s, s2));\n+            RelationDescription relationDescription = new RelationDescription(podItem.getIdentifier(), containerDesc.getIdentifier());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5NTk3MA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435495970", "createdAt": "2020-06-04T19:21:49Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");\n+        descriptions.add(node);\n+        podItem.addRelation(new RelationDescription(node.getIdentifier(), podItem.getIdentifier()));\n+\n         String group = getGroup(pod);\n         pod.getSpec().getContainers().forEach(container -> {\n-            ItemDescription description = new ItemDescription();\n-            description.setGroup(group);\n-            description.setName(container.getName());\n-            description.setIdentifier(container.getName());\n-            description.setLabel(Label.SOFTWARE, container.getImage());\n-            description.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n-            pod.getMetadata().getLabels().forEach((s, s2) -> description.setLabel(s, s2));\n+            ItemDescription containerDesc = new ItemDescription();\n+            containerDesc.setGroup(group);\n+            containerDesc.setName(container.getName());\n+            containerDesc.setIdentifier(podItem.getName() + \"-\" + container.getName());\n+            containerDesc.setLabel(Label.SOFTWARE, container.getImage());\n+            containerDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            containerDesc.setType(\"container\");\n+            pod.getMetadata().getLabels().forEach((s, s2) -> containerDesc.setLabel(s, s2));\n+            RelationDescription relationDescription = new RelationDescription(podItem.getIdentifier(), containerDesc.getIdentifier());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzNDcwOQ=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTcwMjA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToxMjo1MFrOGfKzjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDowNzoyNlrOGfV-8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzNjA3Ng==", "bodyText": "extract to method", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435336076", "createdAt": "2020-06-04T15:12:50Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");\n+        descriptions.add(node);\n+        podItem.addRelation(new RelationDescription(node.getIdentifier(), podItem.getIdentifier()));\n+\n         String group = getGroup(pod);\n         pod.getSpec().getContainers().forEach(container -> {\n-            ItemDescription description = new ItemDescription();\n-            description.setGroup(group);\n-            description.setName(container.getName());\n-            description.setIdentifier(container.getName());\n-            description.setLabel(Label.SOFTWARE, container.getImage());\n-            description.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n-            pod.getMetadata().getLabels().forEach((s, s2) -> description.setLabel(s, s2));\n+            ItemDescription containerDesc = new ItemDescription();\n+            containerDesc.setGroup(group);\n+            containerDesc.setName(container.getName());\n+            containerDesc.setIdentifier(podItem.getName() + \"-\" + container.getName());\n+            containerDesc.setLabel(Label.SOFTWARE, container.getImage());\n+            containerDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            containerDesc.setType(\"container\");\n+            pod.getMetadata().getLabels().forEach((s, s2) -> containerDesc.setLabel(s, s2));\n+            RelationDescription relationDescription = new RelationDescription(podItem.getIdentifier(), containerDesc.getIdentifier());\n+            relationDescription.setType(RelationType.PROVIDER);\n+            containerDesc.addRelation(relationDescription);\n \n             // TODO\n-            //set Labels, introduce new labels property (docker/k8s)\n-            //description.getProvided_by().add(pod.getSpec().)\n             //description.setScale(...);\n             // statuses: pod.getStatus()\n+            setConditionsAndHealth(pod.getStatus(), podItem);\n+            podItem.setLabel(\"hostIP\", pod.getStatus().getHostIP());\n+            podItem.setLabel(\"podIP\", pod.getStatus().getPodIP());\n+            podItem.setLabel(\"phase\", pod.getStatus().getPhase());\n+            podItem.setLabel(\"startTime\", pod.getStatus().getStartTime());\n             //description.setNetworks();\n \n-            descriptions.add(description);\n+            descriptions.add(containerDesc);\n+        });\n+\n+        pod.getSpec().getVolumes().forEach(volume -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxOTIxNw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435519217", "createdAt": "2020-06-04T20:07:26Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");\n+        descriptions.add(node);\n+        podItem.addRelation(new RelationDescription(node.getIdentifier(), podItem.getIdentifier()));\n+\n         String group = getGroup(pod);\n         pod.getSpec().getContainers().forEach(container -> {\n-            ItemDescription description = new ItemDescription();\n-            description.setGroup(group);\n-            description.setName(container.getName());\n-            description.setIdentifier(container.getName());\n-            description.setLabel(Label.SOFTWARE, container.getImage());\n-            description.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n-            pod.getMetadata().getLabels().forEach((s, s2) -> description.setLabel(s, s2));\n+            ItemDescription containerDesc = new ItemDescription();\n+            containerDesc.setGroup(group);\n+            containerDesc.setName(container.getName());\n+            containerDesc.setIdentifier(podItem.getName() + \"-\" + container.getName());\n+            containerDesc.setLabel(Label.SOFTWARE, container.getImage());\n+            containerDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            containerDesc.setType(\"container\");\n+            pod.getMetadata().getLabels().forEach((s, s2) -> containerDesc.setLabel(s, s2));\n+            RelationDescription relationDescription = new RelationDescription(podItem.getIdentifier(), containerDesc.getIdentifier());\n+            relationDescription.setType(RelationType.PROVIDER);\n+            containerDesc.addRelation(relationDescription);\n \n             // TODO\n-            //set Labels, introduce new labels property (docker/k8s)\n-            //description.getProvided_by().add(pod.getSpec().)\n             //description.setScale(...);\n             // statuses: pod.getStatus()\n+            setConditionsAndHealth(pod.getStatus(), podItem);\n+            podItem.setLabel(\"hostIP\", pod.getStatus().getHostIP());\n+            podItem.setLabel(\"podIP\", pod.getStatus().getPodIP());\n+            podItem.setLabel(\"phase\", pod.getStatus().getPhase());\n+            podItem.setLabel(\"startTime\", pod.getStatus().getStartTime());\n             //description.setNetworks();\n \n-            descriptions.add(description);\n+            descriptions.add(containerDesc);\n+        });\n+\n+        pod.getSpec().getVolumes().forEach(volume -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzNjA3Ng=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTcwNjg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToxMzo1MlrOGfK2jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNjo1MjozOFrOGfibKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzNjg0Nw==", "bodyText": "implement!", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435336847", "createdAt": "2020-06-04T15:13:52Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");\n+        descriptions.add(node);\n+        podItem.addRelation(new RelationDescription(node.getIdentifier(), podItem.getIdentifier()));\n+\n         String group = getGroup(pod);\n         pod.getSpec().getContainers().forEach(container -> {\n-            ItemDescription description = new ItemDescription();\n-            description.setGroup(group);\n-            description.setName(container.getName());\n-            description.setIdentifier(container.getName());\n-            description.setLabel(Label.SOFTWARE, container.getImage());\n-            description.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n-            pod.getMetadata().getLabels().forEach((s, s2) -> description.setLabel(s, s2));\n+            ItemDescription containerDesc = new ItemDescription();\n+            containerDesc.setGroup(group);\n+            containerDesc.setName(container.getName());\n+            containerDesc.setIdentifier(podItem.getName() + \"-\" + container.getName());\n+            containerDesc.setLabel(Label.SOFTWARE, container.getImage());\n+            containerDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            containerDesc.setType(\"container\");\n+            pod.getMetadata().getLabels().forEach((s, s2) -> containerDesc.setLabel(s, s2));\n+            RelationDescription relationDescription = new RelationDescription(podItem.getIdentifier(), containerDesc.getIdentifier());\n+            relationDescription.setType(RelationType.PROVIDER);\n+            containerDesc.addRelation(relationDescription);\n \n             // TODO\n-            //set Labels, introduce new labels property (docker/k8s)\n-            //description.getProvided_by().add(pod.getSpec().)\n             //description.setScale(...);\n             // statuses: pod.getStatus()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyMzA1MA==", "bodyText": "implemented a KPI evaluating the condition (status)", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435723050", "createdAt": "2020-06-05T06:52:38Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");\n+        descriptions.add(node);\n+        podItem.addRelation(new RelationDescription(node.getIdentifier(), podItem.getIdentifier()));\n+\n         String group = getGroup(pod);\n         pod.getSpec().getContainers().forEach(container -> {\n-            ItemDescription description = new ItemDescription();\n-            description.setGroup(group);\n-            description.setName(container.getName());\n-            description.setIdentifier(container.getName());\n-            description.setLabel(Label.SOFTWARE, container.getImage());\n-            description.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n-            pod.getMetadata().getLabels().forEach((s, s2) -> description.setLabel(s, s2));\n+            ItemDescription containerDesc = new ItemDescription();\n+            containerDesc.setGroup(group);\n+            containerDesc.setName(container.getName());\n+            containerDesc.setIdentifier(podItem.getName() + \"-\" + container.getName());\n+            containerDesc.setLabel(Label.SOFTWARE, container.getImage());\n+            containerDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            containerDesc.setType(\"container\");\n+            pod.getMetadata().getLabels().forEach((s, s2) -> containerDesc.setLabel(s, s2));\n+            RelationDescription relationDescription = new RelationDescription(podItem.getIdentifier(), containerDesc.getIdentifier());\n+            relationDescription.setType(RelationType.PROVIDER);\n+            containerDesc.addRelation(relationDescription);\n \n             // TODO\n-            //set Labels, introduce new labels property (docker/k8s)\n-            //description.getProvided_by().add(pod.getSpec().)\n             //description.setScale(...);\n             // statuses: pod.getStatus()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzNjg0Nw=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTcxNDIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToxNToyOFrOGfK7Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOToyMjoxMFrOGfUk1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzODAwNw==", "bodyText": "maybe add enum here too", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435338007", "createdAt": "2020-06-04T15:15:28Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");\n+        descriptions.add(node);\n+        podItem.addRelation(new RelationDescription(node.getIdentifier(), podItem.getIdentifier()));\n+\n         String group = getGroup(pod);\n         pod.getSpec().getContainers().forEach(container -> {\n-            ItemDescription description = new ItemDescription();\n-            description.setGroup(group);\n-            description.setName(container.getName());\n-            description.setIdentifier(container.getName());\n-            description.setLabel(Label.SOFTWARE, container.getImage());\n-            description.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n-            pod.getMetadata().getLabels().forEach((s, s2) -> description.setLabel(s, s2));\n+            ItemDescription containerDesc = new ItemDescription();\n+            containerDesc.setGroup(group);\n+            containerDesc.setName(container.getName());\n+            containerDesc.setIdentifier(podItem.getName() + \"-\" + container.getName());\n+            containerDesc.setLabel(Label.SOFTWARE, container.getImage());\n+            containerDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            containerDesc.setType(\"container\");\n+            pod.getMetadata().getLabels().forEach((s, s2) -> containerDesc.setLabel(s, s2));\n+            RelationDescription relationDescription = new RelationDescription(podItem.getIdentifier(), containerDesc.getIdentifier());\n+            relationDescription.setType(RelationType.PROVIDER);\n+            containerDesc.addRelation(relationDescription);\n \n             // TODO\n-            //set Labels, introduce new labels property (docker/k8s)\n-            //description.getProvided_by().add(pod.getSpec().)\n             //description.setScale(...);\n             // statuses: pod.getStatus()\n+            setConditionsAndHealth(pod.getStatus(), podItem);\n+            podItem.setLabel(\"hostIP\", pod.getStatus().getHostIP());\n+            podItem.setLabel(\"podIP\", pod.getStatus().getPodIP());\n+            podItem.setLabel(\"phase\", pod.getStatus().getPhase());\n+            podItem.setLabel(\"startTime\", pod.getStatus().getStartTime());\n             //description.setNetworks();\n \n-            descriptions.add(description);\n+            descriptions.add(containerDesc);\n+        });\n+\n+        pod.getSpec().getVolumes().forEach(volume -> {\n+\n+            //storing configmap volumes in labels\n+            if (volume.getConfigMap() != null) {\n+                podItem.setLabel(\"configMap\" + Label.DELIMITER + volume.getConfigMap().getName(), volume.getConfigMap().getName());\n+                return;\n+            }\n+\n+            ItemDescription volumeDesc = new ItemDescription();\n+            volumeDesc.setGroup(group);\n+            volumeDesc.setName(volume.getName());\n+            volumeDesc.setIdentifier(podItem.getName() + \"-\" + volume.getName());\n+            volumeDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            volumeDesc.setType(\"volume\");\n+            if (volume.getSecret() != null && volume.getSecret().getSecretName().equals(volume.getName())) {\n+                volumeDesc.setLabel(\"secret\", 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM0MDI5MA==", "bodyText": "or add string constants for our presets", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435340290", "createdAt": "2020-06-04T15:18:36Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");\n+        descriptions.add(node);\n+        podItem.addRelation(new RelationDescription(node.getIdentifier(), podItem.getIdentifier()));\n+\n         String group = getGroup(pod);\n         pod.getSpec().getContainers().forEach(container -> {\n-            ItemDescription description = new ItemDescription();\n-            description.setGroup(group);\n-            description.setName(container.getName());\n-            description.setIdentifier(container.getName());\n-            description.setLabel(Label.SOFTWARE, container.getImage());\n-            description.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n-            pod.getMetadata().getLabels().forEach((s, s2) -> description.setLabel(s, s2));\n+            ItemDescription containerDesc = new ItemDescription();\n+            containerDesc.setGroup(group);\n+            containerDesc.setName(container.getName());\n+            containerDesc.setIdentifier(podItem.getName() + \"-\" + container.getName());\n+            containerDesc.setLabel(Label.SOFTWARE, container.getImage());\n+            containerDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            containerDesc.setType(\"container\");\n+            pod.getMetadata().getLabels().forEach((s, s2) -> containerDesc.setLabel(s, s2));\n+            RelationDescription relationDescription = new RelationDescription(podItem.getIdentifier(), containerDesc.getIdentifier());\n+            relationDescription.setType(RelationType.PROVIDER);\n+            containerDesc.addRelation(relationDescription);\n \n             // TODO\n-            //set Labels, introduce new labels property (docker/k8s)\n-            //description.getProvided_by().add(pod.getSpec().)\n             //description.setScale(...);\n             // statuses: pod.getStatus()\n+            setConditionsAndHealth(pod.getStatus(), podItem);\n+            podItem.setLabel(\"hostIP\", pod.getStatus().getHostIP());\n+            podItem.setLabel(\"podIP\", pod.getStatus().getPodIP());\n+            podItem.setLabel(\"phase\", pod.getStatus().getPhase());\n+            podItem.setLabel(\"startTime\", pod.getStatus().getStartTime());\n             //description.setNetworks();\n \n-            descriptions.add(description);\n+            descriptions.add(containerDesc);\n+        });\n+\n+        pod.getSpec().getVolumes().forEach(volume -> {\n+\n+            //storing configmap volumes in labels\n+            if (volume.getConfigMap() != null) {\n+                podItem.setLabel(\"configMap\" + Label.DELIMITER + volume.getConfigMap().getName(), volume.getConfigMap().getName());\n+                return;\n+            }\n+\n+            ItemDescription volumeDesc = new ItemDescription();\n+            volumeDesc.setGroup(group);\n+            volumeDesc.setName(volume.getName());\n+            volumeDesc.setIdentifier(podItem.getName() + \"-\" + volume.getName());\n+            volumeDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            volumeDesc.setType(\"volume\");\n+            if (volume.getSecret() != null && volume.getSecret().getSecretName().equals(volume.getName())) {\n+                volumeDesc.setLabel(\"secret\", 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzODAwNw=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5NjE1MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435496151", "createdAt": "2020-06-04T19:22:10Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/input/kubernetes/ItemDescriptionFactoryKubernetes.java", "diffHunk": "@@ -98,48 +150,114 @@ public ItemDescriptionFactoryKubernetes(KubernetesClient client) {\n \n         //TODO, check if this is reliable\n         if (!StringUtils.isEmpty(targetId)) {\n-            service.getLabels().put(\"nivio.relations\", \"[\" + targetId + \"]\");\n+            service.addRelation(new RelationDescription(service.getIdentifier(), targetId));\n         }\n \n         descriptions.add(service);\n \n+        //link pods as providers\n+        pods.stream()\n+                .filter(pod -> pod.getName().startsWith(service.getIdentifier()))\n+                .forEach(pod -> {\n+                    RelationDescription rel = new RelationDescription(pod.getIdentifier(), service.getIdentifier());\n+                    rel.setType(RelationType.PROVIDER);\n+                    service.addRelation(rel);\n+                    pod.setGroup(service.getGroup());\n+                });\n+\n         return descriptions;\n     }\n \n     public Config getConfiguration() {\n         return getClient(\"\").getConfiguration();\n     }\n \n-    private List<ItemDescription> createDescriptionFromService(Pod pod) {\n+    private List<ItemDescription> createDescriptionsFromPod(Pod pod, ItemDescription podItem) {\n \n         List<ItemDescription> descriptions = new ArrayList<>();\n \n+        ItemDescription node = new ItemDescription();\n+        node.setName(pod.getSpec().getNodeName());\n+        node.setIdentifier(pod.getSpec().getNodeName());\n+        node.setType(\"server\");\n+        descriptions.add(node);\n+        podItem.addRelation(new RelationDescription(node.getIdentifier(), podItem.getIdentifier()));\n+\n         String group = getGroup(pod);\n         pod.getSpec().getContainers().forEach(container -> {\n-            ItemDescription description = new ItemDescription();\n-            description.setGroup(group);\n-            description.setName(container.getName());\n-            description.setIdentifier(container.getName());\n-            description.setLabel(Label.SOFTWARE, container.getImage());\n-            description.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n-            pod.getMetadata().getLabels().forEach((s, s2) -> description.setLabel(s, s2));\n+            ItemDescription containerDesc = new ItemDescription();\n+            containerDesc.setGroup(group);\n+            containerDesc.setName(container.getName());\n+            containerDesc.setIdentifier(podItem.getName() + \"-\" + container.getName());\n+            containerDesc.setLabel(Label.SOFTWARE, container.getImage());\n+            containerDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            containerDesc.setType(\"container\");\n+            pod.getMetadata().getLabels().forEach((s, s2) -> containerDesc.setLabel(s, s2));\n+            RelationDescription relationDescription = new RelationDescription(podItem.getIdentifier(), containerDesc.getIdentifier());\n+            relationDescription.setType(RelationType.PROVIDER);\n+            containerDesc.addRelation(relationDescription);\n \n             // TODO\n-            //set Labels, introduce new labels property (docker/k8s)\n-            //description.getProvided_by().add(pod.getSpec().)\n             //description.setScale(...);\n             // statuses: pod.getStatus()\n+            setConditionsAndHealth(pod.getStatus(), podItem);\n+            podItem.setLabel(\"hostIP\", pod.getStatus().getHostIP());\n+            podItem.setLabel(\"podIP\", pod.getStatus().getPodIP());\n+            podItem.setLabel(\"phase\", pod.getStatus().getPhase());\n+            podItem.setLabel(\"startTime\", pod.getStatus().getStartTime());\n             //description.setNetworks();\n \n-            descriptions.add(description);\n+            descriptions.add(containerDesc);\n+        });\n+\n+        pod.getSpec().getVolumes().forEach(volume -> {\n+\n+            //storing configmap volumes in labels\n+            if (volume.getConfigMap() != null) {\n+                podItem.setLabel(\"configMap\" + Label.DELIMITER + volume.getConfigMap().getName(), volume.getConfigMap().getName());\n+                return;\n+            }\n+\n+            ItemDescription volumeDesc = new ItemDescription();\n+            volumeDesc.setGroup(group);\n+            volumeDesc.setName(volume.getName());\n+            volumeDesc.setIdentifier(podItem.getName() + \"-\" + volume.getName());\n+            volumeDesc.setLabel(Label.MACHINE, pod.getSpec().getNodeName()); //ip?\n+            volumeDesc.setType(\"volume\");\n+            if (volume.getSecret() != null && volume.getSecret().getSecretName().equals(volume.getName())) {\n+                volumeDesc.setLabel(\"secret\", 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzODAwNw=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTg0NzYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/output/map/svg/SvgFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTo0MTo0OFrOGfMOcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOToyNDoxOFrOGfUpRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM1OTM0NA==", "bodyText": "rename variable", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435359344", "createdAt": "2020-06-04T15:41:48Z", "author": {"login": "MarvinSchoening"}, "path": "src/main/java/de/bonndan/nivio/output/map/svg/SvgFactory.java", "diffHunk": "@@ -105,16 +111,20 @@ public DomContent render() {\n \n         List<DomContent> relations = landscape.getItems().all().stream().flatMap(item -> {\n                     LOGGER.debug(\"Adding {} relations for {}\", item.getRelations().size(), item.getFullyQualifiedIdentifier());\n-                    return item.getRelations().stream().map(rel -> {\n-                        Hex start = vertexHexes.get(item);\n-                        Hex target = vertexHexes.get((Item) rel.getTarget());\n-                        HexPath bestPath = pathFinder.getPath(start, target);\n-                        if (bestPath != null) {\n-                            SVGRelation SVGRelation = new SVGRelation(bestPath, item.getColor(), rel);\n-                            return SVGRelation.render();\n-                        }\n-                        return null;\n-                    });\n+                    return item.getRelations().stream()\n+                            .filter(rel -> rel.getSource().equals(item)) //do not paint twice / incoming (inverse) relations\n+                            .map(rel -> {\n+                                Hex start = vertexHexes.get(item);\n+                                Hex target = vertexHexes.get(rel.getTarget());\n+                                HexPath bestPath = pathFinder.getPath(start, target);\n+                                if (bestPath != null) {\n+                                    SVGRelation SVGRelation = new SVGRelation(bestPath, item.getColor(), rel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ5NzI4Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/dedica-team/nivio/pull/148#discussion_r435497286", "createdAt": "2020-06-04T19:24:18Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/svg/SvgFactory.java", "diffHunk": "@@ -105,16 +111,20 @@ public DomContent render() {\n \n         List<DomContent> relations = landscape.getItems().all().stream().flatMap(item -> {\n                     LOGGER.debug(\"Adding {} relations for {}\", item.getRelations().size(), item.getFullyQualifiedIdentifier());\n-                    return item.getRelations().stream().map(rel -> {\n-                        Hex start = vertexHexes.get(item);\n-                        Hex target = vertexHexes.get((Item) rel.getTarget());\n-                        HexPath bestPath = pathFinder.getPath(start, target);\n-                        if (bestPath != null) {\n-                            SVGRelation SVGRelation = new SVGRelation(bestPath, item.getColor(), rel);\n-                            return SVGRelation.render();\n-                        }\n-                        return null;\n-                    });\n+                    return item.getRelations().stream()\n+                            .filter(rel -> rel.getSource().equals(item)) //do not paint twice / incoming (inverse) relations\n+                            .map(rel -> {\n+                                Hex start = vertexHexes.get(item);\n+                                Hex target = vertexHexes.get(rel.getTarget());\n+                                HexPath bestPath = pathFinder.getPath(start, target);\n+                                if (bestPath != null) {\n+                                    SVGRelation SVGRelation = new SVGRelation(bestPath, item.getColor(), rel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM1OTM0NA=="}, "originalCommit": {"oid": "e297d11a861906ad6fbeb77a09f109556f6a7286"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4003, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}