{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzNjI2MzM2", "number": 311, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwOTo0Mjo0NlrOEn0qBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMDo0NjoyNFrOEn09tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTkyNjQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwOTo0Mjo0NlrOHYmKJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMDowNTo1NlrOHYmTFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzA2MA==", "bodyText": "Why don't we care?", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495553060", "createdAt": "2020-09-27T09:42:46Z", "author": {"login": "mfbieber"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "diffHunk": "@@ -18,47 +19,86 @@\n \n     /**\n      * Builds an areas of hex tiles belonging to a group.\n-     *\n+     * <p>\n      * It works as follows: first we circumnavigate all hexes of items and add their neighbours immediately. Then we\n      * iterate over all one-hex gaps and add them. This iteration is repeated, so that effectively a few two-hex gaps are\n      * filled.\n-     *\n+     * <p>\n      * There is clearly much room for improvement here. It's only that I haven't found a better approach so far.\n      *\n-     * @param occupied      tiles occupied by items\n-     * @param group         the group\n-     * @param vertexHexes   a mapping from item to its hex\n-     * @param pathsWithinGroup existing paths\n+     * @param occupied       tiles occupied by items\n+     * @param group          the group\n+     * @param allVertexHexes a mapping from item to its hex (all, unfiltered)\n      * @return all hexes the group consists of (an area)\n      */\n-    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> vertexHexes, List<HexPath> pathsWithinGroup) {\n+    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> allVertexHexes) {\n \n         Set<Item> items = group.getItems();\n         Set<Hex> inArea = new HashSet<>();\n \n         //surround each item\n         items.forEach(item -> {\n-            Hex hex = vertexHexes.get(item);\n+            Hex hex = allVertexHexes.get(item);\n             inArea.add(hex);\n             hex.neighbours().forEach(neigh -> {\n                 if (!occupied.contains(neigh))\n                     inArea.add(neigh);\n             });\n \n-            //add all \"inner\" relations (paths)\n-            pathsWithinGroup.forEach(rel -> inArea.addAll(rel.getHexes()));\n+            Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n+            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1NTM0OQ==", "bodyText": "I'll improve the comment", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495555349", "createdAt": "2020-09-27T10:05:56Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "diffHunk": "@@ -18,47 +19,86 @@\n \n     /**\n      * Builds an areas of hex tiles belonging to a group.\n-     *\n+     * <p>\n      * It works as follows: first we circumnavigate all hexes of items and add their neighbours immediately. Then we\n      * iterate over all one-hex gaps and add them. This iteration is repeated, so that effectively a few two-hex gaps are\n      * filled.\n-     *\n+     * <p>\n      * There is clearly much room for improvement here. It's only that I haven't found a better approach so far.\n      *\n-     * @param occupied      tiles occupied by items\n-     * @param group         the group\n-     * @param vertexHexes   a mapping from item to its hex\n-     * @param pathsWithinGroup existing paths\n+     * @param occupied       tiles occupied by items\n+     * @param group          the group\n+     * @param allVertexHexes a mapping from item to its hex (all, unfiltered)\n      * @return all hexes the group consists of (an area)\n      */\n-    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> vertexHexes, List<HexPath> pathsWithinGroup) {\n+    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> allVertexHexes) {\n \n         Set<Item> items = group.getItems();\n         Set<Hex> inArea = new HashSet<>();\n \n         //surround each item\n         items.forEach(item -> {\n-            Hex hex = vertexHexes.get(item);\n+            Hex hex = allVertexHexes.get(item);\n             inArea.add(hex);\n             hex.neighbours().forEach(neigh -> {\n                 if (!occupied.contains(neigh))\n                     inArea.add(neigh);\n             });\n \n-            //add all \"inner\" relations (paths)\n-            pathsWithinGroup.forEach(rel -> inArea.addAll(rel.getHexes()));\n+            Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n+            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzA2MA=="}, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTkyNjgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwOTo0MzoyMVrOHYmKSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMDoxNTozNVrOHYmWhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzA5OQ==", "bodyText": "Can this be reflected by tests?", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495553099", "createdAt": "2020-09-27T09:43:21Z", "author": {"login": "mfbieber"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "diffHunk": "@@ -18,47 +19,86 @@\n \n     /**\n      * Builds an areas of hex tiles belonging to a group.\n-     *\n+     * <p>\n      * It works as follows: first we circumnavigate all hexes of items and add their neighbours immediately. Then we\n      * iterate over all one-hex gaps and add them. This iteration is repeated, so that effectively a few two-hex gaps are\n      * filled.\n-     *\n+     * <p>\n      * There is clearly much room for improvement here. It's only that I haven't found a better approach so far.\n      *\n-     * @param occupied      tiles occupied by items\n-     * @param group         the group\n-     * @param vertexHexes   a mapping from item to its hex\n-     * @param pathsWithinGroup existing paths\n+     * @param occupied       tiles occupied by items\n+     * @param group          the group\n+     * @param allVertexHexes a mapping from item to its hex (all, unfiltered)\n      * @return all hexes the group consists of (an area)\n      */\n-    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> vertexHexes, List<HexPath> pathsWithinGroup) {\n+    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> allVertexHexes) {\n \n         Set<Item> items = group.getItems();\n         Set<Hex> inArea = new HashSet<>();\n \n         //surround each item\n         items.forEach(item -> {\n-            Hex hex = vertexHexes.get(item);\n+            Hex hex = allVertexHexes.get(item);\n             inArea.add(hex);\n             hex.neighbours().forEach(neigh -> {\n                 if (!occupied.contains(neigh))\n                     inArea.add(neigh);\n             });\n \n-            //add all \"inner\" relations (paths)\n-            pathsWithinGroup.forEach(rel -> inArea.addAll(rel.getHexes()));\n+            Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n+            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here\n+            closestNeighbours.forEach(neighbour -> {\n+                HexPath path = pathFinder.getPath(hex, neighbour);\n+                Set<Hex> padded = new HashSet<>(); //pad to avoid thin bridges, also workaround for svh outline issue", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1NjIzMQ==", "bodyText": "I've added a test.", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495556231", "createdAt": "2020-09-27T10:15:35Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "diffHunk": "@@ -18,47 +19,86 @@\n \n     /**\n      * Builds an areas of hex tiles belonging to a group.\n-     *\n+     * <p>\n      * It works as follows: first we circumnavigate all hexes of items and add their neighbours immediately. Then we\n      * iterate over all one-hex gaps and add them. This iteration is repeated, so that effectively a few two-hex gaps are\n      * filled.\n-     *\n+     * <p>\n      * There is clearly much room for improvement here. It's only that I haven't found a better approach so far.\n      *\n-     * @param occupied      tiles occupied by items\n-     * @param group         the group\n-     * @param vertexHexes   a mapping from item to its hex\n-     * @param pathsWithinGroup existing paths\n+     * @param occupied       tiles occupied by items\n+     * @param group          the group\n+     * @param allVertexHexes a mapping from item to its hex (all, unfiltered)\n      * @return all hexes the group consists of (an area)\n      */\n-    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> vertexHexes, List<HexPath> pathsWithinGroup) {\n+    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> allVertexHexes) {\n \n         Set<Item> items = group.getItems();\n         Set<Hex> inArea = new HashSet<>();\n \n         //surround each item\n         items.forEach(item -> {\n-            Hex hex = vertexHexes.get(item);\n+            Hex hex = allVertexHexes.get(item);\n             inArea.add(hex);\n             hex.neighbours().forEach(neigh -> {\n                 if (!occupied.contains(neigh))\n                     inArea.add(neigh);\n             });\n \n-            //add all \"inner\" relations (paths)\n-            pathsWithinGroup.forEach(rel -> inArea.addAll(rel.getHexes()));\n+            Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n+            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here\n+            closestNeighbours.forEach(neighbour -> {\n+                HexPath path = pathFinder.getPath(hex, neighbour);\n+                Set<Hex> padded = new HashSet<>(); //pad to avoid thin bridges, also workaround for svh outline issue", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzA5OQ=="}, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTkyNzUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwOTo0NDozNVrOHYmKqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMDoxNTowOVrOHYmWSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzE5Mw==", "bodyText": "Is this logic tested by our tests?", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495553193", "createdAt": "2020-09-27T09:44:35Z", "author": {"login": "mfbieber"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "diffHunk": "@@ -18,47 +19,86 @@\n \n     /**\n      * Builds an areas of hex tiles belonging to a group.\n-     *\n+     * <p>\n      * It works as follows: first we circumnavigate all hexes of items and add their neighbours immediately. Then we\n      * iterate over all one-hex gaps and add them. This iteration is repeated, so that effectively a few two-hex gaps are\n      * filled.\n-     *\n+     * <p>\n      * There is clearly much room for improvement here. It's only that I haven't found a better approach so far.\n      *\n-     * @param occupied      tiles occupied by items\n-     * @param group         the group\n-     * @param vertexHexes   a mapping from item to its hex\n-     * @param pathsWithinGroup existing paths\n+     * @param occupied       tiles occupied by items\n+     * @param group          the group\n+     * @param allVertexHexes a mapping from item to its hex (all, unfiltered)\n      * @return all hexes the group consists of (an area)\n      */\n-    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> vertexHexes, List<HexPath> pathsWithinGroup) {\n+    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> allVertexHexes) {\n \n         Set<Item> items = group.getItems();\n         Set<Hex> inArea = new HashSet<>();\n \n         //surround each item\n         items.forEach(item -> {\n-            Hex hex = vertexHexes.get(item);\n+            Hex hex = allVertexHexes.get(item);\n             inArea.add(hex);\n             hex.neighbours().forEach(neigh -> {\n                 if (!occupied.contains(neigh))\n                     inArea.add(neigh);\n             });\n \n-            //add all \"inner\" relations (paths)\n-            pathsWithinGroup.forEach(rel -> inArea.addAll(rel.getHexes()));\n+            Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n+            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here\n+            closestNeighbours.forEach(neighbour -> {\n+                HexPath path = pathFinder.getPath(hex, neighbour);\n+                Set<Hex> padded = new HashSet<>(); //pad to avoid thin bridges, also workaround for svh outline issue\n+                path.getHexes().forEach(pathTile -> {\n+                    padded.add(pathTile);\n+                    padded.addAll(pathTile.neighbours());\n+                });\n+                padded.stream().filter(hex1 -> !occupied.contains(hex1)).forEach(inArea::add);\n+            });\n+\n         });\n \n         Set<Hex> bridges = getBridges(inArea);\n         inArea.addAll(bridges);\n \n-        //2nd pass fills gaps\n-        bridges = getBridges(inArea);\n-        inArea.addAll(bridges);\n-\n         return inArea;\n     }\n \n+    /**\n+     * Returns all neighbours in group which are the have same (minimum) distance.\n+     *\n+     * @param item           the current group item\n+     * @param items          all group items\n+     * @param allVertexHexes item hex mapping\n+     * @return the closest neighbours\n+     */\n+    private static Set<Hex> getClosestItemsHexes(Item item, Set<Item> items, Map<LandscapeItem, Hex> allVertexHexes) {\n+        Hex start = allVertexHexes.get(item);\n+        AtomicInteger minDist = new AtomicInteger(Integer.MAX_VALUE);\n+        final Set<Hex> min = new HashSet<>();\n+        items.stream()\n+                .filter(otherGroupItem -> !item.equals(otherGroupItem))\n+                .forEach(otherGroupItem -> {\n+                    Hex dest = allVertexHexes.get(otherGroupItem);\n+                    int distance = start.distance(dest);\n+                    if (distance > minDist.get()) {\n+                        return;\n+                    }\n+                    if (distance == minDist.get()) {\n+                        min.add(dest);\n+                        return;\n+                    }\n+                    if (distance < minDist.get()) {\n+                        minDist.set(distance);\n+                        min.clear();\n+                        min.add(dest);\n+                    }\n+                });\n+\n+        return min;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1NjE2OQ==", "bodyText": "I've added a test.", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495556169", "createdAt": "2020-09-27T10:15:09Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/GroupAreaFactory.java", "diffHunk": "@@ -18,47 +19,86 @@\n \n     /**\n      * Builds an areas of hex tiles belonging to a group.\n-     *\n+     * <p>\n      * It works as follows: first we circumnavigate all hexes of items and add their neighbours immediately. Then we\n      * iterate over all one-hex gaps and add them. This iteration is repeated, so that effectively a few two-hex gaps are\n      * filled.\n-     *\n+     * <p>\n      * There is clearly much room for improvement here. It's only that I haven't found a better approach so far.\n      *\n-     * @param occupied      tiles occupied by items\n-     * @param group         the group\n-     * @param vertexHexes   a mapping from item to its hex\n-     * @param pathsWithinGroup existing paths\n+     * @param occupied       tiles occupied by items\n+     * @param group          the group\n+     * @param allVertexHexes a mapping from item to its hex (all, unfiltered)\n      * @return all hexes the group consists of (an area)\n      */\n-    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> vertexHexes, List<HexPath> pathsWithinGroup) {\n+    public static Set<Hex> getGroup(Set<Hex> occupied, Group group, Map<LandscapeItem, Hex> allVertexHexes) {\n \n         Set<Item> items = group.getItems();\n         Set<Hex> inArea = new HashSet<>();\n \n         //surround each item\n         items.forEach(item -> {\n-            Hex hex = vertexHexes.get(item);\n+            Hex hex = allVertexHexes.get(item);\n             inArea.add(hex);\n             hex.neighbours().forEach(neigh -> {\n                 if (!occupied.contains(neigh))\n                     inArea.add(neigh);\n             });\n \n-            //add all \"inner\" relations (paths)\n-            pathsWithinGroup.forEach(rel -> inArea.addAll(rel.getHexes()));\n+            Set<Hex> closestNeighbours = getClosestItemsHexes(item, items, allVertexHexes);\n+            PathFinder pathFinder = new PathFinder(Set.of()); //we dont care for occupied tiles here\n+            closestNeighbours.forEach(neighbour -> {\n+                HexPath path = pathFinder.getPath(hex, neighbour);\n+                Set<Hex> padded = new HashSet<>(); //pad to avoid thin bridges, also workaround for svh outline issue\n+                path.getHexes().forEach(pathTile -> {\n+                    padded.add(pathTile);\n+                    padded.addAll(pathTile.neighbours());\n+                });\n+                padded.stream().filter(hex1 -> !occupied.contains(hex1)).forEach(inArea::add);\n+            });\n+\n         });\n \n         Set<Hex> bridges = getBridges(inArea);\n         inArea.addAll(bridges);\n \n-        //2nd pass fills gaps\n-        bridges = getBridges(inArea);\n-        inArea.addAll(bridges);\n-\n         return inArea;\n     }\n \n+    /**\n+     * Returns all neighbours in group which are the have same (minimum) distance.\n+     *\n+     * @param item           the current group item\n+     * @param items          all group items\n+     * @param allVertexHexes item hex mapping\n+     * @return the closest neighbours\n+     */\n+    private static Set<Hex> getClosestItemsHexes(Item item, Set<Item> items, Map<LandscapeItem, Hex> allVertexHexes) {\n+        Hex start = allVertexHexes.get(item);\n+        AtomicInteger minDist = new AtomicInteger(Integer.MAX_VALUE);\n+        final Set<Hex> min = new HashSet<>();\n+        items.stream()\n+                .filter(otherGroupItem -> !item.equals(otherGroupItem))\n+                .forEach(otherGroupItem -> {\n+                    Hex dest = allVertexHexes.get(otherGroupItem);\n+                    int distance = start.distance(dest);\n+                    if (distance > minDist.get()) {\n+                        return;\n+                    }\n+                    if (distance == minDist.get()) {\n+                        min.add(dest);\n+                        return;\n+                    }\n+                    if (distance < minDist.get()) {\n+                        minDist.set(distance);\n+                        min.clear();\n+                        min.add(dest);\n+                    }\n+                });\n+\n+        return min;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzE5Mw=="}, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTkyOTM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwOTo0NjoyMlrOHYmLfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMjoyMTo1MFrOHYnCMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw==", "bodyText": "Where does this magic formula come from? :)", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495553407", "createdAt": "2020-09-27T09:46:22Z", "author": {"login": "mfbieber"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "diffHunk": "@@ -65,6 +68,10 @@ public Hex(int q, int r, int s) {\n         this.s = s;\n     }\n \n+    public Hex(int q, int r) {\n+        this(q, r, (r + q) * -1);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1NTgyOA==", "bodyText": "https://www.redblobgames.com/grids/hexagons/implementation.html\nTLDR: q and r and like x and y and sufficient to describe a hex position. s is a third axis orthogonal to q and r.", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495555828", "createdAt": "2020-09-27T10:11:16Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "diffHunk": "@@ -65,6 +68,10 @@ public Hex(int q, int r, int s) {\n         this.s = s;\n     }\n \n+    public Hex(int q, int r) {\n+        this(q, r, (r + q) * -1);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw=="}, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1ODk4Ng==", "bodyText": "I am trying to really understand this. So I understood that it comes from cube algorithms, and thus s would equal z in a cartesian coordinate system.\nThe comment helps to understand that the formula has something to do with a coordinate system, but it does not explain why z = (x + y) * (-1)\nIn general all these Hex and Layout classes are really hard to understand, without understanding the math and logic behind it.\nInitially we used the linked implementation as a library but then started to implement own logic on top of it, right?\nHaving own complex code, without (me) really understanding what it does makes it hard to review and grow it. Isn't there a possibility to use the library as it was and decorate (or maybe another pattern is better suited) with our own logic? That own logic can be well tested and understandable :)", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495558986", "createdAt": "2020-09-27T10:44:51Z", "author": {"login": "mfbieber"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "diffHunk": "@@ -65,6 +68,10 @@ public Hex(int q, int r, int s) {\n         this.s = s;\n     }\n \n+    public Hex(int q, int r) {\n+        this(q, r, (r + q) * -1);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw=="}, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NTE3MQ==", "bodyText": "No, the hex stuff has never been in a library. That was the layouting (force based positioning stuff). Some time ago I investigated some Java hex libraries, but decided against them. If we find a suitable one, we can consider replacing some of our code.", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495565171", "createdAt": "2020-09-27T11:54:55Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "diffHunk": "@@ -65,6 +68,10 @@ public Hex(int q, int r, int s) {\n         this.s = s;\n     }\n \n+    public Hex(int q, int r) {\n+        this(q, r, (r + q) * -1);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw=="}, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NzQwOQ==", "bodyText": "Btw, I understood the \"s\" coordinate as an alternative coordinate, and not as \"z\". Think of a square with the two sides running parallel to x and y axes in a cartesian system: the sides can be described by offsetting the axes. A hex system has three axes, but you only need to know the offsets of two axes to construct a hex at a position.", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495567409", "createdAt": "2020-09-27T12:21:50Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "diffHunk": "@@ -65,6 +68,10 @@ public Hex(int q, int r, int s) {\n         this.s = s;\n     }\n \n+    public Hex(int q, int r) {\n+        this(q, r, (r + q) * -1);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1MzQwNw=="}, "originalCommit": {"oid": "a6ea7a4cb83b87363dc5e9b8c473f3cfa890cfbb"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTk3NTgxOnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMDo0NToxNVrOHYmhfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMTo1ODozMVrOHYm6iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTAzOQ==", "bodyText": "Why is the distance the sum of all coordinates divided by 2?", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495559039", "createdAt": "2020-09-27T10:45:15Z", "author": {"login": "mfbieber"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "diffHunk": "@@ -103,11 +120,19 @@ public static Hex of(long x, long y, float scaling) {\n         return new Hex(qi, ri, si);\n     }\n \n-\n+    /**\n+     * Returns the distance to the target hex in number of tiles.\n+     *\n+     * @param target target hex\n+     * @return number of tiles\n+     */\n     public int distance(Hex target) {\n-        return lengths(this.subtract(target));\n+        Hex hex = this.subtract(target);\n+        double l = (Math.abs(hex.q) + Math.abs(hex.r) + Math.abs(hex.s)) / 2.0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NTQ0OQ==", "bodyText": "https://www.redblobgames.com/grids/hexagons/#distances I will add this link as comment, too.", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495565449", "createdAt": "2020-09-27T11:58:31Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/Hex.java", "diffHunk": "@@ -103,11 +120,19 @@ public static Hex of(long x, long y, float scaling) {\n         return new Hex(qi, ri, si);\n     }\n \n-\n+    /**\n+     * Returns the distance to the target hex in number of tiles.\n+     *\n+     * @param target target hex\n+     * @return number of tiles\n+     */\n     public int distance(Hex target) {\n-        return lengths(this.subtract(target));\n+        Hex hex = this.subtract(target);\n+        double l = (Math.abs(hex.q) + Math.abs(hex.r) + Math.abs(hex.s)) / 2.0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTAzOQ=="}, "originalCommit": {"oid": "2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTk3Njg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/de/bonndan/nivio/output/map/hex/HexMap.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMDo0NjoyNFrOHYmh9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMjoyNTo1NlrOHYnDug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTE1OQ==", "bodyText": "Why doesn't the Pathfinder return an Optional itself?", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495559159", "createdAt": "2020-09-27T10:46:24Z", "author": {"login": "mfbieber"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/HexMap.java", "diffHunk": "@@ -63,16 +63,7 @@ public Hex hexForItem(Item item) {\n      * @return a path if one could be found\n      */\n     public Optional<HexPath> getPath(Item start, Item target) {\n-        Optional<HexPath> optional = Optional.ofNullable(pathFinder.getPath(hexForItem(start), hexForItem(target)));\n-\n-        optional.ifPresent(hexPath -> {\n-            if (start.getGroup() != null && start.getGroup().equals(target.getGroup())) {\n-                hexPath.setGroup(start.getGroup());\n-            }\n-            paths.add(hexPath);\n-        });\n-\n-        return optional;\n+        return Optional.ofNullable(pathFinder.getPath(hexForItem(start), hexForItem(target)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NDc0NQ==", "bodyText": "Because nobody refactored it yet \ud83d\ude04", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495564745", "createdAt": "2020-09-27T11:49:45Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/HexMap.java", "diffHunk": "@@ -63,16 +63,7 @@ public Hex hexForItem(Item item) {\n      * @return a path if one could be found\n      */\n     public Optional<HexPath> getPath(Item start, Item target) {\n-        Optional<HexPath> optional = Optional.ofNullable(pathFinder.getPath(hexForItem(start), hexForItem(target)));\n-\n-        optional.ifPresent(hexPath -> {\n-            if (start.getGroup() != null && start.getGroup().equals(target.getGroup())) {\n-                hexPath.setGroup(start.getGroup());\n-            }\n-            paths.add(hexPath);\n-        });\n-\n-        return optional;\n+        return Optional.ofNullable(pathFinder.getPath(hexForItem(start), hexForItem(target)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTE1OQ=="}, "originalCommit": {"oid": "2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2NzgwMg==", "bodyText": "I have refactored it to use Optional.", "url": "https://github.com/dedica-team/nivio/pull/311#discussion_r495567802", "createdAt": "2020-09-27T12:25:56Z", "author": {"login": "bonndan"}, "path": "src/main/java/de/bonndan/nivio/output/map/hex/HexMap.java", "diffHunk": "@@ -63,16 +63,7 @@ public Hex hexForItem(Item item) {\n      * @return a path if one could be found\n      */\n     public Optional<HexPath> getPath(Item start, Item target) {\n-        Optional<HexPath> optional = Optional.ofNullable(pathFinder.getPath(hexForItem(start), hexForItem(target)));\n-\n-        optional.ifPresent(hexPath -> {\n-            if (start.getGroup() != null && start.getGroup().equals(target.getGroup())) {\n-                hexPath.setGroup(start.getGroup());\n-            }\n-            paths.add(hexPath);\n-        });\n-\n-        return optional;\n+        return Optional.ofNullable(pathFinder.getPath(hexForItem(start), hexForItem(target)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU1OTE1OQ=="}, "originalCommit": {"oid": "2fe3ab7c3869d5e6fa05f81d6e73d71abcbefcd5"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4038, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}