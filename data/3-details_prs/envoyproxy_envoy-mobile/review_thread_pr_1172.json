{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NTIxMTkz", "number": 1172, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTozMTowOVrOE-2YDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOTo0OTowOVrOFCkK1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MzM4MDYwOnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/local_error/filter.proto", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTozMTowOVrOH8Oo-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoxMjo1NlrOIGTe9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxNjQ3Mw==", "bodyText": "usually done via a runtime field", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r532916473", "createdAt": "2020-11-30T21:31:09Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/local_error/filter.proto", "diffHunk": "@@ -0,0 +1,7 @@\n+syntax = \"proto3\";\n+\n+package envoymobile.extensions.filters.http.local_error;\n+\n+message LocalError {\n+  bool enabled = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa7b7408a959298f9a7d080400c0d34145388695"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzMzg1Mw==", "bodyText": "It is, but I wanted to have at least one configuration value, so I wasn't sure what would happen with an empty config. There are other examples of filters with an enabled boolean.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r538933853", "createdAt": "2020-12-09T01:25:45Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/local_error/filter.proto", "diffHunk": "@@ -0,0 +1,7 @@\n+syntax = \"proto3\";\n+\n+package envoymobile.extensions.filters.http.local_error;\n+\n+message LocalError {\n+  bool enabled = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxNjQ3Mw=="}, "originalCommit": {"oid": "aa7b7408a959298f9a7d080400c0d34145388695"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MjU3OA==", "bodyText": "Oh if that's the case, then you can just delete. It is fine to have an empty message.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r542892578", "createdAt": "2020-12-14T22:47:13Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/local_error/filter.proto", "diffHunk": "@@ -0,0 +1,7 @@\n+syntax = \"proto3\";\n+\n+package envoymobile.extensions.filters.http.local_error;\n+\n+message LocalError {\n+  bool enabled = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxNjQ3Mw=="}, "originalCommit": {"oid": "aa7b7408a959298f9a7d080400c0d34145388695"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4MTU4OQ==", "bodyText": "Pending this.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r543481589", "createdAt": "2020-12-15T16:12:56Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/local_error/filter.proto", "diffHunk": "@@ -0,0 +1,7 @@\n+syntax = \"proto3\";\n+\n+package envoymobile.extensions.filters.http.local_error;\n+\n+message LocalError {\n+  bool enabled = 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxNjQ3Mw=="}, "originalCommit": {"oid": "aa7b7408a959298f9a7d080400c0d34145388695"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MjMwODk0OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/local_error/filter.cc", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOTo0MTozM1rOIBy9og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMzoxNToxOVrOIF265w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDQ2Ng==", "bodyText": "I know this won't surface to the application because we end up mapping to an on error response. But I wonder if we should use a non 2xx code here?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r538754466", "createdAt": "2020-12-08T19:41:33Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/local_error/filter.cc", "diffHunk": "@@ -0,0 +1,88 @@\n+#include \"library/common/extensions/filters/http/local_error/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+#include \"common/http/codes.h\"\n+#include \"common/http/header_map_impl.h\"\n+#include \"common/http/utility.h\"\n+\n+#include \"library/common/http/headers.h\"\n+#include \"library/common/types/c_types.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace LocalError {\n+\n+LocalErrorFilterConfig::LocalErrorFilterConfig(\n+    const envoymobile::extensions::filters::http::local_error::LocalError& proto_config)\n+    : enabled_(proto_config.enabled()) {}\n+\n+LocalErrorFilter::LocalErrorFilter(LocalErrorFilterConfigSharedPtr config) : config_(config) {}\n+\n+Http::FilterHeadersStatus LocalErrorFilter::encodeHeaders(Http::ResponseHeaderMap& headers,\n+                                                          bool end_stream) {\n+  uint64_t response_status = Http::Utility::getResponseStatus(headers);\n+  bool success = Http::CodeUtility::is2xx(response_status);\n+\n+  // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n+  // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n+  // make this possible, but nothing expedient. For the immediate term this is our only real\n+  // option. See https://github.com/lyft/envoy-mobile/issues/460\n+\n+  // Absence of EnvoyUpstreamServiceTime header implies this is a local reply, which we treat as\n+  // a stream error.\n+  if (!success && headers.get(Http::Headers::get().EnvoyUpstreamServiceTime).empty()) {\n+    ENVOY_LOG(debug, \"intercepted local response\");\n+    processingError_ = true;\n+    headers_ = &headers;\n+    mapLocalResponseToError(headers);\n+    return end_stream ? Http::FilterHeadersStatus::Continue\n+                      : Http::FilterHeadersStatus::StopIteration;\n+  }\n+\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus LocalErrorFilter::encodeData(Buffer::Instance& data, bool end_stream) {\n+  if (processingError_) {\n+    // We assume the first (and assumed only) data chunk will be a contextual error message.\n+    ASSERT(end_stream,\n+           \"Local responses must end the stream with a single data frame. If Envoy changes \"\n+           \"this expectation, this code needs to be updated.\");\n+    headers_->addCopy(Http::InternalHeaders::get().ErrorMessage, data.toString());\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void LocalErrorFilter::mapLocalResponseToError(Http::ResponseHeaderMap& headers) {\n+  // Envoy Mobile surfaces non-200 local responses as errors via callbacks rather than an HTTP\n+  // response. Here that response's \"real\" status code is mapped to an Envoy Mobile error code\n+  // which is passed through the response chain as a header. The status code is updated with\n+  // the sentinel value, 218 (\"This is fine\").\n+  switch (Http::Utility::getResponseStatus(headers)) {\n+  case 408:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode, std::to_string(ENVOY_REQUEST_TIMEOUT));\n+    break;\n+  case 413:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode,\n+                    std::to_string(ENVOY_BUFFER_LIMIT_EXCEEDED));\n+    break;\n+  case 503:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode,\n+                    std::to_string(ENVOY_CONNECTION_FAILURE));\n+    break;\n+  default:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode, std::to_string(ENVOY_UNDEFINED_ERROR));\n+  }\n+\n+  headers.setStatus(218);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzNTQxNg==", "bodyText": "I went with it because its unique, and currently used by Apache for a similar purpose. I wanted to reduce the odds of it triggering any status code based behavior in other filters. (Long-term I'd prefer not to use a mechanism like this at all, but rather implement a real onError pathway in Envoy's filter chain.)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r538935416", "createdAt": "2020-12-09T01:29:49Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/local_error/filter.cc", "diffHunk": "@@ -0,0 +1,88 @@\n+#include \"library/common/extensions/filters/http/local_error/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+#include \"common/http/codes.h\"\n+#include \"common/http/header_map_impl.h\"\n+#include \"common/http/utility.h\"\n+\n+#include \"library/common/http/headers.h\"\n+#include \"library/common/types/c_types.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace LocalError {\n+\n+LocalErrorFilterConfig::LocalErrorFilterConfig(\n+    const envoymobile::extensions::filters::http::local_error::LocalError& proto_config)\n+    : enabled_(proto_config.enabled()) {}\n+\n+LocalErrorFilter::LocalErrorFilter(LocalErrorFilterConfigSharedPtr config) : config_(config) {}\n+\n+Http::FilterHeadersStatus LocalErrorFilter::encodeHeaders(Http::ResponseHeaderMap& headers,\n+                                                          bool end_stream) {\n+  uint64_t response_status = Http::Utility::getResponseStatus(headers);\n+  bool success = Http::CodeUtility::is2xx(response_status);\n+\n+  // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n+  // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n+  // make this possible, but nothing expedient. For the immediate term this is our only real\n+  // option. See https://github.com/lyft/envoy-mobile/issues/460\n+\n+  // Absence of EnvoyUpstreamServiceTime header implies this is a local reply, which we treat as\n+  // a stream error.\n+  if (!success && headers.get(Http::Headers::get().EnvoyUpstreamServiceTime).empty()) {\n+    ENVOY_LOG(debug, \"intercepted local response\");\n+    processingError_ = true;\n+    headers_ = &headers;\n+    mapLocalResponseToError(headers);\n+    return end_stream ? Http::FilterHeadersStatus::Continue\n+                      : Http::FilterHeadersStatus::StopIteration;\n+  }\n+\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus LocalErrorFilter::encodeData(Buffer::Instance& data, bool end_stream) {\n+  if (processingError_) {\n+    // We assume the first (and assumed only) data chunk will be a contextual error message.\n+    ASSERT(end_stream,\n+           \"Local responses must end the stream with a single data frame. If Envoy changes \"\n+           \"this expectation, this code needs to be updated.\");\n+    headers_->addCopy(Http::InternalHeaders::get().ErrorMessage, data.toString());\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void LocalErrorFilter::mapLocalResponseToError(Http::ResponseHeaderMap& headers) {\n+  // Envoy Mobile surfaces non-200 local responses as errors via callbacks rather than an HTTP\n+  // response. Here that response's \"real\" status code is mapped to an Envoy Mobile error code\n+  // which is passed through the response chain as a header. The status code is updated with\n+  // the sentinel value, 218 (\"This is fine\").\n+  switch (Http::Utility::getResponseStatus(headers)) {\n+  case 408:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode, std::to_string(ENVOY_REQUEST_TIMEOUT));\n+    break;\n+  case 413:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode,\n+                    std::to_string(ENVOY_BUFFER_LIMIT_EXCEEDED));\n+    break;\n+  case 503:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode,\n+                    std::to_string(ENVOY_CONNECTION_FAILURE));\n+    break;\n+  default:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode, std::to_string(ENVOY_UNDEFINED_ERROR));\n+  }\n+\n+  headers.setStatus(218);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDQ2Ng=="}, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MzU0NQ==", "bodyText": "Sure. Do we have an open issue to get together thoughts on an error pathway in the HCM? I think it is worth opening at this point.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r542893545", "createdAt": "2020-12-14T22:48:07Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/local_error/filter.cc", "diffHunk": "@@ -0,0 +1,88 @@\n+#include \"library/common/extensions/filters/http/local_error/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+#include \"common/http/codes.h\"\n+#include \"common/http/header_map_impl.h\"\n+#include \"common/http/utility.h\"\n+\n+#include \"library/common/http/headers.h\"\n+#include \"library/common/types/c_types.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace LocalError {\n+\n+LocalErrorFilterConfig::LocalErrorFilterConfig(\n+    const envoymobile::extensions::filters::http::local_error::LocalError& proto_config)\n+    : enabled_(proto_config.enabled()) {}\n+\n+LocalErrorFilter::LocalErrorFilter(LocalErrorFilterConfigSharedPtr config) : config_(config) {}\n+\n+Http::FilterHeadersStatus LocalErrorFilter::encodeHeaders(Http::ResponseHeaderMap& headers,\n+                                                          bool end_stream) {\n+  uint64_t response_status = Http::Utility::getResponseStatus(headers);\n+  bool success = Http::CodeUtility::is2xx(response_status);\n+\n+  // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n+  // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n+  // make this possible, but nothing expedient. For the immediate term this is our only real\n+  // option. See https://github.com/lyft/envoy-mobile/issues/460\n+\n+  // Absence of EnvoyUpstreamServiceTime header implies this is a local reply, which we treat as\n+  // a stream error.\n+  if (!success && headers.get(Http::Headers::get().EnvoyUpstreamServiceTime).empty()) {\n+    ENVOY_LOG(debug, \"intercepted local response\");\n+    processingError_ = true;\n+    headers_ = &headers;\n+    mapLocalResponseToError(headers);\n+    return end_stream ? Http::FilterHeadersStatus::Continue\n+                      : Http::FilterHeadersStatus::StopIteration;\n+  }\n+\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus LocalErrorFilter::encodeData(Buffer::Instance& data, bool end_stream) {\n+  if (processingError_) {\n+    // We assume the first (and assumed only) data chunk will be a contextual error message.\n+    ASSERT(end_stream,\n+           \"Local responses must end the stream with a single data frame. If Envoy changes \"\n+           \"this expectation, this code needs to be updated.\");\n+    headers_->addCopy(Http::InternalHeaders::get().ErrorMessage, data.toString());\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void LocalErrorFilter::mapLocalResponseToError(Http::ResponseHeaderMap& headers) {\n+  // Envoy Mobile surfaces non-200 local responses as errors via callbacks rather than an HTTP\n+  // response. Here that response's \"real\" status code is mapped to an Envoy Mobile error code\n+  // which is passed through the response chain as a header. The status code is updated with\n+  // the sentinel value, 218 (\"This is fine\").\n+  switch (Http::Utility::getResponseStatus(headers)) {\n+  case 408:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode, std::to_string(ENVOY_REQUEST_TIMEOUT));\n+    break;\n+  case 413:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode,\n+                    std::to_string(ENVOY_BUFFER_LIMIT_EXCEEDED));\n+    break;\n+  case 503:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode,\n+                    std::to_string(ENVOY_CONNECTION_FAILURE));\n+    break;\n+  default:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode, std::to_string(ENVOY_UNDEFINED_ERROR));\n+  }\n+\n+  headers.setStatus(218);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDQ2Ng=="}, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxMzYwNw==", "bodyText": "#1208", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r543013607", "createdAt": "2020-12-15T03:15:19Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/local_error/filter.cc", "diffHunk": "@@ -0,0 +1,88 @@\n+#include \"library/common/extensions/filters/http/local_error/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+#include \"common/http/codes.h\"\n+#include \"common/http/header_map_impl.h\"\n+#include \"common/http/utility.h\"\n+\n+#include \"library/common/http/headers.h\"\n+#include \"library/common/types/c_types.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace LocalError {\n+\n+LocalErrorFilterConfig::LocalErrorFilterConfig(\n+    const envoymobile::extensions::filters::http::local_error::LocalError& proto_config)\n+    : enabled_(proto_config.enabled()) {}\n+\n+LocalErrorFilter::LocalErrorFilter(LocalErrorFilterConfigSharedPtr config) : config_(config) {}\n+\n+Http::FilterHeadersStatus LocalErrorFilter::encodeHeaders(Http::ResponseHeaderMap& headers,\n+                                                          bool end_stream) {\n+  uint64_t response_status = Http::Utility::getResponseStatus(headers);\n+  bool success = Http::CodeUtility::is2xx(response_status);\n+\n+  // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n+  // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n+  // make this possible, but nothing expedient. For the immediate term this is our only real\n+  // option. See https://github.com/lyft/envoy-mobile/issues/460\n+\n+  // Absence of EnvoyUpstreamServiceTime header implies this is a local reply, which we treat as\n+  // a stream error.\n+  if (!success && headers.get(Http::Headers::get().EnvoyUpstreamServiceTime).empty()) {\n+    ENVOY_LOG(debug, \"intercepted local response\");\n+    processingError_ = true;\n+    headers_ = &headers;\n+    mapLocalResponseToError(headers);\n+    return end_stream ? Http::FilterHeadersStatus::Continue\n+                      : Http::FilterHeadersStatus::StopIteration;\n+  }\n+\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus LocalErrorFilter::encodeData(Buffer::Instance& data, bool end_stream) {\n+  if (processingError_) {\n+    // We assume the first (and assumed only) data chunk will be a contextual error message.\n+    ASSERT(end_stream,\n+           \"Local responses must end the stream with a single data frame. If Envoy changes \"\n+           \"this expectation, this code needs to be updated.\");\n+    headers_->addCopy(Http::InternalHeaders::get().ErrorMessage, data.toString());\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void LocalErrorFilter::mapLocalResponseToError(Http::ResponseHeaderMap& headers) {\n+  // Envoy Mobile surfaces non-200 local responses as errors via callbacks rather than an HTTP\n+  // response. Here that response's \"real\" status code is mapped to an Envoy Mobile error code\n+  // which is passed through the response chain as a header. The status code is updated with\n+  // the sentinel value, 218 (\"This is fine\").\n+  switch (Http::Utility::getResponseStatus(headers)) {\n+  case 408:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode, std::to_string(ENVOY_REQUEST_TIMEOUT));\n+    break;\n+  case 413:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode,\n+                    std::to_string(ENVOY_BUFFER_LIMIT_EXCEEDED));\n+    break;\n+  case 503:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode,\n+                    std::to_string(ENVOY_CONNECTION_FAILURE));\n+    break;\n+  default:\n+    headers.addCopy(Http::InternalHeaders::get().ErrorCode, std::to_string(ENVOY_UNDEFINED_ERROR));\n+  }\n+\n+  headers.setStatus(218);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDQ2Ng=="}, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MjMyNzM1OnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOTo0NTo0NlrOIBzIGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMTozMDoyMlrOIB-BPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzE0NQ==", "bodyText": "related to my comment above re: 218. Should the local error path be counted as success?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r538757145", "createdAt": "2020-12-08T19:45:46Z", "author": {"login": "junr03"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -35,32 +36,41 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n             direct_stream_.stream_handle_, end_stream, headers);\n \n   ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n-\n-  uint64_t response_status = Utility::getResponseStatus(headers);\n-  // Track success for later bookkeeping (stream could still be reset).\n-  success_ = CodeUtility::is2xx(response_status);\n-\n   if (end_stream) {\n     closeStream();\n   }\n \n-  // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n-  // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n-  // make this possible, but nothing expedient. For the immediate term this is our only real\n-  // option. See https://github.com/lyft/envoy-mobile/issues/460\n+  uint64_t response_status = Utility::getResponseStatus(headers);\n+\n+  // Presence of internal error header indicates an error that should be surfaced as an\n+  // error callback (rather than an HTTP response).\n+  const auto error_code_header = headers.get(InternalHeaders::get().ErrorCode);\n+  if (!error_code_header.empty()) {\n+    envoy_error_code_t error_code;\n+    bool check = absl::SimpleAtoi(error_code_header[0]->value().getStringView(), &error_code);\n+    RELEASE_ASSERT(check, \"parse error reading error code\");\n+    error_code_ = error_code;\n+\n+    const auto error_message_header = headers.get(InternalHeaders::get().ErrorMessage);\n+    if (!error_message_header.empty()) {\n+      error_message_ =\n+          Buffer::Utility::copyToBridgeData(error_message_header[0]->value().getStringView());\n+    }\n+\n+    uint32_t attempt_count;\n+    if (headers.EnvoyAttemptCount() &&\n+        absl::SimpleAtoi(headers.EnvoyAttemptCount()->value().getStringView(), &attempt_count)) {\n+      error_attempt_count_ = attempt_count;\n+    }\n \n-  // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as\n-  // a stream error.\n-  if (!success_ && headers.get(Headers::get().EnvoyUpstreamServiceTime).empty()) {\n-    ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n-    mapLocalResponseToError(headers);\n     if (end_stream) {\n       onError();\n     }\n     return;\n   }\n \n-  // Normal response path.\n+  // Track success for later bookkeeping (stream could still be reset).\n+  success_ = CodeUtility::is2xx(response_status);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzNTYxMg==", "bodyText": "It won't be. The function returns a couple lines above.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r538935612", "createdAt": "2020-12-09T01:30:22Z", "author": {"login": "goaway"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -35,32 +36,41 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n             direct_stream_.stream_handle_, end_stream, headers);\n \n   ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n-\n-  uint64_t response_status = Utility::getResponseStatus(headers);\n-  // Track success for later bookkeeping (stream could still be reset).\n-  success_ = CodeUtility::is2xx(response_status);\n-\n   if (end_stream) {\n     closeStream();\n   }\n \n-  // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n-  // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n-  // make this possible, but nothing expedient. For the immediate term this is our only real\n-  // option. See https://github.com/lyft/envoy-mobile/issues/460\n+  uint64_t response_status = Utility::getResponseStatus(headers);\n+\n+  // Presence of internal error header indicates an error that should be surfaced as an\n+  // error callback (rather than an HTTP response).\n+  const auto error_code_header = headers.get(InternalHeaders::get().ErrorCode);\n+  if (!error_code_header.empty()) {\n+    envoy_error_code_t error_code;\n+    bool check = absl::SimpleAtoi(error_code_header[0]->value().getStringView(), &error_code);\n+    RELEASE_ASSERT(check, \"parse error reading error code\");\n+    error_code_ = error_code;\n+\n+    const auto error_message_header = headers.get(InternalHeaders::get().ErrorMessage);\n+    if (!error_message_header.empty()) {\n+      error_message_ =\n+          Buffer::Utility::copyToBridgeData(error_message_header[0]->value().getStringView());\n+    }\n+\n+    uint32_t attempt_count;\n+    if (headers.EnvoyAttemptCount() &&\n+        absl::SimpleAtoi(headers.EnvoyAttemptCount()->value().getStringView(), &attempt_count)) {\n+      error_attempt_count_ = attempt_count;\n+    }\n \n-  // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as\n-  // a stream error.\n-  if (!success_ && headers.get(Headers::get().EnvoyUpstreamServiceTime).empty()) {\n-    ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n-    mapLocalResponseToError(headers);\n     if (end_stream) {\n       onError();\n     }\n     return;\n   }\n \n-  // Normal response path.\n+  // Track success for later bookkeeping (stream could still be reset).\n+  success_ = CodeUtility::is2xx(response_status);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzE0NQ=="}, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MjM0MDcwOnYy", "diffSide": "RIGHT", "path": "test/common/http/dispatcher_test.cc", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOTo0OTowOVrOIBzP5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMzoxNToxOFrOIFw7tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1OTE0MA==", "bodyText": "This is the suite where you are going to add more test? Or are you creating a test suite for the filter? Probably both, right?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r538759140", "createdAt": "2020-12-08T19:49:09Z", "author": {"login": "junr03"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -773,17 +773,29 @@ TEST_F(DispatcherTest, MultipleStreams) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n-TEST_F(DispatcherTest, EnvoyLocalReply) {\n+TEST_F(DispatcherTest, EnvoyLocalReplyNotAnError) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkzNTgzMA==", "bodyText": "Will add both.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r538935830", "createdAt": "2020-12-09T01:30:57Z", "author": {"login": "goaway"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -773,17 +773,29 @@ TEST_F(DispatcherTest, MultipleStreams) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n-TEST_F(DispatcherTest, EnvoyLocalReply) {\n+TEST_F(DispatcherTest, EnvoyLocalReplyNotAnError) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1OTE0MA=="}, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5NDEyNw==", "bodyText": "Per offline discussion it sounds like you will add in subsequent PRs. Do you mind opening issue for that?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r542894127", "createdAt": "2020-12-14T22:48:39Z", "author": {"login": "junr03"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -773,17 +773,29 @@ TEST_F(DispatcherTest, MultipleStreams) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n-TEST_F(DispatcherTest, EnvoyLocalReply) {\n+TEST_F(DispatcherTest, EnvoyLocalReplyNotAnError) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1OTE0MA=="}, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkxNTUxMQ==", "bodyText": "Sure - #1207", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1172#discussion_r542915511", "createdAt": "2020-12-14T23:15:18Z", "author": {"login": "goaway"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -773,17 +773,29 @@ TEST_F(DispatcherTest, MultipleStreams) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n-TEST_F(DispatcherTest, EnvoyLocalReply) {\n+TEST_F(DispatcherTest, EnvoyLocalReplyNotAnError) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1OTE0MA=="}, "originalCommit": {"oid": "140e26ecac62f1d29f64ced2202551bac4208bef"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 503, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}