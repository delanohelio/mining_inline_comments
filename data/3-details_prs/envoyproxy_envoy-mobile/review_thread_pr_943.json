{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MTY3NjI4", "number": 943, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMToyNTo0OFrOEPT5kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMTozNjoyMFrOEQYULw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NDkwMTI5OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMToyNTo0OFrOGy9WHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMTozOTo1OFrOGy9vjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4NzA2OA==", "bodyText": "Are we able to generate a filter name here (for the user) instead of requiring the implementer to handle the name for the registration?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456087068", "createdAt": "2020-07-16T21:25:48Z", "author": {"login": "buildbreaker"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +117,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332\n+  ios_http_filter_context *context = safe_malloc(sizeof(ios_http_filter_context));\n+  CFBridgingRetain(filter);\n+  context->filter = filter;\n+  envoy_http_filter *api = safe_malloc(sizeof(envoy_http_filter));\n+  api->on_request_headers = ios_http_filter_on_request_headers;\n+  api->on_request_data = NULL;\n+  api->on_response_headers = ios_http_filter_on_response_headers;\n+  api->on_response_data = NULL;\n+  api->context = context;\n+  register_platform_api(filter.name.UTF8String, api);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8f24d53814c5a3f9ed2fcc35ab68ed898e32cb8"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA5MzU4MQ==", "bodyText": "Yep, that's covered in the dynamic configuration task in the linked issue. @junr03 suggested, and I agreed that we split that into a separate PR.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456093581", "createdAt": "2020-07-16T21:39:58Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +117,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332\n+  ios_http_filter_context *context = safe_malloc(sizeof(ios_http_filter_context));\n+  CFBridgingRetain(filter);\n+  context->filter = filter;\n+  envoy_http_filter *api = safe_malloc(sizeof(envoy_http_filter));\n+  api->on_request_headers = ios_http_filter_on_request_headers;\n+  api->on_request_data = NULL;\n+  api->on_response_headers = ios_http_filter_on_response_headers;\n+  api->on_response_data = NULL;\n+  api->context = context;\n+  register_platform_api(filter.name.UTF8String, api);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4NzA2OA=="}, "originalCommit": {"oid": "b8f24d53814c5a3f9ed2fcc35ab68ed898e32cb8"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTQ5MDcyOnYy", "diffSide": "RIGHT", "path": "examples/swift/hello_world/ViewController.swift", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMTo1MzoxOVrOGzCq1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjozNjo1N1rOGzDXFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NDI5Mg==", "bodyText": "Can we move this to a different file?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456174292", "createdAt": "2020-07-17T01:53:19Z", "author": {"login": "rebello95"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -6,6 +6,29 @@ private let kRequestAuthority = \"api.lyft.com\"\n private let kRequestPath = \"/ping\"\n private let kRequestScheme = \"https\"\n \n+struct PlatformDemoFilter: ResponseFilter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4NTYyMg==", "bodyText": "Sure, sounds good.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456185622", "createdAt": "2020-07-17T02:36:57Z", "author": {"login": "goaway"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -6,6 +6,29 @@ private let kRequestAuthority = \"api.lyft.com\"\n private let kRequestPath = \"/ping\"\n private let kRequestScheme = \"https\"\n \n+struct PlatformDemoFilter: ResponseFilter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NDI5Mg=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTQ5MTQ5OnYy", "diffSide": "RIGHT", "path": "examples/swift/hello_world/ViewController.swift", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMTo1Mzo0N1rOGzCrQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjo0MToxNFrOGzDbdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NDQwMw==", "bodyText": "Maybe add a TODO here since this'll be removed per https://github.com/lyft/envoy-mobile/pull/943/files#r456093581 I assume?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456174403", "createdAt": "2020-07-17T01:53:47Z", "author": {"login": "rebello95"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -6,6 +6,29 @@ private let kRequestAuthority = \"api.lyft.com\"\n private let kRequestPath = \"/ping\"\n private let kRequestScheme = \"https\"\n \n+struct PlatformDemoFilter: ResponseFilter {\n+  let name = \"PlatformStub\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4Njc0MA==", "bodyText": "Sure thing.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456186740", "createdAt": "2020-07-17T02:41:14Z", "author": {"login": "goaway"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -6,6 +6,29 @@ private let kRequestAuthority = \"api.lyft.com\"\n private let kRequestPath = \"/ping\"\n private let kRequestScheme = \"https\"\n \n+struct PlatformDemoFilter: ResponseFilter {\n+  let name = \"PlatformStub\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NDQwMw=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTQ5NDE2OnYy", "diffSide": "RIGHT", "path": "examples/swift/hello_world/ViewController.swift", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMTo1NToxM1rOGzCszQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNjo0NDo1OVrOGztD7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NDc5Nw==", "bodyText": "Shouldn't this be registering the PlatformDemoFilter type (or a factory that produces a filter) rather than an instance of the filter? I assume that the lifetime of a filter instance will reflect that of 1 request (and that new filters will be instantiated for each request) like upstream Envoy", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456174797", "createdAt": "2020-07-17T01:55:13Z", "author": {"login": "rebello95"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -15,7 +38,7 @@ final class ViewController: UITableViewController {\n     super.viewDidLoad()\n     do {\n       NSLog(\"starting Envoy...\")\n-      self.client = try StreamClientBuilder().build()\n+      self.client = try StreamClientBuilder().addFilter(PlatformDemoFilter()).build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4NjI0NA==", "bodyText": "You're right, the current implementation uses a single long-lived filter instance, which is a departure from upstream Envoy. This approach is definitely simpler to map, but I agree that aligning with upstream Envoy would be nice. Let me think a little bit about what it would take to make filter instances per-stream.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456186244", "createdAt": "2020-07-17T02:39:29Z", "author": {"login": "goaway"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -15,7 +38,7 @@ final class ViewController: UITableViewController {\n     super.viewDidLoad()\n     do {\n       NSLog(\"starting Envoy...\")\n-      self.client = try StreamClientBuilder().build()\n+      self.client = try StreamClientBuilder().addFilter(PlatformDemoFilter()).build()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NDc5Nw=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MjE1Mg==", "bodyText": "\ud83d\udc4d I think this is actually a hard requirement for filters in Envoy Mobile. I know a lot of the use cases Lyft has for platform filters today require filters to be per-stream and to act as both request and response filters", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456572152", "createdAt": "2020-07-17T17:18:25Z", "author": {"login": "rebello95"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -15,7 +38,7 @@ final class ViewController: UITableViewController {\n     super.viewDidLoad()\n     do {\n       NSLog(\"starting Envoy...\")\n-      self.client = try StreamClientBuilder().build()\n+      self.client = try StreamClientBuilder().addFilter(PlatformDemoFilter()).build()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NDc5Nw=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2ODg0Nw==", "bodyText": "Per discussion Friday, we'll do this on top of this PR.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456868847", "createdAt": "2020-07-19T06:44:59Z", "author": {"login": "goaway"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -15,7 +38,7 @@ final class ViewController: UITableViewController {\n     super.viewDidLoad()\n     do {\n       NSLog(\"starting Envoy...\")\n-      self.client = try StreamClientBuilder().build()\n+      self.client = try StreamClientBuilder().addFilter(PlatformDemoFilter()).build()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NDc5Nw=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTQ5ODE3OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMTo1Njo0NFrOGzCu4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNjo1MTozMFrOGztGVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NTMzMA==", "bodyText": "Refactor in what way?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456175330", "createdAt": "2020-07-17T01:56:44Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MTIzNA==", "bodyText": "There's some (egregious) duplication with some of our other mapping code here. It's a little bit tricky to reconcile, because the retain semantics are slightly different. It sure would be nice to though.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456191234", "createdAt": "2020-07-17T02:59:26Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NTMzMA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MjM3NQ==", "bodyText": "Sounds good, maybe make this TODO a bit more descriptive so it doesn't lose context over time", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456572375", "createdAt": "2020-07-17T17:18:51Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NTMzMA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5OTMyMw==", "bodyText": "Isn't it the same as https://github.com/lyft/envoy-mobile/blob/2d86a1c052ec97852ac8161c470649290310fde7/library/objective-c/EnvoyHTTPStreamImpl.m#L21?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456699323", "createdAt": "2020-07-17T22:26:35Z", "author": {"login": "junr03"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NTMzMA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2Nzg5NQ==", "bodyText": "The bridge semantics are a little different; see my comments below. Happy to talk about it more. My inclination is to leave this as a TODO (with extra description per @rebello95's suggestion), and work on a better solution separately. To provide a little bit more context, I'm considering if we need an actual refcount on our structs. It's kind of a bridge I'd like to avoid crossing if possible, but if we're going to avoid it, I do feel it's important to be strict about our release expectations - which we can't yet reconcile here.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456867895", "createdAt": "2020-07-19T06:33:06Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NTMzMA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2OTQ2Mw==", "bodyText": "Updated TODO. Note that some of these TODOs I'd like to address pretty much immediately after core functionality ships. However, as long as they don't affect the public interfaces that Android and iOS applications adhere to, I'm biasing towards getting that functionality shipped so that the apps can be updated independent of under-the-hood improvements. As always, open to discussing.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456869463", "createdAt": "2020-07-19T06:51:30Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NTMzMA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUwMDgwOnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMTo1ODoxNFrOGzCwgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjo0MDo1MVrOGzDbDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NTc0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              for (id headerKey in headers) {\n          \n          \n            \n              for (NSString *headerKey in headers) {", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456175744", "createdAt": "2020-07-17T01:58:14Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4NjYzNg==", "bodyText": "Yep, you're totally right.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456186636", "createdAt": "2020-07-17T02:40:51Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NTc0NA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUwMTYwOnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMTo1ODozOVrOGzCw-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMTo1ODozOVrOGzCw-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NTg2Ng==", "bodyText": "Same here, can we use types instead of using id?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456175866", "createdAt": "2020-07-17T01:58:39Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (id headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (id headerValue in headerList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUwMzQ1OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMTo1OTo0MFrOGzCyAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNjozNzo1MlrOGztBvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NjEzMQ==", "bodyText": "Why not actually assert?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456176131", "createdAt": "2020-07-17T01:59:40Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (id headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (id headerValue in headerList) {\n+      envoy_header new_header = {toManagedNativeString(headerKey),\n+                                 toManagedNativeString(headerValue)};\n+      header_array[header_index++] = new_header;\n+    }\n+  }\n+  // TODO: ASSERT(header_index == length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MDc5Mg==", "bodyText": "We haven't actually (at present) introduced a dependency on Envoy's assertion library at this layer.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456190792", "createdAt": "2020-07-17T02:57:37Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (id headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (id headerValue in headerList) {\n+      envoy_header new_header = {toManagedNativeString(headerKey),\n+                                 toManagedNativeString(headerValue)};\n+      header_array[header_index++] = new_header;\n+    }\n+  }\n+  // TODO: ASSERT(header_index == length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NjEzMQ=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MjY1OQ==", "bodyText": "Got it. If we want, we could use the native assert, but no strong opinion for now I guess", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456572659", "createdAt": "2020-07-17T17:19:24Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (id headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (id headerValue in headerList) {\n+      envoy_header new_header = {toManagedNativeString(headerKey),\n+                                 toManagedNativeString(headerValue)};\n+      header_array[header_index++] = new_header;\n+    }\n+  }\n+  // TODO: ASSERT(header_index == length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NjEzMQ=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4ODc0Nw==", "bodyText": "For sure, we definitely can - we just haven't decided on a convention for this layer yet.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456588747", "createdAt": "2020-07-17T17:51:59Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (id headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (id headerValue in headerList) {\n+      envoy_header new_header = {toManagedNativeString(headerKey),\n+                                 toManagedNativeString(headerValue)};\n+      header_array[header_index++] = new_header;\n+    }\n+  }\n+  // TODO: ASSERT(header_index == length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NjEzMQ=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2ODI4Nw==", "bodyText": "Note a native assert won't get compiled out by Envoy's build directives, so it will always crash the app if we hit it. Not saying it's the right or wrong thing to do, but it's just something to consider.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456868287", "createdAt": "2020-07-19T06:37:52Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (id headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (id headerValue in headerList) {\n+      envoy_header new_header = {toManagedNativeString(headerKey),\n+                                 toManagedNativeString(headerValue)};\n+      header_array[header_index++] = new_header;\n+    }\n+  }\n+  // TODO: ASSERT(header_index == length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NjEzMQ=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUwNDA1OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowMDowMVrOGzCyXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMzowMDo0NFrOGzDuZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NjIyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              envoy_headers ret = {length, header_array};\n          \n          \n            \n              return ret;\n          \n          \n            \n              return envoy_headers{length, header_array};", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456176220", "createdAt": "2020-07-17T02:00:01Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (id headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (id headerValue in headerList) {\n+      envoy_header new_header = {toManagedNativeString(headerKey),\n+                                 toManagedNativeString(headerValue)};\n+      header_array[header_index++] = new_header;\n+    }\n+  }\n+  // TODO: ASSERT(header_index == length);\n+  envoy_headers ret = {length, header_array};\n+  return ret;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MTU4OA==", "bodyText": "Sure, can't remember why I didn't inline this.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456191588", "createdAt": "2020-07-17T03:00:44Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,93 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  envoy_data ret = {length, native_string, free, native_string};\n+  return ret;\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (id headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (id headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (id headerValue in headerList) {\n+      envoy_header new_header = {toManagedNativeString(headerKey),\n+                                 toManagedNativeString(headerValue)};\n+      header_array[header_index++] = new_header;\n+    }\n+  }\n+  // TODO: ASSERT(header_index == length);\n+  envoy_headers ret = {length, header_array};\n+  return ret;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NjIyMA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUwNzc5OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowMTo1NlrOGzC0jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMzowMToyOVrOGzDvGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3Njc4MQ==", "bodyText": "Assuming my comment above about providing an instance of each filter for each request, I think this will become more problematic, no?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456176781", "createdAt": "2020-07-17T02:01:56Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +117,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MTc2OQ==", "bodyText": "Yes. :)\nIt will need to be solved if/when we go that route.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456191769", "createdAt": "2020-07-17T03:01:29Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +117,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3Njc4MQ=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUxMTIzOnYy", "diffSide": "RIGHT", "path": "library/swift/test/StreamClientBuilderTests.swift", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowNDowMlrOGzC2jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMzowMjozMVrOGzDwGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzI5Mg==", "bodyText": "We should add tests for this new functionality", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456177292", "createdAt": "2020-07-17T02:04:02Z", "author": {"login": "rebello95"}, "path": "library/swift/test/StreamClientBuilderTests.swift", "diffHunk": "@@ -172,6 +172,7 @@ final class StreamClientBuilderTests: XCTestCase {\n                                     dnsRefreshSeconds: 300,\n                                     dnsFailureRefreshSecondsBase: 400,\n                                     dnsFailureRefreshSecondsMax: 500,\n+                                    filterChain: [],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MjAyNQ==", "bodyText": "Agreed. To some degree the example app acts as an end-to-end integration test (and I actually plan to update it with n explicit check on the filter's effect). But I can look into what level of testing we can do at the unit layer here as well.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456192025", "createdAt": "2020-07-17T03:02:31Z", "author": {"login": "goaway"}, "path": "library/swift/test/StreamClientBuilderTests.swift", "diffHunk": "@@ -172,6 +172,7 @@ final class StreamClientBuilderTests: XCTestCase {\n                                     dnsRefreshSeconds: 300,\n                                     dnsFailureRefreshSecondsBase: 400,\n                                     dnsFailureRefreshSecondsMax: 500,\n+                                    filterChain: [],", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzI5Mg=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUxMTY3OnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/ResponseFilter.swift", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowNDoxNVrOGzC2yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMzowMzoyNlrOGzDw6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzM1NA==", "bodyText": "I'd either remove this or provide an actual description", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456177354", "createdAt": "2020-07-17T02:04:15Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/ResponseFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MjIzMg==", "bodyText": "Sure, I'll elaborate.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456192232", "createdAt": "2020-07-17T03:03:26Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/ResponseFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzM1NA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUxMzM0OnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/ResponseFilter.swift", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowNToxMVrOGzC3uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxMDoyMjozNlrOGzuX4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzU5NQ==", "bodyText": "Can we name these instead of using 0/1?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456177595", "createdAt": "2020-07-17T02:05:11Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/ResponseFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(responseFilter: ResponseFilter) {\n+    self.init()\n+    self.name = responseFilter.name\n+    self.onResponseHeaders = {\n+      let result = responseFilter.onResponseHeaders(ResponseHeaders(headers: $0), endStream: $1)\n+      switch result {\n+      case .continue(let headers):\n+        return [0, headers.headers]\n+      case .stopIteration(let headers):\n+        return [1, headers.headers]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4NzI2OA==", "bodyText": "Yeah, we should. We don't have a great solution for enums across the bridge layer yet, and I had this in place while I thought about it more. But we should at least make them some kind of named constant.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456187268", "createdAt": "2020-07-17T02:43:28Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/ResponseFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(responseFilter: ResponseFilter) {\n+    self.init()\n+    self.name = responseFilter.name\n+    self.onResponseHeaders = {\n+      let result = responseFilter.onResponseHeaders(ResponseHeaders(headers: $0), endStream: $1)\n+      switch result {\n+      case .continue(let headers):\n+        return [0, headers.headers]\n+      case .stopIteration(let headers):\n+        return [1, headers.headers]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzU5NQ=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5MDMxMw==", "bodyText": "Okay, I came up with a solution, which is \"don't use enums.\" Using enums, we'd have to declare and map this set of options 4 times over: first, in Envoy, next at the bridge layer (because Envoy's type is c++ and can't be directly exposed), next in objective-c (because the EnvoyEngine header can't have includes due to the clang issue), next in Swift (because the objective-c type doesn't support associated values). We'd also have to create mapping functions between all 4 variants.\nextern  consts can be declared in terms of Envoy's implicit internal values and eliminate all but one mapping.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456890313", "createdAt": "2020-07-19T10:22:30Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/ResponseFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(responseFilter: ResponseFilter) {\n+    self.init()\n+    self.name = responseFilter.name\n+    self.onResponseHeaders = {\n+      let result = responseFilter.onResponseHeaders(ResponseHeaders(headers: $0), endStream: $1)\n+      switch result {\n+      case .continue(let headers):\n+        return [0, headers.headers]\n+      case .stopIteration(let headers):\n+        return [1, headers.headers]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzU5NQ=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg5MDMzNw==", "bodyText": "(pushed)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456890337", "createdAt": "2020-07-19T10:22:36Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/ResponseFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(responseFilter: ResponseFilter) {\n+    self.init()\n+    self.name = responseFilter.name\n+    self.onResponseHeaders = {\n+      let result = responseFilter.onResponseHeaders(ResponseHeaders(headers: $0), endStream: $1)\n+      switch result {\n+      case .continue(let headers):\n+        return [0, headers.headers]\n+      case .stopIteration(let headers):\n+        return [1, headers.headers]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzU5NQ=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUxMzkxOnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/ResponseFilter.swift", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowNToyN1rOGzC4BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjo0Mzo1NVrOGzDd_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzY2OA==", "bodyText": "nit: let's name these parameters in the opening of the closure", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456177668", "createdAt": "2020-07-17T02:05:27Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/ResponseFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(responseFilter: ResponseFilter) {\n+    self.init()\n+    self.name = responseFilter.name\n+    self.onResponseHeaders = {\n+      let result = responseFilter.onResponseHeaders(ResponseHeaders(headers: $0), endStream: $1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4NzM4OA==", "bodyText": "sgtm", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456187388", "createdAt": "2020-07-17T02:43:55Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/ResponseFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(responseFilter: ResponseFilter) {\n+    self.init()\n+    self.name = responseFilter.name\n+    self.onResponseHeaders = {\n+      let result = responseFilter.onResponseHeaders(ResponseHeaders(headers: $0), endStream: $1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzY2OA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUxNDYxOnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/RequestFilter.swift", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowNTo1NFrOGzC4bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowNTo1NFrOGzC4bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3Nzc3NQ==", "bodyText": "Same comments here as below", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456177775", "createdAt": "2020-07-17T02:05:54Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/RequestFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(requestFilter: RequestFilter) {\n+    self.init()\n+    self.name = requestFilter.name\n+    self.onRequestHeaders = {\n+      let result = requestFilter.onRequestHeaders(RequestHeaders(headers: $0), endStream: $1)\n+      switch result {\n+      case .continue(let headers):\n+        return [0, headers.headers]\n+      case .stopIteration(let headers):\n+        return [1, headers.headers]\n+      }\n+    }\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUxNTMwOnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/RequestFilter.swift", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowNjoyMlrOGzC43A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNjoyMToyNlrOGzs75A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3Nzg4NA==", "bodyText": "How will this work for filters that want to act as both request and response filters? As-is, it doesn't look like that's possible since the callbacks are only set on EnvoyHTTPFilter.init", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456177884", "createdAt": "2020-07-17T02:06:22Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/RequestFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(requestFilter: RequestFilter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4OTM4Ng==", "bodyText": "Already by the objective-c mapping layer (and everything below) it's actually unified into a bi-directional solution. It's only bifurcated here because it wasn't clear to me here how we'd work with the two disparate interfaces, and I decided to punt on the problem since it wasn't clear to me that the intent was that we'd have filters that implemented both.\nI think I can make things work to allow bi-directional filters with a little tweaking. Since we don't have any usage that necessitates it yet, my slight inclination is to punt on it so we can get something functional onto main and work from there, but I'm open to your thoughts.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456189386", "createdAt": "2020-07-17T02:51:49Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/RequestFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(requestFilter: RequestFilter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3Nzg4NA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3NTAzOA==", "bodyText": "I don't necessarily want to block the PR on this, but I do think it's required functionality for using these filters in production, and am a little concerned that if we don't fix it early on it'll be more difficult to do as we go further down this route. Thoughts?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456575038", "createdAt": "2020-07-17T17:24:14Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/RequestFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(requestFilter: RequestFilter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3Nzg4NA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MTYwOQ==", "bodyText": "Just to capture discussion from Friday here, I will be adding support for bi-directionality prior to merging.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456861609", "createdAt": "2020-07-19T05:20:04Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/RequestFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(requestFilter: RequestFilter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3Nzg4NA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2Njc4OA==", "bodyText": "Pushed a solution, let me know if you have further thoughts.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456866788", "createdAt": "2020-07-19T06:21:26Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/RequestFilter.swift", "diffHunk": "@@ -1,7 +1,28 @@\n+@_implementationOnly import EnvoyEngine\n import Foundation\n \n+extension EnvoyHTTPFilter {\n+  /// Initializer\n+  convenience init(requestFilter: RequestFilter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3Nzg4NA=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NTUxOTAwOnYy", "diffSide": "RIGHT", "path": "library/swift/src/StreamClientBuilder.swift", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMjowODo1NlrOGzC7KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwNjoyMDo0NlrOGzs7iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3ODQ3Mw==", "bodyText": "It looks like this prevents filters from being able to act as both RequestFilter and ResponseFilter conformers. The idea behind the empty Filter protocol in place is to allow registration of a filter, then call its request/response functionality depending on what it conforms to. Should we be doing something like that here?\nPer comments above, I think these should accept closures that create the filters on each request/stream, rather than instances of the filters.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456178473", "createdAt": "2020-07-17T02:08:56Z", "author": {"login": "rebello95"}, "path": "library/swift/src/StreamClientBuilder.swift", "diffHunk": "@@ -107,6 +108,28 @@ public final class StreamClientBuilder: NSObject {\n     return self\n   }\n \n+  /// Add HTTP filter for requests sent by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: RequestFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(requestFilter: filter))\n+    return self\n+  }\n+\n+  /// Add HTTP filter for resonses received by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: ResponseFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(responseFilter: filter))\n+    return self\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MDIwNw==", "bodyText": "Agreed, see my response above. With a little bit of reflection I think we can achieve that, so I'm open to working that out here, or in a subsequent PR, though my slight preference is for the latter.\nI agree, though I have to think a little bit more about the ramifications to the API and mapping layer. I'm forming an idea of how to do it though - it should be possible.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456190207", "createdAt": "2020-07-17T02:55:17Z", "author": {"login": "goaway"}, "path": "library/swift/src/StreamClientBuilder.swift", "diffHunk": "@@ -107,6 +108,28 @@ public final class StreamClientBuilder: NSObject {\n     return self\n   }\n \n+  /// Add HTTP filter for requests sent by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: RequestFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(requestFilter: filter))\n+    return self\n+  }\n+\n+  /// Add HTTP filter for resonses received by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: ResponseFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(responseFilter: filter))\n+    return self\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3ODQ3Mw=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwNDkxOQ==", "bodyText": "re: 2. we should definitely do this per stream instance. And re: 1. do we really need reflection? Can't we have multiple inheritance and have a filter class that is both, and thus calls both request and response addFilter functions as in envoy:\nhttps://github.com/envoyproxy/envoy/blob/bc02b7748a69fd3854f74b9e5bec236b5499f7fd/include/envoy/http/filter.h#L772\nhttps://github.com/envoyproxy/envoy/blob/0c6523c0925d260de41d89002044d0d6271550d0/source/common/http/conn_manager_impl.h#L553", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456704919", "createdAt": "2020-07-17T22:48:58Z", "author": {"login": "junr03"}, "path": "library/swift/src/StreamClientBuilder.swift", "diffHunk": "@@ -107,6 +108,28 @@ public final class StreamClientBuilder: NSObject {\n     return self\n   }\n \n+  /// Add HTTP filter for requests sent by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: RequestFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(requestFilter: filter))\n+    return self\n+  }\n+\n+  /// Add HTTP filter for resonses received by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: ResponseFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(responseFilter: filter))\n+    return self\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3ODQ3Mw=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MTUxMw==", "bodyText": "I believe reflection is the way to go, yes. It's true a class can implement multiple interfaces, but even if we declare an interface that conforms to both RequestFilter and ResponseFilter, Swift will not implicitly or automatically cause classes that implement both interfaces to conform to it. So when we go to instantiate bridge type from a generic Filter, we will need to check which interfaces it implements. If we create type-specialized constructors (like I had here), it will be ambiguous to the compiler which it should call.\nThat's the best explanation I can provide here. Happy to discuss more offline.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456861513", "createdAt": "2020-07-19T05:18:45Z", "author": {"login": "goaway"}, "path": "library/swift/src/StreamClientBuilder.swift", "diffHunk": "@@ -107,6 +108,28 @@ public final class StreamClientBuilder: NSObject {\n     return self\n   }\n \n+  /// Add HTTP filter for requests sent by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: RequestFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(requestFilter: filter))\n+    return self\n+  }\n+\n+  /// Add HTTP filter for resonses received by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: ResponseFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(responseFilter: filter))\n+    return self\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3ODQ3Mw=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2NjY5Ng==", "bodyText": "For bi-directionality, see the solution I've pushed, and let me know if you have additional thoughts. :)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456866696", "createdAt": "2020-07-19T06:20:46Z", "author": {"login": "goaway"}, "path": "library/swift/src/StreamClientBuilder.swift", "diffHunk": "@@ -107,6 +108,28 @@ public final class StreamClientBuilder: NSObject {\n     return self\n   }\n \n+  /// Add HTTP filter for requests sent by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: RequestFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(requestFilter: filter))\n+    return self\n+  }\n+\n+  /// Add HTTP filter for resonses received by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: ResponseFilter) -> StreamClientBuilder {\n+    self.filterChain.append(EnvoyHTTPFilter(responseFilter: filter))\n+    return self\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3ODQ3Mw=="}, "originalCommit": {"oid": "7a296fdf97f9a24f63fce6dd9821510970bc4f14"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODg5MjM5OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjoyNzo1NFrOGzivEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwMzo0NToxOVrOGzsMng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5OTY2NQ==", "bodyText": "I feel like the user can determine if they are going to modify or not, and this function should release on copy? Or conversely, change the existing API and have the caller bear the responsibility of releasing? In any case, I think we can unify these helpers with the ones in EnvoyHTTPStreamImpl", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456699665", "createdAt": "2020-07-17T22:27:54Z", "author": {"login": "junr03"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,91 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  return (envoy_data){length, native_string, free, native_string};\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b08d0548fb52ead8556ac632ab60b389a86774f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NDY4Ng==", "bodyText": "The convention I feel we should maintain is that the callee always releases or passes that responsibility. I don't think it's really possible to invert that, because there's no way for the caller (or returner) to otherwise determine what the callee does with it. This is true for calls going in either direction across the bridge layer.\nWhile I do think we can reconcile the differences here, I added it as a TODO because it felt a little bit extraneous to getting the core functionality in place.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456854686", "createdAt": "2020-07-19T03:45:19Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,91 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  return (envoy_data){length, native_string, free, native_string};\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5OTY2NQ=="}, "originalCommit": {"oid": "5b08d0548fb52ead8556ac632ab60b389a86774f"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkwMDI5OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjozMjoxNlrOGzizuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwMzo0ODo1NFrOGzsNlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMDg1OQ==", "bodyText": "Is there no tuple type?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456700859", "createdAt": "2020-07-17T22:32:16Z", "author": {"login": "junr03"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,91 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  return (envoy_data){length, native_string, free, native_string};\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (NSString *headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (NSString *headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (NSString *headerValue in headerList) {\n+      envoy_header new_header = {toManagedNativeString(headerKey),\n+                                 toManagedNativeString(headerValue)};\n+      header_array[header_index++] = new_header;\n+    }\n+  }\n+  // TODO: ASSERT(header_index == length);\n+  return (envoy_headers){length, header_array};\n+}\n+\n+static envoy_filter_headers_status\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+  // TODO(goaway): optimize unmodified case\n+  ios_http_filter_context *c = (ios_http_filter_context *)context;\n+  if (c->filter.onRequestHeaders == nil) {\n+    return (envoy_filter_headers_status){/*status*/ 0, /*headers*/ headers};\n+  }\n+\n+  EnvoyHeaders *platformHeaders = to_ios_headers(headers);\n+  release_envoy_headers(headers);\n+  // TODO(goaway): consider better solution for compound return\n+  NSArray *result = c->filter.onRequestHeaders(platformHeaders, end_stream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b08d0548fb52ead8556ac632ab60b389a86774f"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NDkzNA==", "bodyText": "There is at the core layer, and at the platform layer. I skipped making yet another implementation in between. - While we could re-use the bridge/core type on iOS technically, it will then deviate from what we'll need on Android. It also comes back down to that we don't really have a great way to share enums in a consistent way either - something I would like to come up with a better solution for as well.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456854934", "createdAt": "2020-07-19T03:48:54Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -10,6 +11,91 @@ static void ios_on_exit() {\n   NSLog(@\"[Envoy] library is exiting\");\n }\n \n+typedef struct {\n+  __unsafe_unretained EnvoyHTTPFilter *filter;\n+} ios_http_filter_context;\n+\n+// TODO(goaway): refactor and relocate translation\n+static envoy_data toManagedNativeString(NSString *s) {\n+  size_t length = s.length;\n+  uint8_t *native_string = (uint8_t *)safe_malloc(sizeof(uint8_t) * length);\n+  memcpy(native_string, s.UTF8String, length);\n+  return (envoy_data){length, native_string, free, native_string};\n+}\n+\n+static EnvoyHeaders *to_ios_headers(envoy_headers headers) {\n+  NSMutableDictionary *headerDict = [NSMutableDictionary new];\n+  for (envoy_header_size_t i = 0; i < headers.length; i++) {\n+    envoy_header header = headers.headers[i];\n+    NSString *headerKey = [[NSString alloc] initWithBytes:header.key.bytes\n+                                                   length:header.key.length\n+                                                 encoding:NSUTF8StringEncoding];\n+    NSString *headerValue = [[NSString alloc] initWithBytes:header.value.bytes\n+                                                     length:header.value.length\n+                                                   encoding:NSUTF8StringEncoding];\n+    NSMutableArray *headerValueList = headerDict[headerKey];\n+    if (headerValueList == nil) {\n+      headerValueList = [NSMutableArray new];\n+      headerDict[headerKey] = headerValueList;\n+    }\n+    [headerValueList addObject:headerValue];\n+  }\n+  // TODO(goaway): consider solution that doesn't violate release convention\n+  // Note: We don't call release_envoy_headers because they may not be modified by the filter\n+  return headerDict;\n+}\n+\n+static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n+  envoy_header_size_t length = 0;\n+  for (NSString *headerKey in headers) {\n+    length += [headers[headerKey] count];\n+  }\n+  envoy_header *header_array = (envoy_header *)safe_malloc(sizeof(envoy_header) * length);\n+  envoy_header_size_t header_index = 0;\n+  for (NSString *headerKey in headers) {\n+    NSArray *headerList = headers[headerKey];\n+    for (NSString *headerValue in headerList) {\n+      envoy_header new_header = {toManagedNativeString(headerKey),\n+                                 toManagedNativeString(headerValue)};\n+      header_array[header_index++] = new_header;\n+    }\n+  }\n+  // TODO: ASSERT(header_index == length);\n+  return (envoy_headers){length, header_array};\n+}\n+\n+static envoy_filter_headers_status\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+  // TODO(goaway): optimize unmodified case\n+  ios_http_filter_context *c = (ios_http_filter_context *)context;\n+  if (c->filter.onRequestHeaders == nil) {\n+    return (envoy_filter_headers_status){/*status*/ 0, /*headers*/ headers};\n+  }\n+\n+  EnvoyHeaders *platformHeaders = to_ios_headers(headers);\n+  release_envoy_headers(headers);\n+  // TODO(goaway): consider better solution for compound return\n+  NSArray *result = c->filter.onRequestHeaders(platformHeaders, end_stream);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMDg1OQ=="}, "originalCommit": {"oid": "5b08d0548fb52ead8556ac632ab60b389a86774f"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkxODIwOnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0MjozM1rOGzi95g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQwMzo1NDo1M1rOGzsPMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMzQ2Mg==", "bodyText": "following on @rebello95's comment about lifetime. We definitely want a per stream instance of the full chain, like Envoy.\nI wonder if what we can do is: have the api retain a filter factory in its context, and register that. Then the registry can instantiate a filter chain, that the stream retains, and passes that in the context to the static ios_http_filter_on_*_* functions. So we would have two different contexts, and the one here (which retains the factory) leaks, but will eventually be tied/retained to/by the engine instance.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456703462", "createdAt": "2020-07-17T22:42:33Z", "author": {"login": "junr03"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +115,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332\n+  ios_http_filter_context *context = safe_malloc(sizeof(ios_http_filter_context));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b08d0548fb52ead8556ac632ab60b389a86774f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NTI0NQ==", "bodyText": "That's one of the options that I've been considering, but there's some added complexity with the memory management of the instance. We'll need a dealloc hook as well, and we need to guard against the platform implementation living longer than the underlying core instantiation (and more specifically, trying to interact with it after it's gone).\nI've actually been leaning towards a more integrated approach - with the API presenting both an init() and a release() function, the former of which will populate the rest of the function pointers on the struct, and the latter of which will nullify them (and trigger memory-safe cleanup).", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456855245", "createdAt": "2020-07-19T03:53:19Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +115,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332\n+  ios_http_filter_context *context = safe_malloc(sizeof(ios_http_filter_context));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMzQ2Mg=="}, "originalCommit": {"oid": "5b08d0548fb52ead8556ac632ab60b389a86774f"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NTM0Nw==", "bodyText": "Per our discussion Friday, my current plan is to finish addressing other issues here, land this and build per-stream instantiation on top.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r456855347", "createdAt": "2020-07-19T03:54:53Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +115,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332\n+  ios_http_filter_context *context = safe_malloc(sizeof(ios_http_filter_context));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMzQ2Mg=="}, "originalCommit": {"oid": "5b08d0548fb52ead8556ac632ab60b389a86774f"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjA3OTQ3OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngine.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMToyNToyM1rOG0f1vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjoxMDowOFrOG0lg4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcwMDc5OQ==", "bodyText": "Shouldn't this be an NSMutableArray as the values?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r457700799", "createdAt": "2020-07-20T21:25:23Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngine.h", "diffHunk": "@@ -7,6 +7,9 @@ NS_ASSUME_NONNULL_BEGIN\n /// A set of headers that may be passed to/from an Envoy stream.\n typedef NSDictionary<NSString *, NSArray<NSString *> *> EnvoyHeaders;\n \n+/// A mutable set of headers that may be passed to/from an Envoy stream.\n+typedef NSMutableDictionary<NSString *, NSArray<NSString *> *> EnvoyMutableHeaders;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3269118018bd4e493e1606782e747cb89ee9cdc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5Mzc2Mw==", "bodyText": "Sure, sounds good. I was trying to avoid unnecessary reallocations when converting from the immutable type, but honestly I wouldn't be surprised if Apple had a copy-on-write optimization under the hood anyways.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r457793763", "createdAt": "2020-07-21T02:10:08Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngine.h", "diffHunk": "@@ -7,6 +7,9 @@ NS_ASSUME_NONNULL_BEGIN\n /// A set of headers that may be passed to/from an Envoy stream.\n typedef NSDictionary<NSString *, NSArray<NSString *> *> EnvoyHeaders;\n \n+/// A mutable set of headers that may be passed to/from an Envoy stream.\n+typedef NSMutableDictionary<NSString *, NSArray<NSString *> *> EnvoyMutableHeaders;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcwMDc5OQ=="}, "originalCommit": {"oid": "d3269118018bd4e493e1606782e747cb89ee9cdc"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjEwODY1OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMTozNTo0MlrOG0gHpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNDoxNzo0NVrOG0ngIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcwNTM4MA==", "bodyText": "ENVOY_SUCCESS?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r457705380", "createdAt": "2020-07-20T21:35:42Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +119,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332\n+  ios_http_filter_context *context = safe_malloc(sizeof(ios_http_filter_context));\n+  CFBridgingRetain(filter);\n+  context->filter = filter;\n+  envoy_http_filter *api = safe_malloc(sizeof(envoy_http_filter));\n+  api->on_request_headers = ios_http_filter_on_request_headers;\n+  api->on_request_data = NULL;\n+  api->on_response_headers = ios_http_filter_on_response_headers;\n+  api->on_response_data = NULL;\n+  api->context = context;\n+  register_platform_api(filter.name.UTF8String, api);\n+  return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3269118018bd4e493e1606782e747cb89ee9cdc"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5MzU0Mw==", "bodyText": "We don't have the type available on the header here, so we've only used 0 and 1 in this file so far. The extern-based solution I propose in this PR for filter status would work for this as well though, so maybe I can fix this for all the outstanding cases in a subsequent PR?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r457793543", "createdAt": "2020-07-21T02:09:19Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +119,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332\n+  ios_http_filter_context *context = safe_malloc(sizeof(ios_http_filter_context));\n+  CFBridgingRetain(filter);\n+  context->filter = filter;\n+  envoy_http_filter *api = safe_malloc(sizeof(envoy_http_filter));\n+  api->on_request_headers = ios_http_filter_on_request_headers;\n+  api->on_request_data = NULL;\n+  api->on_response_headers = ios_http_filter_on_response_headers;\n+  api->on_response_data = NULL;\n+  api->context = context;\n+  register_platform_api(filter.name.UTF8String, api);\n+  return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcwNTM4MA=="}, "originalCommit": {"oid": "d3269118018bd4e493e1606782e747cb89ee9cdc"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNjMzOA==", "bodyText": "SGTM", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r457826338", "createdAt": "2020-07-21T04:17:45Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -29,13 +119,33 @@ - (void)dealloc {\n   [[NSNotificationCenter defaultCenter] removeObserver:self];\n }\n \n+- (int)registerFilter:(EnvoyHTTPFilter *)filter {\n+  // TODO(goaway): Everything here leaks, but it's all be tied to the life of the engine.\n+  // This will need to be updated for https://github.com/lyft/envoy-mobile/issues/332\n+  ios_http_filter_context *context = safe_malloc(sizeof(ios_http_filter_context));\n+  CFBridgingRetain(filter);\n+  context->filter = filter;\n+  envoy_http_filter *api = safe_malloc(sizeof(envoy_http_filter));\n+  api->on_request_headers = ios_http_filter_on_request_headers;\n+  api->on_request_data = NULL;\n+  api->on_response_headers = ios_http_filter_on_response_headers;\n+  api->on_response_data = NULL;\n+  api->context = context;\n+  register_platform_api(filter.name.UTF8String, api);\n+  return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcwNTM4MA=="}, "originalCommit": {"oid": "d3269118018bd4e493e1606782e747cb89ee9cdc"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjExMDU1OnYy", "diffSide": "RIGHT", "path": "library/swift/src/StreamClientBuilder.swift", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMTozNjoyMFrOG0gIxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjoxMDoxOVrOG0lhDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcwNTY3MA==", "bodyText": "Maybe add a todo here since we'll be switching from instance-based filters in a future PR?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r457705670", "createdAt": "2020-07-20T21:36:20Z", "author": {"login": "rebello95"}, "path": "library/swift/src/StreamClientBuilder.swift", "diffHunk": "@@ -107,6 +108,17 @@ public final class StreamClientBuilder: NSObject {\n     return self\n   }\n \n+  /// Add HTTP filter for requests sent by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: Filter) -> StreamClientBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3269118018bd4e493e1606782e747cb89ee9cdc"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5MzgwNg==", "bodyText": "Sure thing.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/943#discussion_r457793806", "createdAt": "2020-07-21T02:10:19Z", "author": {"login": "goaway"}, "path": "library/swift/src/StreamClientBuilder.swift", "diffHunk": "@@ -107,6 +108,17 @@ public final class StreamClientBuilder: NSObject {\n     return self\n   }\n \n+  /// Add HTTP filter for requests sent by this client.\n+  ///\n+  /// - parameter filter: RequestFilter to be invoked for streams.\n+  ///\n+  /// - returns: This builder.\n+  @discardableResult\n+  public func addFilter(_ filter: Filter) -> StreamClientBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcwNTY3MA=="}, "originalCommit": {"oid": "d3269118018bd4e493e1606782e747cb89ee9cdc"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 685, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}