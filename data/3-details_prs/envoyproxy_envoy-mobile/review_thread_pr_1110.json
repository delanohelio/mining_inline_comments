{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NDgyOTg4", "number": 1110, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxODo0OToxMVrOElFHwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDoxMzo0OVrOElGk7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzE2NjczOnYy", "diffSide": "RIGHT", "path": "test/common/http/dispatcher_test.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxODo0OToxMVrOHUYSTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxODo0OToxMVrOHUYSTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMTQ3MQ==", "bodyText": "Cool that this works", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1110#discussion_r491131471", "createdAt": "2020-09-18T18:49:11Z", "author": {"login": "rebello95"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -1324,5 +1324,127 @@ TEST_F(DispatcherTest, ResetWhenRemoteClosesBeforeLocal) {\n   ASSERT_EQ(cc.on_error_calls, 0);\n }\n \n+TEST_F(DispatcherTest, Encode100Continue) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  envoy_http_callbacks bridge_callbacks;\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode 100 continue should blow up.\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n+  EXPECT_DEATH(response_encoder_->encode100ContinueHeaders(response_headers), \"panic: not implemented\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c6b2d4f3ec9e5f0b43ab9551f4c78c7e21f5cfb"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzM5OTk2OnYy", "diffSide": "RIGHT", "path": "test/common/network/synthetic_address_impl_test.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDoxMjowN1rOHUagEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDoxMjowN1rOHUagEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2Nzc2Mw==", "bodyText": "?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1110#discussion_r491167763", "createdAt": "2020-09-18T20:12:07Z", "author": {"login": "goaway"}, "path": "test/common/network/synthetic_address_impl_test.cc", "diffHunk": "@@ -22,8 +22,10 @@ TEST(SyntheticAddressImplTest, Accessors) {\n   SyntheticAddressImpl address;\n   ASSERT_EQ(address.ip(), nullptr);\n   ASSERT_EQ(address.pipe(), nullptr);\n+  ASSERT_EQ(address.envoyInternalAddress(), nullptr);\n   ASSERT_EQ(address.sockAddr(), nullptr);\n   ASSERT_EQ(address.sockAddrLen(), 0);\n+  address.socketInterface();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29466ab9fc1114496fa813d8212773f4d8779bc2"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzQwNTI2OnYy", "diffSide": "RIGHT", "path": "test/common/main_interface_test.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDoxMzo0OVrOHUajZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDo1MDoxMlrOHUbhEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2ODYxNQ==", "bodyText": "This doesn't really feel like a useful test to me. I get that we're just trying to increase coverage, but I don't know that we actually want to be asserting or implying that this returns a specific value. If we were to change this to return 2 tomorrow, everything should still work, and the only thing that would be different is that now we'd have a broken test.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1110#discussion_r491168615", "createdAt": "2020-09-18T20:13:49Z", "author": {"login": "goaway"}, "path": "test/common/main_interface_test.cc", "diffHunk": "@@ -218,6 +218,75 @@ TEST(MainInterfaceTest, ResetStream) {\n   ASSERT_TRUE(engine_cbs_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));\n }\n \n+TEST(MainInterfaceTest, UsingMainInterfaceWithoutARunningEngine) {\n+\n+  Http::TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Http::Utility::toBridgeHeaders(headers);\n+\n+  Buffer::OwnedImpl request_data = Buffer::OwnedImpl(\"request body\");\n+  envoy_data c_data = Buffer::Utility::toBridgeData(request_data);\n+\n+  Http::TestRequestTrailerMapImpl trailers;\n+  envoy_headers c_trailers = Http::Utility::toBridgeHeaders(trailers);\n+\n+  EXPECT_EQ(ENVOY_FAILURE, send_headers(0, c_headers, false));\n+  EXPECT_EQ(ENVOY_FAILURE, send_data(0, c_data, false));\n+  EXPECT_EQ(ENVOY_FAILURE, send_trailers(0, c_trailers));\n+  EXPECT_EQ(ENVOY_FAILURE, reset_stream(0));\n+\n+  // Release memory\n+  release_envoy_headers(c_headers);\n+  c_data.release(c_data.context);\n+  release_envoy_headers(c_trailers);\n+}\n+\n+TEST(MainInterfaceTest, RegisterPlatformApi) {\n+  // This config is the minimal envoy mobile config that allows for running the engine.\n+  const std::string config =\n+      \"{\\\"admin\\\":{},\\\"static_resources\\\":{\\\"listeners\\\":[{\\\"name\\\":\\\"base_api_listener\\\",\"\n+      \"\\\"address\\\":{\\\"socket_address\\\":{\\\"protocol\\\":\\\"TCP\\\",\\\"address\\\":\\\"0.0.0.0\\\",\\\"port_\"\n+      \"value\\\":10000}},\\\"api_listener\\\":{\\\"api_listener\\\":{\\\"@type\\\":\\\"type.googleapis.com/\"\n+      \"envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\\\",\\\"stat_\"\n+      \"prefix\\\":\\\"hcm\\\",\\\"route_config\\\":{\\\"name\\\":\\\"api_router\\\",\\\"virtual_hosts\\\":[{\\\"name\\\":\"\n+      \"\\\"api\\\",\\\"include_attempt_count_in_response\\\":true,\\\"domains\\\":[\\\"*\\\"],\\\"routes\\\":[{\"\n+      \"\\\"match\\\":{\\\"prefix\\\":\\\"/\"\n+      \"\\\"},\\\"route\\\":{\\\"cluster_header\\\":\\\"x-envoy-mobile-cluster\\\",\\\"retry_policy\\\":{\\\"retry_back_\"\n+      \"off\\\":{\\\"base_interval\\\":\\\"0.25s\\\",\\\"max_interval\\\":\\\"60s\\\"}}}}]}]},\\\"http_filters\\\":[{\"\n+      \"\\\"name\\\":\\\"envoy.router\\\",\\\"typed_config\\\":{\\\"@type\\\":\\\"type.googleapis.com/\"\n+      \"envoy.extensions.filters.http.router.v3.Router\\\"}}]}}}]},\\\"layered_runtime\\\":{\\\"layers\\\":[{\"\n+      \"\\\"name\\\":\\\"static_layer_0\\\",\\\"static_layer\\\":{\\\"overload\\\":{\\\"global_downstream_max_\"\n+      \"connections\\\":50000}}}]}}\";\n+  const std::string level = \"debug\";\n+  engine_test_context engine_cbs_context{};\n+  envoy_engine_callbacks engine_cbs{[](void* context) -> void {\n+                                      auto* engine_running =\n+                                          static_cast<engine_test_context*>(context);\n+                                      engine_running->on_engine_running.Notify();\n+                                    } /*on_engine_running*/,\n+                                    [](void* context) -> void {\n+                                      auto* exit = static_cast<engine_test_context*>(context);\n+                                      exit->on_exit.Notify();\n+                                    } /*on_exit*/,\n+                                    &engine_cbs_context /*context*/};\n+  run_engine(0, engine_cbs, config.c_str(), level.c_str());\n+\n+  ASSERT_TRUE(\n+      engine_cbs_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(10)));\n+\n+  EXPECT_EQ(ENVOY_SUCCESS, register_platform_api(\"api\", nullptr));\n+\n+  terminate_engine(0);\n+\n+  ASSERT_TRUE(engine_cbs_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));\n+}\n+\n+TEST(MainInterfaceTest, InitEngineReturns1) {\n+  // TODO(goaway): return new handle once multiple engine support is in place.\n+  // https://github.com/lyft/envoy-mobile/issues/332\n+  ASSERT_EQ(1, init_engine());\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29466ab9fc1114496fa813d8212773f4d8779bc2"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NDQwMg==", "bodyText": "I see this as a sentinel that we have to have coverage for init_engine(). So in my mind having a test that breaks is, in and of itself, useful.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1110#discussion_r491184402", "createdAt": "2020-09-18T20:50:12Z", "author": {"login": "junr03"}, "path": "test/common/main_interface_test.cc", "diffHunk": "@@ -218,6 +218,75 @@ TEST(MainInterfaceTest, ResetStream) {\n   ASSERT_TRUE(engine_cbs_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));\n }\n \n+TEST(MainInterfaceTest, UsingMainInterfaceWithoutARunningEngine) {\n+\n+  Http::TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Http::Utility::toBridgeHeaders(headers);\n+\n+  Buffer::OwnedImpl request_data = Buffer::OwnedImpl(\"request body\");\n+  envoy_data c_data = Buffer::Utility::toBridgeData(request_data);\n+\n+  Http::TestRequestTrailerMapImpl trailers;\n+  envoy_headers c_trailers = Http::Utility::toBridgeHeaders(trailers);\n+\n+  EXPECT_EQ(ENVOY_FAILURE, send_headers(0, c_headers, false));\n+  EXPECT_EQ(ENVOY_FAILURE, send_data(0, c_data, false));\n+  EXPECT_EQ(ENVOY_FAILURE, send_trailers(0, c_trailers));\n+  EXPECT_EQ(ENVOY_FAILURE, reset_stream(0));\n+\n+  // Release memory\n+  release_envoy_headers(c_headers);\n+  c_data.release(c_data.context);\n+  release_envoy_headers(c_trailers);\n+}\n+\n+TEST(MainInterfaceTest, RegisterPlatformApi) {\n+  // This config is the minimal envoy mobile config that allows for running the engine.\n+  const std::string config =\n+      \"{\\\"admin\\\":{},\\\"static_resources\\\":{\\\"listeners\\\":[{\\\"name\\\":\\\"base_api_listener\\\",\"\n+      \"\\\"address\\\":{\\\"socket_address\\\":{\\\"protocol\\\":\\\"TCP\\\",\\\"address\\\":\\\"0.0.0.0\\\",\\\"port_\"\n+      \"value\\\":10000}},\\\"api_listener\\\":{\\\"api_listener\\\":{\\\"@type\\\":\\\"type.googleapis.com/\"\n+      \"envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\\\",\\\"stat_\"\n+      \"prefix\\\":\\\"hcm\\\",\\\"route_config\\\":{\\\"name\\\":\\\"api_router\\\",\\\"virtual_hosts\\\":[{\\\"name\\\":\"\n+      \"\\\"api\\\",\\\"include_attempt_count_in_response\\\":true,\\\"domains\\\":[\\\"*\\\"],\\\"routes\\\":[{\"\n+      \"\\\"match\\\":{\\\"prefix\\\":\\\"/\"\n+      \"\\\"},\\\"route\\\":{\\\"cluster_header\\\":\\\"x-envoy-mobile-cluster\\\",\\\"retry_policy\\\":{\\\"retry_back_\"\n+      \"off\\\":{\\\"base_interval\\\":\\\"0.25s\\\",\\\"max_interval\\\":\\\"60s\\\"}}}}]}]},\\\"http_filters\\\":[{\"\n+      \"\\\"name\\\":\\\"envoy.router\\\",\\\"typed_config\\\":{\\\"@type\\\":\\\"type.googleapis.com/\"\n+      \"envoy.extensions.filters.http.router.v3.Router\\\"}}]}}}]},\\\"layered_runtime\\\":{\\\"layers\\\":[{\"\n+      \"\\\"name\\\":\\\"static_layer_0\\\",\\\"static_layer\\\":{\\\"overload\\\":{\\\"global_downstream_max_\"\n+      \"connections\\\":50000}}}]}}\";\n+  const std::string level = \"debug\";\n+  engine_test_context engine_cbs_context{};\n+  envoy_engine_callbacks engine_cbs{[](void* context) -> void {\n+                                      auto* engine_running =\n+                                          static_cast<engine_test_context*>(context);\n+                                      engine_running->on_engine_running.Notify();\n+                                    } /*on_engine_running*/,\n+                                    [](void* context) -> void {\n+                                      auto* exit = static_cast<engine_test_context*>(context);\n+                                      exit->on_exit.Notify();\n+                                    } /*on_exit*/,\n+                                    &engine_cbs_context /*context*/};\n+  run_engine(0, engine_cbs, config.c_str(), level.c_str());\n+\n+  ASSERT_TRUE(\n+      engine_cbs_context.on_engine_running.WaitForNotificationWithTimeout(absl::Seconds(10)));\n+\n+  EXPECT_EQ(ENVOY_SUCCESS, register_platform_api(\"api\", nullptr));\n+\n+  terminate_engine(0);\n+\n+  ASSERT_TRUE(engine_cbs_context.on_exit.WaitForNotificationWithTimeout(absl::Seconds(10)));\n+}\n+\n+TEST(MainInterfaceTest, InitEngineReturns1) {\n+  // TODO(goaway): return new handle once multiple engine support is in place.\n+  // https://github.com/lyft/envoy-mobile/issues/332\n+  ASSERT_EQ(1, init_engine());\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2ODYxNQ=="}, "originalCommit": {"oid": "29466ab9fc1114496fa813d8212773f4d8779bc2"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 633, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}