{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2NzQ4MTYw", "number": 1061, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoxNTo1M1rOEfARsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo0NzozM1rOEfGzvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTQ1ODQzOnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoxNTo1M1rOHLAkxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozNzowOFrOHLHT3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNTc5Ng==", "bodyText": "I would somehow move this call back out to the calling function (either via return code or something else) so that all of the reset/closure logic is in one place.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481305796", "createdAt": "2020-09-01T17:15:53Z", "author": {"login": "mattklein123"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -96,131 +95,109 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n \n   ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n   if (end_stream) {\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n+    // If the stream is not locally closed, the HCM will fire resetStream subsequently. However, we will see\n+    // that the stream is already gone from the streams_ map, and direct Envoy to runResetCallbacks() without\n+    // redundantly calling on onReset().\n+    // @see Dispatcher::DirectStreamCallbacks::resetStream.\n+    onReset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "851b92691071bd941f217512cbd27004a9813b24"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxNjE1OQ==", "bodyText": "Sure - in fact, your suggestion led to me to realize I can simplify this even further, by checking success prior to this special handling.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481416159", "createdAt": "2020-09-01T20:37:08Z", "author": {"login": "goaway"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -96,131 +95,109 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n \n   ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n   if (end_stream) {\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n+    // If the stream is not locally closed, the HCM will fire resetStream subsequently. However, we will see\n+    // that the stream is already gone from the streams_ map, and direct Envoy to runResetCallbacks() without\n+    // redundantly calling on onReset().\n+    // @see Dispatcher::DirectStreamCallbacks::resetStream.\n+    onReset();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNTc5Ng=="}, "originalCommit": {"oid": "851b92691071bd941f217512cbd27004a9813b24"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTQ1OTc4OnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoxNjoxOVrOHLAltQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoxNjoxOVrOHLAltQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNjAzNw==", "bodyText": "I would probably inline this where it's called. I don't think it's worth moving out, for the same reason I commented on above (all closure logic in one place).", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481306037", "createdAt": "2020-09-01T17:16:19Z", "author": {"login": "mattklein123"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -96,131 +95,109 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n \n   ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n   if (end_stream) {\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n+    // If the stream is not locally closed, the HCM will fire resetStream subsequently. However, we will see\n+    // that the stream is already gone from the streams_ map, and direct Envoy to runResetCallbacks() without\n+    // redundantly calling on onReset().\n+    // @see Dispatcher::DirectStreamCallbacks::resetStream.\n+    onReset();\n   }\n }\n \n+void Dispatcher::DirectStreamCallbacks::mapLocalDataToError(Buffer::Instance& data, bool end_stream) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "851b92691071bd941f217512cbd27004a9813b24"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDMwOTY2OnYy", "diffSide": "LEFT", "path": "test/common/http/dispatcher_test.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToyNDoyNVrOHLIyGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTo1Mjo1NlrOHLJkDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MDI4Mg==", "bodyText": "What was the failure here? Shouldn't the race two ordering possibilities between local and remote reset still be covered?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481440282", "createdAt": "2020-09-01T21:24:25Z", "author": {"login": "junr03"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -1273,100 +1273,6 @@ TEST_F(DispatcherTest, StreamResetAfterOnComplete) {\n   ASSERT_EQ(cc.on_cancel_calls, 0);\n }\n \n-TEST_F(DispatcherTest, ResetStreamLocalHeadersRemoteRaceLocalWins) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1MzA3MQ==", "bodyText": "There is no more race - because of serialization, it's just a matter of ordering, which is covered elsewhere. The specific failure here was that the synchronization point no longer gated what it originally did - cleanup happened before it instead of after. But it's also no longer relevant to the implementation. And the test would no longer be meaningful for what it was covering if I were to simply move the sync point.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481453071", "createdAt": "2020-09-01T21:52:56Z", "author": {"login": "goaway"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -1273,100 +1273,6 @@ TEST_F(DispatcherTest, StreamResetAfterOnComplete) {\n   ASSERT_EQ(cc.on_cancel_calls, 0);\n }\n \n-TEST_F(DispatcherTest, ResetStreamLocalHeadersRemoteRaceLocalWins) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MDI4Mg=="}, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDMyMDQwOnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToyNzoyMFrOHLI4aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToyNzoyMFrOHLI4aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MTg5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as\n          \n          \n            \n              // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which Envoy Mobile treats as\n          \n      \n    \n    \n  \n\nnit", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481441897", "createdAt": "2020-09-01T21:27:20Z", "author": {"login": "junr03"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -34,50 +34,59 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n   ENVOY_LOG(debug, \"[S{}] response headers for stream (end_stream={}):\\n{}\",\n             direct_stream_.stream_handle_, end_stream, headers);\n \n-  uint64_t response_status = Utility::getResponseStatus(headers);\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n \n-  // Record received status to report success or failure stat in\n-  // Dispatcher::DirectStreamCallbacks::closeRemote. Not reported here to avoid more complexity with\n-  // checking end stream, and the potential for stream reset, thus resulting in mis-reporting.\n-  observed_success_ = CodeUtility::is2xx(response_status);\n+  uint64_t response_status = Utility::getResponseStatus(headers);\n+  // Track success for later bookkeeping (stream could still be reset).\n+  success_ = CodeUtility::is2xx(response_status);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  if (end_stream) {\n+    closeStream();\n   }\n \n   // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n   // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n   // make this possible, but nothing expedient. For the immediate term this is our only real\n   // option. See https://github.com/lyft/envoy-mobile/issues/460\n \n-  // The presence of EnvoyUpstreamServiceTime implies these headers are not due to a local reply.\n-  if (headers.get(Headers::get().EnvoyUpstreamServiceTime) != nullptr) {\n-    // Testing hook.\n-    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n-                direct_stream_.stream_handle_, end_stream, headers);\n-      bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n-                                   bridge_callbacks_.context);\n-      closeRemote(end_stream);\n+  // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDMyNzE5OnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToyOTozNVrOHLI8eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTo1MzozNlrOHLJlDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MjkzNg==", "bodyText": "looks like in the 200 case we are firing onComplete() in mapLocalResponseToError and then onRese() here?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481442936", "createdAt": "2020-09-01T21:29:35Z", "author": {"login": "junr03"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -34,50 +34,59 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n   ENVOY_LOG(debug, \"[S{}] response headers for stream (end_stream={}):\\n{}\",\n             direct_stream_.stream_handle_, end_stream, headers);\n \n-  uint64_t response_status = Utility::getResponseStatus(headers);\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n \n-  // Record received status to report success or failure stat in\n-  // Dispatcher::DirectStreamCallbacks::closeRemote. Not reported here to avoid more complexity with\n-  // checking end stream, and the potential for stream reset, thus resulting in mis-reporting.\n-  observed_success_ = CodeUtility::is2xx(response_status);\n+  uint64_t response_status = Utility::getResponseStatus(headers);\n+  // Track success for later bookkeeping (stream could still be reset).\n+  success_ = CodeUtility::is2xx(response_status);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  if (end_stream) {\n+    closeStream();\n   }\n \n   // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n   // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n   // make this possible, but nothing expedient. For the immediate term this is our only real\n   // option. See https://github.com/lyft/envoy-mobile/issues/460\n \n-  // The presence of EnvoyUpstreamServiceTime implies these headers are not due to a local reply.\n-  if (headers.get(Headers::get().EnvoyUpstreamServiceTime) != nullptr) {\n-    // Testing hook.\n-    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n-                direct_stream_.stream_handle_, end_stream, headers);\n-      bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n-                                   bridge_callbacks_.context);\n-      closeRemote(end_stream);\n+  // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as\n+  // a stream error.\n+  if (!success_ && headers.get(Headers::get().EnvoyUpstreamServiceTime) == nullptr) {\n+    ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n+    mapLocalResponseToError(headers, end_stream);\n+    if (end_stream) {\n+      onReset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1MzMyNQ==", "bodyText": "Actually the 200 case will never match because I check success first - I just forgot to delete it.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481453325", "createdAt": "2020-09-01T21:53:36Z", "author": {"login": "goaway"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -34,50 +34,59 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n   ENVOY_LOG(debug, \"[S{}] response headers for stream (end_stream={}):\\n{}\",\n             direct_stream_.stream_handle_, end_stream, headers);\n \n-  uint64_t response_status = Utility::getResponseStatus(headers);\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n \n-  // Record received status to report success or failure stat in\n-  // Dispatcher::DirectStreamCallbacks::closeRemote. Not reported here to avoid more complexity with\n-  // checking end stream, and the potential for stream reset, thus resulting in mis-reporting.\n-  observed_success_ = CodeUtility::is2xx(response_status);\n+  uint64_t response_status = Utility::getResponseStatus(headers);\n+  // Track success for later bookkeeping (stream could still be reset).\n+  success_ = CodeUtility::is2xx(response_status);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  if (end_stream) {\n+    closeStream();\n   }\n \n   // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n   // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n   // make this possible, but nothing expedient. For the immediate term this is our only real\n   // option. See https://github.com/lyft/envoy-mobile/issues/460\n \n-  // The presence of EnvoyUpstreamServiceTime implies these headers are not due to a local reply.\n-  if (headers.get(Headers::get().EnvoyUpstreamServiceTime) != nullptr) {\n-    // Testing hook.\n-    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n-                direct_stream_.stream_handle_, end_stream, headers);\n-      bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n-                                   bridge_callbacks_.context);\n-      closeRemote(end_stream);\n+  // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as\n+  // a stream error.\n+  if (!success_ && headers.get(Headers::get().EnvoyUpstreamServiceTime) == nullptr) {\n+    ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n+    mapLocalResponseToError(headers, end_stream);\n+    if (end_stream) {\n+      onReset();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0MjkzNg=="}, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDM1MzQ5OnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTozODoyOVrOHLJL4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjowMjowMFrOHLJy2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0Njg4MA==", "bodyText": "I wonder if we should move stats charging to closeStream so that it is only done there, and we don't have a chance of double counting?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481446880", "createdAt": "2020-09-01T21:38:29Z", "author": {"login": "junr03"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -93,134 +102,93 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n       absl::SimpleAtoi(headers.EnvoyAttemptCount()->value().getStringView(), &attempt_count)) {\n     error_attempt_count_ = attempt_count;\n   }\n-\n-  ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n-  if (end_stream) {\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n-  }\n }\n \n void Dispatcher::DirectStreamCallbacks::encodeData(Buffer::Instance& data, bool end_stream) {\n   ENVOY_LOG(debug, \"[S{}] response data for stream (length={} end_stream={})\",\n             direct_stream_.stream_handle_, data.length(), end_stream);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n+  if (end_stream) {\n+    closeStream();\n   }\n \n-  if (!error_code_.has_value()) {\n-    // Testing hook.\n-    if (end_stream) {\n-      http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_final_data\");\n-    }\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response data for stream (length={} end_stream={})\",\n-                direct_stream_.stream_handle_, data.length(), end_stream);\n-      bridge_callbacks_.on_data(Buffer::Utility::toBridgeData(data), end_stream,\n-                                bridge_callbacks_.context);\n-      closeRemote(end_stream);\n-    }\n-  } else {\n-    ASSERT(end_stream, \"local response has to end the stream with a data frame. If Envoy changes \"\n-                       \"this expectation, this code needs to be updated.\");\n+  // Error path.\n+  if (error_code_.has_value()) {\n+    ASSERT(end_stream,\n+           \"local response has to end the stream with a single data frame. If Envoy changes \"\n+           \"this expectation, this code needs to be updated.\");\n     error_message_ = Buffer::Utility::toBridgeData(data);\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n+    onReset();\n+    return;\n+  }\n+\n+  // Normal path.\n+\n+  // Testing hook.\n+  if (end_stream) {\n+    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_final_data\");\n+  }\n+\n+  ENVOY_LOG(debug,\n+            \"[S{}] dispatching to platform response data for stream (length={} end_stream={})\",\n+            direct_stream_.stream_handle_, data.length(), end_stream);\n+  bridge_callbacks_.on_data(Buffer::Utility::toBridgeData(data), end_stream,\n+                            bridge_callbacks_.context);\n+  if (end_stream) {\n+    onComplete();\n   }\n }\n \n void Dispatcher::DirectStreamCallbacks::encodeTrailers(const ResponseTrailerMap& trailers) {\n   ENVOY_LOG(debug, \"[S{}] response trailers for stream:\\n{}\", direct_stream_.stream_handle_,\n             trailers);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n-  }\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n+  closeStream(); // Trailers always indicate the end of the stream.\n \n-  if (direct_stream_.dispatchable(true)) {\n-    ENVOY_LOG(debug, \"[S{}] dispatching to platform response trailers for stream:\\n{}\",\n-              direct_stream_.stream_handle_, trailers);\n-    bridge_callbacks_.on_trailers(Utility::toBridgeHeaders(trailers), bridge_callbacks_.context);\n-    closeRemote(true);\n-  }\n+  ENVOY_LOG(debug, \"[S{}] dispatching to platform response trailers for stream:\\n{}\",\n+            direct_stream_.stream_handle_, trailers);\n+  bridge_callbacks_.on_trailers(Utility::toBridgeHeaders(trailers), bridge_callbacks_.context);\n+  onComplete();\n }\n \n-// n.b: all calls to closeRemote are guarded by a call to dispatchable. Hence the on_complete call\n-// here does not, and should not call dispatchable.\n-void Dispatcher::DirectStreamCallbacks::closeRemote(bool end_stream) {\n-  if (end_stream) {\n-    // Envoy itself does not currently allow half-open streams where the local half is open\n-    // but the remote half is closed. Therefore, we fire the on_complete callback\n-    // to the platform layer whenever remote closes.\n-    ENVOY_LOG(debug, \"[S{}] complete stream (success={})\", direct_stream_.stream_handle_,\n-              observed_success_);\n-    if (observed_success_) {\n-      http_dispatcher_.stats().stream_success_.inc();\n-    } else {\n-      http_dispatcher_.stats().stream_failure_.inc();\n-    }\n-    bridge_callbacks_.on_complete(bridge_callbacks_.context);\n-    // Likewise cleanup happens whenever remote closes even though\n-    // local might be open. Note that if local is open Envoy will reset the stream. Calling cleanup\n-    // here is fine because the stream reset will come through synchronously in the same thread as\n-    // this closeRemote code. Because DirectStream deletion is deferred, the deletion will happen\n-    // necessarily after the reset occurs. Thus Dispatcher::DirectStreamCallbacks::onReset will\n-    // **not** have a dangling reference.\n-    ENVOY_LOG(debug, \"[S{}] scheduling cleanup\", direct_stream_.stream_handle_);\n-    http_dispatcher_.cleanup(direct_stream_.stream_handle_);\n-  }\n+void Dispatcher::DirectStreamCallbacks::closeStream() {\n+  // Envoy itself does not currently allow half-open streams where the local half is open\n+  // but the remote half is closed. Note that if local is open, Envoy will reset the stream.\n+  http_dispatcher_.removeStream(direct_stream_.stream_handle_);\n }\n \n-Stream& Dispatcher::DirectStreamCallbacks::getStream() { return direct_stream_; }\n+void Dispatcher::DirectStreamCallbacks::onComplete() {\n+  ENVOY_LOG(debug, \"[S{}] complete stream (success={})\", direct_stream_.stream_handle_, success_);\n+  if (success_) {\n+    http_dispatcher_.stats().stream_success_.inc();\n+  } else {\n+    http_dispatcher_.stats().stream_failure_.inc();\n+  }\n+  bridge_callbacks_.on_complete(bridge_callbacks_.context);\n+}\n \n void Dispatcher::DirectStreamCallbacks::onReset() {\n   ENVOY_LOG(debug, \"[S{}] remote reset stream\", direct_stream_.stream_handle_);\n+\n+  // The stream should no longer be preset in the map, because onReset() was either called from a\n+  // terminal callback that mapped to an error or it was called in response to a resetStream().\n+  ASSERT(!http_dispatcher_.getStream(direct_stream_.stream_handle_));\n   envoy_error_code_t code = error_code_.value_or(ENVOY_STREAM_RESET);\n   envoy_data message = error_message_.value_or(envoy_nodata);\n   int32_t attempt_count = error_attempt_count_.value_or(-1);\n \n   // Testing hook.\n   http_dispatcher_.synchronizer_.syncPoint(\"dispatch_on_error\");\n \n-  // direct_stream_ will not be a dangling reference even in the case that closeRemote cleaned up\n-  // because in that case this reset is happening synchronously, with the encoding call that called\n-  // closeRemote, in the Envoy Main thread. Hence DirectStream destruction which is posted on the\n-  // Envoy Main thread's event loop will strictly happen after this direct_stream_ reference is\n-  // used. @see Dispatcher::DirectStreamCallbacks::closeRemote() for more details.\n-  if (direct_stream_.dispatchable(true)) {\n-    ENVOY_LOG(debug, \"[S{}] dispatching to platform remote reset stream\",\n-              direct_stream_.stream_handle_);\n-    // Only count the on error if it is dispatchable. Otherwise, the onReset was caused due to a\n-    // client side cancel via Dispatcher::DirectStream::resetStream().\n-    http_dispatcher_.stats().stream_failure_.inc();\n-    bridge_callbacks_.on_error({code, message, attempt_count}, bridge_callbacks_.context);\n-\n-    // All the terminal callbacks only cleanup if they are dispatchable.\n-    // This ensures that cleanup will happen exactly one time.\n-    http_dispatcher_.cleanup(direct_stream_.stream_handle_);\n-  }\n+  ENVOY_LOG(debug, \"[S{}] dispatching to platform remote reset stream\",\n+            direct_stream_.stream_handle_);\n+  http_dispatcher_.stats().stream_failure_.inc();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1Njg1OA==", "bodyText": "Stats are charged on each of the terminal paths of which only one will be called per stream - onReset, onComplete, and onCancel. closeStream on the other hand is not guaranteed to be called.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481456858", "createdAt": "2020-09-01T22:02:00Z", "author": {"login": "goaway"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -93,134 +102,93 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n       absl::SimpleAtoi(headers.EnvoyAttemptCount()->value().getStringView(), &attempt_count)) {\n     error_attempt_count_ = attempt_count;\n   }\n-\n-  ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n-  if (end_stream) {\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n-  }\n }\n \n void Dispatcher::DirectStreamCallbacks::encodeData(Buffer::Instance& data, bool end_stream) {\n   ENVOY_LOG(debug, \"[S{}] response data for stream (length={} end_stream={})\",\n             direct_stream_.stream_handle_, data.length(), end_stream);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n+  if (end_stream) {\n+    closeStream();\n   }\n \n-  if (!error_code_.has_value()) {\n-    // Testing hook.\n-    if (end_stream) {\n-      http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_final_data\");\n-    }\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response data for stream (length={} end_stream={})\",\n-                direct_stream_.stream_handle_, data.length(), end_stream);\n-      bridge_callbacks_.on_data(Buffer::Utility::toBridgeData(data), end_stream,\n-                                bridge_callbacks_.context);\n-      closeRemote(end_stream);\n-    }\n-  } else {\n-    ASSERT(end_stream, \"local response has to end the stream with a data frame. If Envoy changes \"\n-                       \"this expectation, this code needs to be updated.\");\n+  // Error path.\n+  if (error_code_.has_value()) {\n+    ASSERT(end_stream,\n+           \"local response has to end the stream with a single data frame. If Envoy changes \"\n+           \"this expectation, this code needs to be updated.\");\n     error_message_ = Buffer::Utility::toBridgeData(data);\n-    // The local stream may or may not have completed.\n-    // If the local is not closed envoy will fire the reset for us.\n-    // @see Dispatcher::DirectStreamCallbacks::closeRemote.\n-    // Otherwise fire the reset from here.\n-    if (direct_stream_.local_closed_) {\n-      onReset();\n-    }\n+    onReset();\n+    return;\n+  }\n+\n+  // Normal path.\n+\n+  // Testing hook.\n+  if (end_stream) {\n+    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_final_data\");\n+  }\n+\n+  ENVOY_LOG(debug,\n+            \"[S{}] dispatching to platform response data for stream (length={} end_stream={})\",\n+            direct_stream_.stream_handle_, data.length(), end_stream);\n+  bridge_callbacks_.on_data(Buffer::Utility::toBridgeData(data), end_stream,\n+                            bridge_callbacks_.context);\n+  if (end_stream) {\n+    onComplete();\n   }\n }\n \n void Dispatcher::DirectStreamCallbacks::encodeTrailers(const ResponseTrailerMap& trailers) {\n   ENVOY_LOG(debug, \"[S{}] response trailers for stream:\\n{}\", direct_stream_.stream_handle_,\n             trailers);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n-  }\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n+  closeStream(); // Trailers always indicate the end of the stream.\n \n-  if (direct_stream_.dispatchable(true)) {\n-    ENVOY_LOG(debug, \"[S{}] dispatching to platform response trailers for stream:\\n{}\",\n-              direct_stream_.stream_handle_, trailers);\n-    bridge_callbacks_.on_trailers(Utility::toBridgeHeaders(trailers), bridge_callbacks_.context);\n-    closeRemote(true);\n-  }\n+  ENVOY_LOG(debug, \"[S{}] dispatching to platform response trailers for stream:\\n{}\",\n+            direct_stream_.stream_handle_, trailers);\n+  bridge_callbacks_.on_trailers(Utility::toBridgeHeaders(trailers), bridge_callbacks_.context);\n+  onComplete();\n }\n \n-// n.b: all calls to closeRemote are guarded by a call to dispatchable. Hence the on_complete call\n-// here does not, and should not call dispatchable.\n-void Dispatcher::DirectStreamCallbacks::closeRemote(bool end_stream) {\n-  if (end_stream) {\n-    // Envoy itself does not currently allow half-open streams where the local half is open\n-    // but the remote half is closed. Therefore, we fire the on_complete callback\n-    // to the platform layer whenever remote closes.\n-    ENVOY_LOG(debug, \"[S{}] complete stream (success={})\", direct_stream_.stream_handle_,\n-              observed_success_);\n-    if (observed_success_) {\n-      http_dispatcher_.stats().stream_success_.inc();\n-    } else {\n-      http_dispatcher_.stats().stream_failure_.inc();\n-    }\n-    bridge_callbacks_.on_complete(bridge_callbacks_.context);\n-    // Likewise cleanup happens whenever remote closes even though\n-    // local might be open. Note that if local is open Envoy will reset the stream. Calling cleanup\n-    // here is fine because the stream reset will come through synchronously in the same thread as\n-    // this closeRemote code. Because DirectStream deletion is deferred, the deletion will happen\n-    // necessarily after the reset occurs. Thus Dispatcher::DirectStreamCallbacks::onReset will\n-    // **not** have a dangling reference.\n-    ENVOY_LOG(debug, \"[S{}] scheduling cleanup\", direct_stream_.stream_handle_);\n-    http_dispatcher_.cleanup(direct_stream_.stream_handle_);\n-  }\n+void Dispatcher::DirectStreamCallbacks::closeStream() {\n+  // Envoy itself does not currently allow half-open streams where the local half is open\n+  // but the remote half is closed. Note that if local is open, Envoy will reset the stream.\n+  http_dispatcher_.removeStream(direct_stream_.stream_handle_);\n }\n \n-Stream& Dispatcher::DirectStreamCallbacks::getStream() { return direct_stream_; }\n+void Dispatcher::DirectStreamCallbacks::onComplete() {\n+  ENVOY_LOG(debug, \"[S{}] complete stream (success={})\", direct_stream_.stream_handle_, success_);\n+  if (success_) {\n+    http_dispatcher_.stats().stream_success_.inc();\n+  } else {\n+    http_dispatcher_.stats().stream_failure_.inc();\n+  }\n+  bridge_callbacks_.on_complete(bridge_callbacks_.context);\n+}\n \n void Dispatcher::DirectStreamCallbacks::onReset() {\n   ENVOY_LOG(debug, \"[S{}] remote reset stream\", direct_stream_.stream_handle_);\n+\n+  // The stream should no longer be preset in the map, because onReset() was either called from a\n+  // terminal callback that mapped to an error or it was called in response to a resetStream().\n+  ASSERT(!http_dispatcher_.getStream(direct_stream_.stream_handle_));\n   envoy_error_code_t code = error_code_.value_or(ENVOY_STREAM_RESET);\n   envoy_data message = error_message_.value_or(envoy_nodata);\n   int32_t attempt_count = error_attempt_count_.value_or(-1);\n \n   // Testing hook.\n   http_dispatcher_.synchronizer_.syncPoint(\"dispatch_on_error\");\n \n-  // direct_stream_ will not be a dangling reference even in the case that closeRemote cleaned up\n-  // because in that case this reset is happening synchronously, with the encoding call that called\n-  // closeRemote, in the Envoy Main thread. Hence DirectStream destruction which is posted on the\n-  // Envoy Main thread's event loop will strictly happen after this direct_stream_ reference is\n-  // used. @see Dispatcher::DirectStreamCallbacks::closeRemote() for more details.\n-  if (direct_stream_.dispatchable(true)) {\n-    ENVOY_LOG(debug, \"[S{}] dispatching to platform remote reset stream\",\n-              direct_stream_.stream_handle_);\n-    // Only count the on error if it is dispatchable. Otherwise, the onReset was caused due to a\n-    // client side cancel via Dispatcher::DirectStream::resetStream().\n-    http_dispatcher_.stats().stream_failure_.inc();\n-    bridge_callbacks_.on_error({code, message, attempt_count}, bridge_callbacks_.context);\n-\n-    // All the terminal callbacks only cleanup if they are dispatchable.\n-    // This ensures that cleanup will happen exactly one time.\n-    http_dispatcher_.cleanup(direct_stream_.stream_handle_);\n-  }\n+  ENVOY_LOG(debug, \"[S{}] dispatching to platform remote reset stream\",\n+            direct_stream_.stream_handle_);\n+  http_dispatcher_.stats().stream_failure_.inc();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0Njg4MA=="}, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDM1NjU1OnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTozOTozNlrOHLJNug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTozOTozNlrOHLJNug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NzM1NA==", "bodyText": "drop a comment that this is the expectation in higher layers, like the h2 codec does?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481447354", "createdAt": "2020-09-01T21:39:36Z", "author": {"login": "junr03"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -234,38 +202,24 @@ Dispatcher::DirectStream::~DirectStream() {\n }\n \n void Dispatcher::DirectStream::resetStream(StreamResetReason reason) {\n-  // The Http::ConnectionManager does not destroy the stream in doEndStream() when it calls\n-  // resetStream on the response_encoder_'s Stream. It is up to the response_encoder_ to\n-  // runResetCallbacks in order to have the Http::ConnectionManager call doDeferredStreamDestroy in\n-  // ConnectionManagerImpl::ActiveStream::onResetStream.\n-  //\n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks for an explanation if\n-  // this if guard.\n-  if (!hcm_stream_pending_destroy_) {\n-    hcm_stream_pending_destroy_ = true;\n-    runResetCallbacks(reason);\n+  runResetCallbacks(reason);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 288}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDM1Nzk3OnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTo0MDowOVrOHLJOoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTo0MDowOVrOHLJOoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NzU4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // our streams_ map due to the remote closure.\n          \n          \n            \n                // streams_ map due to the remote closure.\n          \n      \n    \n    \n  \n\nnit", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481447584", "createdAt": "2020-09-01T21:40:09Z", "author": {"login": "junr03"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -234,38 +202,24 @@ Dispatcher::DirectStream::~DirectStream() {\n }\n \n void Dispatcher::DirectStream::resetStream(StreamResetReason reason) {\n-  // The Http::ConnectionManager does not destroy the stream in doEndStream() when it calls\n-  // resetStream on the response_encoder_'s Stream. It is up to the response_encoder_ to\n-  // runResetCallbacks in order to have the Http::ConnectionManager call doDeferredStreamDestroy in\n-  // ConnectionManagerImpl::ActiveStream::onResetStream.\n-  //\n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks for an explanation if\n-  // this if guard.\n-  if (!hcm_stream_pending_destroy_) {\n-    hcm_stream_pending_destroy_ = true;\n-    runResetCallbacks(reason);\n+  runResetCallbacks(reason);\n+  if (!parent_.getStream(stream_handle_)) {\n+    // We don't assert here, because Envoy will issue a stream reset if a stream closes remotely\n+    // while still open locally. In this case the stream will already have been removed from\n+    // our streams_ map due to the remote closure.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDM1OTQ1OnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTo0MDozOFrOHLJPfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMTo0MDozOFrOHLJPfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NzgwNg==", "bodyText": "this is out of place now?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481447806", "createdAt": "2020-09-01T21:40:38Z", "author": {"login": "junr03"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -234,38 +202,24 @@ Dispatcher::DirectStream::~DirectStream() {\n }\n \n void Dispatcher::DirectStream::resetStream(StreamResetReason reason) {\n-  // The Http::ConnectionManager does not destroy the stream in doEndStream() when it calls\n-  // resetStream on the response_encoder_'s Stream. It is up to the response_encoder_ to\n-  // runResetCallbacks in order to have the Http::ConnectionManager call doDeferredStreamDestroy in\n-  // ConnectionManagerImpl::ActiveStream::onResetStream.\n-  //\n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks for an explanation if\n-  // this if guard.\n-  if (!hcm_stream_pending_destroy_) {\n-    hcm_stream_pending_destroy_ = true;\n-    runResetCallbacks(reason);\n+  runResetCallbacks(reason);\n+  if (!parent_.getStream(stream_handle_)) {\n+    // We don't assert here, because Envoy will issue a stream reset if a stream closes remotely\n+    // while still open locally. In this case the stream will already have been removed from\n+    // our streams_ map due to the remote closure.\n+\n+    // The Http::ConnectionManager does not destroy the stream in doEndStream() when it calls\n+    // resetStream on the response_encoder_'s Stream. It is up to the response_encoder_ to\n+    // runResetCallbacks in order to have the Http::ConnectionManager call doDeferredStreamDestroy\n+    // in ConnectionManagerImpl::ActiveStream::onResetStream.\n+    // TODO: explore an upstream fix to get the HCM to clean up ActiveStream itself.\n+    // runResetCallbacks(reason);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faffc8cf42892ce1a7327d51ed9581c474ff4d37"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDUyODYzOnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo0NzozM1rOHLK1Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo0NzozM1rOHLK1Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3Mzg1MQ==", "bodyText": "unused param ^", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1061#discussion_r481473851", "createdAt": "2020-09-01T22:47:33Z", "author": {"login": "junr03"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -34,53 +34,53 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n   ENVOY_LOG(debug, \"[S{}] response headers for stream (end_stream={}):\\n{}\",\n             direct_stream_.stream_handle_, end_stream, headers);\n \n-  uint64_t response_status = Utility::getResponseStatus(headers);\n+  ASSERT(http_dispatcher_.getStream(direct_stream_.stream_handle_));\n \n-  // Record received status to report success or failure stat in\n-  // Dispatcher::DirectStreamCallbacks::closeRemote. Not reported here to avoid more complexity with\n-  // checking end stream, and the potential for stream reset, thus resulting in mis-reporting.\n-  observed_success_ = CodeUtility::is2xx(response_status);\n+  uint64_t response_status = Utility::getResponseStatus(headers);\n+  // Track success for later bookkeeping (stream could still be reset).\n+  success_ = CodeUtility::is2xx(response_status);\n \n-  // @see Dispatcher::resetStream's comment on its call to runResetCallbacks.\n-  // Envoy only deferredDeletes the ActiveStream if it was fully closed otherwise it issues a reset.\n-  if (direct_stream_.local_closed_ && end_stream) {\n-    direct_stream_.hcm_stream_pending_destroy_ = true;\n+  if (end_stream) {\n+    closeStream();\n   }\n \n   // TODO: ***HACK*** currently Envoy sends local replies in cases where an error ought to be\n   // surfaced via the error path. There are ways we can clean up Envoy's local reply path to\n   // make this possible, but nothing expedient. For the immediate term this is our only real\n   // option. See https://github.com/lyft/envoy-mobile/issues/460\n \n-  // The presence of EnvoyUpstreamServiceTime implies these headers are not due to a local reply.\n-  if (headers.get(Headers::get().EnvoyUpstreamServiceTime) != nullptr) {\n-    // Testing hook.\n-    http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n-\n-    if (direct_stream_.dispatchable(end_stream)) {\n-      ENVOY_LOG(debug,\n-                \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n-                direct_stream_.stream_handle_, end_stream, headers);\n-      bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n-                                   bridge_callbacks_.context);\n-      closeRemote(end_stream);\n+  // Error path: missing EnvoyUpstreamServiceTime implies this is a local reply, which we treat as\n+  // a stream error.\n+  if (!success_ && headers.get(Headers::get().EnvoyUpstreamServiceTime) == nullptr) {\n+    ENVOY_LOG(debug, \"[S{}] intercepted local response\", direct_stream_.stream_handle_);\n+    mapLocalResponseToError(headers, end_stream);\n+    if (end_stream) {\n+      onReset();\n     }\n     return;\n   }\n \n+  // Normal response path.\n+\n+  // Testing hook.\n+  http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n+\n+  ENVOY_LOG(debug, \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n+            direct_stream_.stream_handle_, end_stream, headers);\n+  bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n+                               bridge_callbacks_.context);\n+  if (end_stream) {\n+    onComplete();\n+  }\n+}\n+\n+void Dispatcher::DirectStreamCallbacks::mapLocalResponseToError(const ResponseHeaderMap& headers,\n+                                                                bool end_stream) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf79f94c7c573a27c476d251dd366c5e336f97f0"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 594, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}