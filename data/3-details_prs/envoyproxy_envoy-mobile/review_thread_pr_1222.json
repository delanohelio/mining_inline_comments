{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyODA2NTg3", "number": 1222, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxMzoxMTozMFrOFLsCfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxODoxMToyNFrOFNzmlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3ODAwMTg5OnYy", "diffSide": "RIGHT", "path": "library/cc/bridge_utility.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxMzoxMTozMFrOIO_sHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxMzoxMTozMFrOIO_sHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjU5NDQ2MQ==", "bodyText": "Presumably we don't need this anymore?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1222#discussion_r552594461", "createdAt": "2021-01-06T13:11:30Z", "author": {"login": "goaway"}, "path": "library/cc/bridge_utility.cc", "diffHunk": "@@ -0,0 +1,115 @@\n+#include \"bridge_utility.h\"\n+\n+#include <sstream>\n+\n+namespace Envoy {\n+namespace Platform {\n+\n+// TODO(crockeo): we always copy memory across boundaries; consider allowing for moves and/or\n+// shared ownership w/ reference counting via envoy-mobile's release callbacks\n+\n+envoy_data buffer_as_envoy_data(const std::vector<uint8_t>& data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7018dc5f5f85395dad1a9e23a24c23271a1c251f"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3ODAxNjI3OnYy", "diffSide": "RIGHT", "path": "library/cc/bridge_utility.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxMzoxNDozM1rOIO_1Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxMzoxNDozM1rOIO_1Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjU5Njc2Nw==", "bodyText": "I think this is maybe the wrong size - since the number of entries in the map won't account for header names that have multiple values.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1222#discussion_r552596767", "createdAt": "2021-01-06T13:14:33Z", "author": {"login": "goaway"}, "path": "library/cc/bridge_utility.cc", "diffHunk": "@@ -0,0 +1,115 @@\n+#include \"bridge_utility.h\"\n+\n+#include <sstream>\n+\n+namespace Envoy {\n+namespace Platform {\n+\n+// TODO(crockeo): we always copy memory across boundaries; consider allowing for moves and/or\n+// shared ownership w/ reference counting via envoy-mobile's release callbacks\n+\n+envoy_data buffer_as_envoy_data(const std::vector<uint8_t>& data) {\n+  size_t byte_len = sizeof(uint8_t) * data.size();\n+\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(byte_len));\n+  memcpy(bytes, &data[0], byte_len);\n+  envoy_data raw_data{\n+      .length = byte_len,\n+      .bytes = bytes,\n+      .release = envoy_noop_release,\n+      .context = nullptr,\n+  };\n+\n+  return raw_data;\n+}\n+\n+envoy_data string_as_envoy_data(const std::string& data) {\n+  size_t byte_len = sizeof(uint8_t) * data.size();\n+\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(byte_len));\n+  memcpy(bytes, &data[0], byte_len);\n+  envoy_data raw_data{\n+      .length = byte_len,\n+      .bytes = bytes,\n+      .release = envoy_noop_release,\n+      .context = nullptr,\n+  };\n+\n+  return raw_data;\n+}\n+\n+envoy_headers raw_headers_as_envoy_headers(const RawHeaders& headers) {\n+  envoy_header* headers_list =\n+      static_cast<envoy_header*>(safe_malloc(sizeof(envoy_header) * headers.size()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7018dc5f5f85395dad1a9e23a24c23271a1c251f"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3ODAyNTU2OnYy", "diffSide": "RIGHT", "path": "library/cc/bridge_utility.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxMzoxNjoxMVrOIO_7CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxMzoxNjoxMVrOIO_7CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjU5ODI4MQ==", "bodyText": "Need to check if the map already has a values entry for this header name, I believe.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1222#discussion_r552598281", "createdAt": "2021-01-06T13:16:11Z", "author": {"login": "goaway"}, "path": "library/cc/bridge_utility.cc", "diffHunk": "@@ -0,0 +1,115 @@\n+#include \"bridge_utility.h\"\n+\n+#include <sstream>\n+\n+namespace Envoy {\n+namespace Platform {\n+\n+// TODO(crockeo): we always copy memory across boundaries; consider allowing for moves and/or\n+// shared ownership w/ reference counting via envoy-mobile's release callbacks\n+\n+envoy_data buffer_as_envoy_data(const std::vector<uint8_t>& data) {\n+  size_t byte_len = sizeof(uint8_t) * data.size();\n+\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(byte_len));\n+  memcpy(bytes, &data[0], byte_len);\n+  envoy_data raw_data{\n+      .length = byte_len,\n+      .bytes = bytes,\n+      .release = envoy_noop_release,\n+      .context = nullptr,\n+  };\n+\n+  return raw_data;\n+}\n+\n+envoy_data string_as_envoy_data(const std::string& data) {\n+  size_t byte_len = sizeof(uint8_t) * data.size();\n+\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(byte_len));\n+  memcpy(bytes, &data[0], byte_len);\n+  envoy_data raw_data{\n+      .length = byte_len,\n+      .bytes = bytes,\n+      .release = envoy_noop_release,\n+      .context = nullptr,\n+  };\n+\n+  return raw_data;\n+}\n+\n+envoy_headers raw_headers_as_envoy_headers(const RawHeaders& headers) {\n+  envoy_header* headers_list =\n+      static_cast<envoy_header*>(safe_malloc(sizeof(envoy_header) * headers.size()));\n+\n+  std::ostringstream value_fmt;\n+  size_t i = 0;\n+  for (const auto& pair : headers) {\n+    const auto& key = pair.first;\n+    const auto& values = pair.second;\n+\n+    for (size_t i = 0; i < values.size(); i++) {\n+      value_fmt << values[i];\n+      if (i != values.size() - 1) {\n+        value_fmt << \",\";\n+      }\n+    }\n+\n+    envoy_header& header = headers_list[i++];\n+    header.key = string_as_envoy_data(key);\n+    header.value = string_as_envoy_data(value_fmt.str());\n+\n+    value_fmt.str(\"\");\n+    value_fmt.clear();\n+  }\n+\n+  envoy_headers raw_headers{\n+      .length = static_cast<envoy_header_size_t>(headers.size()),\n+      .headers = headers_list,\n+  };\n+  return raw_headers;\n+}\n+\n+std::vector<uint8_t> envoy_data_as_buffer(envoy_data raw_data) {\n+  size_t len = raw_data.length / sizeof(uint8_t);\n+\n+  std::vector<uint8_t> buffer;\n+  buffer.resize(len);\n+  memcpy(&buffer[0], raw_data.bytes, raw_data.length);\n+\n+  return buffer;\n+}\n+\n+std::string envoy_data_as_string(envoy_data raw_data) {\n+  size_t len = raw_data.length / sizeof(uint8_t);\n+\n+  std::string str;\n+  str.resize(len);\n+  memcpy(&str[0], raw_data.bytes, raw_data.length);\n+\n+  return str;\n+}\n+\n+RawHeaders envoy_headers_as_raw_headers(envoy_headers raw_headers) {\n+  RawHeaders headers;\n+  for (auto i = 0; i < raw_headers.length; i++) {\n+    auto key = envoy_data_as_string(raw_headers.headers[i].key);\n+    auto value = envoy_data_as_string(raw_headers.headers[i].value);\n+\n+    // split the header value by \",\"\n+    std::vector<std::string> values;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7018dc5f5f85395dad1a9e23a24c23271a1c251f"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NjMxNjA3OnYy", "diffSide": "RIGHT", "path": "library/cc/bridge_utility.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMToxMjo0OFrOIQOa2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxNDowNTowMlrOIQTH3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4NDM3OQ==", "bodyText": "release should probably be free here (since you're using malloc).", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1222#discussion_r553884379", "createdAt": "2021-01-08T11:12:48Z", "author": {"login": "goaway"}, "path": "library/cc/bridge_utility.cc", "diffHunk": "@@ -0,0 +1,70 @@\n+#include \"bridge_utility.h\"\n+\n+#include <sstream>\n+\n+namespace Envoy {\n+namespace Platform {\n+\n+// TODO(crockeo): we always copy memory across boundaries; consider allowing for moves and/or\n+// shared ownership w/ reference counting via envoy-mobile's release callbacks\n+\n+envoy_data string_as_envoy_data(const std::string& str) {\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(str.size()));\n+  memcpy(bytes, &str[0], str.size());\n+  return envoy_data{\n+      .length = str.size(),\n+      .bytes = bytes,\n+      .release = envoy_noop_release,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5f4e0bf370d6829d967b726b9746052a5a813f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk2MTQzNg==", "bodyText": "ohhh my bad. i should have looked at the implementation of envoy_noop_release; i assumed that it was a free call w/o further action. in retrospect it's obviously noop = no free \ud83d\ude01", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1222#discussion_r553961436", "createdAt": "2021-01-08T14:05:02Z", "author": {"login": "crockeo"}, "path": "library/cc/bridge_utility.cc", "diffHunk": "@@ -0,0 +1,70 @@\n+#include \"bridge_utility.h\"\n+\n+#include <sstream>\n+\n+namespace Envoy {\n+namespace Platform {\n+\n+// TODO(crockeo): we always copy memory across boundaries; consider allowing for moves and/or\n+// shared ownership w/ reference counting via envoy-mobile's release callbacks\n+\n+envoy_data string_as_envoy_data(const std::string& str) {\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(str.size()));\n+  memcpy(bytes, &str[0], str.size());\n+  return envoy_data{\n+      .length = str.size(),\n+      .bytes = bytes,\n+      .release = envoy_noop_release,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4NDM3OQ=="}, "originalCommit": {"oid": "5e5f4e0bf370d6829d967b726b9746052a5a813f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NjMxNzI3OnYy", "diffSide": "RIGHT", "path": "library/cc/bridge_utility.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMToxMzoxOVrOIQObpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMToxMzoxOVrOIQObpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4NDU4MA==", "bodyText": "By library convention envoy_data should be released here.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1222#discussion_r553884580", "createdAt": "2021-01-08T11:13:19Z", "author": {"login": "goaway"}, "path": "library/cc/bridge_utility.cc", "diffHunk": "@@ -0,0 +1,70 @@\n+#include \"bridge_utility.h\"\n+\n+#include <sstream>\n+\n+namespace Envoy {\n+namespace Platform {\n+\n+// TODO(crockeo): we always copy memory across boundaries; consider allowing for moves and/or\n+// shared ownership w/ reference counting via envoy-mobile's release callbacks\n+\n+envoy_data string_as_envoy_data(const std::string& str) {\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(str.size()));\n+  memcpy(bytes, &str[0], str.size());\n+  return envoy_data{\n+      .length = str.size(),\n+      .bytes = bytes,\n+      .release = envoy_noop_release,\n+      .context = nullptr,\n+  };\n+}\n+\n+std::string envoy_data_as_string(envoy_data data) {\n+  std::string str;\n+  str.resize(data.length);\n+  memcpy(&str[0], data.bytes, data.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e5f4e0bf370d6829d967b726b9746052a5a813f"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4ODE1Njk0OnYy", "diffSide": "RIGHT", "path": "library/cc/bridge_utility.cc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMDoyMzozMlrOIQgAQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMDoyMzozMlrOIQgAQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE3MjQ4MQ==", "bodyText": "Call release_envoy_headers before returning.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1222#discussion_r554172481", "createdAt": "2021-01-08T20:23:32Z", "author": {"login": "goaway"}, "path": "library/cc/bridge_utility.cc", "diffHunk": "@@ -0,0 +1,71 @@\n+#include \"bridge_utility.h\"\n+\n+#include <sstream>\n+\n+namespace Envoy {\n+namespace Platform {\n+\n+// TODO(crockeo): we always copy memory across boundaries; consider allowing for moves and/or\n+// shared ownership w/ reference counting via envoy-mobile's release callbacks\n+\n+envoy_data string_as_envoy_data(const std::string& str) {\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(str.size()));\n+  memcpy(bytes, &str[0], str.size());\n+  return envoy_data{\n+      .length = str.size(),\n+      .bytes = bytes,\n+      .release = free,\n+      .context = nullptr,\n+  };\n+}\n+\n+std::string envoy_data_as_string(envoy_data data) {\n+  std::string str;\n+  str.resize(data.length);\n+  memcpy(&str[0], data.bytes, data.length);\n+  data.release(data.context);\n+  return str;\n+}\n+\n+envoy_headers raw_header_map_as_envoy_headers(const RawHeaderMap& headers) {\n+  size_t header_count = 0;\n+  for (const auto& pair : headers) {\n+    header_count += pair.second.size();\n+  }\n+\n+  envoy_header* headers_list =\n+      static_cast<envoy_header*>(safe_malloc(sizeof(envoy_header) * header_count));\n+\n+  size_t i = 0;\n+  for (const auto& pair : headers) {\n+    const auto& key = pair.first;\n+    for (const auto& value : pair.second) {\n+      envoy_header& header = headers_list[i++];\n+      header.key = string_as_envoy_data(key);\n+      header.value = string_as_envoy_data(value);\n+    }\n+  }\n+\n+  envoy_headers raw_headers{\n+      .length = static_cast<envoy_header_size_t>(header_count),\n+      .headers = headers_list,\n+  };\n+  return raw_headers;\n+}\n+\n+RawHeaderMap envoy_headers_as_raw_headers(envoy_headers raw_headers) {\n+  RawHeaderMap headers;\n+  for (auto i = 0; i < raw_headers.length; i++) {\n+    auto key = envoy_data_as_string(raw_headers.headers[i].key);\n+    auto value = envoy_data_as_string(raw_headers.headers[i].value);\n+\n+    if (!headers.contains(key)) {\n+      headers.emplace(key, std::vector<std::string>());\n+    }\n+    headers[key].push_back(value);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f8cbdfc30a1c2cf995e088fb4a1525a576cf1dd"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwMDIxMjY4OnYy", "diffSide": "RIGHT", "path": "library/cc/bridge_utility.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxODoxMToyNFrOISOCoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxODoxNTo1OVrOISONKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTk3NTMyOA==", "bodyText": "context needs to be the bytes pointer in order for release to work.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1222#discussion_r555975328", "createdAt": "2021-01-12T18:11:24Z", "author": {"login": "goaway"}, "path": "library/cc/bridge_utility.cc", "diffHunk": "@@ -0,0 +1,72 @@\n+#include \"bridge_utility.h\"\n+\n+#include <sstream>\n+\n+namespace Envoy {\n+namespace Platform {\n+\n+// TODO(crockeo): we always copy memory across boundaries; consider allowing for moves and/or\n+// shared ownership w/ reference counting via envoy-mobile's release callbacks\n+\n+envoy_data string_as_envoy_data(const std::string& str) {\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(str.size()));\n+  memcpy(bytes, &str[0], str.size());\n+  return envoy_data{\n+      .length = str.size(),\n+      .bytes = bytes,\n+      .release = free,\n+      .context = nullptr,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "891923aa932f7a565bd20042ac2b72d647097487"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTk3ODAyNg==", "bodyText": "doh", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1222#discussion_r555978026", "createdAt": "2021-01-12T18:15:59Z", "author": {"login": "crockeo"}, "path": "library/cc/bridge_utility.cc", "diffHunk": "@@ -0,0 +1,72 @@\n+#include \"bridge_utility.h\"\n+\n+#include <sstream>\n+\n+namespace Envoy {\n+namespace Platform {\n+\n+// TODO(crockeo): we always copy memory across boundaries; consider allowing for moves and/or\n+// shared ownership w/ reference counting via envoy-mobile's release callbacks\n+\n+envoy_data string_as_envoy_data(const std::string& str) {\n+  uint8_t* bytes = static_cast<uint8_t*>(safe_malloc(str.size()));\n+  memcpy(bytes, &str[0], str.size());\n+  return envoy_data{\n+      .length = str.size(),\n+      .bytes = bytes,\n+      .release = free,\n+      .context = nullptr,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTk3NTMyOA=="}, "originalCommit": {"oid": "891923aa932f7a565bd20042ac2b72d647097487"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 569, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}