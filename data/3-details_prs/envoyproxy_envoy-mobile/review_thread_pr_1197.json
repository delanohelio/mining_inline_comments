{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyNzg0ODc4", "number": 1197, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMTozMToyNVrOFA_Jtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNjowMTo1MFrOFHrIJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTc4OTk4OnYy", "diffSide": "RIGHT", "path": "library/python/envoy_mobile/BUILD", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMTozMToyNVrOH_iuug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMTozOToxOFrOH_i8SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5MTM1NA==", "bodyText": "Having envoy_mobile in the path seems a little bit funky. Could this be pybind or cc_platform?\nAlso maybe the cc_library belongs in //library/cc and just the pybind_extension should go here.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r536391354", "createdAt": "2020-12-04T21:31:25Z", "author": {"login": "goaway"}, "path": "library/python/envoy_mobile/BUILD", "diffHunk": "@@ -0,0 +1,49 @@\n+load(\"@pybind11_bazel//:build_defs.bzl\", \"pybind_extension\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "081f9bf2bcf9907eac7f140f0ed81a8e24005548"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NDgyNA==", "bodyText": "original naming scheme was just trying to match up folder name w/ how it would be imported in python. right now the .so built from //library/python/envoy_mobile:envoy_mobile.so can just be imported from python as import envoy_mobile, which would be canonical naming scheme\nthere's nothing keeping the .so name and the dir name coupled, though, so i'm happy to change it to whatever", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r536394824", "createdAt": "2020-12-04T21:39:18Z", "author": {"login": "crockeo"}, "path": "library/python/envoy_mobile/BUILD", "diffHunk": "@@ -0,0 +1,49 @@\n+load(\"@pybind11_bazel//:build_defs.bzl\", \"pybind_extension\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5MTM1NA=="}, "originalCommit": {"oid": "081f9bf2bcf9907eac7f140f0ed81a8e24005548"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NTc5MzU3OnYy", "diffSide": "RIGHT", "path": "library/python/envoy_mobile/executor.h", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMTozMjozMFrOH_iwpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMTo1MTo1MVrOH_jYug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5MTg0Nw==", "bodyText": "I don't know that we should necessarily have this, since it's basically where we'd want to plug in native python dispatch. I mean, it is a flexible and pretty agnostic interface, but does it really align with python based dispatch mechanisms?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r536391847", "createdAt": "2020-12-04T21:32:30Z", "author": {"login": "goaway"}, "path": "library/python/envoy_mobile/executor.h", "diffHunk": "@@ -0,0 +1,11 @@\n+#pragma once\n+\n+#include <functional>\n+\n+\n+class Executor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "081f9bf2bcf9907eac7f140f0ed81a8e24005548"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5MzUzMQ==", "bodyText": "it's necessary to have a type defined in C++ for the C++ side of the lib to interact with it, e.g. to call into it from on_XXX. in practice this is going to work like: executor_base.h being implemented by something akin to asyncio_executor.py or gevent_executor.py inside of Python", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r536393531", "createdAt": "2020-12-04T21:36:20Z", "author": {"login": "crockeo"}, "path": "library/python/envoy_mobile/executor.h", "diffHunk": "@@ -0,0 +1,11 @@\n+#pragma once\n+\n+#include <functional>\n+\n+\n+class Executor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5MTg0Nw=="}, "originalCommit": {"oid": "081f9bf2bcf9907eac7f140f0ed81a8e24005548"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwMjEwNg==", "bodyText": "Okay, cool - if it's directly supported with gevent/asyncio (and the \"right\" way to integrate) then that's totally fine.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r536402106", "createdAt": "2020-12-04T21:51:51Z", "author": {"login": "goaway"}, "path": "library/python/envoy_mobile/executor.h", "diffHunk": "@@ -0,0 +1,11 @@\n+#pragma once\n+\n+#include <functional>\n+\n+\n+class Executor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5MTg0Nw=="}, "originalCommit": {"oid": "081f9bf2bcf9907eac7f140f0ed81a8e24005548"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTY0Njc4OnYy", "diffSide": "RIGHT", "path": "library/cc/headers_builder.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0MDowOFrOIA08zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0MDowOFrOIA08zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczODQ0NQ==", "bodyText": "make this const std::string&", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r537738445", "createdAt": "2020-12-07T18:40:08Z", "author": {"login": "crockeo"}, "path": "library/cc/headers_builder.h", "diffHunk": "@@ -0,0 +1,19 @@\n+#pragma once\n+\n+#include \"headers.h\"\n+\n+class HeadersBuilder {\n+public:\n+  HeadersBuilder& add(const std::string& name, std::string& value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTY0NzY4OnYy", "diffSide": "RIGHT", "path": "library/cc/log_level.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0MDoyNVrOIA09XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0MDoyNVrOIA09XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczODU4OA==", "bodyText": "LogLeve -> LogLevel", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r537738588", "createdAt": "2020-12-07T18:40:25Z", "author": {"login": "crockeo"}, "path": "library/cc/log_level.h", "diffHunk": "@@ -0,0 +1,32 @@\n+#pragma once\n+\n+#include <string>\n+\n+/**\n+ * See: https://pybind11.readthedocs.io/en/stable/classes.html#enumerations-and-internal-types\n+ * this set up will let Python see:\n+ *\n+ * LogLevel.Trace = the enum value\n+ * LogLevel.to_string(LogLeve.Trace) = the string value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTY0Nzk1OnYy", "diffSide": "RIGHT", "path": "library/cc/log_level.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0MDozMVrOIA09hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0MDozMVrOIA09hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczODYyOQ==", "bodyText": "static", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r537738629", "createdAt": "2020-12-07T18:40:31Z", "author": {"login": "crockeo"}, "path": "library/cc/log_level.h", "diffHunk": "@@ -0,0 +1,32 @@\n+#pragma once\n+\n+#include <string>\n+\n+/**\n+ * See: https://pybind11.readthedocs.io/en/stable/classes.html#enumerations-and-internal-types\n+ * this set up will let Python see:\n+ *\n+ * LogLevel.Trace = the enum value\n+ * LogLevel.to_string(LogLeve.Trace) = the string value\n+ *\n+ * But it's not actually constructible bc of the private constructor (this may not work in practice,\n+ * as pybind11 may require that there is a public constructor for py::init)\n+ */\n+class LogLevel {\n+public:\n+  enum _LogLevel {\n+    Trace,\n+    Debug,\n+    Info,\n+    Warn,\n+    Error,\n+    Critical,\n+    Off,\n+  };\n+\n+  _LogLevel from_string(std::string log_level);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTY1MzE4OnYy", "diffSide": "RIGHT", "path": "library/cc/request_headers.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0MTo0M1rOIA1Ang==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0MTo0M1rOIA1Ang==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczOTQyMg==", "bodyText": "this can probably just be const std::string& and avoid copying strings here, same for the rest of them", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r537739422", "createdAt": "2020-12-07T18:41:43Z", "author": {"login": "crockeo"}, "path": "library/cc/request_headers.h", "diffHunk": "@@ -0,0 +1,26 @@\n+#pragma once\n+\n+#include <optional>\n+\n+#include \"headers.h\"\n+#include \"request_headers_builder.h\"\n+#include \"request_method.h\"\n+#include \"retry_policy.h\"\n+#include \"upstream_http_protocol.h\"\n+\n+class RequestHeaders : public Headers {\n+public:\n+  RequestMethod request_method() const;\n+  std::string scheme() const;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTY1ODAwOnYy", "diffSide": "RIGHT", "path": "library/cc/request_headers_builder.h", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0Mjo1MlrOIA1DZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMDoyMTozNVrOIDbs7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MDEzNQ==", "bodyText": "C++ question:\n\n\ndo I even need this, or will inheritance automatically allow subclasses to have the superclass's implementation?\n\n\ni have a feeling that this will return a HeadersBuilder& instead of a RequestHeadersBuilder&, is that right?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r537740135", "createdAt": "2020-12-07T18:42:52Z", "author": {"login": "crockeo"}, "path": "library/cc/request_headers_builder.h", "diffHunk": "@@ -0,0 +1,30 @@\n+#pragma once\n+\n+#include <string>\n+\n+#include \"headers_builder.h\"\n+#include \"request_headers.h\"\n+#include \"request_method.h\"\n+#include \"retry_policy.h\"\n+#include \"upstream_http_protocol.h\"\n+\n+class RequestHeaders;\n+\n+class RequestHeadersBuilder : public HeadersBuilder {\n+public:\n+  RequestHeadersBuilder(RequestMethod::_RequestMethod request_method, const std::string& scheme,\n+                        const std::string& authority, const std::string& path);\n+\n+  using HeadersBuilder::add;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3MDUwOA==", "bodyText": "Subclasses will indeed inherit their superclasses' interface/implementations.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r540470508", "createdAt": "2020-12-10T20:21:35Z", "author": {"login": "goaway"}, "path": "library/cc/request_headers_builder.h", "diffHunk": "@@ -0,0 +1,30 @@\n+#pragma once\n+\n+#include <string>\n+\n+#include \"headers_builder.h\"\n+#include \"request_headers.h\"\n+#include \"request_method.h\"\n+#include \"retry_policy.h\"\n+#include \"upstream_http_protocol.h\"\n+\n+class RequestHeaders;\n+\n+class RequestHeadersBuilder : public HeadersBuilder {\n+public:\n+  RequestHeadersBuilder(RequestMethod::_RequestMethod request_method, const std::string& scheme,\n+                        const std::string& authority, const std::string& path);\n+\n+  using HeadersBuilder::add;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MDEzNQ=="}, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTY2NjU2OnYy", "diffSide": "RIGHT", "path": "library/cc/retry_policy.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0NDo0N1rOIA1INA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzowNzowMlrOIDhl3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MTM2NA==", "bodyText": "it could be more performant to put this directly into an already-existing RawHeaders instance, or otherwise just add headers to a HeadersBuilder reference, but the API wouldn't be nearly as nice", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r537741364", "createdAt": "2020-12-07T18:44:47Z", "author": {"login": "crockeo"}, "path": "library/cc/retry_policy.h", "diffHunk": "@@ -0,0 +1,36 @@\n+#pragma once\n+\n+#include \"headers.h\"\n+#include \"request_headers.h\"\n+\n+class RequestHeaders;\n+\n+class RetryRule {\n+public:\n+  enum _RetryRule {\n+    Status5xx,\n+    GatewayFailure,\n+    ConnectFailure,\n+    RefusedStream,\n+    Retriable4xx,\n+    RetriableHeaders,\n+    Reset,\n+  };\n+\n+  static _RetryRule from_string(std::string retry_rule);\n+  static std::string to_string(_RetryRule retry_rule);\n+\n+private:\n+  RetryRule() {}\n+};\n+\n+struct RetryPolicy {\n+  int max_retry_count;\n+  int retry_on;\n+  std::vector<int> retry_status_codes;\n+  int per_try_timeout_ms;\n+  int total_upstream_timeout_ms;\n+\n+  RawHeaders output_headers() const;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2NzAwNA==", "bodyText": "resolving this for now bc it's a perf issue that we can figure out later", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r540567004", "createdAt": "2020-12-10T23:07:02Z", "author": {"login": "crockeo"}, "path": "library/cc/retry_policy.h", "diffHunk": "@@ -0,0 +1,36 @@\n+#pragma once\n+\n+#include \"headers.h\"\n+#include \"request_headers.h\"\n+\n+class RequestHeaders;\n+\n+class RetryRule {\n+public:\n+  enum _RetryRule {\n+    Status5xx,\n+    GatewayFailure,\n+    ConnectFailure,\n+    RefusedStream,\n+    Retriable4xx,\n+    RetriableHeaders,\n+    Reset,\n+  };\n+\n+  static _RetryRule from_string(std::string retry_rule);\n+  static std::string to_string(_RetryRule retry_rule);\n+\n+private:\n+  RetryRule() {}\n+};\n+\n+struct RetryPolicy {\n+  int max_retry_count;\n+  int retry_on;\n+  std::vector<int> retry_status_codes;\n+  int per_try_timeout_ms;\n+  int total_upstream_timeout_ms;\n+\n+  RawHeaders output_headers() const;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MTM2NA=="}, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTY3NDQwOnYy", "diffSide": "RIGHT", "path": "library/cc/stream_callbacks.h", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0Njo0MFrOIA1M7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNzo0ODowM1rOIDVxjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MjU3Mg==", "bodyText": "i've been futzing around in rust-land where i get to feel comfortable about reference lifetimes. this isn't really safe per se, but its lifetime will be articulated in a pybind11::keep_alive on the python obj definition", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r537742572", "createdAt": "2020-12-07T18:46:40Z", "author": {"login": "crockeo"}, "path": "library/cc/stream_callbacks.h", "diffHunk": "@@ -0,0 +1,34 @@\n+#pragma once\n+\n+#include <cstddef>\n+#include <optional>\n+#include <vector>\n+\n+#include \"envoy_error.h\"\n+#include \"executor.h\"\n+#include \"response_headers.h\"\n+#include \"response_trailers.h\"\n+\n+using OnHeadersCallback = std::function<void(ResponseHeaders headers, bool end_stream)>;\n+using OnDataCallback = std::function<void(std::vector<std::byte> data, bool end_stream)>;\n+using OnTrailersCallback = std::function<void(ResponseTrailers trailers)>;\n+using OnCancelCallback = std::function<void()>;\n+using OnErrorCallback = std::function<void(EnvoyError error)>;\n+\n+struct StreamCallbacks {\n+  std::optional<OnHeadersCallback> on_headers;\n+  std::optional<OnDataCallback> on_data;\n+  std::optional<OnTrailersCallback> on_trailers;\n+  std::optional<OnCancelCallback> on_cancel;\n+  std::optional<OnErrorCallback> on_error;\n+};\n+\n+class EnvoyHttpCallbacksAdapter {\n+public:\n+  EnvoyHttpCallbacksAdapter(Executor executor, StreamCallbacks callbacks);\n+\n+private:\n+  // TODO(crockeo): figure out lifecycle management here\n+  Executor& executor_;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MTc4MQ==", "bodyText": "You could use std::weak_ptr for a stronger guarantee. Or even just a shared_ptr to ensure its lifetime.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r539751781", "createdAt": "2020-12-10T00:30:07Z", "author": {"login": "goaway"}, "path": "library/cc/stream_callbacks.h", "diffHunk": "@@ -0,0 +1,34 @@\n+#pragma once\n+\n+#include <cstddef>\n+#include <optional>\n+#include <vector>\n+\n+#include \"envoy_error.h\"\n+#include \"executor.h\"\n+#include \"response_headers.h\"\n+#include \"response_trailers.h\"\n+\n+using OnHeadersCallback = std::function<void(ResponseHeaders headers, bool end_stream)>;\n+using OnDataCallback = std::function<void(std::vector<std::byte> data, bool end_stream)>;\n+using OnTrailersCallback = std::function<void(ResponseTrailers trailers)>;\n+using OnCancelCallback = std::function<void()>;\n+using OnErrorCallback = std::function<void(EnvoyError error)>;\n+\n+struct StreamCallbacks {\n+  std::optional<OnHeadersCallback> on_headers;\n+  std::optional<OnDataCallback> on_data;\n+  std::optional<OnTrailersCallback> on_trailers;\n+  std::optional<OnCancelCallback> on_cancel;\n+  std::optional<OnErrorCallback> on_error;\n+};\n+\n+class EnvoyHttpCallbacksAdapter {\n+public:\n+  EnvoyHttpCallbacksAdapter(Executor executor, StreamCallbacks callbacks);\n+\n+private:\n+  // TODO(crockeo): figure out lifecycle management here\n+  Executor& executor_;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MjU3Mg=="}, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4MzA5Nw==", "bodyText": "the best case scenario for this is that someone in python land creates and then immediately moves ownership of the Executor into the C++ codebase. i'm not sure that we can enforce move semantics in python, though, so that may be a moot attempt.\ni'd say let's use std::unique_ptr for now to represent the ideal world and then we can backtrack into whatever ends up working (probably a std::weak_ptr or std::shared_ptr", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r540283097", "createdAt": "2020-12-10T15:54:35Z", "author": {"login": "crockeo"}, "path": "library/cc/stream_callbacks.h", "diffHunk": "@@ -0,0 +1,34 @@\n+#pragma once\n+\n+#include <cstddef>\n+#include <optional>\n+#include <vector>\n+\n+#include \"envoy_error.h\"\n+#include \"executor.h\"\n+#include \"response_headers.h\"\n+#include \"response_trailers.h\"\n+\n+using OnHeadersCallback = std::function<void(ResponseHeaders headers, bool end_stream)>;\n+using OnDataCallback = std::function<void(std::vector<std::byte> data, bool end_stream)>;\n+using OnTrailersCallback = std::function<void(ResponseTrailers trailers)>;\n+using OnCancelCallback = std::function<void()>;\n+using OnErrorCallback = std::function<void(EnvoyError error)>;\n+\n+struct StreamCallbacks {\n+  std::optional<OnHeadersCallback> on_headers;\n+  std::optional<OnDataCallback> on_data;\n+  std::optional<OnTrailersCallback> on_trailers;\n+  std::optional<OnCancelCallback> on_cancel;\n+  std::optional<OnErrorCallback> on_error;\n+};\n+\n+class EnvoyHttpCallbacksAdapter {\n+public:\n+  EnvoyHttpCallbacksAdapter(Executor executor, StreamCallbacks callbacks);\n+\n+private:\n+  // TODO(crockeo): figure out lifecycle management here\n+  Executor& executor_;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MjU3Mg=="}, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3MzM5MA==", "bodyText": "In other words, there is nothing special that needs to be done. While returning unique pointers in this way is allowed, it is illegal to use them as function arguments. For instance, the following function signature cannot be processed by pybind11.\n\nfrom pybind11 docs\nlooks like we're going to have to use shared_ptrs", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r540373390", "createdAt": "2020-12-10T17:48:03Z", "author": {"login": "crockeo"}, "path": "library/cc/stream_callbacks.h", "diffHunk": "@@ -0,0 +1,34 @@\n+#pragma once\n+\n+#include <cstddef>\n+#include <optional>\n+#include <vector>\n+\n+#include \"envoy_error.h\"\n+#include \"executor.h\"\n+#include \"response_headers.h\"\n+#include \"response_trailers.h\"\n+\n+using OnHeadersCallback = std::function<void(ResponseHeaders headers, bool end_stream)>;\n+using OnDataCallback = std::function<void(std::vector<std::byte> data, bool end_stream)>;\n+using OnTrailersCallback = std::function<void(ResponseTrailers trailers)>;\n+using OnCancelCallback = std::function<void()>;\n+using OnErrorCallback = std::function<void(EnvoyError error)>;\n+\n+struct StreamCallbacks {\n+  std::optional<OnHeadersCallback> on_headers;\n+  std::optional<OnDataCallback> on_data;\n+  std::optional<OnTrailersCallback> on_trailers;\n+  std::optional<OnCancelCallback> on_cancel;\n+  std::optional<OnErrorCallback> on_error;\n+};\n+\n+class EnvoyHttpCallbacksAdapter {\n+public:\n+  EnvoyHttpCallbacksAdapter(Executor executor, StreamCallbacks callbacks);\n+\n+private:\n+  // TODO(crockeo): figure out lifecycle management here\n+  Executor& executor_;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MjU3Mg=="}, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTY3NzQ0OnYy", "diffSide": "RIGHT", "path": "library/cc/stream_prototype.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0NzoyMVrOIA1Oqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0NzoyMVrOIA1Oqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MzAxOA==", "bodyText": "use callback types here to make sure they stay the same", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r537743018", "createdAt": "2020-12-07T18:47:21Z", "author": {"login": "crockeo"}, "path": "library/cc/stream_prototype.h", "diffHunk": "@@ -0,0 +1,34 @@\n+#pragma once\n+\n+#include <cstddef>\n+#include <functional>\n+\n+#include \"engine.h\"\n+#include \"envoy_error.h\"\n+#include \"executor.h\"\n+#include \"response_headers.h\"\n+#include \"response_trailers.h\"\n+#include \"stream.h\"\n+#include \"stream_callbacks.h\"\n+\n+class Engine;\n+\n+class StreamPrototype {\n+public:\n+  StreamPrototype(Engine engine);\n+\n+  Stream start(Executor executor);\n+\n+  StreamPrototype& set_on_response_headers(\n+      std::function<void(const ResponseHeaders& headers, bool end_stream)> closure);\n+  StreamPrototype& set_on_response_data(\n+      std::function<void(const std::vector<std::byte>& bytes, bool end_stream)> closure);\n+  StreamPrototype&\n+  set_on_response_trailers(std::function<void(const ResponseTrailers& trailers)> closure);\n+  StreamPrototype& set_on_error(std::function<void(const EnvoyError& error)> closure);\n+  StreamPrototype& set_on_cancel(std::function<void()> closure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTcwMzU2OnYy", "diffSide": "RIGHT", "path": "library/python/envoy_mobile/BUILD", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo1MzozNFrOIA1eMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo1MzozNFrOIA1eMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0Njk5Mg==", "bodyText": "rm this build file", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r537746992", "createdAt": "2020-12-07T18:53:34Z", "author": {"login": "crockeo"}, "path": "library/python/envoy_mobile/BUILD", "diffHunk": "@@ -0,0 +1,49 @@\n+load(\"@pybind11_bazel//:build_defs.bzl\", \"pybind_extension\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad439322ff929ab226f5b5ce4054077eae2ae908"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTA5MDM1OnYy", "diffSide": "RIGHT", "path": "library/cc/log_level.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDozNjo1MlrOICwAOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDozNjo1MlrOICwAOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NDU1Mg==", "bodyText": "Is there an Envoy enum we can leverage for this?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r539754552", "createdAt": "2020-12-10T00:36:52Z", "author": {"login": "goaway"}, "path": "library/cc/log_level.h", "diffHunk": "@@ -0,0 +1,11 @@\n+#pragma once\n+\n+enum LogLevel {\n+  Trace,\n+  Debug,\n+  Info,\n+  Warn,\n+  Error,\n+  Critical,\n+  Off,\n+};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0598b4d9361f339ec0e4ead58d52bca8f758f8c0"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTA5MTM1OnYy", "diffSide": "RIGHT", "path": "library/cc/request_method.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDozNzoxM1rOICwAvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDozNzoxM1rOICwAvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NDY4NA==", "bodyText": "Here, too, I'd look to just use an Envoy-defined enum, I think.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r539754684", "createdAt": "2020-12-10T00:37:13Z", "author": {"login": "goaway"}, "path": "library/cc/request_method.h", "diffHunk": "@@ -0,0 +1,12 @@\n+#pragma once\n+\n+enum RequestMethod {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0598b4d9361f339ec0e4ead58d52bca8f758f8c0"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4OTEwNjk4OnYy", "diffSide": "RIGHT", "path": "library/cc/stream.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMDo0MjoyNVrOICwI8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTozNjo0MFrOIDPXew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1Njc4Ng==", "bodyText": "Is there a pybind reason to use this buffer representation? If not, I'd propose we use uint8_t (which Envoy currently uses internally) and probably just simple arrays.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r539756786", "createdAt": "2020-12-10T00:42:25Z", "author": {"login": "goaway"}, "path": "library/cc/stream.h", "diffHunk": "@@ -0,0 +1,22 @@\n+#pragma once\n+\n+#include <cstddef>\n+#include <vector>\n+\n+#include \"library/common/types/c_types.h\"\n+#include \"request_headers.h\"\n+#include \"request_trailers.h\"\n+\n+class Stream {\n+public:\n+  Stream(envoy_stream_t handle);\n+\n+  Stream& send_headers(const RequestHeaders& headers, bool end_stream);\n+  Stream& send_data(const std::vector<std::byte>& data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0598b4d9361f339ec0e4ead58d52bca8f758f8c0"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2ODQxMQ==", "bodyText": "there is not, i'll use uint8_t.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r540268411", "createdAt": "2020-12-10T15:36:40Z", "author": {"login": "crockeo"}, "path": "library/cc/stream.h", "diffHunk": "@@ -0,0 +1,22 @@\n+#pragma once\n+\n+#include <cstddef>\n+#include <vector>\n+\n+#include \"library/common/types/c_types.h\"\n+#include \"request_headers.h\"\n+#include \"request_trailers.h\"\n+\n+class Stream {\n+public:\n+  Stream(envoy_stream_t handle);\n+\n+  Stream& send_headers(const RequestHeaders& headers, bool end_stream);\n+  Stream& send_data(const std::vector<std::byte>& data);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1Njc4Ng=="}, "originalCommit": {"oid": "0598b4d9361f339ec0e4ead58d52bca8f758f8c0"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTg5OTY5OnYy", "diffSide": "RIGHT", "path": "library/cc/stream.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNTo1NjowN1rOIJNEYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNTo1NjowN1rOIJNEYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyMjIxMQ==", "bodyText": "After thinking about this a bit, I think we should switch to using envoy_data directly in this implementation to represent buffers. Python's buffer protocol doesn't deal in vectors, nor do any buffer representations in Envoy. We've already have a bridge implementation of Envoy's internal buffer type defined in terms of envoy_data. It seems like using vectors will just result in extra indirection, and potentially, copies.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r546522211", "createdAt": "2020-12-21T05:56:07Z", "author": {"login": "goaway"}, "path": "library/cc/stream.h", "diffHunk": "@@ -0,0 +1,25 @@\n+#pragma once\n+\n+// NOLINT(namespace-envoy)\n+\n+#include <vector>\n+\n+#include \"library/common/types/c_types.h\"\n+#include \"request_headers.h\"\n+#include \"request_trailers.h\"\n+\n+class Stream {\n+public:\n+  Stream(envoy_stream_t handle);\n+\n+  Stream& send_headers(RequestHeadersSharedPtr headers, bool end_stream);\n+  Stream& send_data(const std::vector<uint8_t>& data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6324d96459de11fe384fca8b19838a9e95117cdb"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTkwOTUwOnYy", "diffSide": "RIGHT", "path": "library/cc/engine.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNjowMTo1MFrOIJNJ_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwNjowMTo1MFrOIJNJ_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyMzY0NA==", "bodyText": "Let's namespace everything in these files. Envoy::Mobile, Envoy::Platform, Envoy::Lib/rary all seem like reasonable candidates to me.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1197#discussion_r546523644", "createdAt": "2020-12-21T06:01:50Z", "author": {"login": "goaway"}, "path": "library/cc/engine.h", "diffHunk": "@@ -0,0 +1,29 @@\n+#pragma once\n+\n+// NOLINT(namespace-envoy)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6324d96459de11fe384fca8b19838a9e95117cdb"}, "originalPosition": 3}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 527, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}