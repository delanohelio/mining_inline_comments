{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3NzE3NjYx", "number": 979, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzozNTowNVrOEVNDAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjo1MToxMVrOEVmpfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjY5MzEzOnYy", "diffSide": "RIGHT", "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzozNTowNVrOG71AaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMDowNjowMVrOG71kkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4NzYyNA==", "bodyText": "Could we add a couple unit tests for the behaviors expected for this class?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465387624", "createdAt": "2020-08-04T23:35:05Z", "author": {"login": "buildbreaker"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package io.envoyproxy.envoymobile.engine;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n+\n+/**\n+ * Class to assist with passing types from native code over the JNI. Currently supports\n+ * HTTP headers.\n+ */\n+class JvmBridgeUtility {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Njg4MQ==", "bodyText": "Yes, though if you're okay with it, I'd prefer to do it in a separate PR to keep things rolling forward on main.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465396881", "createdAt": "2020-08-05T00:06:01Z", "author": {"login": "goaway"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package io.envoyproxy.envoymobile.engine;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n+\n+/**\n+ * Class to assist with passing types from native code over the JNI. Currently supports\n+ * HTTP headers.\n+ */\n+class JvmBridgeUtility {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4NzYyNA=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjY5NTI2OnYy", "diffSide": "RIGHT", "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzozNjoxM1rOG71Bvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMDowOTozMVrOG71oUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4Nzk2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Map headers = headerAccumulator;\n          \n          \n            \n                Map<String, List<String>> headers = headerAccumulator;", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465387966", "createdAt": "2020-08-04T23:36:13Z", "author": {"login": "buildbreaker"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package io.envoyproxy.envoymobile.engine;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n+\n+/**\n+ * Class to assist with passing types from native code over the JNI. Currently supports\n+ * HTTP headers.\n+ */\n+class JvmBridgeUtility {\n+  // State-tracking for header accumulation\n+  private Map<String, List<String>> headerAccumulator = null;\n+  private long headerCount = 0;\n+\n+  JvmBridgeUtility() {}\n+\n+  /**\n+   * Receives pairs of strings passed via the JNI.\n+   *\n+   * @param key,        the name of the HTTP header.\n+   * @param value,      the value of the HTTP header.\n+   * @param start,      indicates this is the first header pair of the block.\n+   */\n+  void passHeader(byte[] key, byte[] value, boolean start) {\n+    if (start) {\n+      assert headerAccumulator == null;\n+      assert headerCount == 0;\n+      headerAccumulator = new HashMap();\n+    }\n+\n+    String headerKey;\n+    String headerValue;\n+\n+    try {\n+      headerKey = new String(key, \"UTF-8\");\n+      headerValue = new String(value, \"UTF-8\");\n+    } catch (java.io.UnsupportedEncodingException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    List<String> values = headerAccumulator.get(headerKey);\n+    if (values == null) {\n+      values = new ArrayList(1);\n+      headerAccumulator.put(headerKey, values);\n+    }\n+    values.add(headerValue);\n+    headerCount++;\n+  }\n+\n+  /**\n+   * Retrieves accumulated headers and resets state.\n+   *\n+   * @return Map, a map of header names to one or more values.\n+   */\n+  Map<String, List<String>> retrieveHeaders() {\n+    Map headers = headerAccumulator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NjcwNA==", "bodyText": "Sure, I don't have strong feelings. Is that more common/idiomatic?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465396704", "createdAt": "2020-08-05T00:05:19Z", "author": {"login": "goaway"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package io.envoyproxy.envoymobile.engine;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n+\n+/**\n+ * Class to assist with passing types from native code over the JNI. Currently supports\n+ * HTTP headers.\n+ */\n+class JvmBridgeUtility {\n+  // State-tracking for header accumulation\n+  private Map<String, List<String>> headerAccumulator = null;\n+  private long headerCount = 0;\n+\n+  JvmBridgeUtility() {}\n+\n+  /**\n+   * Receives pairs of strings passed via the JNI.\n+   *\n+   * @param key,        the name of the HTTP header.\n+   * @param value,      the value of the HTTP header.\n+   * @param start,      indicates this is the first header pair of the block.\n+   */\n+  void passHeader(byte[] key, byte[] value, boolean start) {\n+    if (start) {\n+      assert headerAccumulator == null;\n+      assert headerCount == 0;\n+      headerAccumulator = new HashMap();\n+    }\n+\n+    String headerKey;\n+    String headerValue;\n+\n+    try {\n+      headerKey = new String(key, \"UTF-8\");\n+      headerValue = new String(value, \"UTF-8\");\n+    } catch (java.io.UnsupportedEncodingException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    List<String> values = headerAccumulator.get(headerKey);\n+    if (values == null) {\n+      values = new ArrayList(1);\n+      headerAccumulator.put(headerKey, values);\n+    }\n+    values.add(headerValue);\n+    headerCount++;\n+  }\n+\n+  /**\n+   * Retrieves accumulated headers and resets state.\n+   *\n+   * @return Map, a map of header names to one or more values.\n+   */\n+  Map<String, List<String>> retrieveHeaders() {\n+    Map headers = headerAccumulator;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4Nzk2Ng=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Nzg0Mg==", "bodyText": "Yeah, it's looks a bit bare without the type declarations haha", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465397842", "createdAt": "2020-08-05T00:09:31Z", "author": {"login": "buildbreaker"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package io.envoyproxy.envoymobile.engine;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n+\n+/**\n+ * Class to assist with passing types from native code over the JNI. Currently supports\n+ * HTTP headers.\n+ */\n+class JvmBridgeUtility {\n+  // State-tracking for header accumulation\n+  private Map<String, List<String>> headerAccumulator = null;\n+  private long headerCount = 0;\n+\n+  JvmBridgeUtility() {}\n+\n+  /**\n+   * Receives pairs of strings passed via the JNI.\n+   *\n+   * @param key,        the name of the HTTP header.\n+   * @param value,      the value of the HTTP header.\n+   * @param start,      indicates this is the first header pair of the block.\n+   */\n+  void passHeader(byte[] key, byte[] value, boolean start) {\n+    if (start) {\n+      assert headerAccumulator == null;\n+      assert headerCount == 0;\n+      headerAccumulator = new HashMap();\n+    }\n+\n+    String headerKey;\n+    String headerValue;\n+\n+    try {\n+      headerKey = new String(key, \"UTF-8\");\n+      headerValue = new String(value, \"UTF-8\");\n+    } catch (java.io.UnsupportedEncodingException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    List<String> values = headerAccumulator.get(headerKey);\n+    if (values == null) {\n+      values = new ArrayList(1);\n+      headerAccumulator.put(headerKey, values);\n+    }\n+    values.add(headerValue);\n+    headerCount++;\n+  }\n+\n+  /**\n+   * Retrieves accumulated headers and resets state.\n+   *\n+   * @return Map, a map of header names to one or more values.\n+   */\n+  Map<String, List<String>> retrieveHeaders() {\n+    Map headers = headerAccumulator;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4Nzk2Ng=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjY5NzQwOnYy", "diffSide": "RIGHT", "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmCallbackContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzozNzoxNlrOG71DEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo1OTo1M1rOG71dcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4ODMwNA==", "bodyText": "This would crash if the validation returns false?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465388304", "createdAt": "2020-08-04T23:37:16Z", "author": {"login": "buildbreaker"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmCallbackContext.java", "diffHunk": "@@ -10,118 +10,67 @@\n import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n \n class JvmCallbackContext {\n-  private enum FrameType {\n-    NONE,\n-    HEADERS,\n-    METADATA,\n-    TRAILERS,\n-  }\n-\n+  private final JvmBridgeUtility bridgeUtility;\n   private final EnvoyHTTPCallbacks callbacks;\n \n-  // State-tracking for header accumulation\n-  private Map<String, List<String>> headerAccumulator = null;\n-  private FrameType pendingFrameType = FrameType.NONE;\n-  private boolean pendingEndStream = false;\n-  private long expectedHeaderLength = 0;\n-  private long accumulatedHeaderLength = 0;\n-\n-  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) { this.callbacks = callbacks; }\n+  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) {\n+    bridgeUtility = new JvmBridgeUtility();\n+    this.callbacks = callbacks;\n+  }\n \n   /**\n    * Initializes state for accumulating header pairs via passHeaders, ultimately\n    * to be dispatched via the callback.\n    *\n    * @param length,    the total number of headers included in this header block.\n    * @param endStream, whether this header block is the final remote frame.\n+   * @return Void,     not used for response callbacks.\n    */\n-  public void onHeaders(long length, boolean endStream) {\n-    startAccumulation(FrameType.HEADERS, length, endStream);\n+  public Void onHeaders(long headerCount, boolean endStream) {\n+    assert bridgeUtility.validateCount(headerCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NTA1OA==", "bodyText": "Yes. It shouldn't ever fail, and the implementation is broken if it fails.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465395058", "createdAt": "2020-08-04T23:59:53Z", "author": {"login": "goaway"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmCallbackContext.java", "diffHunk": "@@ -10,118 +10,67 @@\n import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n \n class JvmCallbackContext {\n-  private enum FrameType {\n-    NONE,\n-    HEADERS,\n-    METADATA,\n-    TRAILERS,\n-  }\n-\n+  private final JvmBridgeUtility bridgeUtility;\n   private final EnvoyHTTPCallbacks callbacks;\n \n-  // State-tracking for header accumulation\n-  private Map<String, List<String>> headerAccumulator = null;\n-  private FrameType pendingFrameType = FrameType.NONE;\n-  private boolean pendingEndStream = false;\n-  private long expectedHeaderLength = 0;\n-  private long accumulatedHeaderLength = 0;\n-\n-  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) { this.callbacks = callbacks; }\n+  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) {\n+    bridgeUtility = new JvmBridgeUtility();\n+    this.callbacks = callbacks;\n+  }\n \n   /**\n    * Initializes state for accumulating header pairs via passHeaders, ultimately\n    * to be dispatched via the callback.\n    *\n    * @param length,    the total number of headers included in this header block.\n    * @param endStream, whether this header block is the final remote frame.\n+   * @return Void,     not used for response callbacks.\n    */\n-  public void onHeaders(long length, boolean endStream) {\n-    startAccumulation(FrameType.HEADERS, length, endStream);\n+  public Void onHeaders(long headerCount, boolean endStream) {\n+    assert bridgeUtility.validateCount(headerCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4ODMwNA=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjY5OTM2OnYy", "diffSide": "RIGHT", "path": "test/common/http/dispatcher_test.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzozODoyMVrOG71EMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo0OToxNlrOG71QjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4ODU5NA==", "bodyText": "What's the difference between ASSERT_TRUE and EXPECT_TRUE?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465388594", "createdAt": "2020-08-04T23:38:21Z", "author": {"login": "buildbreaker"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -73,16 +73,18 @@ TEST_F(DispatcherTest, SetDestinationCluster) {\n   callbacks_called cc = {0, 0, 0, 0, 0, 0};\n   bridge_callbacks.context = &cc;\n   bridge_callbacks.on_headers = [](envoy_headers c_headers, bool end_stream,\n-                                   void* context) -> void {\n-    ASSERT_TRUE(end_stream);\n+                                   void* context) -> void* {\n+    EXPECT_TRUE(end_stream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MTc1Ng==", "bodyText": "ASSERT_TRUE aborts execution if the expectation fails. It also requires the enclosing function to have a void return type, because it actually calls return. EXPECT_TRUE does not abort execution, and has no requirements on the return-type of the enclosing function. Both will cause the test to fail if the passed assertion/expectation isn't met.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465391756", "createdAt": "2020-08-04T23:49:16Z", "author": {"login": "goaway"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -73,16 +73,18 @@ TEST_F(DispatcherTest, SetDestinationCluster) {\n   callbacks_called cc = {0, 0, 0, 0, 0, 0};\n   bridge_callbacks.context = &cc;\n   bridge_callbacks.on_headers = [](envoy_headers c_headers, bool end_stream,\n-                                   void* context) -> void {\n-    ASSERT_TRUE(end_stream);\n+                                   void* context) -> void* {\n+    EXPECT_TRUE(end_stream);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4ODU5NA=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjcwODM4OnYy", "diffSide": "RIGHT", "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo0MzowNVrOG71Jmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo1MDowN1rOG71Row==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4OTk3OQ==", "bodyText": "I might be missing something, but division into this utility class is not predicated on the returned context, right?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465389979", "createdAt": "2020-08-04T23:43:05Z", "author": {"login": "junr03"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package io.envoyproxy.envoymobile.engine;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n+\n+/**\n+ * Class to assist with passing types from native code over the JNI. Currently supports\n+ * HTTP headers.\n+ */\n+class JvmBridgeUtility {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MjAzNQ==", "bodyText": "No, but it does encapsulate the complexity a bit better (imo), and it allows re-use (in the case of filters).", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465392035", "createdAt": "2020-08-04T23:50:07Z", "author": {"login": "goaway"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmBridgeUtility.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package io.envoyproxy.envoymobile.engine;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n+\n+/**\n+ * Class to assist with passing types from native code over the JNI. Currently supports\n+ * HTTP headers.\n+ */\n+class JvmBridgeUtility {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4OTk3OQ=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjcxMDAyOnYy", "diffSide": "RIGHT", "path": "library/common/jni/jni_interface.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo0NDowMVrOG71KlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo1MDozMVrOG71SLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MDIyOQ==", "bodyText": "As far as I can tell the returned contexts are not getting used anywhere yet right?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465390229", "createdAt": "2020-08-04T23:44:01Z", "author": {"login": "junr03"}, "path": "library/common/jni/jni_interface.cc", "diffHunk": "@@ -143,22 +143,23 @@ static JNIEnv* get_env() {\n   return env;\n }\n \n-static void jvm_on_headers(envoy_headers headers, bool end_stream, void* context) {\n+static void* jvm_on_headers(envoy_headers headers, bool end_stream, void* context) {\n   JNIEnv* env = get_env();\n   jobject j_context = static_cast<jobject>(context);\n+  pass_headers(env, headers, j_context);\n \n   jclass jcls_JvmCallbackContext = env->GetObjectClass(j_context);\n   jmethodID jmid_onHeaders = env->GetMethodID(jcls_JvmCallbackContext, \"onHeaders\", \"(JZ)V\");\n   // Note: be careful of JVM types. Before we casted to jlong we were getting integer problems.\n   // TODO: make this cast safer.\n-  env->CallVoidMethod(j_context, jmid_onHeaders, (jlong)headers.length,\n-                      end_stream ? JNI_TRUE : JNI_FALSE);\n+  jobject result = env->CallObjectMethod(j_context, jmid_onHeaders, (jlong)headers.length,\n+                                         end_stream ? JNI_TRUE : JNI_FALSE);\n \n   env->DeleteLocalRef(jcls_JvmCallbackContext);\n-  pass_headers(env, headers, j_context);\n+  return result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MjE3NA==", "bodyText": "Correct, they're used in the subsequent PR I have for filters.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465392174", "createdAt": "2020-08-04T23:50:31Z", "author": {"login": "goaway"}, "path": "library/common/jni/jni_interface.cc", "diffHunk": "@@ -143,22 +143,23 @@ static JNIEnv* get_env() {\n   return env;\n }\n \n-static void jvm_on_headers(envoy_headers headers, bool end_stream, void* context) {\n+static void* jvm_on_headers(envoy_headers headers, bool end_stream, void* context) {\n   JNIEnv* env = get_env();\n   jobject j_context = static_cast<jobject>(context);\n+  pass_headers(env, headers, j_context);\n \n   jclass jcls_JvmCallbackContext = env->GetObjectClass(j_context);\n   jmethodID jmid_onHeaders = env->GetMethodID(jcls_JvmCallbackContext, \"onHeaders\", \"(JZ)V\");\n   // Note: be careful of JVM types. Before we casted to jlong we were getting integer problems.\n   // TODO: make this cast safer.\n-  env->CallVoidMethod(j_context, jmid_onHeaders, (jlong)headers.length,\n-                      end_stream ? JNI_TRUE : JNI_FALSE);\n+  jobject result = env->CallObjectMethod(j_context, jmid_onHeaders, (jlong)headers.length,\n+                                         end_stream ? JNI_TRUE : JNI_FALSE);\n \n   env->DeleteLocalRef(jcls_JvmCallbackContext);\n-  pass_headers(env, headers, j_context);\n+  return result;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MDIyOQ=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjcxMTQ1OnYy", "diffSide": "RIGHT", "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmCallbackContext.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo0NDozOVrOG71LYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwODoyODo0OVrOG8ougg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MDQzNA==", "bodyText": "what is capital V void?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465390434", "createdAt": "2020-08-04T23:44:39Z", "author": {"login": "junr03"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmCallbackContext.java", "diffHunk": "@@ -10,118 +10,67 @@\n import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n \n class JvmCallbackContext {\n-  private enum FrameType {\n-    NONE,\n-    HEADERS,\n-    METADATA,\n-    TRAILERS,\n-  }\n-\n+  private final JvmBridgeUtility bridgeUtility;\n   private final EnvoyHTTPCallbacks callbacks;\n \n-  // State-tracking for header accumulation\n-  private Map<String, List<String>> headerAccumulator = null;\n-  private FrameType pendingFrameType = FrameType.NONE;\n-  private boolean pendingEndStream = false;\n-  private long expectedHeaderLength = 0;\n-  private long accumulatedHeaderLength = 0;\n-\n-  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) { this.callbacks = callbacks; }\n+  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) {\n+    bridgeUtility = new JvmBridgeUtility();\n+    this.callbacks = callbacks;\n+  }\n \n   /**\n    * Initializes state for accumulating header pairs via passHeaders, ultimately\n    * to be dispatched via the callback.\n    *\n    * @param length,    the total number of headers included in this header block.\n    * @param endStream, whether this header block is the final remote frame.\n+   * @return Void,     not used for response callbacks.\n    */\n-  public void onHeaders(long length, boolean endStream) {\n-    startAccumulation(FrameType.HEADERS, length, endStream);\n+  public Void onHeaders(long headerCount, boolean endStream) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MzQ3Nw==", "bodyText": "https://docs.oracle.com/javase/7/docs/api/java/lang/Void.html\nNote, we could use any other non-instantiable type here, including our own. But Void is built in, and there's some precedent/convention for using Void for this purpose.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465393477", "createdAt": "2020-08-04T23:54:38Z", "author": {"login": "goaway"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmCallbackContext.java", "diffHunk": "@@ -10,118 +10,67 @@\n import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n \n class JvmCallbackContext {\n-  private enum FrameType {\n-    NONE,\n-    HEADERS,\n-    METADATA,\n-    TRAILERS,\n-  }\n-\n+  private final JvmBridgeUtility bridgeUtility;\n   private final EnvoyHTTPCallbacks callbacks;\n \n-  // State-tracking for header accumulation\n-  private Map<String, List<String>> headerAccumulator = null;\n-  private FrameType pendingFrameType = FrameType.NONE;\n-  private boolean pendingEndStream = false;\n-  private long expectedHeaderLength = 0;\n-  private long accumulatedHeaderLength = 0;\n-\n-  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) { this.callbacks = callbacks; }\n+  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) {\n+    bridgeUtility = new JvmBridgeUtility();\n+    this.callbacks = callbacks;\n+  }\n \n   /**\n    * Initializes state for accumulating header pairs via passHeaders, ultimately\n    * to be dispatched via the callback.\n    *\n    * @param length,    the total number of headers included in this header block.\n    * @param endStream, whether this header block is the final remote frame.\n+   * @return Void,     not used for response callbacks.\n    */\n-  public void onHeaders(long length, boolean endStream) {\n-    startAccumulation(FrameType.HEADERS, length, endStream);\n+  public Void onHeaders(long headerCount, boolean endStream) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MDQzNA=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0OTIxMQ==", "bodyText": "I see so it is the java way of returning a void*?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r466049211", "createdAt": "2020-08-05T22:57:58Z", "author": {"login": "junr03"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmCallbackContext.java", "diffHunk": "@@ -10,118 +10,67 @@\n import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n \n class JvmCallbackContext {\n-  private enum FrameType {\n-    NONE,\n-    HEADERS,\n-    METADATA,\n-    TRAILERS,\n-  }\n-\n+  private final JvmBridgeUtility bridgeUtility;\n   private final EnvoyHTTPCallbacks callbacks;\n \n-  // State-tracking for header accumulation\n-  private Map<String, List<String>> headerAccumulator = null;\n-  private FrameType pendingFrameType = FrameType.NONE;\n-  private boolean pendingEndStream = false;\n-  private long expectedHeaderLength = 0;\n-  private long accumulatedHeaderLength = 0;\n-\n-  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) { this.callbacks = callbacks; }\n+  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) {\n+    bridgeUtility = new JvmBridgeUtility();\n+    this.callbacks = callbacks;\n+  }\n \n   /**\n    * Initializes state for accumulating header pairs via passHeaders, ultimately\n    * to be dispatched via the callback.\n    *\n    * @param length,    the total number of headers included in this header block.\n    * @param endStream, whether this header block is the final remote frame.\n+   * @return Void,     not used for response callbacks.\n    */\n-  public void onHeaders(long length, boolean endStream) {\n-    startAccumulation(FrameType.HEADERS, length, endStream);\n+  public Void onHeaders(long headerCount, boolean endStream) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MDQzNA=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIzNTAxMA==", "bodyText": "Effectively, yes. I switched over to Object though as you can see, due to an issue with JNI signature lookup.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r466235010", "createdAt": "2020-08-06T08:28:49Z", "author": {"login": "goaway"}, "path": "library/java/src/io/envoyproxy/envoymobile/engine/JvmCallbackContext.java", "diffHunk": "@@ -10,118 +10,67 @@\n import io.envoyproxy.envoymobile.engine.types.EnvoyHTTPCallbacks;\n \n class JvmCallbackContext {\n-  private enum FrameType {\n-    NONE,\n-    HEADERS,\n-    METADATA,\n-    TRAILERS,\n-  }\n-\n+  private final JvmBridgeUtility bridgeUtility;\n   private final EnvoyHTTPCallbacks callbacks;\n \n-  // State-tracking for header accumulation\n-  private Map<String, List<String>> headerAccumulator = null;\n-  private FrameType pendingFrameType = FrameType.NONE;\n-  private boolean pendingEndStream = false;\n-  private long expectedHeaderLength = 0;\n-  private long accumulatedHeaderLength = 0;\n-\n-  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) { this.callbacks = callbacks; }\n+  public JvmCallbackContext(EnvoyHTTPCallbacks callbacks) {\n+    bridgeUtility = new JvmBridgeUtility();\n+    this.callbacks = callbacks;\n+  }\n \n   /**\n    * Initializes state for accumulating header pairs via passHeaders, ultimately\n    * to be dispatched via the callback.\n    *\n    * @param length,    the total number of headers included in this header block.\n    * @param endStream, whether this header block is the final remote frame.\n+   * @return Void,     not used for response callbacks.\n    */\n-  public void onHeaders(long length, boolean endStream) {\n-    startAccumulation(FrameType.HEADERS, length, endStream);\n+  public Void onHeaders(long headerCount, boolean endStream) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MDQzNA=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjcxNTA2OnYy", "diffSide": "RIGHT", "path": "test/common/http/dispatcher_test.cc", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo0NjozOVrOG71Nuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMzowMDoyMFrOG8dbyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MTAzNQ==", "bodyText": "Do you foresee the context being passed down all the way to the Http::Dispatcher or stopping in the bridge layer?\nI ask because it would be great if instead of just updating the return type here we could actually cover the change with testing. But obviously the dispatcher is not seeing the context yet (or ever, hence my question).", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465391035", "createdAt": "2020-08-04T23:46:39Z", "author": {"login": "junr03"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -73,16 +73,18 @@ TEST_F(DispatcherTest, SetDestinationCluster) {\n   callbacks_called cc = {0, 0, 0, 0, 0, 0};\n   bridge_callbacks.context = &cc;\n   bridge_callbacks.on_headers = [](envoy_headers c_headers, bool end_stream,\n-                                   void* context) -> void {\n-    ASSERT_TRUE(end_stream);\n+                                   void* context) -> void* {\n+    EXPECT_TRUE(end_stream);\n     ResponseHeaderMapPtr response_headers = toResponseHeaders(c_headers);\n     EXPECT_EQ(response_headers->Status()->value().getStringView(), \"200\");\n     callbacks_called* cc = static_cast<callbacks_called*>(context);\n     cc->on_headers_calls++;\n+    return nullptr;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NDM5Mg==", "bodyText": "The dispatcher has no need to see it, since it doesn't utilize any signals returned by callbacks. So my inclination would be not to expose it at all there. My line of thinking was that the existing tests actually do cover the change, since they demonstrate that it causes no change in underlying functionality. Additional coverage will be needed for filters usage, of course.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r465394392", "createdAt": "2020-08-04T23:57:43Z", "author": {"login": "goaway"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -73,16 +73,18 @@ TEST_F(DispatcherTest, SetDestinationCluster) {\n   callbacks_called cc = {0, 0, 0, 0, 0, 0};\n   bridge_callbacks.context = &cc;\n   bridge_callbacks.on_headers = [](envoy_headers c_headers, bool end_stream,\n-                                   void* context) -> void {\n-    ASSERT_TRUE(end_stream);\n+                                   void* context) -> void* {\n+    EXPECT_TRUE(end_stream);\n     ResponseHeaderMapPtr response_headers = toResponseHeaders(c_headers);\n     EXPECT_EQ(response_headers->Status()->value().getStringView(), \"200\");\n     callbacks_called* cc = static_cast<callbacks_called*>(context);\n     cc->on_headers_calls++;\n+    return nullptr;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MTAzNQ=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0ODE3NA==", "bodyText": "Just so I understand: we're returning a nullptr here since we don't expect the consumer (the dispatcher) to use the return value?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r466048174", "createdAt": "2020-08-05T22:55:03Z", "author": {"login": "buildbreaker"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -73,16 +73,18 @@ TEST_F(DispatcherTest, SetDestinationCluster) {\n   callbacks_called cc = {0, 0, 0, 0, 0, 0};\n   bridge_callbacks.context = &cc;\n   bridge_callbacks.on_headers = [](envoy_headers c_headers, bool end_stream,\n-                                   void* context) -> void {\n-    ASSERT_TRUE(end_stream);\n+                                   void* context) -> void* {\n+    EXPECT_TRUE(end_stream);\n     ResponseHeaderMapPtr response_headers = toResponseHeaders(c_headers);\n     EXPECT_EQ(response_headers->Status()->value().getStringView(), \"200\");\n     callbacks_called* cc = static_cast<callbacks_called*>(context);\n     cc->on_headers_calls++;\n+    return nullptr;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MTAzNQ=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0OTk5Mg==", "bodyText": "The dispatcher has no need to see it, since it doesn't utilize any signals returned by callbacks. So my inclination would be not to expose it at all there.\n\nok, that was my read of it.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r466049992", "createdAt": "2020-08-05T23:00:20Z", "author": {"login": "junr03"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -73,16 +73,18 @@ TEST_F(DispatcherTest, SetDestinationCluster) {\n   callbacks_called cc = {0, 0, 0, 0, 0, 0};\n   bridge_callbacks.context = &cc;\n   bridge_callbacks.on_headers = [](envoy_headers c_headers, bool end_stream,\n-                                   void* context) -> void {\n-    ASSERT_TRUE(end_stream);\n+                                   void* context) -> void* {\n+    EXPECT_TRUE(end_stream);\n     ResponseHeaderMapPtr response_headers = toResponseHeaders(c_headers);\n     EXPECT_EQ(response_headers->Status()->value().getStringView(), \"200\");\n     callbacks_called* cc = static_cast<callbacks_called*>(context);\n     cc->on_headers_calls++;\n+    return nullptr;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MTAzNQ=="}, "originalCommit": {"oid": "904d455b8ee3b33f3c758e64f50040de20f92217"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDg4NzY3OnYy", "diffSide": "RIGHT", "path": "library/common/jni/jni_interface.cc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjo1MToxMlrOG8dPcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjo1MToxMlrOG8dPcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0NjgzNA==", "bodyText": "This isn't related to this PR but do we want to remove the on metadata callbacks since we are not using them or exposing them?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/979#discussion_r466046834", "createdAt": "2020-08-05T22:51:12Z", "author": {"login": "buildbreaker"}, "path": "library/common/jni/jni_interface.cc", "diffHunk": "@@ -175,41 +181,47 @@ static void jvm_on_data(envoy_data data, bool end_stream, void* context) {\n   // Here '0' (for which there is no named constant) indicates we want to commit the changes back\n   // to the JVM and free the c array, where applicable.\n   env->ReleasePrimitiveArrayCritical(j_data, critical_data, 0);\n-  env->CallVoidMethod(j_context, jmid_onData, j_data, end_stream ? JNI_TRUE : JNI_FALSE);\n+  jobject result =\n+      env->CallObjectMethod(j_context, jmid_onData, j_data, end_stream ? JNI_TRUE : JNI_FALSE);\n \n   data.release(data.context);\n   env->DeleteLocalRef(j_data);\n   env->DeleteLocalRef(jcls_JvmCallbackContext);\n+  return result;\n }\n \n-static void jvm_on_metadata(envoy_headers metadata, void* context) {\n+static void* jvm_on_metadata(envoy_headers metadata, void* context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f605878f39bfb1661876864b036097673622afb3"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 713, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}