{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0OTk2ODk5", "number": 967, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzowOTo1MlrOERI9Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMjozMzoyNlrOER-7QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDA4MDA2OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzowOTo1MlrOG1sGjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMTo0MTowN1rOG11QAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MDI4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              ASSERT(platform_filter_.instance_context, \"init_filter must be called initially\");\n          \n          \n            \n              ASSERT(platform_filter_.instance_context, \"expected initialized filter context\");", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r458950287", "createdAt": "2020-07-22T17:09:52Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -20,18 +20,31 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  platform_filter_.instance_context = platform_filter_.init_filter(platform_filter_.static_context);\n+\n+  ASSERT(platform_filter_.instance_context, \"init_filter unsuccessful\");\n+}\n+\n+void PlatformBridgeFilter::onDestroy() {\n+  ASSERT(platform_filter_.instance_context, \"init_filter must be called initially\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MDk3Nw==", "bodyText": "Same below. I think this is a bit clearer since technically init_filter can fail per the above assert", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r458950977", "createdAt": "2020-07-22T17:11:00Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -20,18 +20,31 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  platform_filter_.instance_context = platform_filter_.init_filter(platform_filter_.static_context);\n+\n+  ASSERT(platform_filter_.instance_context, \"init_filter unsuccessful\");\n+}\n+\n+void PlatformBridgeFilter::onDestroy() {\n+  ASSERT(platform_filter_.instance_context, \"init_filter must be called initially\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MDI4Nw=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwMDE2Mw==", "bodyText": "Sounds good.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459100163", "createdAt": "2020-07-22T21:41:07Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -20,18 +20,31 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  platform_filter_.instance_context = platform_filter_.init_filter(platform_filter_.static_context);\n+\n+  ASSERT(platform_filter_.instance_context, \"init_filter unsuccessful\");\n+}\n+\n+void PlatformBridgeFilter::onDestroy() {\n+  ASSERT(platform_filter_.instance_context, \"init_filter must be called initially\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MDI4Nw=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDA4OTY2OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzoxMjoxNFrOG1sMQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMTo0MzowMVrOG11TQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MTc0Ng==", "bodyText": "Is this necessary?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r458951746", "createdAt": "2020-07-22T17:12:14Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -66,40 +62,51 @@ static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n   return (envoy_headers){length, header_array};\n }\n \n+static const void* ios_http_filter_init(const void *context) {\n+  EnvoyHTTPFilterFactory *filterFactory = (__bridge EnvoyHTTPFilterFactory *)context;\n+  EnvoyHTTPFilter *filter = filterFactory.create();\n+  return CFBridgingRetain(filter);\n+}\n+\n static envoy_filter_headers_status\n-ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onRequestHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;\n+  if (filter.onRequestHeaders == nil) {\n     return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusContinue,\n                                          /*headers*/ headers};\n   }\n \n   EnvoyHeaders *platformHeaders = to_ios_headers(headers);\n   release_envoy_headers(headers);\n   // TODO(goaway): consider better solution for compound return\n-  NSArray *result = c->filter.onRequestHeaders(platformHeaders, end_stream);\n+  NSArray *result = filter.onRequestHeaders(platformHeaders, end_stream);\n   return (envoy_filter_headers_status){/*status*/ [result[0] intValue],\n                                        /*headers*/ toNativeHeaders(result[1])};\n }\n \n static envoy_filter_headers_status\n-ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onResponseHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;\n+  if (filter.onResponseHeaders == nil) {\n     return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusContinue,\n                                          /*headers*/ headers};\n   }\n \n   EnvoyHeaders *platformHeaders = to_ios_headers(headers);\n   release_envoy_headers(headers);\n   // TODO(goaway): consider better solution for compound return\n-  NSArray *result = c->filter.onResponseHeaders(platformHeaders, end_stream);\n+  NSArray *result = filter.onResponseHeaders(platformHeaders, end_stream);\n   return (envoy_filter_headers_status){/*status*/ [result[0] intValue],\n                                        /*headers*/ toNativeHeaders(result[1])};\n }\n \n+static void ios_http_filter_release(const void *context) {\n+  CFRelease(context);\n+  return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwMDk5Mw==", "bodyText": "The return statement? Technically no, but I guess I tend to err on the side of being explicit.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459100993", "createdAt": "2020-07-22T21:43:01Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -66,40 +62,51 @@ static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n   return (envoy_headers){length, header_array};\n }\n \n+static const void* ios_http_filter_init(const void *context) {\n+  EnvoyHTTPFilterFactory *filterFactory = (__bridge EnvoyHTTPFilterFactory *)context;\n+  EnvoyHTTPFilter *filter = filterFactory.create();\n+  return CFBridgingRetain(filter);\n+}\n+\n static envoy_filter_headers_status\n-ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onRequestHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;\n+  if (filter.onRequestHeaders == nil) {\n     return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusContinue,\n                                          /*headers*/ headers};\n   }\n \n   EnvoyHeaders *platformHeaders = to_ios_headers(headers);\n   release_envoy_headers(headers);\n   // TODO(goaway): consider better solution for compound return\n-  NSArray *result = c->filter.onRequestHeaders(platformHeaders, end_stream);\n+  NSArray *result = filter.onRequestHeaders(platformHeaders, end_stream);\n   return (envoy_filter_headers_status){/*status*/ [result[0] intValue],\n                                        /*headers*/ toNativeHeaders(result[1])};\n }\n \n static envoy_filter_headers_status\n-ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onResponseHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;\n+  if (filter.onResponseHeaders == nil) {\n     return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusContinue,\n                                          /*headers*/ headers};\n   }\n \n   EnvoyHeaders *platformHeaders = to_ios_headers(headers);\n   release_envoy_headers(headers);\n   // TODO(goaway): consider better solution for compound return\n-  NSArray *result = c->filter.onResponseHeaders(platformHeaders, end_stream);\n+  NSArray *result = filter.onResponseHeaders(platformHeaders, end_stream);\n   return (envoy_filter_headers_status){/*status*/ [result[0] intValue],\n                                        /*headers*/ toNativeHeaders(result[1])};\n }\n \n+static void ios_http_filter_release(const void *context) {\n+  CFRelease(context);\n+  return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MTc0Ng=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDA5NzYxOnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/Filter.swift", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzoxNDoyNFrOG1sROg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMTo0MzoyMVrOG11TyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MzAxOA==", "bodyText": "I'd probably remove this and just it below using filterType.init()", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r458953018", "createdAt": "2020-07-22T17:14:24Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -4,14 +4,33 @@ import Foundation\n /// Interface representing a filter. See `RequestFilter` and `ResponseFilter` for more details.\n public protocol Filter {\n   /// A unique name for a filter implementation. Needed for extension registration.\n-  var name: String { get }\n+  static var name: String { get }\n+\n+  /// Required initializer for internal creation.\n+  init()\n+}\n+\n+extension Filter {\n+  static func create() -> EnvoyHTTPFilter {\n+    return EnvoyHTTPFilter(filter: Self.init())\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwMTEyOQ==", "bodyText": "Yep, good catch - this is leftover from an earlier approach.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459101129", "createdAt": "2020-07-22T21:43:21Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -4,14 +4,33 @@ import Foundation\n /// Interface representing a filter. See `RequestFilter` and `ResponseFilter` for more details.\n public protocol Filter {\n   /// A unique name for a filter implementation. Needed for extension registration.\n-  var name: String { get }\n+  static var name: String { get }\n+\n+  /// Required initializer for internal creation.\n+  init()\n+}\n+\n+extension Filter {\n+  static func create() -> EnvoyHTTPFilter {\n+    return EnvoyHTTPFilter(filter: Self.init())\n+  }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MzAxOA=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTA2NDE4OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMTo1ODozMlrOG11thg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjozNzo1NlrOG12o1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwNzcxOA==", "bodyText": "should this be a const ref to the struct? Ah nvm, I understand now. Each c++ filter instance gets a fresh copy of the struct, and then changes the instance_context_ pointer to point to whatever the init function returns. But all the other fields in the copied struct refer to static fields.\nCan we spell the model a little bit more in inline comments? For posterity, and for our personal reference.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459107718", "createdAt": "2020-07-22T21:58:32Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.h", "diffHunk": "@@ -50,7 +53,7 @@ class PlatformBridgeFilter final : public Http::PassThroughFilter {\n private:\n   Http::FilterHeadersStatus onHeaders(Http::HeaderMap& headers, bool end_stream,\n                                       envoy_filter_on_headers_f on_headers);\n-  const envoy_http_filter* platform_filter_;\n+  envoy_http_filter platform_filter_;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMjkwMA==", "bodyText": "Good call.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459122900", "createdAt": "2020-07-22T22:37:56Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.h", "diffHunk": "@@ -50,7 +53,7 @@ class PlatformBridgeFilter final : public Http::PassThroughFilter {\n private:\n   Http::FilterHeadersStatus onHeaders(Http::HeaderMap& headers, bool end_stream,\n                                       envoy_filter_on_headers_f on_headers);\n-  const envoy_http_filter* platform_filter_;\n+  envoy_http_filter platform_filter_;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwNzcxOA=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTA3MzA0OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngine.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjowMTo0NFrOG11y3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjozNzoxNFrOG12n5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTA4NA==", "bodyText": "should we use similar verbs between here and the bridge (init)?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459109084", "createdAt": "2020-07-22T22:01:44Z", "author": {"login": "junr03"}, "path": "library/objective-c/EnvoyEngine.h", "diffHunk": "@@ -68,14 +68,22 @@ extern const int kEnvoyFilterHeadersStatusStopAllIterationAndBuffer;\n \n @interface EnvoyHTTPFilter : NSObject\n \n-@property (nonatomic, strong) NSString *name;\n-\n @property (nonatomic, strong) NSArray * (^onRequestHeaders)(EnvoyHeaders *headers, BOOL endStream);\n \n @property (nonatomic, strong) NSArray * (^onResponseHeaders)(EnvoyHeaders *headers, BOOL endStream);\n \n @end\n \n+#pragma mark - EnvoyHTTPFilterFactory\n+\n+@interface EnvoyHTTPFilterFactory : NSObject\n+\n+@property (nonatomic, strong) NSString *filterName;\n+\n+@property (nonatomic, strong) EnvoyHTTPFilter * (^create)();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMjY2Mg==", "bodyText": "I presented the interface to the bridge layer as something like a class/instance, so init made sense. I implemented it at this layer as a split between a factory and an implementation, so create made sense.\nAt least, to me.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459122662", "createdAt": "2020-07-22T22:37:14Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngine.h", "diffHunk": "@@ -68,14 +68,22 @@ extern const int kEnvoyFilterHeadersStatusStopAllIterationAndBuffer;\n \n @interface EnvoyHTTPFilter : NSObject\n \n-@property (nonatomic, strong) NSString *name;\n-\n @property (nonatomic, strong) NSArray * (^onRequestHeaders)(EnvoyHeaders *headers, BOOL endStream);\n \n @property (nonatomic, strong) NSArray * (^onResponseHeaders)(EnvoyHeaders *headers, BOOL endStream);\n \n @end\n \n+#pragma mark - EnvoyHTTPFilterFactory\n+\n+@interface EnvoyHTTPFilterFactory : NSObject\n+\n+@property (nonatomic, strong) NSString *filterName;\n+\n+@property (nonatomic, strong) EnvoyHTTPFilter * (^create)();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEwOTA4NA=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTA4NTEzOnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjowNjozN1rOG116OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjozNTo0M1rOG12mCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMDk2OA==", "bodyText": "what does the __bridge in the cast mean?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459110968", "createdAt": "2020-07-22T22:06:37Z", "author": {"login": "junr03"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -66,40 +62,51 @@ static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n   return (envoy_headers){length, header_array};\n }\n \n+static const void* ios_http_filter_init(const void *context) {\n+  EnvoyHTTPFilterFactory *filterFactory = (__bridge EnvoyHTTPFilterFactory *)context;\n+  EnvoyHTTPFilter *filter = filterFactory.create();\n+  return CFBridgingRetain(filter);\n+}\n+\n static envoy_filter_headers_status\n-ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onRequestHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMjE4NQ==", "bodyText": "__bridge tells ARC that we're pulling out a retainable object here, but not to actually do anything with the retain count at this point.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459122185", "createdAt": "2020-07-22T22:35:43Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -66,40 +62,51 @@ static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n   return (envoy_headers){length, header_array};\n }\n \n+static const void* ios_http_filter_init(const void *context) {\n+  EnvoyHTTPFilterFactory *filterFactory = (__bridge EnvoyHTTPFilterFactory *)context;\n+  EnvoyHTTPFilter *filter = filterFactory.create();\n+  return CFBridgingRetain(filter);\n+}\n+\n static envoy_filter_headers_status\n-ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onRequestHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMDk2OA=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTA4ODA1OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjowNzo0OFrOG118FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjozMzowOVrOG12h9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTQ0NA==", "bodyText": "how come the pointer doen't need dereference here?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459111444", "createdAt": "2020-07-22T22:07:48Z", "author": {"login": "junr03"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -66,40 +62,51 @@ static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n   return (envoy_headers){length, header_array};\n }\n \n+static const void* ios_http_filter_init(const void *context) {\n+  EnvoyHTTPFilterFactory *filterFactory = (__bridge EnvoyHTTPFilterFactory *)context;\n+  EnvoyHTTPFilter *filter = filterFactory.create();\n+  return CFBridgingRetain(filter);\n+}\n+\n static envoy_filter_headers_status\n-ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onRequestHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;\n+  if (filter.onRequestHeaders == nil) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMTE0Mg==", "bodyText": "Yeah, seems weird if you've been looking at C++ for a while. Technically speaking we're using shorthand to send an Objective-C message to filter - the expanded syntax would be [filter onRequestHeaders]. This just happens to be what the shorthand looks like.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459121142", "createdAt": "2020-07-22T22:33:09Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -66,40 +62,51 @@ static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n   return (envoy_headers){length, header_array};\n }\n \n+static const void* ios_http_filter_init(const void *context) {\n+  EnvoyHTTPFilterFactory *filterFactory = (__bridge EnvoyHTTPFilterFactory *)context;\n+  EnvoyHTTPFilter *filter = filterFactory.create();\n+  return CFBridgingRetain(filter);\n+}\n+\n static envoy_filter_headers_status\n-ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onRequestHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;\n+  if (filter.onRequestHeaders == nil) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExMTQ0NA=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTEwOTk2OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngineImpl.m", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjoxNjo0OFrOG12JJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjozMDo1N1rOG12etQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNDc5MQ==", "bodyText": "I think we talked about it in one of the earlier PRs, but could we delete the duplication and dispatch to common code between request and reply?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459114791", "createdAt": "2020-07-22T22:16:48Z", "author": {"login": "junr03"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -66,40 +62,51 @@ static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n   return (envoy_headers){length, header_array};\n }\n \n+static const void* ios_http_filter_init(const void *context) {\n+  EnvoyHTTPFilterFactory *filterFactory = (__bridge EnvoyHTTPFilterFactory *)context;\n+  EnvoyHTTPFilter *filter = filterFactory.create();\n+  return CFBridgingRetain(filter);\n+}\n+\n static envoy_filter_headers_status\n-ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onRequestHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;\n+  if (filter.onRequestHeaders == nil) {\n     return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusContinue,\n                                          /*headers*/ headers};\n   }\n \n   EnvoyHeaders *platformHeaders = to_ios_headers(headers);\n   release_envoy_headers(headers);\n   // TODO(goaway): consider better solution for compound return\n-  NSArray *result = c->filter.onRequestHeaders(platformHeaders, end_stream);\n+  NSArray *result = filter.onRequestHeaders(platformHeaders, end_stream);\n   return (envoy_filter_headers_status){/*status*/ [result[0] intValue],\n                                        /*headers*/ toNativeHeaders(result[1])};\n }\n \n static envoy_filter_headers_status\n-ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, const void *context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMDExNg==", "bodyText": "I did delete the (more significant) duplication on that PR (in filter.cc). Here, I'd suggest it's pretty limited. We check if the function's present, map the headers, call the function. I almost feel the extra indirection from factoring here would serve only to complicate the code.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459120116", "createdAt": "2020-07-22T22:30:24Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -66,40 +62,51 @@ static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n   return (envoy_headers){length, header_array};\n }\n \n+static const void* ios_http_filter_init(const void *context) {\n+  EnvoyHTTPFilterFactory *filterFactory = (__bridge EnvoyHTTPFilterFactory *)context;\n+  EnvoyHTTPFilter *filter = filterFactory.create();\n+  return CFBridgingRetain(filter);\n+}\n+\n static envoy_filter_headers_status\n-ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onRequestHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;\n+  if (filter.onRequestHeaders == nil) {\n     return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusContinue,\n                                          /*headers*/ headers};\n   }\n \n   EnvoyHeaders *platformHeaders = to_ios_headers(headers);\n   release_envoy_headers(headers);\n   // TODO(goaway): consider better solution for compound return\n-  NSArray *result = c->filter.onRequestHeaders(platformHeaders, end_stream);\n+  NSArray *result = filter.onRequestHeaders(platformHeaders, end_stream);\n   return (envoy_filter_headers_status){/*status*/ [result[0] intValue],\n                                        /*headers*/ toNativeHeaders(result[1])};\n }\n \n static envoy_filter_headers_status\n-ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, const void *context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNDc5MQ=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMDMwOQ==", "bodyText": "But I mean, only just almost? If you feel strongly, I can still do it.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r459120309", "createdAt": "2020-07-22T22:30:57Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngineImpl.m", "diffHunk": "@@ -66,40 +62,51 @@ static envoy_headers toNativeHeaders(EnvoyHeaders *headers) {\n   return (envoy_headers){length, header_array};\n }\n \n+static const void* ios_http_filter_init(const void *context) {\n+  EnvoyHTTPFilterFactory *filterFactory = (__bridge EnvoyHTTPFilterFactory *)context;\n+  EnvoyHTTPFilter *filter = filterFactory.create();\n+  return CFBridgingRetain(filter);\n+}\n+\n static envoy_filter_headers_status\n-ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_request_headers(envoy_headers headers, bool end_stream, const void *context) {\n   // TODO(goaway): optimize unmodified case\n-  ios_http_filter_context *c = (ios_http_filter_context *)context;\n-  if (c->filter.onRequestHeaders == nil) {\n+  EnvoyHTTPFilter *filter = (__bridge EnvoyHTTPFilter *)context;\n+  if (filter.onRequestHeaders == nil) {\n     return (envoy_filter_headers_status){/*status*/ kEnvoyFilterHeadersStatusContinue,\n                                          /*headers*/ headers};\n   }\n \n   EnvoyHeaders *platformHeaders = to_ios_headers(headers);\n   release_envoy_headers(headers);\n   // TODO(goaway): consider better solution for compound return\n-  NSArray *result = c->filter.onRequestHeaders(platformHeaders, end_stream);\n+  NSArray *result = filter.onRequestHeaders(platformHeaders, end_stream);\n   return (envoy_filter_headers_status){/*status*/ [result[0] intValue],\n                                        /*headers*/ toNativeHeaders(result[1])};\n }\n \n static envoy_filter_headers_status\n-ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, void *context) {\n+ios_http_filter_on_response_headers(envoy_headers headers, bool end_stream, const void *context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNDc5MQ=="}, "originalCommit": {"oid": "e37f31065e1ab205385f2dac10785cdc0f2a7ba6"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjUwNzQyOnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTozODoyN1rOG27iOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDo1Nzo1MlrOG29kMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MTcwNw==", "bodyText": "Is this a feature we want to support? i.e do we want it to be possible to have static filters? While potentially useful in some cases I worry that giving options might make the entire affair a little more confusing.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460251707", "createdAt": "2020-07-24T19:38:27Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2MDEwMA==", "bodyText": "I'm primarily interested in supporting it right now because I like the convention of being able to calloc these structs as a safety convention. I wasn't planning on exposing it above this level at this point.\nI agree about not introducing extra complexity, but I also realized it didn't take very much to support it generally here. Assuming we move forward, I will ensure a test covers this case.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460260100", "createdAt": "2020-07-24T19:57:38Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MTcwNw=="}, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MjE2Ng==", "bodyText": "I agree with @junr03 that I'd prefer we stick with one approach (instance-based filters) rather than supporting static implementations (even if it's minimal work to add that support). Even if it's not something we bubble up to the public interface, it's still something we'd be implicitly supporting internally and subject to breakage, and I'm not sure I see much value in providing that functionality", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460272166", "createdAt": "2020-07-24T20:26:58Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MTcwNw=="}, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MjU4Mg==", "bodyText": "I'm also a little concerned that having this in place might lead us to miss actual problems with instance-based filters (i.e., init_filter being accidentally unset)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460272582", "createdAt": "2020-07-24T20:28:03Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MTcwNw=="}, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4NDk3Nw==", "bodyText": "Talked to @rebello95 and upon further consideration, I think the two of you make a good point and we should prefer simplicity. I'll switch this over to logging if init_filter isn't provided, and nulling out the rest of the struct for safety.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460284977", "createdAt": "2020-07-24T20:57:52Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MTcwNw=="}, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjUwOTY3OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTozOToxN1rOG27jnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTo1ODo1NlrOG28E_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MjA2Mw==", "bodyText": "can we interpolate the filter name here? Makes for easier crash debugging", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460252063", "createdAt": "2020-07-24T19:39:17Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.\n+  if (platform_filter_.init_filter == nullptr) {\n+    // Make static context available to invocations, in lieu of instatiated context.\n+    platform_filter_.instance_context = platform_filter_.static_context;\n+    return;\n+  }\n+\n+  // Set the instance_context to the result of the initialization call. Cleanup will ultimately\n+  // occur during in the onDestroy() invocation below.\n+  platform_filter_.instance_context = platform_filter_.init_filter(platform_filter_.static_context);\n+\n+  ASSERT(platform_filter_.instance_context, \"init_filter unsuccessful\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2MDYwNQ==", "bodyText": "Sure.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460260605", "createdAt": "2020-07-24T19:58:56Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.\n+  if (platform_filter_.init_filter == nullptr) {\n+    // Make static context available to invocations, in lieu of instatiated context.\n+    platform_filter_.instance_context = platform_filter_.static_context;\n+    return;\n+  }\n+\n+  // Set the instance_context to the result of the initialization call. Cleanup will ultimately\n+  // occur during in the onDestroy() invocation below.\n+  platform_filter_.instance_context = platform_filter_.init_filter(platform_filter_.static_context);\n+\n+  ASSERT(platform_filter_.instance_context, \"init_filter unsuccessful\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MjA2Mw=="}, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjUxMjAwOnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTo0MDowNlrOG27lCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDoyOTozNFrOG282Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MjQyNA==", "bodyText": "I liked being able to tell that reaching a nullptr here was a programming mistake.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460252424", "createdAt": "2020-07-24T19:40:06Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.\n+  if (platform_filter_.init_filter == nullptr) {\n+    // Make static context available to invocations, in lieu of instatiated context.\n+    platform_filter_.instance_context = platform_filter_.static_context;\n+    return;\n+  }\n+\n+  // Set the instance_context to the result of the initialization call. Cleanup will ultimately\n+  // occur during in the onDestroy() invocation below.\n+  platform_filter_.instance_context = platform_filter_.init_filter(platform_filter_.static_context);\n+\n+  ASSERT(platform_filter_.instance_context, \"init_filter unsuccessful\");\n+}\n+\n+void PlatformBridgeFilter::onDestroy() {\n+  // Allow nullptr to act as no-op. Also return if nothing was initialized.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1ODkwOQ==", "bodyText": "The thing is that as long as Envoy adheres to its contract about filter callbacks, the assertion in init_filter will have already been hit.\nI decided the extra assertions really amounted to asserting Envoy adheres to its contract, which is better done by Envoy's own coverage.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460258909", "createdAt": "2020-07-24T19:55:02Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.\n+  if (platform_filter_.init_filter == nullptr) {\n+    // Make static context available to invocations, in lieu of instatiated context.\n+    platform_filter_.instance_context = platform_filter_.static_context;\n+    return;\n+  }\n+\n+  // Set the instance_context to the result of the initialization call. Cleanup will ultimately\n+  // occur during in the onDestroy() invocation below.\n+  platform_filter_.instance_context = platform_filter_.init_filter(platform_filter_.static_context);\n+\n+  ASSERT(platform_filter_.instance_context, \"init_filter unsuccessful\");\n+}\n+\n+void PlatformBridgeFilter::onDestroy() {\n+  // Allow nullptr to act as no-op. Also return if nothing was initialized.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MjQyNA=="}, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3MzE5OQ==", "bodyText": "As I alluded above, I also think that it'd be better to treat nullptr as a programming error here rather than allowing for static filters", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460273199", "createdAt": "2020-07-24T20:29:34Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n+  // In the typical case, this will represent a filter implementation that needs to be intantiated.\n+  // static_context will contain the necessary platform-specific mechanism to produce a filter\n+  // instance. instance_context will initially be null, but after initialization, set to the\n+  // context needed for actual filter invocations.\n+\n+  // We treat a null initializer as a static implementation.\n+  if (platform_filter_.init_filter == nullptr) {\n+    // Make static context available to invocations, in lieu of instatiated context.\n+    platform_filter_.instance_context = platform_filter_.static_context;\n+    return;\n+  }\n+\n+  // Set the instance_context to the result of the initialization call. Cleanup will ultimately\n+  // occur during in the onDestroy() invocation below.\n+  platform_filter_.instance_context = platform_filter_.init_filter(platform_filter_.static_context);\n+\n+  ASSERT(platform_filter_.instance_context, \"init_filter unsuccessful\");\n+}\n+\n+void PlatformBridgeFilter::onDestroy() {\n+  // Allow nullptr to act as no-op. Also return if nothing was initialized.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MjQyNA=="}, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjUxNjg2OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTo0MTo1MFrOG27oCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxOTo0MTo1MFrOG27oCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MzE5Mw==", "bodyText": "Awesome this is great.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460253193", "createdAt": "2020-07-24T19:41:50Z", "author": {"login": "junr03"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -21,18 +21,47 @@ PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(config->platform_filter()) {}\n+    : platform_filter_(*config->platform_filter()) {\n+  // The initialization above sets platform_filter_ to a copy of the struct stored on the config.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdc0af67d3e3dd261e62a1d3914bc2382e446868"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MjkyMjI0OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMjozMzoyNlrOG2_brg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMjo1MjowMVrOG2_ucQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMxNTU2Ng==", "bodyText": "Any reason not to make this an ASSERT?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460315566", "createdAt": "2020-07-24T22:33:26Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -17,34 +17,37 @@ namespace PlatformBridge {\n \n PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n     const envoymobile::extensions::filters::http::platform_bridge::PlatformBridge& proto_config)\n-    : platform_filter_(static_cast<envoy_http_filter*>(\n+    : filter_name_(proto_config.platform_filter_name()),\n+      platform_filter_(static_cast<envoy_http_filter*>(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(*config->platform_filter()) {\n+    : filter_name_(config->filter_name()), platform_filter_(*config->platform_filter()) {\n   // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n   // In the typical case, this will represent a filter implementation that needs to be intantiated.\n   // static_context will contain the necessary platform-specific mechanism to produce a filter\n   // instance. instance_context will initially be null, but after initialization, set to the\n   // context needed for actual filter invocations.\n \n-  // We treat a null initializer as a static implementation.\n+  // If init_filter is missing, zero out the rest of the struct for safety.\n   if (platform_filter_.init_filter == nullptr) {\n-    // Make static context available to invocations, in lieu of instatiated context.\n-    platform_filter_.instance_context = platform_filter_.static_context;\n+    ENVOY_LOG(debug, \"platform bridge filter: missing initializer for {}\", filter_name_);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "538c8da2d443730d5440dc51c7dadf3b6ef65266"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMyMDM2OQ==", "bodyText": "Yeah, calloc as no-op still has way less overhead than an empty implementation. This restricts handling to only that case though (as opposed to the previous general notion of static support).", "url": "https://github.com/envoyproxy/envoy-mobile/pull/967#discussion_r460320369", "createdAt": "2020-07-24T22:52:01Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -17,34 +17,37 @@ namespace PlatformBridge {\n \n PlatformBridgeFilterConfig::PlatformBridgeFilterConfig(\n     const envoymobile::extensions::filters::http::platform_bridge::PlatformBridge& proto_config)\n-    : platform_filter_(static_cast<envoy_http_filter*>(\n+    : filter_name_(proto_config.platform_filter_name()),\n+      platform_filter_(static_cast<envoy_http_filter*>(\n           Api::External::retrieveApi(proto_config.platform_filter_name()))) {}\n \n PlatformBridgeFilter::PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config)\n-    : platform_filter_(*config->platform_filter()) {\n+    : filter_name_(config->filter_name()), platform_filter_(*config->platform_filter()) {\n   // The initialization above sets platform_filter_ to a copy of the struct stored on the config.\n   // In the typical case, this will represent a filter implementation that needs to be intantiated.\n   // static_context will contain the necessary platform-specific mechanism to produce a filter\n   // instance. instance_context will initially be null, but after initialization, set to the\n   // context needed for actual filter invocations.\n \n-  // We treat a null initializer as a static implementation.\n+  // If init_filter is missing, zero out the rest of the struct for safety.\n   if (platform_filter_.init_filter == nullptr) {\n-    // Make static context available to invocations, in lieu of instatiated context.\n-    platform_filter_.instance_context = platform_filter_.static_context;\n+    ENVOY_LOG(debug, \"platform bridge filter: missing initializer for {}\", filter_name_);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMxNTU2Ng=="}, "originalCommit": {"oid": "538c8da2d443730d5440dc51c7dadf3b6ef65266"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 698, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}