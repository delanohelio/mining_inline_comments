{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxNjc4NjI5", "number": 1118, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMToyNDo1NFrOErXOSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjoxODowOVrOEszCJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTA0NzE1OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/c_type_definitions.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMToyNDo1NFrOHeGEwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNzoxMVrOHfDgeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxODg0OA==", "bodyText": "If these are truly arbitrary, why not start zero-indexed? I assume the -1 is coming from the same reasoning above, in which case we should probably make that clearer here", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501318848", "createdAt": "2020-10-07T21:24:54Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/c_type_definitions.h", "diffHunk": "@@ -44,3 +44,7 @@ const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusStopIteration =\n // See comment above.\n const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusResumeIteration =\n     kEnvoyFilterTrailersStatusContinue - 1;\n+\n+// These values don't exist in Envoy and are essentially arbitrary.\n+const envoy_filter_resume_status_t kEnvoyFilterResumeStatusStopIteration = 1;\n+const envoy_filter_resume_status_t kEnvoyFilterResumeStatusResumeIteration = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNTM2OA==", "bodyText": "I simply set them to be consistent with other invocations, but the comment is meant to suggest that one shouldn't rely on them being anything in particular (other than constant). They could also be zero-indexed (and I actually don't have a preference).", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502325368", "createdAt": "2020-10-09T10:07:11Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/c_type_definitions.h", "diffHunk": "@@ -44,3 +44,7 @@ const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusStopIteration =\n // See comment above.\n const envoy_filter_trailers_status_t kEnvoyFilterTrailersStatusResumeIteration =\n     kEnvoyFilterTrailersStatusContinue - 1;\n+\n+// These values don't exist in Envoy and are essentially arbitrary.\n+const envoy_filter_resume_status_t kEnvoyFilterResumeStatusStopIteration = 1;\n+const envoy_filter_resume_status_t kEnvoyFilterResumeStatusResumeIteration = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxODg0OA=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTA4OTM5OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTozODo0N1rOHeGdpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDowNzowMVrOHfDgLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNTIyMg==", "bodyText": "nits on naming:\n\npending_* here might be easily misread between pending_headers/pending_request_header. Might be worth changing to headers_to_send or something like that\nwhy internal_buffer instead of pending_request_data to align with the others?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501325222", "createdAt": "2020-10-07T21:38:47Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNjkwOQ==", "bodyText": "I now see below that internal_buffer is reused between request/response, which I assume is the reason for that name. Are there any concerns around that state not being properly cleared before starting to receive response data?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501326909", "createdAt": "2020-10-07T21:42:46Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNTIyMg=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNTI5Mw==", "bodyText": "internal_buffer is a temporary pointer to the buffer needed for that invocation. The naming here is consistent with the other invocations, which do share more code. (The actual underlying memory is never shared between the request and response path.) I elected not to share code in this case as I felt it introduced more complexity rather than simplified things, due to the number of pending references in this singular case.\nBut honestly no strong feelings. Since the code isn't shared, we could be more particular about the naming.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502325293", "createdAt": "2020-10-09T10:07:01Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNTIyMg=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTA5MTUxOnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTozOTozNVrOHeGe7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDoxMToxM1rOHfDoyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNTU1MQ==", "bodyText": "Should we assert in the else case that result.pending_headers is not passed?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501325551", "createdAt": "2020-10-07T21:39:35Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;\n+  if (pending_request_headers_) {\n+    *pending_headers = Http::Utility::toBridgeHeaders(*pending_request_headers_);\n+  }\n+  if (internal_buffer) {\n+    *pending_data = Buffer::Utility::copyToBridgeData(*internal_buffer);\n+  }\n+  if (pending_request_trailers_) {\n+    *pending_trailers = Http::Utility::toBridgeHeaders(*pending_request_trailers_);\n+  }\n+\n+  envoy_filter_resume_status result =\n+      platform_filter_.on_resume_request(pending_headers, pending_data, pending_trailers,\n+                                         request_complete_, platform_filter_.instance_context);\n+  if (result.status == kEnvoyFilterResumeStatusStopIteration) {\n+    return;\n+  }\n+  if (pending_request_headers_) {\n+    PlatformBridgeFilter::replaceHeaders(*pending_request_headers_, *result.pending_headers);\n+    pending_request_headers_ = nullptr;\n+    free(result.pending_headers);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNzQ5Ng==", "bodyText": "Sure. It will explode either way, but an ASSERT lets us give a nice reason for it. I'll update.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502327496", "createdAt": "2020-10-09T10:11:13Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;\n+  if (pending_request_headers_) {\n+    *pending_headers = Http::Utility::toBridgeHeaders(*pending_request_headers_);\n+  }\n+  if (internal_buffer) {\n+    *pending_data = Buffer::Utility::copyToBridgeData(*internal_buffer);\n+  }\n+  if (pending_request_trailers_) {\n+    *pending_trailers = Http::Utility::toBridgeHeaders(*pending_request_trailers_);\n+  }\n+\n+  envoy_filter_resume_status result =\n+      platform_filter_.on_resume_request(pending_headers, pending_data, pending_trailers,\n+                                         request_complete_, platform_filter_.instance_context);\n+  if (result.status == kEnvoyFilterResumeStatusStopIteration) {\n+    return;\n+  }\n+  if (pending_request_headers_) {\n+    PlatformBridgeFilter::replaceHeaders(*pending_request_headers_, *result.pending_headers);\n+    pending_request_headers_ = nullptr;\n+    free(result.pending_headers);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNTU1MQ=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTA5MjE4OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTozOTo0NFrOHeGfSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDoxMzo1MFrOHfDtdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNTY0Mg==", "bodyText": "Same here regarding assert", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501325642", "createdAt": "2020-10-07T21:39:44Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;\n+  if (pending_request_headers_) {\n+    *pending_headers = Http::Utility::toBridgeHeaders(*pending_request_headers_);\n+  }\n+  if (internal_buffer) {\n+    *pending_data = Buffer::Utility::copyToBridgeData(*internal_buffer);\n+  }\n+  if (pending_request_trailers_) {\n+    *pending_trailers = Http::Utility::toBridgeHeaders(*pending_request_trailers_);\n+  }\n+\n+  envoy_filter_resume_status result =\n+      platform_filter_.on_resume_request(pending_headers, pending_data, pending_trailers,\n+                                         request_complete_, platform_filter_.instance_context);\n+  if (result.status == kEnvoyFilterResumeStatusStopIteration) {\n+    return;\n+  }\n+  if (pending_request_headers_) {\n+    PlatformBridgeFilter::replaceHeaders(*pending_request_headers_, *result.pending_headers);\n+    pending_request_headers_ = nullptr;\n+    free(result.pending_headers);\n+  }\n+  if (internal_buffer) {\n+    internal_buffer->drain(internal_buffer->length());\n+    internal_buffer->addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    free(result.pending_data);\n+  } else if (result.pending_data) {\n+    Buffer::OwnedImpl inject_data;\n+    inject_data.addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    decoder_callbacks_->addDecodedData(inject_data, false);\n+    free(result.pending_data);\n+  }\n+  if (pending_request_trailers_) {\n+    PlatformBridgeFilter::replaceHeaders(*pending_request_trailers_, *result.pending_trailers);\n+    pending_request_trailers_ = nullptr;\n+    free(result.pending_trailers);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyODY5Mw==", "bodyText": "Sounds good, I'll update.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502328693", "createdAt": "2020-10-09T10:13:50Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;\n+  if (pending_request_headers_) {\n+    *pending_headers = Http::Utility::toBridgeHeaders(*pending_request_headers_);\n+  }\n+  if (internal_buffer) {\n+    *pending_data = Buffer::Utility::copyToBridgeData(*internal_buffer);\n+  }\n+  if (pending_request_trailers_) {\n+    *pending_trailers = Http::Utility::toBridgeHeaders(*pending_request_trailers_);\n+  }\n+\n+  envoy_filter_resume_status result =\n+      platform_filter_.on_resume_request(pending_headers, pending_data, pending_trailers,\n+                                         request_complete_, platform_filter_.instance_context);\n+  if (result.status == kEnvoyFilterResumeStatusStopIteration) {\n+    return;\n+  }\n+  if (pending_request_headers_) {\n+    PlatformBridgeFilter::replaceHeaders(*pending_request_headers_, *result.pending_headers);\n+    pending_request_headers_ = nullptr;\n+    free(result.pending_headers);\n+  }\n+  if (internal_buffer) {\n+    internal_buffer->drain(internal_buffer->length());\n+    internal_buffer->addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    free(result.pending_data);\n+  } else if (result.pending_data) {\n+    Buffer::OwnedImpl inject_data;\n+    inject_data.addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    decoder_callbacks_->addDecodedData(inject_data, false);\n+    free(result.pending_data);\n+  }\n+  if (pending_request_trailers_) {\n+    PlatformBridgeFilter::replaceHeaders(*pending_request_trailers_, *result.pending_trailers);\n+    pending_request_trailers_ = nullptr;\n+    free(result.pending_trailers);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNTY0Mg=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTA5NTkzOnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0MTowN1rOHeGhiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo0MjoxNlrOHfRSjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNjIxNg==", "bodyText": "is false referring to end_stream here? If so, is it safe to always assume false (how does the consumer close the stream?)?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501326216", "createdAt": "2020-10-07T21:41:07Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;\n+  if (pending_request_headers_) {\n+    *pending_headers = Http::Utility::toBridgeHeaders(*pending_request_headers_);\n+  }\n+  if (internal_buffer) {\n+    *pending_data = Buffer::Utility::copyToBridgeData(*internal_buffer);\n+  }\n+  if (pending_request_trailers_) {\n+    *pending_trailers = Http::Utility::toBridgeHeaders(*pending_request_trailers_);\n+  }\n+\n+  envoy_filter_resume_status result =\n+      platform_filter_.on_resume_request(pending_headers, pending_data, pending_trailers,\n+                                         request_complete_, platform_filter_.instance_context);\n+  if (result.status == kEnvoyFilterResumeStatusStopIteration) {\n+    return;\n+  }\n+  if (pending_request_headers_) {\n+    PlatformBridgeFilter::replaceHeaders(*pending_request_headers_, *result.pending_headers);\n+    pending_request_headers_ = nullptr;\n+    free(result.pending_headers);\n+  }\n+  if (internal_buffer) {\n+    internal_buffer->drain(internal_buffer->length());\n+    internal_buffer->addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    free(result.pending_data);\n+  } else if (result.pending_data) {\n+    Buffer::OwnedImpl inject_data;\n+    inject_data.addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    decoder_callbacks_->addDecodedData(inject_data, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyODYxMg==", "bodyText": "The false actually is part of an unrelated Envoy API that has to do with whether buffer watermarking will occur - which has to do with backpressure, and isn't applicable for a library. (The documentation on the API is actually a little bit ambiguous to me, but false seemed correct based on my reading of it and other usage I've encountered.)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502328612", "createdAt": "2020-10-09T10:13:43Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;\n+  if (pending_request_headers_) {\n+    *pending_headers = Http::Utility::toBridgeHeaders(*pending_request_headers_);\n+  }\n+  if (internal_buffer) {\n+    *pending_data = Buffer::Utility::copyToBridgeData(*internal_buffer);\n+  }\n+  if (pending_request_trailers_) {\n+    *pending_trailers = Http::Utility::toBridgeHeaders(*pending_request_trailers_);\n+  }\n+\n+  envoy_filter_resume_status result =\n+      platform_filter_.on_resume_request(pending_headers, pending_data, pending_trailers,\n+                                         request_complete_, platform_filter_.instance_context);\n+  if (result.status == kEnvoyFilterResumeStatusStopIteration) {\n+    return;\n+  }\n+  if (pending_request_headers_) {\n+    PlatformBridgeFilter::replaceHeaders(*pending_request_headers_, *result.pending_headers);\n+    pending_request_headers_ = nullptr;\n+    free(result.pending_headers);\n+  }\n+  if (internal_buffer) {\n+    internal_buffer->drain(internal_buffer->length());\n+    internal_buffer->addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    free(result.pending_data);\n+  } else if (result.pending_data) {\n+    Buffer::OwnedImpl inject_data;\n+    inject_data.addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    decoder_callbacks_->addDecodedData(inject_data, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNjIxNg=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MTE4Mw==", "bodyText": "Got it. Let's do an inline /* watermark */ to annotate", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502551183", "createdAt": "2020-10-09T16:42:16Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.cc", "diffHunk": "@@ -313,9 +321,111 @@ PlatformBridgeFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {\n   if (status == Http::FilterTrailersStatus::StopIteration) {\n     pending_response_trailers_ = &trailers;\n   }\n+  response_complete_ = true;\n   return status;\n }\n \n+void PlatformBridgeFilter::onResumeDecoding() {\n+  Buffer::Instance* internal_buffer = nullptr;\n+  if (decoder_callbacks_->decodingBuffer()) {\n+    decoder_callbacks_->modifyDecodingBuffer([&internal_buffer](Buffer::Instance& mutable_buffer) {\n+      internal_buffer = &mutable_buffer;\n+    });\n+  }\n+\n+  envoy_headers* pending_headers = nullptr;\n+  envoy_data* pending_data = nullptr;\n+  envoy_headers* pending_trailers = nullptr;\n+  if (pending_request_headers_) {\n+    *pending_headers = Http::Utility::toBridgeHeaders(*pending_request_headers_);\n+  }\n+  if (internal_buffer) {\n+    *pending_data = Buffer::Utility::copyToBridgeData(*internal_buffer);\n+  }\n+  if (pending_request_trailers_) {\n+    *pending_trailers = Http::Utility::toBridgeHeaders(*pending_request_trailers_);\n+  }\n+\n+  envoy_filter_resume_status result =\n+      platform_filter_.on_resume_request(pending_headers, pending_data, pending_trailers,\n+                                         request_complete_, platform_filter_.instance_context);\n+  if (result.status == kEnvoyFilterResumeStatusStopIteration) {\n+    return;\n+  }\n+  if (pending_request_headers_) {\n+    PlatformBridgeFilter::replaceHeaders(*pending_request_headers_, *result.pending_headers);\n+    pending_request_headers_ = nullptr;\n+    free(result.pending_headers);\n+  }\n+  if (internal_buffer) {\n+    internal_buffer->drain(internal_buffer->length());\n+    internal_buffer->addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    free(result.pending_data);\n+  } else if (result.pending_data) {\n+    Buffer::OwnedImpl inject_data;\n+    inject_data.addBufferFragment(\n+        *Buffer::BridgeFragment::createBridgeFragment(*result.pending_data));\n+    decoder_callbacks_->addDecodedData(inject_data, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNjIxNg=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEwNDg0OnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/filter.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0NDoyMFrOHeGmsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDoyMDoxNVrOHfD56w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNzUzNg==", "bodyText": "I know decoding/encoding is an Envoy construct, but I think onResumeRequest/onResumeResponse would be clearer here since these are executed as a result of functions with similar names in Envoy Mobile", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501327536", "createdAt": "2020-10-07T21:44:20Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.h", "diffHunk": "@@ -50,6 +50,18 @@ class PlatformBridgeFilter final : public Http::PassThroughFilter,\n public:\n   PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config);\n \n+  // Scheduled on the dispatcher when resumeRequest is called from platform\n+  // filter callbacks. Provides a snapshot of pending request state to the\n+  // platform filter, and consumes invocation results to modify pending HTTP\n+  // entities before resuming decoding.\n+  void onResumeDecoding();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMTg4Mw==", "bodyText": "The other functions in this class all use decode and encode (see L69+ below), due to the names being dictated by Envoy's own interfaces. I use request/response everywhere above this, because I do think it's clearer, especially for our use case, but my feeling was that it was worthwhile being consistent at least within a single class.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502331883", "createdAt": "2020-10-09T10:20:15Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/platform_bridge/filter.h", "diffHunk": "@@ -50,6 +50,18 @@ class PlatformBridgeFilter final : public Http::PassThroughFilter,\n public:\n   PlatformBridgeFilter(PlatformBridgeFilterConfigSharedPtr config);\n \n+  // Scheduled on the dispatcher when resumeRequest is called from platform\n+  // filter callbacks. Provides a snapshot of pending request state to the\n+  // platform filter, and consumes invocation results to modify pending HTTP\n+  // entities before resuming decoding.\n+  void onResumeDecoding();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNzUzNg=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEwNzMzOnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngine.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0NTowN1rOHeGoEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0NTowN1rOHeGoEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyNzg5MQ==", "bodyText": "Mind documenting this?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501327891", "createdAt": "2020-10-07T21:45:07Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngine.h", "diffHunk": "@@ -74,6 +74,17 @@ extern const int kEnvoyFilterTrailersStatusContinue;\n extern const int kEnvoyFilterTrailersStatusStopIteration;\n extern const int kEnvoyFilterTrailersStatusResumeIteration;\n \n+/// Return codes for on-resume filter invocations. These are unique to platform filters,\n+/// and used exclusively after an asynchronous request to resume iteration via callbacks.\n+extern const int kEnvoyFilterResumeStatusStopIteration;\n+extern const int kEnvoyFilterResumeStatusResumeIteration;\n+\n+@protocol EnvoyHTTPFilterCallbacks\n+\n+- (void)resumeIteration;\n+\n+@end", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTExMTAwOnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/ResponseFilterCallbacksImpl.swift", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0NjoyOFrOHeGqUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0NjoyOFrOHeGqUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyODQ2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                callbacks.resumeIteration()\n          \n          \n            \n                self.callbacks.resumeIteration()", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501328464", "createdAt": "2020-10-07T21:46:28Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/ResponseFilterCallbacksImpl.swift", "diffHunk": "@@ -0,0 +1,18 @@\n+@_implementationOnly import EnvoyEngine\n+import Foundation\n+\n+/// Envoy implementation of ResponseFilterCallbacks\n+final class ResponseFilterCallbacksImpl: NSObject {\n+  private let callbacks: EnvoyHTTPFilterCallbacks\n+\n+  init(callbacks: EnvoyHTTPFilterCallbacks) {\n+    self.callbacks = callbacks\n+    super.init()\n+  }\n+}\n+\n+extension ResponseFilterCallbacksImpl: ResponseFilterCallbacks {\n+  func resumeResponse() {\n+    callbacks.resumeIteration()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTExMTM3OnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/RequestFilterCallbacksImpl.swift", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0NjozNFrOHeGqhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo0MzoxN1rOHfRUXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyODUxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                callbacks.resumeIteration()\n          \n          \n            \n                self.callbacks.resumeIteration()", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501328519", "createdAt": "2020-10-07T21:46:34Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/RequestFilterCallbacksImpl.swift", "diffHunk": "@@ -0,0 +1,18 @@\n+@_implementationOnly import EnvoyEngine\n+import Foundation\n+\n+/// Envoy implementation of RequestFilterCallbacks\n+final class RequestFilterCallbacksImpl: NSObject {\n+  private let callbacks: EnvoyHTTPFilterCallbacks\n+\n+  init(callbacks: EnvoyHTTPFilterCallbacks) {\n+    self.callbacks = callbacks\n+    super.init()\n+  }\n+}\n+\n+extension RequestFilterCallbacksImpl: RequestFilterCallbacks {\n+  func resumeRequest() {\n+    callbacks.resumeIteration()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzNTM3OA==", "bodyText": "Cool; for same reason every language has a different convention around this. :p", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502335378", "createdAt": "2020-10-09T10:27:29Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/RequestFilterCallbacksImpl.swift", "diffHunk": "@@ -0,0 +1,18 @@\n+@_implementationOnly import EnvoyEngine\n+import Foundation\n+\n+/// Envoy implementation of RequestFilterCallbacks\n+final class RequestFilterCallbacksImpl: NSObject {\n+  private let callbacks: EnvoyHTTPFilterCallbacks\n+\n+  init(callbacks: EnvoyHTTPFilterCallbacks) {\n+    self.callbacks = callbacks\n+    super.init()\n+  }\n+}\n+\n+extension RequestFilterCallbacksImpl: RequestFilterCallbacks {\n+  func resumeRequest() {\n+    callbacks.resumeIteration()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyODUxOQ=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MTY0NQ==", "bodyText": "yea the bias I've kept in this repo (same at Lyft) is to explicitly use self. to make the source clearer (it's required within closures as well)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502551645", "createdAt": "2020-10-09T16:43:17Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/RequestFilterCallbacksImpl.swift", "diffHunk": "@@ -0,0 +1,18 @@\n+@_implementationOnly import EnvoyEngine\n+import Foundation\n+\n+/// Envoy implementation of RequestFilterCallbacks\n+final class RequestFilterCallbacksImpl: NSObject {\n+  private let callbacks: EnvoyHTTPFilterCallbacks\n+\n+  init(callbacks: EnvoyHTTPFilterCallbacks) {\n+    self.callbacks = callbacks\n+    super.init()\n+  }\n+}\n+\n+extension RequestFilterCallbacksImpl: RequestFilterCallbacks {\n+  func resumeRequest() {\n+    callbacks.resumeIteration()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyODUxOQ=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyMDgxOnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyEngine.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo0OTo1MlrOHeGwIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDoyMTo1M1rOHfD9Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyOTk1NQ==", "bodyText": "I know adding type annotations here isn't possible since they're varied types, but can we at least document the expected contents and lengths of these NSArrays?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501329955", "createdAt": "2020-10-07T21:49:52Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyEngine.h", "diffHunk": "@@ -88,6 +99,20 @@ extern const int kEnvoyFilterTrailersStatusResumeIteration;\n \n @property (nonatomic, copy) NSArray * (^onResponseTrailers)(EnvoyHeaders *trailers);\n \n+@property (nonatomic, copy) void (^setRequestFilterCallbacks)\n+    (id<EnvoyHTTPFilterCallbacks> callbacks);\n+\n+@property (nonatomic, copy) NSArray * (^onResumeRequest)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMjczNQ==", "bodyText": "Sounds good.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502332735", "createdAt": "2020-10-09T10:21:53Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyEngine.h", "diffHunk": "@@ -88,6 +99,20 @@ extern const int kEnvoyFilterTrailersStatusResumeIteration;\n \n @property (nonatomic, copy) NSArray * (^onResponseTrailers)(EnvoyHeaders *trailers);\n \n+@property (nonatomic, copy) void (^setRequestFilterCallbacks)\n+    (id<EnvoyHTTPFilterCallbacks> callbacks);\n+\n+@property (nonatomic, copy) NSArray * (^onResumeRequest)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyOTk1NQ=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyMjg4OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyFilterCallbacksImpl.m", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MDozNFrOHeGxXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDoyNDoxN1rOHfEB0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDI3MQ==", "bodyText": "Why do we need this?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501330271", "createdAt": "2020-10-07T21:50:34Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyFilterCallbacksImpl.m", "diffHunk": "@@ -0,0 +1,20 @@\n+#import \"library/objective-c/EnvoyEngine.h\"\n+\n+#pragma mark - EnvoyHTTPFilterCallbacksImpl\n+\n+@implementation EnvoyHTTPFilterCallbacks {\n+}\n+\n+- (instancetype)init {\n+  self = [super init];\n+  if (!self) {\n+    return nil\n+  }\n+  return self;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMzkwNw==", "bodyText": "The next PR has stuff that needs to go here, so I went ahead and dropped in the boilerplate when I created the class.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502333907", "createdAt": "2020-10-09T10:24:17Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyFilterCallbacksImpl.m", "diffHunk": "@@ -0,0 +1,20 @@\n+#import \"library/objective-c/EnvoyEngine.h\"\n+\n+#pragma mark - EnvoyHTTPFilterCallbacksImpl\n+\n+@implementation EnvoyHTTPFilterCallbacks {\n+}\n+\n+- (instancetype)init {\n+  self = [super init];\n+  if (!self) {\n+    return nil\n+  }\n+  return self;\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDI3MQ=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyMzM0OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyFilterCallbacksImpl.m", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MDo0MVrOHeGxnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MDo0MVrOHeGxnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDMzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @implementation EnvoyHTTPFilterCallbacks {\n          \n          \n            \n            }\n          \n          \n            \n            @implementation EnvoyHTTPFilterCallbacks", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501330333", "createdAt": "2020-10-07T21:50:41Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyFilterCallbacksImpl.m", "diffHunk": "@@ -0,0 +1,20 @@\n+#import \"library/objective-c/EnvoyEngine.h\"\n+\n+#pragma mark - EnvoyHTTPFilterCallbacksImpl\n+\n+@implementation EnvoyHTTPFilterCallbacks {\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyMzY2OnYy", "diffSide": "RIGHT", "path": "library/objective-c/EnvoyFilterCallbacksImpl.m", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MDo0N1rOHeGxxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDoyMzo1NVrOHfEBNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDM3NA==", "bodyText": "Should there be a TODO here?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501330374", "createdAt": "2020-10-07T21:50:47Z", "author": {"login": "rebello95"}, "path": "library/objective-c/EnvoyFilterCallbacksImpl.m", "diffHunk": "@@ -0,0 +1,20 @@\n+#import \"library/objective-c/EnvoyEngine.h\"\n+\n+#pragma mark - EnvoyHTTPFilterCallbacksImpl\n+\n+@implementation EnvoyHTTPFilterCallbacks {\n+}\n+\n+- (instancetype)init {\n+  self = [super init];\n+  if (!self) {\n+    return nil\n+  }\n+  return self;\n+}\n+\n+- (void)resumeIteration {\n+  NSLog(@\"async resume\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMzc0OA==", "bodyText": "Yeah, I'll add one.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502333748", "createdAt": "2020-10-09T10:23:55Z", "author": {"login": "goaway"}, "path": "library/objective-c/EnvoyFilterCallbacksImpl.m", "diffHunk": "@@ -0,0 +1,20 @@\n+#import \"library/objective-c/EnvoyEngine.h\"\n+\n+#pragma mark - EnvoyHTTPFilterCallbacksImpl\n+\n+@implementation EnvoyHTTPFilterCallbacks {\n+}\n+\n+- (instancetype)init {\n+  self = [super init];\n+  if (!self) {\n+    return nil\n+  }\n+  return self;\n+}\n+\n+- (void)resumeIteration {\n+  NSLog(@\"async resume\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDM3NA=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyNjQ4OnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/Filter.swift", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MTo0MFrOHeGzaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxNjoyMlrOHf8Oxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDc5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      headers: envoyHeaders.flatMap(RequestHeaders.init),\n          \n          \n            \n                      headers: envoyHeaders.map(RequestHeaders.init),", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501330793", "createdAt": "2020-10-07T21:51:40Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -105,5 +105,55 @@ extension EnvoyHTTPFilter {\n         }\n       }\n     }\n+\n+    if let asyncRequestFilter = filter as? AsyncRequestFilter {\n+      self.setRequestFilterCallbacks = { envoyCallbacks in\n+        asyncRequestFilter.setRequestFilterCallbacks(\n+          RequestFilterCallbacksImpl(callbacks: envoyCallbacks)\n+        )\n+      }\n+\n+      self.onResumeRequest = { envoyHeaders, data, envoyTrailers, endStream in\n+        let result = asyncRequestFilter.onResumeRequest(\n+          headers: envoyHeaders.flatMap(RequestHeaders.init),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzNDgwMg==", "bodyText": "Oh is map preferred/idiomatic for optional over flatMap now? (and did that change or did I misremember?)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502334802", "createdAt": "2020-10-09T10:26:12Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -105,5 +105,55 @@ extension EnvoyHTTPFilter {\n         }\n       }\n     }\n+\n+    if let asyncRequestFilter = filter as? AsyncRequestFilter {\n+      self.setRequestFilterCallbacks = { envoyCallbacks in\n+        asyncRequestFilter.setRequestFilterCallbacks(\n+          RequestFilterCallbacksImpl(callbacks: envoyCallbacks)\n+        )\n+      }\n+\n+      self.onResumeRequest = { envoyHeaders, data, envoyTrailers, endStream in\n+        let result = asyncRequestFilter.onResumeRequest(\n+          headers: envoyHeaders.flatMap(RequestHeaders.init),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDc5Mw=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MjAzMg==", "bodyText": "flatMap will unwrap the optional and the optional returned as the result of the closure. Since the closure returns a non-optional, there's no reason to use flatMap over map", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r502552032", "createdAt": "2020-10-09T16:44:00Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -105,5 +105,55 @@ extension EnvoyHTTPFilter {\n         }\n       }\n     }\n+\n+    if let asyncRequestFilter = filter as? AsyncRequestFilter {\n+      self.setRequestFilterCallbacks = { envoyCallbacks in\n+        asyncRequestFilter.setRequestFilterCallbacks(\n+          RequestFilterCallbacksImpl(callbacks: envoyCallbacks)\n+        )\n+      }\n+\n+      self.onResumeRequest = { envoyHeaders, data, envoyTrailers, endStream in\n+        let result = asyncRequestFilter.onResumeRequest(\n+          headers: envoyHeaders.flatMap(RequestHeaders.init),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDc5Mw=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI1NDcyNw==", "bodyText": "Thanks, that makes sense.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r503254727", "createdAt": "2020-10-12T12:16:22Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -105,5 +105,55 @@ extension EnvoyHTTPFilter {\n         }\n       }\n     }\n+\n+    if let asyncRequestFilter = filter as? AsyncRequestFilter {\n+      self.setRequestFilterCallbacks = { envoyCallbacks in\n+        asyncRequestFilter.setRequestFilterCallbacks(\n+          RequestFilterCallbacksImpl(callbacks: envoyCallbacks)\n+        )\n+      }\n+\n+      self.onResumeRequest = { envoyHeaders, data, envoyTrailers, endStream in\n+        let result = asyncRequestFilter.onResumeRequest(\n+          headers: envoyHeaders.flatMap(RequestHeaders.init),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDc5Mw=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyNjc1OnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/Filter.swift", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MTo0NVrOHeGzlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MTo0NVrOHeGzlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDgzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      trailers: envoyTrailers.flatMap(RequestTrailers.init),\n          \n          \n            \n                      trailers: envoyTrailers.map(RequestTrailers.init),", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501330837", "createdAt": "2020-10-07T21:51:45Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -105,5 +105,55 @@ extension EnvoyHTTPFilter {\n         }\n       }\n     }\n+\n+    if let asyncRequestFilter = filter as? AsyncRequestFilter {\n+      self.setRequestFilterCallbacks = { envoyCallbacks in\n+        asyncRequestFilter.setRequestFilterCallbacks(\n+          RequestFilterCallbacksImpl(callbacks: envoyCallbacks)\n+        )\n+      }\n+\n+      self.onResumeRequest = { envoyHeaders, data, envoyTrailers, endStream in\n+        let result = asyncRequestFilter.onResumeRequest(\n+          headers: envoyHeaders.flatMap(RequestHeaders.init),\n+          data: data,\n+          trailers: envoyTrailers.flatMap(RequestTrailers.init),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyOTY4OnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/Filter.swift", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1Mjo0NFrOHeG1Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1Mjo0NFrOHeG1Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTI5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      headers: envoyHeaders.flatMap(ResponseHeaders.init),\n          \n          \n            \n                      headers: envoyHeaders.map(ResponseHeaders.init),", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501331299", "createdAt": "2020-10-07T21:52:44Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -105,5 +105,55 @@ extension EnvoyHTTPFilter {\n         }\n       }\n     }\n+\n+    if let asyncRequestFilter = filter as? AsyncRequestFilter {\n+      self.setRequestFilterCallbacks = { envoyCallbacks in\n+        asyncRequestFilter.setRequestFilterCallbacks(\n+          RequestFilterCallbacksImpl(callbacks: envoyCallbacks)\n+        )\n+      }\n+\n+      self.onResumeRequest = { envoyHeaders, data, envoyTrailers, endStream in\n+        let result = asyncRequestFilter.onResumeRequest(\n+          headers: envoyHeaders.flatMap(RequestHeaders.init),\n+          data: data,\n+          trailers: envoyTrailers.flatMap(RequestTrailers.init),\n+          endStream: endStream)\n+        switch result {\n+        case .resumeIteration(let headers, let data, let trailers):\n+          return [\n+            kEnvoyFilterResumeStatusResumeIteration,\n+            headers?.headers as Any,\n+            data as Any,\n+            trailers?.headers as Any,\n+          ]\n+        }\n+      }\n+    }\n+\n+    if let asyncResponseFilter = filter as? AsyncResponseFilter {\n+      self.setResponseFilterCallbacks = { envoyCallbacks in\n+        asyncResponseFilter.setResponseFilterCallbacks(\n+          ResponseFilterCallbacksImpl(callbacks: envoyCallbacks)\n+        )\n+      }\n+\n+      self.onResumeResponse = { envoyHeaders, data, envoyTrailers, endStream in\n+        let result = asyncResponseFilter.onResumeResponse(\n+          headers: envoyHeaders.flatMap(ResponseHeaders.init),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEyOTk4OnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/Filter.swift", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1Mjo1MFrOHeG1kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1Mjo1MFrOHeG1kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTM0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      trailers: envoyTrailers.flatMap(ResponseTrailers.init),\n          \n          \n            \n                      trailers: envoyTrailers.map(ResponseTrailers.init),", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501331344", "createdAt": "2020-10-07T21:52:50Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -105,5 +105,55 @@ extension EnvoyHTTPFilter {\n         }\n       }\n     }\n+\n+    if let asyncRequestFilter = filter as? AsyncRequestFilter {\n+      self.setRequestFilterCallbacks = { envoyCallbacks in\n+        asyncRequestFilter.setRequestFilterCallbacks(\n+          RequestFilterCallbacksImpl(callbacks: envoyCallbacks)\n+        )\n+      }\n+\n+      self.onResumeRequest = { envoyHeaders, data, envoyTrailers, endStream in\n+        let result = asyncRequestFilter.onResumeRequest(\n+          headers: envoyHeaders.flatMap(RequestHeaders.init),\n+          data: data,\n+          trailers: envoyTrailers.flatMap(RequestTrailers.init),\n+          endStream: endStream)\n+        switch result {\n+        case .resumeIteration(let headers, let data, let trailers):\n+          return [\n+            kEnvoyFilterResumeStatusResumeIteration,\n+            headers?.headers as Any,\n+            data as Any,\n+            trailers?.headers as Any,\n+          ]\n+        }\n+      }\n+    }\n+\n+    if let asyncResponseFilter = filter as? AsyncResponseFilter {\n+      self.setResponseFilterCallbacks = { envoyCallbacks in\n+        asyncResponseFilter.setResponseFilterCallbacks(\n+          ResponseFilterCallbacksImpl(callbacks: envoyCallbacks)\n+        )\n+      }\n+\n+      self.onResumeResponse = { envoyHeaders, data, envoyTrailers, endStream in\n+        let result = asyncResponseFilter.onResumeResponse(\n+          headers: envoyHeaders.flatMap(ResponseHeaders.init),\n+          data: data,\n+          trailers: envoyTrailers.flatMap(ResponseTrailers.init),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTEzMTA4OnYy", "diffSide": "RIGHT", "path": "library/swift/src/filters/Filter.swift", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMTo1MzoxOFrOHeG2QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMjoxODo1NFrOHf8T2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTUyMQ==", "bodyText": "asyncRequestFilter is being retained here - I assume that's intentional, but want to flag", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r501331521", "createdAt": "2020-10-07T21:53:18Z", "author": {"login": "rebello95"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -105,5 +105,55 @@ extension EnvoyHTTPFilter {\n         }\n       }\n     }\n+\n+    if let asyncRequestFilter = filter as? AsyncRequestFilter {\n+      self.setRequestFilterCallbacks = { envoyCallbacks in\n+        asyncRequestFilter.setRequestFilterCallbacks(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI1NjAyNw==", "bodyText": "Yep, good callout, but should be fine since both the internal filter and downcasted reference are both tied to the lifecycle of the parent Filter.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r503256027", "createdAt": "2020-10-12T12:18:54Z", "author": {"login": "goaway"}, "path": "library/swift/src/filters/Filter.swift", "diffHunk": "@@ -105,5 +105,55 @@ extension EnvoyHTTPFilter {\n         }\n       }\n     }\n+\n+    if let asyncRequestFilter = filter as? AsyncRequestFilter {\n+      self.setRequestFilterCallbacks = { envoyCallbacks in\n+        asyncRequestFilter.setRequestFilterCallbacks(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTUyMQ=="}, "originalCommit": {"oid": "4584f8f456b6c69ef822cd98c1e954b8f6803ef0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDA4OTMyOnYy", "diffSide": "RIGHT", "path": "library/common/extensions/filters/http/platform_bridge/c_types.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjoxODowOVrOHgO_UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjoxODowOVrOHgO_UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU2MjA2NQ==", "bodyText": "Let's document these typedefs", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1118#discussion_r503562065", "createdAt": "2020-10-12T22:18:09Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/platform_bridge/c_types.h", "diffHunk": "@@ -103,11 +124,30 @@ typedef envoy_filter_data_status (*envoy_filter_on_data_f)(envoy_data data, bool\n typedef envoy_filter_trailers_status (*envoy_filter_on_trailers_f)(envoy_headers trailers,\n                                                                    const void* context);\n \n+/**\n+ * Function signature for filter invocation after asynchronous resumption. Passes a\n+ * snapshot of all HTTP state that has not yet been forwarded along the filter chain.\n+ */\n+typedef envoy_filter_resume_status (*envoy_filter_on_resume_f)(envoy_headers* headers,\n+                                                               envoy_data* data,\n+                                                               envoy_headers* trailers,\n+                                                               bool end_stream,\n+                                                               const void* context);\n+\n /**\n  * Function signature to release a filter instance once the filter chain is finished with it.\n  */\n typedef void (*envoy_filter_release_f)(const void* context);\n \n+typedef void (*envoy_filter_resume_f)(const void* context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27539473e69ec38b20d042a09ddfe941f494d704"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 645, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}