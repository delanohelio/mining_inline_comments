{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5OTk1Mjk3", "number": 792, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowNDoxMVrODvwipA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjoxNTo1NlrODvwuZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDA0OTY0OnYy", "diffSide": "RIGHT", "path": "test/integration/dispatcher_integration_test.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowNDoxMVrOGCX09g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjoyNDoxOVrOGCYUsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MDcyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // TODO(junr03): test with envoy local reply with local stream not close, which causes a reset fired\n          \n          \n            \n            // TODO(junr03): test with envoy local reply with local stream not closed, which causes a reset fired", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405140726", "createdAt": "2020-04-07T22:04:11Z", "author": {"login": "rebello95"}, "path": "test/integration/dispatcher_integration_test.cc", "diffHunk": "@@ -229,5 +229,9 @@ TEST_P(DispatcherIntegrationTest, RaceDoesNotCauseDoubleDeletion) {\n   http_dispatcher_.synchronizer().signal(\"dispatch_encode_final_data\");\n }\n \n+// TODO(junr03): test with envoy local reply with local stream not close, which causes a reset fired", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0ODg0OA==", "bodyText": "if you are ok with it, I will fix this in #791 to avoid re-running CI", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405148848", "createdAt": "2020-04-07T22:24:19Z", "author": {"login": "junr03"}, "path": "test/integration/dispatcher_integration_test.cc", "diffHunk": "@@ -229,5 +229,9 @@ TEST_P(DispatcherIntegrationTest, RaceDoesNotCauseDoubleDeletion) {\n   http_dispatcher_.synchronizer().signal(\"dispatch_encode_final_data\");\n }\n \n+// TODO(junr03): test with envoy local reply with local stream not close, which causes a reset fired", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MDcyNg=="}, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDA1ODI1OnYy", "diffSide": "RIGHT", "path": "test/common/http/dispatcher_test.cc", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowNzo0M1rOGCX6bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjozMDowOFrOGCYdxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjEyNA==", "bodyText": "This test feels quite large and it's kind of difficult to understand what suite of behaviors we're trying to exercise here. Do you know if we can isolate the specific behaviors and have smaller individual tests?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405142124", "createdAt": "2020-04-07T22:07:43Z", "author": {"login": "buildbreaker"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -519,13 +520,123 @@ TEST_F(DispatcherTest, BasicStream) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n+TEST_F(DispatcherTest, BasicStreamWithTrailers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0ODU1Mw==", "bodyText": "Some of these tests can be condensed a little bit by taking the repeated parts into utility functions in the test class. I was thinking about this as I was adding more tests. Will do in a subsequent PR #794", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405148553", "createdAt": "2020-04-07T22:23:40Z", "author": {"login": "junr03"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -519,13 +520,123 @@ TEST_F(DispatcherTest, BasicStream) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n+TEST_F(DispatcherTest, BasicStreamWithTrailers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjEyNA=="}, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1MDI3MQ==", "bodyText": "I think that's great to do also (I am slightly opinionated about test utils but we can talk about that separately)\nThe confusion I have is more on the behavior exercised by this test (since it seems to be asserting on all the different handlers). Does this test primarily exercise a general end to end behavior of a basic stream?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405150271", "createdAt": "2020-04-07T22:27:55Z", "author": {"login": "buildbreaker"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -519,13 +520,123 @@ TEST_F(DispatcherTest, BasicStream) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n+TEST_F(DispatcherTest, BasicStreamWithTrailers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjEyNA=="}, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1MTE3NQ==", "bodyText": "yeah, it is an http stream with trailers. There are individual tests for a headers only request, one with a body, and now this one with trailers.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405151175", "createdAt": "2020-04-07T22:30:08Z", "author": {"login": "junr03"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -519,13 +520,123 @@ TEST_F(DispatcherTest, BasicStream) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n+TEST_F(DispatcherTest, BasicStreamWithTrailers) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjEyNA=="}, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDA3OTczOnYy", "diffSide": "RIGHT", "path": "test/common/http/dispatcher_test.cc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjoxNTo1NlrOGCYHow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjoyMzo1MFrOGCYT3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTUwNw==", "bodyText": "I agree with @buildbreaker's comment above regarding encapsulating testable pieces so we don't have large test functions. Another idea might be to break up this file with those smaller individual tests (it's ~1500LOC)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405145507", "createdAt": "2020-04-07T22:15:56Z", "author": {"login": "rebello95"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -739,12 +850,189 @@ TEST_F(DispatcherTest, MultipleStreams) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n+TEST_F(DispatcherTest, EnvoyLocalReply) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  // Setup bridge_callbacks to handle the response headers.\n+  envoy_http_callbacks bridge_callbacks;\n+  callbacks_called cc = {0, 0, 0, 0, 0, 0};\n+  bridge_callbacks.context = &cc;\n+  bridge_callbacks.on_error = [](envoy_error error, void* context) -> void {\n+    ASSERT_EQ(error.error_code, ENVOY_CONNECTION_FAILURE);\n+    callbacks_called* cc = static_cast<callbacks_called*>(context);\n+    cc->on_error_calls++;\n+  };\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a\n+  // 503 should have an ENVOY_CONNECTION_FAILURE error code.\n+  Event::PostCb stream_deletion_post_cb;\n+  EXPECT_CALL(event_dispatcher_, isThreadSafe()).Times(1).WillRepeatedly(Return(true));\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&stream_deletion_post_cb));\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"}};\n+  response_encoder_->encodeHeaders(response_headers, true);\n+  ASSERT_EQ(cc.on_headers_calls, 0);\n+  stream_deletion_post_cb();\n+\n+  // Ensure that the callbacks on the bridge_callbacks were called.\n+  ASSERT_EQ(cc.on_complete_calls, 0);\n+  ASSERT_EQ(cc.on_error_calls, 1);\n+}\n+\n+TEST_F(DispatcherTest, EnvoyLocalReplyNon503) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  // Setup bridge_callbacks to handle the response headers.\n+  envoy_http_callbacks bridge_callbacks;\n+  callbacks_called cc = {0, 0, 0, 0, 0, 0};\n+  bridge_callbacks.context = &cc;\n+  bridge_callbacks.on_error = [](envoy_error error, void* context) -> void {\n+    ASSERT_EQ(error.error_code, ENVOY_UNDEFINED_ERROR);\n+    callbacks_called* cc = static_cast<callbacks_called*>(context);\n+    cc->on_error_calls++;\n+  };\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a\n+  // non-503 should have an ENVOY_UNDEFINED_ERROR error code.\n+  Event::PostCb stream_deletion_post_cb;\n+  EXPECT_CALL(event_dispatcher_, isThreadSafe()).Times(1).WillRepeatedly(Return(true));\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&stream_deletion_post_cb));\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"504\"}};\n+  response_encoder_->encodeHeaders(response_headers, true);\n+  ASSERT_EQ(cc.on_headers_calls, 0);\n+  stream_deletion_post_cb();\n+\n+  // Ensure that the callbacks on the bridge_callbacks were called.\n+  ASSERT_EQ(cc.on_complete_calls, 0);\n+  ASSERT_EQ(cc.on_error_calls, 1);\n+}\n+\n+TEST_F(DispatcherTest, EnvoyLocalReplyWithData) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  // Setup bridge_callbacks to handle the response headers.\n+  envoy_http_callbacks bridge_callbacks;\n+  callbacks_called cc = {0, 0, 0, 0, 0, 0};\n+  bridge_callbacks.context = &cc;\n+  bridge_callbacks.on_error = [](envoy_error error, void* context) -> void {\n+    ASSERT_EQ(error.error_code, ENVOY_CONNECTION_FAILURE);\n+    ASSERT_EQ(Http::Utility::convertToString(error.message), \"error message\");\n+    callbacks_called* cc = static_cast<callbacks_called*>(context);\n+    cc->on_error_calls++;\n+    error.message.release(error.message.context);\n+  };\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a\n+  // 503 should have an ENVOY_CONNECTION_FAILURE error code. However, do not end the stream yet.\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"}};\n+  response_encoder_->encodeHeaders(response_headers, false);\n+  ASSERT_EQ(cc.on_headers_calls, 0);\n+\n+  Event::PostCb stream_deletion_post_cb;\n+  EXPECT_CALL(event_dispatcher_, isThreadSafe()).Times(1).WillRepeatedly(Return(true));\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&stream_deletion_post_cb));\n+  Buffer::InstancePtr response_data{new Buffer::OwnedImpl(\"error message\")};\n+  response_encoder_->encodeData(*response_data, true);\n+  ASSERT_EQ(cc.on_data_calls, 0);\n+  stream_deletion_post_cb();\n+\n+  // Ensure that the callbacks on the bridge_callbacks were called.\n+  ASSERT_EQ(cc.on_complete_calls, 0);\n+  ASSERT_EQ(cc.on_error_calls, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0ODYzOA==", "bodyText": "see #792 (comment)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405148638", "createdAt": "2020-04-07T22:23:50Z", "author": {"login": "junr03"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -739,12 +850,189 @@ TEST_F(DispatcherTest, MultipleStreams) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n+TEST_F(DispatcherTest, EnvoyLocalReply) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  // Setup bridge_callbacks to handle the response headers.\n+  envoy_http_callbacks bridge_callbacks;\n+  callbacks_called cc = {0, 0, 0, 0, 0, 0};\n+  bridge_callbacks.context = &cc;\n+  bridge_callbacks.on_error = [](envoy_error error, void* context) -> void {\n+    ASSERT_EQ(error.error_code, ENVOY_CONNECTION_FAILURE);\n+    callbacks_called* cc = static_cast<callbacks_called*>(context);\n+    cc->on_error_calls++;\n+  };\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a\n+  // 503 should have an ENVOY_CONNECTION_FAILURE error code.\n+  Event::PostCb stream_deletion_post_cb;\n+  EXPECT_CALL(event_dispatcher_, isThreadSafe()).Times(1).WillRepeatedly(Return(true));\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&stream_deletion_post_cb));\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"}};\n+  response_encoder_->encodeHeaders(response_headers, true);\n+  ASSERT_EQ(cc.on_headers_calls, 0);\n+  stream_deletion_post_cb();\n+\n+  // Ensure that the callbacks on the bridge_callbacks were called.\n+  ASSERT_EQ(cc.on_complete_calls, 0);\n+  ASSERT_EQ(cc.on_error_calls, 1);\n+}\n+\n+TEST_F(DispatcherTest, EnvoyLocalReplyNon503) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  // Setup bridge_callbacks to handle the response headers.\n+  envoy_http_callbacks bridge_callbacks;\n+  callbacks_called cc = {0, 0, 0, 0, 0, 0};\n+  bridge_callbacks.context = &cc;\n+  bridge_callbacks.on_error = [](envoy_error error, void* context) -> void {\n+    ASSERT_EQ(error.error_code, ENVOY_UNDEFINED_ERROR);\n+    callbacks_called* cc = static_cast<callbacks_called*>(context);\n+    cc->on_error_calls++;\n+  };\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a\n+  // non-503 should have an ENVOY_UNDEFINED_ERROR error code.\n+  Event::PostCb stream_deletion_post_cb;\n+  EXPECT_CALL(event_dispatcher_, isThreadSafe()).Times(1).WillRepeatedly(Return(true));\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&stream_deletion_post_cb));\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"504\"}};\n+  response_encoder_->encodeHeaders(response_headers, true);\n+  ASSERT_EQ(cc.on_headers_calls, 0);\n+  stream_deletion_post_cb();\n+\n+  // Ensure that the callbacks on the bridge_callbacks were called.\n+  ASSERT_EQ(cc.on_complete_calls, 0);\n+  ASSERT_EQ(cc.on_error_calls, 1);\n+}\n+\n+TEST_F(DispatcherTest, EnvoyLocalReplyWithData) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  // Setup bridge_callbacks to handle the response headers.\n+  envoy_http_callbacks bridge_callbacks;\n+  callbacks_called cc = {0, 0, 0, 0, 0, 0};\n+  bridge_callbacks.context = &cc;\n+  bridge_callbacks.on_error = [](envoy_error error, void* context) -> void {\n+    ASSERT_EQ(error.error_code, ENVOY_CONNECTION_FAILURE);\n+    ASSERT_EQ(Http::Utility::convertToString(error.message), \"error message\");\n+    callbacks_called* cc = static_cast<callbacks_called*>(context);\n+    cc->on_error_calls++;\n+    error.message.release(error.message.context);\n+  };\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a\n+  // 503 should have an ENVOY_CONNECTION_FAILURE error code. However, do not end the stream yet.\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"}};\n+  response_encoder_->encodeHeaders(response_headers, false);\n+  ASSERT_EQ(cc.on_headers_calls, 0);\n+\n+  Event::PostCb stream_deletion_post_cb;\n+  EXPECT_CALL(event_dispatcher_, isThreadSafe()).Times(1).WillRepeatedly(Return(true));\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&stream_deletion_post_cb));\n+  Buffer::InstancePtr response_data{new Buffer::OwnedImpl(\"error message\")};\n+  response_encoder_->encodeData(*response_data, true);\n+  ASSERT_EQ(cc.on_data_calls, 0);\n+  stream_deletion_post_cb();\n+\n+  // Ensure that the callbacks on the bridge_callbacks were called.\n+  ASSERT_EQ(cc.on_complete_calls, 0);\n+  ASSERT_EQ(cc.on_error_calls, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTUwNw=="}, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 374}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 897, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}