{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNDQ5OTg0", "number": 858, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMDo0MDo1MVrOEDnpJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMToxMjozN1rOEDrVbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjMwNjkzOnYy", "diffSide": "RIGHT", "path": "examples/objective-c/hello_world/ViewController.m", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMDo0MDo1MVrOGgvnZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMTowNDoyMFrOGg1TDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4Nzc0OA==", "bodyText": "Should we change the name of the builder, since what it builds has changed?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r436987748", "createdAt": "2020-06-08T20:40:51Z", "author": {"login": "goaway"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -37,7 +37,7 @@ - (void)startEnvoy {\n   NSLog(@\"Starting Envoy...\");\n   NSError *error;\n   EnvoyClientBuilder *builder = [[EnvoyClientBuilder alloc] init];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MzM4MQ==", "bodyText": "StreamClientBuilder would be fine yeah", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437063381", "createdAt": "2020-06-08T23:56:12Z", "author": {"login": "rebello95"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -37,7 +37,7 @@ - (void)startEnvoy {\n   NSLog(@\"Starting Envoy...\");\n   NSError *error;\n   EnvoyClientBuilder *builder = [[EnvoyClientBuilder alloc] init];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4Nzc0OA=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDg0NA==", "bodyText": "Updated", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437080844", "createdAt": "2020-06-09T01:04:20Z", "author": {"login": "rebello95"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -37,7 +37,7 @@ - (void)startEnvoy {\n   NSLog(@\"Starting Envoy...\");\n   NSError *error;\n   EnvoyClientBuilder *builder = [[EnvoyClientBuilder alloc] init];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4Nzc0OA=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjMxMjMyOnYy", "diffSide": "RIGHT", "path": "examples/objective-c/hello_world/ViewController.m", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMDo0MjoxOFrOGgvqeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMTowNDoyNVrOGg1TJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4ODUzNw==", "bodyText": "StreamPrototype?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r436988537", "createdAt": "2020-06-08T20:42:18Z", "author": {"login": "goaway"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -65,38 +65,38 @@ - (void)performRequest {\n   self.requestCount++;\n   NSLog(@\"Starting request to '%@'\", _REQUEST_PATH);\n \n-  int requestID = self.requestCount;\n   // Note: this request will use an http/1.1 stream for the upstream request.\n   // The Swift example uses h2. This is done on purpose to test both paths in end-to-end tests\n   // in CI.\n-  RequestBuilder *builder = [[RequestBuilder alloc] initWithMethod:RequestMethodGet\n-                                                            scheme:_REQUEST_SCHEME\n-                                                         authority:_REQUEST_AUTHORITY\n-                                                              path:_REQUEST_PATH];\n-  Request *request = [builder build];\n-  ResponseHandler *handler = [[ResponseHandler alloc] initWithQueue:dispatch_get_main_queue()];\n+  int requestID = self.requestCount;\n+  RequestHeadersBuilder *builder = [[RequestHeadersBuilder alloc] initWithMethod:RequestMethodGet\n+                                                                          scheme:_REQUEST_SCHEME\n+                                                                       authority:_REQUEST_AUTHORITY\n+                                                                            path:_REQUEST_PATH];\n+  [builder addUpstreamHttpProtocol:UpstreamHttpProtocolHttp1];\n+  RequestHeaders *headers = [builder build];\n \n   __weak ViewController *weakSelf = self;\n-  [handler onHeaders:^(NSDictionary<NSString *, NSArray<NSString *> *> *headers,\n-                       NSInteger statusCode, BOOL endStream) {\n-    NSLog(@\"Response status (%i): %ld\\n%@\", requestID, statusCode, headers);\n-    NSString *body = [NSString stringWithFormat:@\"Status: %ld\", statusCode];\n+  InactiveStream *inactiveStream = [self.client newStream];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MzQyMg==", "bodyText": "No strong opinion, @junr03 do you have thoughts?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437063422", "createdAt": "2020-06-08T23:56:24Z", "author": {"login": "rebello95"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -65,38 +65,38 @@ - (void)performRequest {\n   self.requestCount++;\n   NSLog(@\"Starting request to '%@'\", _REQUEST_PATH);\n \n-  int requestID = self.requestCount;\n   // Note: this request will use an http/1.1 stream for the upstream request.\n   // The Swift example uses h2. This is done on purpose to test both paths in end-to-end tests\n   // in CI.\n-  RequestBuilder *builder = [[RequestBuilder alloc] initWithMethod:RequestMethodGet\n-                                                            scheme:_REQUEST_SCHEME\n-                                                         authority:_REQUEST_AUTHORITY\n-                                                              path:_REQUEST_PATH];\n-  Request *request = [builder build];\n-  ResponseHandler *handler = [[ResponseHandler alloc] initWithQueue:dispatch_get_main_queue()];\n+  int requestID = self.requestCount;\n+  RequestHeadersBuilder *builder = [[RequestHeadersBuilder alloc] initWithMethod:RequestMethodGet\n+                                                                          scheme:_REQUEST_SCHEME\n+                                                                       authority:_REQUEST_AUTHORITY\n+                                                                            path:_REQUEST_PATH];\n+  [builder addUpstreamHttpProtocol:UpstreamHttpProtocolHttp1];\n+  RequestHeaders *headers = [builder build];\n \n   __weak ViewController *weakSelf = self;\n-  [handler onHeaders:^(NSDictionary<NSString *, NSArray<NSString *> *> *headers,\n-                       NSInteger statusCode, BOOL endStream) {\n-    NSLog(@\"Response status (%i): %ld\\n%@\", requestID, statusCode, headers);\n-    NSString *body = [NSString stringWithFormat:@\"Status: %ld\", statusCode];\n+  InactiveStream *inactiveStream = [self.client newStream];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4ODUzNw=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2NTA1MA==", "bodyText": "active/inactive parallels envoy a bit more, but if you prefer Stream and StreamPrototype I don't care too much.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437065050", "createdAt": "2020-06-09T00:02:29Z", "author": {"login": "junr03"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -65,38 +65,38 @@ - (void)performRequest {\n   self.requestCount++;\n   NSLog(@\"Starting request to '%@'\", _REQUEST_PATH);\n \n-  int requestID = self.requestCount;\n   // Note: this request will use an http/1.1 stream for the upstream request.\n   // The Swift example uses h2. This is done on purpose to test both paths in end-to-end tests\n   // in CI.\n-  RequestBuilder *builder = [[RequestBuilder alloc] initWithMethod:RequestMethodGet\n-                                                            scheme:_REQUEST_SCHEME\n-                                                         authority:_REQUEST_AUTHORITY\n-                                                              path:_REQUEST_PATH];\n-  Request *request = [builder build];\n-  ResponseHandler *handler = [[ResponseHandler alloc] initWithQueue:dispatch_get_main_queue()];\n+  int requestID = self.requestCount;\n+  RequestHeadersBuilder *builder = [[RequestHeadersBuilder alloc] initWithMethod:RequestMethodGet\n+                                                                          scheme:_REQUEST_SCHEME\n+                                                                       authority:_REQUEST_AUTHORITY\n+                                                                            path:_REQUEST_PATH];\n+  [builder addUpstreamHttpProtocol:UpstreamHttpProtocolHttp1];\n+  RequestHeaders *headers = [builder build];\n \n   __weak ViewController *weakSelf = self;\n-  [handler onHeaders:^(NSDictionary<NSString *, NSArray<NSString *> *> *headers,\n-                       NSInteger statusCode, BOOL endStream) {\n-    NSLog(@\"Response status (%i): %ld\\n%@\", requestID, statusCode, headers);\n-    NSString *body = [NSString stringWithFormat:@\"Status: %ld\", statusCode];\n+  InactiveStream *inactiveStream = [self.client newStream];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4ODUzNw=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MjU3OA==", "bodyText": "I mean Envoy has an ActiveStream type. It doesn't have an InactiveStream type, nor does it use streams classified as inactive them as a mechanism to produce active streams.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437072578", "createdAt": "2020-06-09T00:31:47Z", "author": {"login": "goaway"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -65,38 +65,38 @@ - (void)performRequest {\n   self.requestCount++;\n   NSLog(@\"Starting request to '%@'\", _REQUEST_PATH);\n \n-  int requestID = self.requestCount;\n   // Note: this request will use an http/1.1 stream for the upstream request.\n   // The Swift example uses h2. This is done on purpose to test both paths in end-to-end tests\n   // in CI.\n-  RequestBuilder *builder = [[RequestBuilder alloc] initWithMethod:RequestMethodGet\n-                                                            scheme:_REQUEST_SCHEME\n-                                                         authority:_REQUEST_AUTHORITY\n-                                                              path:_REQUEST_PATH];\n-  Request *request = [builder build];\n-  ResponseHandler *handler = [[ResponseHandler alloc] initWithQueue:dispatch_get_main_queue()];\n+  int requestID = self.requestCount;\n+  RequestHeadersBuilder *builder = [[RequestHeadersBuilder alloc] initWithMethod:RequestMethodGet\n+                                                                          scheme:_REQUEST_SCHEME\n+                                                                       authority:_REQUEST_AUTHORITY\n+                                                                            path:_REQUEST_PATH];\n+  [builder addUpstreamHttpProtocol:UpstreamHttpProtocolHttp1];\n+  RequestHeaders *headers = [builder build];\n \n   __weak ViewController *weakSelf = self;\n-  [handler onHeaders:^(NSDictionary<NSString *, NSArray<NSString *> *> *headers,\n-                       NSInteger statusCode, BOOL endStream) {\n-    NSLog(@\"Response status (%i): %ld\\n%@\", requestID, statusCode, headers);\n-    NSString *body = [NSString stringWithFormat:@\"Status: %ld\", statusCode];\n+  InactiveStream *inactiveStream = [self.client newStream];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4ODUzNw=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MzIwOQ==", "bodyText": "I'm open to other possibilities, too, but InactiveStream really suggests something other than a suite of callbacks along with a factory mechanism to me. StreamBase?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437073209", "createdAt": "2020-06-09T00:34:14Z", "author": {"login": "goaway"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -65,38 +65,38 @@ - (void)performRequest {\n   self.requestCount++;\n   NSLog(@\"Starting request to '%@'\", _REQUEST_PATH);\n \n-  int requestID = self.requestCount;\n   // Note: this request will use an http/1.1 stream for the upstream request.\n   // The Swift example uses h2. This is done on purpose to test both paths in end-to-end tests\n   // in CI.\n-  RequestBuilder *builder = [[RequestBuilder alloc] initWithMethod:RequestMethodGet\n-                                                            scheme:_REQUEST_SCHEME\n-                                                         authority:_REQUEST_AUTHORITY\n-                                                              path:_REQUEST_PATH];\n-  Request *request = [builder build];\n-  ResponseHandler *handler = [[ResponseHandler alloc] initWithQueue:dispatch_get_main_queue()];\n+  int requestID = self.requestCount;\n+  RequestHeadersBuilder *builder = [[RequestHeadersBuilder alloc] initWithMethod:RequestMethodGet\n+                                                                          scheme:_REQUEST_SCHEME\n+                                                                       authority:_REQUEST_AUTHORITY\n+                                                                            path:_REQUEST_PATH];\n+  [builder addUpstreamHttpProtocol:UpstreamHttpProtocolHttp1];\n+  RequestHeaders *headers = [builder build];\n \n   __weak ViewController *weakSelf = self;\n-  [handler onHeaders:^(NSDictionary<NSString *, NSArray<NSString *> *> *headers,\n-                       NSInteger statusCode, BOOL endStream) {\n-    NSLog(@\"Response status (%i): %ld\\n%@\", requestID, statusCode, headers);\n-    NSString *body = [NSString stringWithFormat:@\"Status: %ld\", statusCode];\n+  InactiveStream *inactiveStream = [self.client newStream];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4ODUzNw=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NDQ3NQ==", "bodyText": "StreamBase sounds more like a superclass which doesn't really fit here IMO. I'm not opposed to StreamPrototype/Stream if you and Jose are in agreement", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437074475", "createdAt": "2020-06-09T00:39:43Z", "author": {"login": "rebello95"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -65,38 +65,38 @@ - (void)performRequest {\n   self.requestCount++;\n   NSLog(@\"Starting request to '%@'\", _REQUEST_PATH);\n \n-  int requestID = self.requestCount;\n   // Note: this request will use an http/1.1 stream for the upstream request.\n   // The Swift example uses h2. This is done on purpose to test both paths in end-to-end tests\n   // in CI.\n-  RequestBuilder *builder = [[RequestBuilder alloc] initWithMethod:RequestMethodGet\n-                                                            scheme:_REQUEST_SCHEME\n-                                                         authority:_REQUEST_AUTHORITY\n-                                                              path:_REQUEST_PATH];\n-  Request *request = [builder build];\n-  ResponseHandler *handler = [[ResponseHandler alloc] initWithQueue:dispatch_get_main_queue()];\n+  int requestID = self.requestCount;\n+  RequestHeadersBuilder *builder = [[RequestHeadersBuilder alloc] initWithMethod:RequestMethodGet\n+                                                                          scheme:_REQUEST_SCHEME\n+                                                                       authority:_REQUEST_AUTHORITY\n+                                                                            path:_REQUEST_PATH];\n+  [builder addUpstreamHttpProtocol:UpstreamHttpProtocolHttp1];\n+  RequestHeaders *headers = [builder build];\n \n   __weak ViewController *weakSelf = self;\n-  [handler onHeaders:^(NSDictionary<NSString *, NSArray<NSString *> *> *headers,\n-                       NSInteger statusCode, BOOL endStream) {\n-    NSLog(@\"Response status (%i): %ld\\n%@\", requestID, statusCode, headers);\n-    NSString *body = [NSString stringWithFormat:@\"Status: %ld\", statusCode];\n+  InactiveStream *inactiveStream = [self.client newStream];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4ODUzNw=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTg3Nw==", "bodyText": "lets do StreamPrototype/Stream", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437075877", "createdAt": "2020-06-09T00:45:19Z", "author": {"login": "junr03"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -65,38 +65,38 @@ - (void)performRequest {\n   self.requestCount++;\n   NSLog(@\"Starting request to '%@'\", _REQUEST_PATH);\n \n-  int requestID = self.requestCount;\n   // Note: this request will use an http/1.1 stream for the upstream request.\n   // The Swift example uses h2. This is done on purpose to test both paths in end-to-end tests\n   // in CI.\n-  RequestBuilder *builder = [[RequestBuilder alloc] initWithMethod:RequestMethodGet\n-                                                            scheme:_REQUEST_SCHEME\n-                                                         authority:_REQUEST_AUTHORITY\n-                                                              path:_REQUEST_PATH];\n-  Request *request = [builder build];\n-  ResponseHandler *handler = [[ResponseHandler alloc] initWithQueue:dispatch_get_main_queue()];\n+  int requestID = self.requestCount;\n+  RequestHeadersBuilder *builder = [[RequestHeadersBuilder alloc] initWithMethod:RequestMethodGet\n+                                                                          scheme:_REQUEST_SCHEME\n+                                                                       authority:_REQUEST_AUTHORITY\n+                                                                            path:_REQUEST_PATH];\n+  [builder addUpstreamHttpProtocol:UpstreamHttpProtocolHttp1];\n+  RequestHeaders *headers = [builder build];\n \n   __weak ViewController *weakSelf = self;\n-  [handler onHeaders:^(NSDictionary<NSString *, NSArray<NSString *> *> *headers,\n-                       NSInteger statusCode, BOOL endStream) {\n-    NSLog(@\"Response status (%i): %ld\\n%@\", requestID, statusCode, headers);\n-    NSString *body = [NSString stringWithFormat:@\"Status: %ld\", statusCode];\n+  InactiveStream *inactiveStream = [self.client newStream];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4ODUzNw=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDg2OQ==", "bodyText": "Done", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437080869", "createdAt": "2020-06-09T01:04:25Z", "author": {"login": "rebello95"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -65,38 +65,38 @@ - (void)performRequest {\n   self.requestCount++;\n   NSLog(@\"Starting request to '%@'\", _REQUEST_PATH);\n \n-  int requestID = self.requestCount;\n   // Note: this request will use an http/1.1 stream for the upstream request.\n   // The Swift example uses h2. This is done on purpose to test both paths in end-to-end tests\n   // in CI.\n-  RequestBuilder *builder = [[RequestBuilder alloc] initWithMethod:RequestMethodGet\n-                                                            scheme:_REQUEST_SCHEME\n-                                                         authority:_REQUEST_AUTHORITY\n-                                                              path:_REQUEST_PATH];\n-  Request *request = [builder build];\n-  ResponseHandler *handler = [[ResponseHandler alloc] initWithQueue:dispatch_get_main_queue()];\n+  int requestID = self.requestCount;\n+  RequestHeadersBuilder *builder = [[RequestHeadersBuilder alloc] initWithMethod:RequestMethodGet\n+                                                                          scheme:_REQUEST_SCHEME\n+                                                                       authority:_REQUEST_AUTHORITY\n+                                                                            path:_REQUEST_PATH];\n+  [builder addUpstreamHttpProtocol:UpstreamHttpProtocolHttp1];\n+  RequestHeaders *headers = [builder build];\n \n   __weak ViewController *weakSelf = self;\n-  [handler onHeaders:^(NSDictionary<NSString *, NSArray<NSString *> *> *headers,\n-                       NSInteger statusCode, BOOL endStream) {\n-    NSLog(@\"Response status (%i): %ld\\n%@\", requestID, statusCode, headers);\n-    NSString *body = [NSString stringWithFormat:@\"Status: %ld\", statusCode];\n+  InactiveStream *inactiveStream = [self.client newStream];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4ODUzNw=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjMyMTQ4OnYy", "diffSide": "RIGHT", "path": "library/kotlin/src/io/envoyproxy/envoymobile/filters/ResponseFilter.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMDo0NTowNFrOGgvv-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo1Njo1MVrOGg0Pcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4OTk0Nw==", "bodyText": "I feel like onCancellation is most grammatically in line with the other callbacks, but \u00af\\_(\u30c4)_/\u00af", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r436989947", "createdAt": "2020-06-08T20:45:04Z", "author": {"login": "goaway"}, "path": "library/kotlin/src/io/envoyproxy/envoymobile/filters/ResponseFilter.kt", "diffHunk": "@@ -66,5 +66,5 @@ interface ResponseFilter: Filter {\n    * This should be considered a terminal state, and invalidates any previous attempts to\n    * `stopIteration{...}`.\n    */\n-  fun onCanceled()\n+  fun onCancel()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MzUzOQ==", "bodyText": "I'd like to keep it as-is for this PR since this is how it's named further down as well. We can open PRs after to rename everywhere if necessary", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437063539", "createdAt": "2020-06-08T23:56:51Z", "author": {"login": "rebello95"}, "path": "library/kotlin/src/io/envoyproxy/envoymobile/filters/ResponseFilter.kt", "diffHunk": "@@ -66,5 +66,5 @@ interface ResponseFilter: Filter {\n    * This should be considered a terminal state, and invalidates any previous attempts to\n    * `stopIteration{...}`.\n    */\n-  fun onCanceled()\n+  fun onCancel()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4OTk0Nw=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjc2Nzg2OnYy", "diffSide": "RIGHT", "path": "examples/swift/hello_world/ViewController.swift", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo0Njo0OVrOGg0Esg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMTowNjozNVrOGg1VoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MDc4Ng==", "bodyText": "I sort of prefer the old naming scheme (onHeaders) since setOnResponseHeaders to a degree suggests the implementation detail that this is a functor captured as a member, whereas I feel onHeaders (or onResponseHeaders) to me simply suggests \"on headers, do x\". But this is subjective.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437060786", "createdAt": "2020-06-08T23:46:49Z", "author": {"login": "goaway"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -38,33 +38,36 @@ final class ViewController: UITableViewController {\n   }\n \n   private func performRequest() {\n-    guard let envoy = self.envoy else {\n+    guard let client = self.client else {\n       NSLog(\"Failed to start request - Envoy is not running\")\n       return\n     }\n \n     self.requestCount += 1\n     NSLog(\"Starting request to '\\(kRequestPath)'\")\n \n-    let requestID = self.requestCount\n     // Note: this request will use an h2 stream for the upstream request.\n     // The Objective-C example uses http/1.1. This is done on purpose to test both paths in\n     // end-to-end tests in CI.\n-    let request = RequestBuilder(method: .get, scheme: kRequestScheme,\n-                                 authority: kRequestAuthority,\n-                                 path: kRequestPath)\n-        .addUpstreamHttpProtocol(.http2)\n-        .build()\n-    let handler = ResponseHandler()\n-      .onHeaders { [weak self] headers, statusCode, _ in\n+    let requestID = self.requestCount\n+    let headers = RequestHeadersBuilder(method: .get, scheme: kRequestScheme,\n+                                        authority: kRequestAuthority, path: kRequestPath)\n+      .addUpstreamHttpProtocol(.http2)\n+      .build()\n+\n+    client\n+      .newStream()\n+      .setOnResponseHeaders { [weak self] headers, _ in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2NDA2Mg==", "bodyText": "Discussed this a bit with @junr03 and @buildbreaker when we were first looking at this, and had elected to go this route to avoid confusion between setting the callbacks and calling the callbacks. That said, I think set might be clearer but don't feel that strongly", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437064062", "createdAt": "2020-06-08T23:58:48Z", "author": {"login": "rebello95"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -38,33 +38,36 @@ final class ViewController: UITableViewController {\n   }\n \n   private func performRequest() {\n-    guard let envoy = self.envoy else {\n+    guard let client = self.client else {\n       NSLog(\"Failed to start request - Envoy is not running\")\n       return\n     }\n \n     self.requestCount += 1\n     NSLog(\"Starting request to '\\(kRequestPath)'\")\n \n-    let requestID = self.requestCount\n     // Note: this request will use an h2 stream for the upstream request.\n     // The Objective-C example uses http/1.1. This is done on purpose to test both paths in\n     // end-to-end tests in CI.\n-    let request = RequestBuilder(method: .get, scheme: kRequestScheme,\n-                                 authority: kRequestAuthority,\n-                                 path: kRequestPath)\n-        .addUpstreamHttpProtocol(.http2)\n-        .build()\n-    let handler = ResponseHandler()\n-      .onHeaders { [weak self] headers, statusCode, _ in\n+    let requestID = self.requestCount\n+    let headers = RequestHeadersBuilder(method: .get, scheme: kRequestScheme,\n+                                        authority: kRequestAuthority, path: kRequestPath)\n+      .addUpstreamHttpProtocol(.http2)\n+      .build()\n+\n+    client\n+      .newStream()\n+      .setOnResponseHeaders { [weak self] headers, _ in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MDc4Ng=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MTM0OA==", "bodyText": "I get the idea behind distinguishing them, but the user of the public API will never actually be the one calling the callbacks. If anything, I'd be slightly more on board with naming the closure-type something more verbose internally, since it's never really exposed. e.g., onHeadersCallback.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437071348", "createdAt": "2020-06-09T00:26:43Z", "author": {"login": "goaway"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -38,33 +38,36 @@ final class ViewController: UITableViewController {\n   }\n \n   private func performRequest() {\n-    guard let envoy = self.envoy else {\n+    guard let client = self.client else {\n       NSLog(\"Failed to start request - Envoy is not running\")\n       return\n     }\n \n     self.requestCount += 1\n     NSLog(\"Starting request to '\\(kRequestPath)'\")\n \n-    let requestID = self.requestCount\n     // Note: this request will use an h2 stream for the upstream request.\n     // The Objective-C example uses http/1.1. This is done on purpose to test both paths in\n     // end-to-end tests in CI.\n-    let request = RequestBuilder(method: .get, scheme: kRequestScheme,\n-                                 authority: kRequestAuthority,\n-                                 path: kRequestPath)\n-        .addUpstreamHttpProtocol(.http2)\n-        .build()\n-    let handler = ResponseHandler()\n-      .onHeaders { [weak self] headers, statusCode, _ in\n+    let requestID = self.requestCount\n+    let headers = RequestHeadersBuilder(method: .get, scheme: kRequestScheme,\n+                                        authority: kRequestAuthority, path: kRequestPath)\n+      .addUpstreamHttpProtocol(.http2)\n+      .build()\n+\n+    client\n+      .newStream()\n+      .setOnResponseHeaders { [weak self] headers, _ in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MDc4Ng=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MTUwNQ==", "bodyText": "That's true. However, if we're going for consistency, our other builders expose addXYZ and setXYZ for our other builders (i.e., addRetryPolicy, set(name:value:), so this maintains consistency there. If you feel strongly we can change, but I'd lean towards keeping this for the time being for the sake of parity", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437081505", "createdAt": "2020-06-09T01:06:35Z", "author": {"login": "rebello95"}, "path": "examples/swift/hello_world/ViewController.swift", "diffHunk": "@@ -38,33 +38,36 @@ final class ViewController: UITableViewController {\n   }\n \n   private func performRequest() {\n-    guard let envoy = self.envoy else {\n+    guard let client = self.client else {\n       NSLog(\"Failed to start request - Envoy is not running\")\n       return\n     }\n \n     self.requestCount += 1\n     NSLog(\"Starting request to '\\(kRequestPath)'\")\n \n-    let requestID = self.requestCount\n     // Note: this request will use an h2 stream for the upstream request.\n     // The Objective-C example uses http/1.1. This is done on purpose to test both paths in\n     // end-to-end tests in CI.\n-    let request = RequestBuilder(method: .get, scheme: kRequestScheme,\n-                                 authority: kRequestAuthority,\n-                                 path: kRequestPath)\n-        .addUpstreamHttpProtocol(.http2)\n-        .build()\n-    let handler = ResponseHandler()\n-      .onHeaders { [weak self] headers, statusCode, _ in\n+    let requestID = self.requestCount\n+    let headers = RequestHeadersBuilder(method: .get, scheme: kRequestScheme,\n+                                        authority: kRequestAuthority, path: kRequestPath)\n+      .addUpstreamHttpProtocol(.http2)\n+      .build()\n+\n+    client\n+      .newStream()\n+      .setOnResponseHeaders { [weak self] headers, _ in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MDc4Ng=="}, "originalCommit": {"oid": "a63422f927aa84db6fa237730ff4544494a052c3"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjkwMzQyOnYy", "diffSide": "RIGHT", "path": "library/swift/src/RequestHeaders.swift", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMTowNzo0OFrOGg1W5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMToxMjowN1rOGg1bNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MTgzMA==", "bodyText": "No need for final?\n(RequestTrailers is final btw)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437081830", "createdAt": "2020-06-09T01:07:48Z", "author": {"login": "buildbreaker"}, "path": "library/swift/src/RequestHeaders.swift", "diffHunk": "@@ -2,7 +2,7 @@ import Foundation\n \n /// Headers representing an outbound request.\n @objcMembers\n-public final class RequestHeaders: Headers {\n+public class RequestHeaders: Headers {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8956be0c398327fd1d11be11051e49974b69ebbf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MjI2Nw==", "bodyText": "GRPCRequestHeaders subclasses this, so we can't use final here", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437082267", "createdAt": "2020-06-09T01:09:34Z", "author": {"login": "rebello95"}, "path": "library/swift/src/RequestHeaders.swift", "diffHunk": "@@ -2,7 +2,7 @@ import Foundation\n \n /// Headers representing an outbound request.\n @objcMembers\n-public final class RequestHeaders: Headers {\n+public class RequestHeaders: Headers {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MTgzMA=="}, "originalCommit": {"oid": "8956be0c398327fd1d11be11051e49974b69ebbf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MjYyMg==", "bodyText": "For context, I had considered replicating RequestHeaders entirely for gRPC, but that would be problematic for filters if we're passing a <T: RequestHeaders> into filters, since gRPC requests wouldn't conform to that. Granted, we may very well be constructing those headers that at a much lower layer if we go the C++ harness filter approach, in which case this wouldn't be a problem. The approach in the PR seemed like the least overhead for now", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437082622", "createdAt": "2020-06-09T01:10:47Z", "author": {"login": "rebello95"}, "path": "library/swift/src/RequestHeaders.swift", "diffHunk": "@@ -2,7 +2,7 @@ import Foundation\n \n /// Headers representing an outbound request.\n @objcMembers\n-public final class RequestHeaders: Headers {\n+public class RequestHeaders: Headers {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MTgzMA=="}, "originalCommit": {"oid": "8956be0c398327fd1d11be11051e49974b69ebbf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MjkzNA==", "bodyText": "Ah", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437082934", "createdAt": "2020-06-09T01:12:07Z", "author": {"login": "buildbreaker"}, "path": "library/swift/src/RequestHeaders.swift", "diffHunk": "@@ -2,7 +2,7 @@ import Foundation\n \n /// Headers representing an outbound request.\n @objcMembers\n-public final class RequestHeaders: Headers {\n+public class RequestHeaders: Headers {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MTgzMA=="}, "originalCommit": {"oid": "8956be0c398327fd1d11be11051e49974b69ebbf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjkxMTgyOnYy", "diffSide": "RIGHT", "path": "examples/objective-c/hello_world/ViewController.m", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMToxMjozN1rOGg1bwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMToxMjozN1rOGg1bwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MzA3Mg==", "bodyText": "I'd be fine with newStream or newStreamPrototype, but if you're going with the latter, looks like you missed this.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/858#discussion_r437083072", "createdAt": "2020-06-09T01:12:37Z", "author": {"login": "goaway"}, "path": "examples/objective-c/hello_world/ViewController.m", "diffHunk": "@@ -65,38 +65,38 @@ - (void)performRequest {\n   self.requestCount++;\n   NSLog(@\"Starting request to '%@'\", _REQUEST_PATH);\n \n-  int requestID = self.requestCount;\n   // Note: this request will use an http/1.1 stream for the upstream request.\n   // The Swift example uses h2. This is done on purpose to test both paths in end-to-end tests\n   // in CI.\n-  RequestBuilder *builder = [[RequestBuilder alloc] initWithMethod:RequestMethodGet\n-                                                            scheme:_REQUEST_SCHEME\n-                                                         authority:_REQUEST_AUTHORITY\n-                                                              path:_REQUEST_PATH];\n-  Request *request = [builder build];\n-  ResponseHandler *handler = [[ResponseHandler alloc] initWithQueue:dispatch_get_main_queue()];\n+  int requestID = self.requestCount;\n+  RequestHeadersBuilder *builder = [[RequestHeadersBuilder alloc] initWithMethod:RequestMethodGet\n+                                                                          scheme:_REQUEST_SCHEME\n+                                                                       authority:_REQUEST_AUTHORITY\n+                                                                            path:_REQUEST_PATH];\n+  [builder addUpstreamHttpProtocol:UpstreamHttpProtocolHttp1];\n+  RequestHeaders *headers = [builder build];\n \n   __weak ViewController *weakSelf = self;\n-  [handler onHeaders:^(NSDictionary<NSString *, NSArray<NSString *> *> *headers,\n-                       NSInteger statusCode, BOOL endStream) {\n-    NSLog(@\"Response status (%i): %ld\\n%@\", requestID, statusCode, headers);\n-    NSString *body = [NSString stringWithFormat:@\"Status: %ld\", statusCode];\n+  StreamPrototype *prototype = [self.client newStream];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8956be0c398327fd1d11be11051e49974b69ebbf"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 801, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}