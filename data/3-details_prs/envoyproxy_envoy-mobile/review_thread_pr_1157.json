{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMzQ3OTMz", "number": 1157, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQwNDoyOTozNlrOE0Auwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQwNDoyOTozNlrOE0Auwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTczMzc4OnYy", "diffSide": "RIGHT", "path": "examples/swift/hello_world/BufferDemoFilter.swift", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQwNDoyOTozN1rOHrk0wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQxNDoxOTo0NFrOHrnuwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1NDE0Ng==", "bodyText": "I think for requests that are headers and trailers (no body), this would crash because self.body is force unwrapped. Should we make body an optional in the declaration as var body: Data??", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1157#discussion_r515454146", "createdAt": "2020-10-31T04:29:37Z", "author": {"login": "rebello95"}, "path": "examples/swift/hello_world/BufferDemoFilter.swift", "diffHunk": "@@ -0,0 +1,41 @@\n+import Envoy\n+import Foundation\n+\n+/// Example of a more complex HTTP filter that pauses processing on the response filter chain,\n+/// buffers until the response is complete, then resumes filter iteration while setting a new\n+/// header.\n+final class BufferDemoFilter: ResponseFilter {\n+  private var headers: ResponseHeaders!\n+  private var body: Data!\n+\n+  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool)\n+    -> FilterHeadersStatus<ResponseHeaders>\n+  {\n+    self.headers = headers\n+    return .stopIteration\n+  }\n+\n+  func onResponseData(_ data: Data, endStream: Bool) -> FilterDataStatus<ResponseHeaders> {\n+    // Since we request buffering, each invocation will include all data buffered so far.\n+    self.body = data\n+\n+    // If this is the end of the stream, resume processing of the (now fully-buffered) response.\n+    if endStream {\n+      let builder = self.headers.toResponseHeadersBuilder()\n+        .add(name: \"buffer-filter-demo\", value: \"1\")\n+      return .resumeIteration(headers: builder.build(), data: self.body)\n+    }\n+    return .stopIterationAndBuffer\n+  }\n+\n+  func onResponseTrailers(\n+    _ trailers: ResponseTrailers\n+  ) -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {\n+    // Trailers imply end of stream; resume processing of the (now fully-buffered) response.\n+    return .resumeIteration(data: self.body, trailers: trailers)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4a5c504a362fc4afae394b1ac83188de2b0cee2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3MDY1OQ==", "bodyText": "Very good point. Updated.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1157#discussion_r515470659", "createdAt": "2020-10-31T08:09:58Z", "author": {"login": "goaway"}, "path": "examples/swift/hello_world/BufferDemoFilter.swift", "diffHunk": "@@ -0,0 +1,41 @@\n+import Envoy\n+import Foundation\n+\n+/// Example of a more complex HTTP filter that pauses processing on the response filter chain,\n+/// buffers until the response is complete, then resumes filter iteration while setting a new\n+/// header.\n+final class BufferDemoFilter: ResponseFilter {\n+  private var headers: ResponseHeaders!\n+  private var body: Data!\n+\n+  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool)\n+    -> FilterHeadersStatus<ResponseHeaders>\n+  {\n+    self.headers = headers\n+    return .stopIteration\n+  }\n+\n+  func onResponseData(_ data: Data, endStream: Bool) -> FilterDataStatus<ResponseHeaders> {\n+    // Since we request buffering, each invocation will include all data buffered so far.\n+    self.body = data\n+\n+    // If this is the end of the stream, resume processing of the (now fully-buffered) response.\n+    if endStream {\n+      let builder = self.headers.toResponseHeadersBuilder()\n+        .add(name: \"buffer-filter-demo\", value: \"1\")\n+      return .resumeIteration(headers: builder.build(), data: self.body)\n+    }\n+    return .stopIterationAndBuffer\n+  }\n+\n+  func onResponseTrailers(\n+    _ trailers: ResponseTrailers\n+  ) -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {\n+    // Trailers imply end of stream; resume processing of the (now fully-buffered) response.\n+    return .resumeIteration(data: self.body, trailers: trailers)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1NDE0Ng=="}, "originalCommit": {"oid": "d4a5c504a362fc4afae394b1ac83188de2b0cee2"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUwMTc2MA==", "bodyText": "I think you forgot to push \ud83d\ude43", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1157#discussion_r515501760", "createdAt": "2020-10-31T14:19:44Z", "author": {"login": "rebello95"}, "path": "examples/swift/hello_world/BufferDemoFilter.swift", "diffHunk": "@@ -0,0 +1,41 @@\n+import Envoy\n+import Foundation\n+\n+/// Example of a more complex HTTP filter that pauses processing on the response filter chain,\n+/// buffers until the response is complete, then resumes filter iteration while setting a new\n+/// header.\n+final class BufferDemoFilter: ResponseFilter {\n+  private var headers: ResponseHeaders!\n+  private var body: Data!\n+\n+  func onResponseHeaders(_ headers: ResponseHeaders, endStream: Bool)\n+    -> FilterHeadersStatus<ResponseHeaders>\n+  {\n+    self.headers = headers\n+    return .stopIteration\n+  }\n+\n+  func onResponseData(_ data: Data, endStream: Bool) -> FilterDataStatus<ResponseHeaders> {\n+    // Since we request buffering, each invocation will include all data buffered so far.\n+    self.body = data\n+\n+    // If this is the end of the stream, resume processing of the (now fully-buffered) response.\n+    if endStream {\n+      let builder = self.headers.toResponseHeadersBuilder()\n+        .add(name: \"buffer-filter-demo\", value: \"1\")\n+      return .resumeIteration(headers: builder.build(), data: self.body)\n+    }\n+    return .stopIterationAndBuffer\n+  }\n+\n+  func onResponseTrailers(\n+    _ trailers: ResponseTrailers\n+  ) -> FilterTrailersStatus<ResponseHeaders, ResponseTrailers> {\n+    // Trailers imply end of stream; resume processing of the (now fully-buffered) response.\n+    return .resumeIteration(data: self.body, trailers: trailers)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1NDE0Ng=="}, "originalCommit": {"oid": "d4a5c504a362fc4afae394b1ac83188de2b0cee2"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 495, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}