{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5OTk1Mjk3", "number": 792, "title": "test: add testing for missing coverage", "bodyText": "Description: this PR adds tests based on local coverage runs to raise coverage. This PR adds all non-silly coverage, but still hits misses on some accessors and because NOT_IMPLEMENTED_GCOVR_EXCL_LINE is being included (known problem in Envoy upstream since we stopped using gcovr).\nRisk Level: lowest! we are increasing our code coverage :)\nTesting: local coverage runs to see missing spots, and then CI\nSigned-off-by: Jose Nino jnino@lyft.com", "createdAt": "2020-04-07T02:04:37Z", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792", "merged": true, "mergeCommit": {"oid": "7ea53ab2f0a6263694cad21a0da6b872e1d6cae0"}, "closed": true, "closedAt": "2020-04-08T20:45:00Z", "author": {"login": "junr03"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVYkA4gH2gAyMzk5OTk1Mjk3OmQ1YTIxNTRkZTEyOTMwYWNiYzlmZGQ2NmU4OTM2NGMzZDFhNjExMzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVt8WIAFqTM5MDMwODIwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d5a2154de12930acbc9fdd66e89364c3d1a61137", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/d5a2154de12930acbc9fdd66e89364c3d1a61137", "committedDate": "2020-04-07T19:35:33Z", "message": "test: add more testing for missing coverage\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7166501c801e56c4d4b1a8c4fb1229916265f71a", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/7166501c801e56c4d4b1a8c4fb1229916265f71a", "committedDate": "2020-04-07T00:32:44Z", "message": "test: add testing for missing coverage\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}, "afterCommit": {"oid": "d5a2154de12930acbc9fdd66e89364c3d1a61137", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/d5a2154de12930acbc9fdd66e89364c3d1a61137", "committedDate": "2020-04-07T19:35:33Z", "message": "test: add more testing for missing coverage\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39f3216a9433309319dd2e9cf7bfd784263e1ef0", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/39f3216a9433309319dd2e9cf7bfd784263e1ef0", "committedDate": "2020-04-07T19:43:39Z", "message": "fmt\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/1c5d924e303635ff9c7702508d5665eaf4ba4c72", "committedDate": "2020-04-07T21:08:06Z", "message": "leave the envoy update for other PR\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTI0ODkx", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#pullrequestreview-389524891", "createdAt": "2020-04-07T22:07:43Z", "commit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowNzo0M1rOGCX6bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowNzo0M1rOGCX6bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjEyNA==", "bodyText": "This test feels quite large and it's kind of difficult to understand what suite of behaviors we're trying to exercise here. Do you know if we can isolate the specific behaviors and have smaller individual tests?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405142124", "createdAt": "2020-04-07T22:07:43Z", "author": {"login": "buildbreaker"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -519,13 +520,123 @@ TEST_F(DispatcherTest, BasicStream) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n+TEST_F(DispatcherTest, BasicStreamWithTrailers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTIzMjQx", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#pullrequestreview-389523241", "createdAt": "2020-04-07T22:04:11Z", "commit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowNDoxMVrOGCX09g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowNDoxMVrOGCX09g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MDcyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // TODO(junr03): test with envoy local reply with local stream not close, which causes a reset fired\n          \n          \n            \n            // TODO(junr03): test with envoy local reply with local stream not closed, which causes a reset fired", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405140726", "createdAt": "2020-04-07T22:04:11Z", "author": {"login": "rebello95"}, "path": "test/integration/dispatcher_integration_test.cc", "diffHunk": "@@ -229,5 +229,9 @@ TEST_P(DispatcherIntegrationTest, RaceDoesNotCauseDoubleDeletion) {\n   http_dispatcher_.synchronizer().signal(\"dispatch_encode_final_data\");\n }\n \n+// TODO(junr03): test with envoy local reply with local stream not close, which causes a reset fired", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTI4ODAz", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#pullrequestreview-389528803", "createdAt": "2020-04-07T22:15:56Z", "commit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjoxNTo1NlrOGCYHow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjoxNTo1NlrOGCYHow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTUwNw==", "bodyText": "I agree with @buildbreaker's comment above regarding encapsulating testable pieces so we don't have large test functions. Another idea might be to break up this file with those smaller individual tests (it's ~1500LOC)", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#discussion_r405145507", "createdAt": "2020-04-07T22:15:56Z", "author": {"login": "rebello95"}, "path": "test/common/http/dispatcher_test.cc", "diffHunk": "@@ -739,12 +850,189 @@ TEST_F(DispatcherTest, MultipleStreams) {\n   ASSERT_EQ(cc.on_complete_calls, 1);\n }\n \n+TEST_F(DispatcherTest, EnvoyLocalReply) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  // Setup bridge_callbacks to handle the response headers.\n+  envoy_http_callbacks bridge_callbacks;\n+  callbacks_called cc = {0, 0, 0, 0, 0, 0};\n+  bridge_callbacks.context = &cc;\n+  bridge_callbacks.on_error = [](envoy_error error, void* context) -> void {\n+    ASSERT_EQ(error.error_code, ENVOY_CONNECTION_FAILURE);\n+    callbacks_called* cc = static_cast<callbacks_called*>(context);\n+    cc->on_error_calls++;\n+  };\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a\n+  // 503 should have an ENVOY_CONNECTION_FAILURE error code.\n+  Event::PostCb stream_deletion_post_cb;\n+  EXPECT_CALL(event_dispatcher_, isThreadSafe()).Times(1).WillRepeatedly(Return(true));\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&stream_deletion_post_cb));\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"}};\n+  response_encoder_->encodeHeaders(response_headers, true);\n+  ASSERT_EQ(cc.on_headers_calls, 0);\n+  stream_deletion_post_cb();\n+\n+  // Ensure that the callbacks on the bridge_callbacks were called.\n+  ASSERT_EQ(cc.on_complete_calls, 0);\n+  ASSERT_EQ(cc.on_error_calls, 1);\n+}\n+\n+TEST_F(DispatcherTest, EnvoyLocalReplyNon503) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  // Setup bridge_callbacks to handle the response headers.\n+  envoy_http_callbacks bridge_callbacks;\n+  callbacks_called cc = {0, 0, 0, 0, 0, 0};\n+  bridge_callbacks.context = &cc;\n+  bridge_callbacks.on_error = [](envoy_error error, void* context) -> void {\n+    ASSERT_EQ(error.error_code, ENVOY_UNDEFINED_ERROR);\n+    callbacks_called* cc = static_cast<callbacks_called*>(context);\n+    cc->on_error_calls++;\n+  };\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a\n+  // non-503 should have an ENVOY_UNDEFINED_ERROR error code.\n+  Event::PostCb stream_deletion_post_cb;\n+  EXPECT_CALL(event_dispatcher_, isThreadSafe()).Times(1).WillRepeatedly(Return(true));\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&stream_deletion_post_cb));\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"504\"}};\n+  response_encoder_->encodeHeaders(response_headers, true);\n+  ASSERT_EQ(cc.on_headers_calls, 0);\n+  stream_deletion_post_cb();\n+\n+  // Ensure that the callbacks on the bridge_callbacks were called.\n+  ASSERT_EQ(cc.on_complete_calls, 0);\n+  ASSERT_EQ(cc.on_error_calls, 1);\n+}\n+\n+TEST_F(DispatcherTest, EnvoyLocalReplyWithData) {\n+  ready();\n+\n+  envoy_stream_t stream = 1;\n+  // Setup bridge_callbacks to handle the response headers.\n+  envoy_http_callbacks bridge_callbacks;\n+  callbacks_called cc = {0, 0, 0, 0, 0, 0};\n+  bridge_callbacks.context = &cc;\n+  bridge_callbacks.on_error = [](envoy_error error, void* context) -> void {\n+    ASSERT_EQ(error.error_code, ENVOY_CONNECTION_FAILURE);\n+    ASSERT_EQ(Http::Utility::convertToString(error.message), \"error message\");\n+    callbacks_called* cc = static_cast<callbacks_called*>(context);\n+    cc->on_error_calls++;\n+    error.message.release(error.message.context);\n+  };\n+\n+  // Build a set of request headers.\n+  TestRequestHeaderMapImpl headers;\n+  HttpTestUtility::addDefaultHeaders(headers);\n+  envoy_headers c_headers = Utility::toBridgeHeaders(headers);\n+\n+  // Create a stream.\n+  Event::PostCb start_stream_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&start_stream_post_cb));\n+  EXPECT_EQ(http_dispatcher_.startStream(stream, bridge_callbacks), ENVOY_SUCCESS);\n+\n+  // Grab the response encoder in order to dispatch responses on the stream.\n+  // Return the request decoder to make sure calls are dispatched to the decoder via the dispatcher\n+  // API.\n+  EXPECT_CALL(api_listener_, newStream(_, _))\n+      .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n+        response_encoder_ = &encoder;\n+        return request_decoder_;\n+      }));\n+  start_stream_post_cb();\n+\n+  // Send request headers.\n+  Event::PostCb send_headers_post_cb;\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&send_headers_post_cb));\n+  http_dispatcher_.sendHeaders(stream, c_headers, true);\n+\n+  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n+  send_headers_post_cb();\n+\n+  // Encode response headers. A non-200 code triggers an on_error callback chain. In particular, a\n+  // 503 should have an ENVOY_CONNECTION_FAILURE error code. However, do not end the stream yet.\n+  TestResponseHeaderMapImpl response_headers{{\":status\", \"503\"}};\n+  response_encoder_->encodeHeaders(response_headers, false);\n+  ASSERT_EQ(cc.on_headers_calls, 0);\n+\n+  Event::PostCb stream_deletion_post_cb;\n+  EXPECT_CALL(event_dispatcher_, isThreadSafe()).Times(1).WillRepeatedly(Return(true));\n+  EXPECT_CALL(event_dispatcher_, post(_)).WillOnce(SaveArg<0>(&stream_deletion_post_cb));\n+  Buffer::InstancePtr response_data{new Buffer::OwnedImpl(\"error message\")};\n+  response_encoder_->encodeData(*response_data, true);\n+  ASSERT_EQ(cc.on_data_calls, 0);\n+  stream_deletion_post_cb();\n+\n+  // Ensure that the callbacks on the bridge_callbacks were called.\n+  ASSERT_EQ(cc.on_complete_calls, 0);\n+  ASSERT_EQ(cc.on_error_calls, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c5d924e303635ff9c7702508d5665eaf4ba4c72"}, "originalPosition": 374}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faca4d4f98fc8a6a2dfb98a7d211ab6fe087dbe6", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/faca4d4f98fc8a6a2dfb98a7d211ab6fe087dbe6", "committedDate": "2020-04-08T17:28:06Z", "message": "update\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cb8662b5bd75fdd3935d383543c47d72612aa5e", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/4cb8662b5bd75fdd3935d383543c47d72612aa5e", "committedDate": "2020-04-08T17:30:45Z", "message": "comment\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62c660cb3a0e53d99a23e27b6cf504bb8f865580", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/62c660cb3a0e53d99a23e27b6cf504bb8f865580", "committedDate": "2020-04-08T18:10:22Z", "message": "fmt\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMzA4MjAy", "url": "https://github.com/envoyproxy/envoy-mobile/pull/792#pullrequestreview-390308202", "createdAt": "2020-04-08T20:30:08Z", "commit": {"oid": "62c660cb3a0e53d99a23e27b6cf504bb8f865580"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4335, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}