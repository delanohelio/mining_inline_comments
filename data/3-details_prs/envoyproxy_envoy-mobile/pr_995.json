{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwNjE0NTU4", "number": 995, "title": "assertion filter: initial filter implementation", "bodyText": "Description: the assertion filter will allow us to programatically test end-to-end bridging code between platform (swift/kotlin) and the native (c++) layers. This PR only lands the filter with subsequent PRs using it to build test suites.\nRisk Level: low\nTesting: unit tests\nDocs Changes: will add additional documentation with the swift and kotlin test suites.\nSigned-off-by: Jose Nino jnino@lyft.com", "createdAt": "2020-07-31T23:37:00Z", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995", "merged": true, "mergeCommit": {"oid": "b33e426eeb13a668c79e65edd437cecbb8a5c97f"}, "closed": true, "closedAt": "2020-08-06T23:33:04Z", "author": {"login": "junr03"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6c6bXgH2gAyNDYwNjE0NTU4OmRmZjNkN2ViNWIxOTIxM2JlZmQyZTE0MGE2NGU2MWNiNjhlZmY0MjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8Yd_WgH2gAyNDYwNjE0NTU4OmViOWMzZGUzYjM1ZGEwNWRmMGY3Mjc2YTRiNjdkZGY5ZTkyOTVkNWQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "dff3d7eb5b19213befd2e140a64e61cb68eff420", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/dff3d7eb5b19213befd2e140a64e61cb68eff420", "committedDate": "2020-07-31T23:34:51Z", "message": "assertion filter: initial filter implementation\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTMyNTI3", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#pullrequestreview-459532527", "createdAt": "2020-08-01T00:26:40Z", "commit": {"oid": "dff3d7eb5b19213befd2e140a64e61cb68eff420"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQwMDoyNjo0MVrOG6Z8_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMVQwMDoyODozOFrOG6Z-BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTgwNQ==", "bodyText": "I don't think this is accurate since the filter isn't being bubbled up to the platform", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r463895805", "createdAt": "2020-08-01T00:26:41Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/assertion/filter.h", "diffHunk": "@@ -0,0 +1,50 @@\n+#pragma once\n+\n+#include \"envoy/http/filter.h\"\n+\n+#include \"extensions/common/tap/tap_matcher.h\"\n+#include \"extensions/filters/http/common/pass_through_filter.h\"\n+\n+#include \"library/common/extensions/filters/http/assertion/filter.pb.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+class AssertionFilterConfig {\n+public:\n+  AssertionFilterConfig(\n+      const envoymobile::extensions::filters::http::assertion::Assertion& proto_config);\n+\n+  Extensions::Common::Tap::Matcher& rootMatcher() const;\n+  size_t matchersSize() const { return matchers_.size(); }\n+\n+private:\n+  std::vector<Extensions::Common::Tap::MatcherPtr> matchers_;\n+};\n+\n+typedef std::shared_ptr<AssertionFilterConfig> AssertionFilterConfigSharedPtr;\n+\n+/**\n+ * Harness to bridge Envoy filter invocations up to the platform layer.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff3d7eb5b19213befd2e140a64e61cb68eff420"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NTkxMg==", "bodyText": "These are super clever \ud83d\udc4f", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r463895912", "createdAt": "2020-08-01T00:27:16Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {\n+  statuses_ = Extensions::Common::Tap::Matcher::MatchStatusVector(config_->matchersSize());\n+  config_->rootMatcher().onNewStream(statuses_);\n+}\n+\n+Http::FilterHeadersStatus AssertionFilter::decodeHeaders(Http::RequestHeaderMap& headers,\n+                                                         bool end_stream) {\n+  config_->rootMatcher().onHttpRequestHeaders(headers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                         \"Request Headers match configured expectations\", nullptr,\n+                                         absl::nullopt, \"\");\n+      return Http::FilterHeadersStatus::StopIteration;\n+    }\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Headers do not match configured expectations\",\n+                                     nullptr, absl::nullopt, \"\");\n+  return Http::FilterHeadersStatus::StopIteration;\n+}\n+\n+Http::FilterDataStatus AssertionFilter::decodeData(Buffer::Instance& data, bool end_stream) {\n+  config_->rootMatcher().onRequestBody(data, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(\n+          Http::Code::OK, \"Request Body match configured expectations\", nullptr, absl::nullopt, \"\");\n+      return Http::FilterDataStatus::StopIterationNoBuffer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff3d7eb5b19213befd2e140a64e61cb68eff420"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg5NjA2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // The match configuration. If the configuration matches the request frames the filter will send\n          \n          \n            \n              // a local reply with Http::Code::OK on the last frame of the request stream (continuing on\n          \n          \n            \n              // intervening frames). Otherwise, it will send a local reply with Http::Code::BadRequest.\n          \n          \n            \n              envoy.config.tap.v3.MatchPredicate match_config = 1 [(validate.rules).message = {required: true}];\n          \n          \n            \n            }\n          \n          \n            \n              // The match configuration. If the configuration matches the request frames, the filter will send\n          \n          \n            \n              // a local reply with Http::Code::OK on the last frame of the request stream (continuing on\n          \n          \n            \n              // intervening frames). Otherwise, it will send a local reply with Http::Code::BadRequest.\n          \n          \n            \n              envoy.config.tap.v3.MatchPredicate match_config = 1 [(validate.rules).message = {required: true}];\n          \n          \n            \n            }\n          \n      \n    \n    \n  \n\nIt'd be nice if we could validate here that there's at least 1 matcher rule within the config (since it's asserted above), but not a big deal. We should probably document it here though", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r463896069", "createdAt": "2020-08-01T00:28:38Z", "author": {"login": "rebello95"}, "path": "library/common/extensions/filters/http/assertion/filter.proto", "diffHunk": "@@ -0,0 +1,14 @@\n+syntax = \"proto3\";\n+\n+package envoymobile.extensions.filters.http.assertion;\n+\n+import \"envoy/config/tap/v3/common.proto\";\n+\n+import \"validate/validate.proto\";\n+\n+message Assertion {\n+  // The match configuration. If the configuration matches the request frames the filter will send\n+  // a local reply with Http::Code::OK on the last frame of the request stream (continuing on\n+  // intervening frames). Otherwise, it will send a local reply with Http::Code::BadRequest.\n+  envoy.config.tap.v3.MatchPredicate match_config = 1 [(validate.rules).message = {required: true}];\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff3d7eb5b19213befd2e140a64e61cb68eff420"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f93c8f9d1a5fa30592b717803d740b1a5a2d51b8", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/f93c8f9d1a5fa30592b717803d740b1a5a2d51b8", "committedDate": "2020-08-01T00:31:52Z", "message": "bad copy paste\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8dbc2a9f56bd233b56ce721ed33410473c538e2", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/f8dbc2a9f56bd233b56ce721ed33410473c538e2", "committedDate": "2020-08-01T02:04:15Z", "message": "stale comment\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/5fadf096c802087f4f416a7ef386803fa08dfdae", "committedDate": "2020-08-04T18:29:04Z", "message": "proto comment\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjMzMzc1", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#pullrequestreview-461233375", "createdAt": "2020-08-04T23:02:14Z", "commit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowMjoxNFrOG70YEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowMjoxNFrOG70YEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzI5Ng==", "bodyText": "I would probably suggest an inverted control flow, which I think simplifies the reading of the logic, and would also help you avoid some nesting.\nIn other words:\nif not matches -> 400\nif end_stream -> 200\ncontinue", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465377296", "createdAt": "2020-08-04T23:02:14Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {\n+  statuses_ = Extensions::Common::Tap::Matcher::MatchStatusVector(config_->matchersSize());\n+  config_->rootMatcher().onNewStream(statuses_);\n+}\n+\n+Http::FilterHeadersStatus AssertionFilter::decodeHeaders(Http::RequestHeaderMap& headers,\n+                                                         bool end_stream) {\n+  config_->rootMatcher().onHttpRequestHeaders(headers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                         \"Request Headers match configured expectations\", nullptr,\n+                                         absl::nullopt, \"\");\n+      return Http::FilterHeadersStatus::StopIteration;\n+    }\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Headers do not match configured expectations\",\n+                                     nullptr, absl::nullopt, \"\");\n+  return Http::FilterHeadersStatus::StopIteration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjMzNjAx", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#pullrequestreview-461233601", "createdAt": "2020-08-04T23:02:50Z", "commit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowMjo1MFrOG70Y2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowMjo1MFrOG70Y2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzQ5Nw==", "bodyText": "Again, I would suggest inverting the control flow here, and removing the nesting.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465377497", "createdAt": "2020-08-04T23:02:50Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {\n+  statuses_ = Extensions::Common::Tap::Matcher::MatchStatusVector(config_->matchersSize());\n+  config_->rootMatcher().onNewStream(statuses_);\n+}\n+\n+Http::FilterHeadersStatus AssertionFilter::decodeHeaders(Http::RequestHeaderMap& headers,\n+                                                         bool end_stream) {\n+  config_->rootMatcher().onHttpRequestHeaders(headers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                         \"Request Headers match configured expectations\", nullptr,\n+                                         absl::nullopt, \"\");\n+      return Http::FilterHeadersStatus::StopIteration;\n+    }\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Headers do not match configured expectations\",\n+                                     nullptr, absl::nullopt, \"\");\n+  return Http::FilterHeadersStatus::StopIteration;\n+}\n+\n+Http::FilterDataStatus AssertionFilter::decodeData(Buffer::Instance& data, bool end_stream) {\n+  config_->rootMatcher().onRequestBody(data, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(\n+          Http::Code::OK, \"Request Body match configured expectations\", nullptr, absl::nullopt, \"\");\n+      return Http::FilterDataStatus::StopIterationNoBuffer;\n+    }\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Body does not match configured expectations\", nullptr,\n+                                     absl::nullopt, \"\");\n+  return Http::FilterDataStatus::StopIterationNoBuffer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjM0MDM0", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#pullrequestreview-461234034", "createdAt": "2020-08-04T23:03:56Z", "commit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowMzo1NlrOG70aMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowMzo1NlrOG70aMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3Nzg0MA==", "bodyText": "Same as above, also, additional return instead of else.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465377840", "createdAt": "2020-08-04T23:03:56Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {\n+  statuses_ = Extensions::Common::Tap::Matcher::MatchStatusVector(config_->matchersSize());\n+  config_->rootMatcher().onNewStream(statuses_);\n+}\n+\n+Http::FilterHeadersStatus AssertionFilter::decodeHeaders(Http::RequestHeaderMap& headers,\n+                                                         bool end_stream) {\n+  config_->rootMatcher().onHttpRequestHeaders(headers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                         \"Request Headers match configured expectations\", nullptr,\n+                                         absl::nullopt, \"\");\n+      return Http::FilterHeadersStatus::StopIteration;\n+    }\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Headers do not match configured expectations\",\n+                                     nullptr, absl::nullopt, \"\");\n+  return Http::FilterHeadersStatus::StopIteration;\n+}\n+\n+Http::FilterDataStatus AssertionFilter::decodeData(Buffer::Instance& data, bool end_stream) {\n+  config_->rootMatcher().onRequestBody(data, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    if (end_stream) {\n+      decoder_callbacks_->sendLocalReply(\n+          Http::Code::OK, \"Request Body match configured expectations\", nullptr, absl::nullopt, \"\");\n+      return Http::FilterDataStatus::StopIterationNoBuffer;\n+    }\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                     \"Request Body does not match configured expectations\", nullptr,\n+                                     absl::nullopt, \"\");\n+  return Http::FilterDataStatus::StopIterationNoBuffer;\n+}\n+\n+Http::FilterTrailersStatus AssertionFilter::decodeTrailers(Http::RequestTrailerMap& trailers) {\n+  config_->rootMatcher().onHttpRequestTrailers(trailers, statuses_);\n+  if (config_->rootMatcher().matchStatus(statuses_).matches_) {\n+    decoder_callbacks_->sendLocalReply(Http::Code::OK,\n+                                       \"Request Trailers match configured expectations\", nullptr,\n+                                       absl::nullopt, \"\");\n+  } else {\n+    decoder_callbacks_->sendLocalReply(Http::Code::BadRequest,\n+                                       \"Request Trailers do not match configured expectations\",\n+                                       nullptr, absl::nullopt, \"\");\n+  }\n+  return Http::FilterTrailersStatus::StopIteration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjM0NzQz", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#pullrequestreview-461234743", "createdAt": "2020-08-04T23:05:50Z", "commit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowNTo1MFrOG70c1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowNTo1MFrOG70c1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3ODUxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Buffer::InstancePtr body{new Buffer::OwnedImpl(\"dont_match_ma\")};\n          \n          \n            \n              Buffer::InstancePtr body{new Buffer::OwnedImpl(\"dont_match_me\")};", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465378516", "createdAt": "2020-08-04T23:05:50Z", "author": {"login": "buildbreaker"}, "path": "test/common/extensions/filters/http/assertion/assertion_filter_test.cc", "diffHunk": "@@ -0,0 +1,167 @@\n+#include \"test/mocks/http/mocks.h\"\n+#include \"test/test_common/utility.h\"\n+\n+#include \"gtest/gtest.h\"\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+#include \"library/common/extensions/filters/http/assertion/filter.pb.h\"\n+\n+using testing::ByMove;\n+using testing::Return;\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+namespace {\n+\n+class AssertionFilterTest : public testing::Test {\n+public:\n+  void setUpFilter(std::string&& yaml) {\n+    envoymobile::extensions::filters::http::assertion::Assertion config;\n+    TestUtility::loadFromYaml(yaml, config);\n+    config_ = std::make_shared<AssertionFilterConfig>(config);\n+    filter_ = std::make_unique<AssertionFilter>(config_);\n+    filter_->setDecoderFilterCallbacks(decoder_callbacks_);\n+    filter_->setEncoderFilterCallbacks(encoder_callbacks_);\n+  }\n+\n+  AssertionFilterConfigSharedPtr config_{};\n+  std::unique_ptr<AssertionFilter> filter_{};\n+  NiceMock<Http::MockStreamDecoderFilterCallbacks> decoder_callbacks_;\n+  NiceMock<Http::MockStreamEncoderFilterCallbacks> encoder_callbacks_;\n+};\n+\n+TEST_F(AssertionFilterTest, HeadersMatchWithEndStream) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_headers_match:\n+    headers:\n+      - name: \":authority\"\n+        exact_match: test.code\n+)EOF\");\n+\n+  Http::TestRequestHeaderMapImpl request_headers{{\":authority\", \"test.code\"}};\n+\n+  EXPECT_CALL(\n+      decoder_callbacks_,\n+      sendLocalReply(Http::Code::OK, \"Request Headers match configured expectations\", _, _, \"\"));\n+  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n+            filter_->decodeHeaders(request_headers, true));\n+}\n+\n+TEST_F(AssertionFilterTest, HeadersMatch) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_headers_match:\n+    headers:\n+      - name: \":authority\"\n+        exact_match: test.code\n+)EOF\");\n+\n+  Http::TestRequestHeaderMapImpl request_headers{{\":authority\", \"test.code\"}};\n+\n+  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, false));\n+}\n+\n+TEST_F(AssertionFilterTest, HeadersNoMatch) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_headers_match:\n+    headers:\n+      - name: \":authority\"\n+        exact_match: test.code\n+)EOF\");\n+\n+  Http::TestRequestHeaderMapImpl request_headers{{\":authority\", \"no.match\"}};\n+\n+  EXPECT_CALL(decoder_callbacks_,\n+              sendLocalReply(Http::Code::BadRequest,\n+                             \"Request Headers do not match configured expectations\", _, _, \"\"));\n+  EXPECT_EQ(Http::FilterHeadersStatus::StopIteration,\n+            filter_->decodeHeaders(request_headers, true));\n+}\n+\n+TEST_F(AssertionFilterTest, DataMatchWithEndStream) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_generic_body_match:\n+    patterns:\n+      - string_match: match_me\n+)EOF\");\n+\n+  Buffer::InstancePtr body{new Buffer::OwnedImpl(\"match_me\")};\n+\n+  EXPECT_CALL(\n+      decoder_callbacks_,\n+      sendLocalReply(Http::Code::OK, \"Request Body match configured expectations\", _, _, \"\"));\n+  EXPECT_EQ(Http::FilterDataStatus::StopIterationNoBuffer, filter_->decodeData(*body, true));\n+}\n+\n+TEST_F(AssertionFilterTest, DataMatch) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_generic_body_match:\n+    patterns:\n+      - string_match: match_me\n+)EOF\");\n+\n+  Buffer::InstancePtr body{new Buffer::OwnedImpl(\"match_me\")};\n+\n+  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(*body, false));\n+}\n+\n+TEST_F(AssertionFilterTest, DataNoMatch) {\n+  setUpFilter(R\"EOF(\n+match_config:\n+  http_request_generic_body_match:\n+    patterns:\n+      - string_match: match_me\n+)EOF\");\n+\n+  Buffer::InstancePtr body{new Buffer::OwnedImpl(\"dont_match_ma\")};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjM0NzQ5", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#pullrequestreview-461234749", "createdAt": "2020-08-04T23:05:51Z", "commit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowNTo1MVrOG70c2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowNTo1MVrOG70c2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3ODUyMg==", "bodyText": "Can we add a docstring to this? It would also be really helpful to link the matcher documentation (whatever there is).", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465378522", "createdAt": "2020-08-04T23:05:51Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/assertion/filter.cc", "diffHunk": "@@ -0,0 +1,79 @@\n+#include \"library/common/extensions/filters/http/assertion/filter.h\"\n+\n+#include \"envoy/http/codes.h\"\n+#include \"envoy/server/filter_config.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+AssertionFilterConfig::AssertionFilterConfig(\n+    const envoymobile::extensions::filters::http::assertion::Assertion& proto_config) {\n+  Common::Tap::buildMatcher(proto_config.match_config(), matchers_);\n+}\n+\n+Extensions::Common::Tap::Matcher& AssertionFilterConfig::rootMatcher() const {\n+  ASSERT(!matchers_.empty());\n+  return *matchers_[0];\n+}\n+\n+AssertionFilter::AssertionFilter(AssertionFilterConfigSharedPtr config) : config_(config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjM2MTE3", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#pullrequestreview-461236117", "createdAt": "2020-08-04T23:09:31Z", "commit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowOTozMVrOG70hTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowOTozMVrOG70hTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3OTY2Mw==", "bodyText": "Can we validate response as well? Do matchers work on responses?\nThe current implementation generates 200s on end_stream, but that could easily be handled by a different upstream filter. Meanwhile it would allow testing of, e.g., modification of responses via platform filters.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r465379663", "createdAt": "2020-08-04T23:09:31Z", "author": {"login": "goaway"}, "path": "library/common/extensions/filters/http/assertion/filter.h", "diffHunk": "@@ -0,0 +1,50 @@\n+#pragma once\n+\n+#include \"envoy/http/filter.h\"\n+\n+#include \"extensions/common/tap/tap_matcher.h\"\n+#include \"extensions/filters/http/common/pass_through_filter.h\"\n+\n+#include \"library/common/extensions/filters/http/assertion/filter.pb.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace Assertion {\n+\n+class AssertionFilterConfig {\n+public:\n+  AssertionFilterConfig(\n+      const envoymobile::extensions::filters::http::assertion::Assertion& proto_config);\n+\n+  Extensions::Common::Tap::Matcher& rootMatcher() const;\n+  size_t matchersSize() const { return matchers_.size(); }\n+\n+private:\n+  std::vector<Extensions::Common::Tap::MatcherPtr> matchers_;\n+};\n+\n+typedef std::shared_ptr<AssertionFilterConfig> AssertionFilterConfigSharedPtr;\n+\n+/**\n+ * Filter to assert expectations on HTTP requests.\n+ */\n+class AssertionFilter final : public Http::PassThroughFilter {\n+public:\n+  AssertionFilter(AssertionFilterConfigSharedPtr config);\n+\n+  // StreamDecoderFilter\n+  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers,\n+                                          bool end_stream) override;\n+  Http::FilterDataStatus decodeData(Buffer::Instance& data, bool end_stream) override;\n+  Http::FilterTrailersStatus decodeTrailers(Http::RequestTrailerMap& trailers) override;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5fadf096c802087f4f416a7ef386803fa08dfdae"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f766d30dfbbf24ad7ac47c851592cffa7a6cf70", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/5f766d30dfbbf24ad7ac47c851592cffa7a6cf70", "committedDate": "2020-08-05T01:44:05Z", "message": "comments\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aecd5cff20732e7163205bcbd07e85d3a17de571", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/aecd5cff20732e7163205bcbd07e85d3a17de571", "committedDate": "2020-08-06T18:16:51Z", "message": "why is coverage failing in CI?\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4656315c5aee5d1b27aedf0fcb64ddf68ca9409d", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/4656315c5aee5d1b27aedf0fcb64ddf68ca9409d", "committedDate": "2020-08-06T20:20:47Z", "message": "try\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "928ae7bead35952362c3d86c37f7c4a0d3555d5d", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/928ae7bead35952362c3d86c37f7c4a0d3555d5d", "committedDate": "2020-08-06T20:33:43Z", "message": "Merge branch 'main' into assertion-filter\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25c7f6a92ccd93446b41dd01935ca0eaf5f9fcf4", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/25c7f6a92ccd93446b41dd01935ca0eaf5f9fcf4", "committedDate": "2020-08-06T20:34:10Z", "message": "Merge branch 'assertion-filter' of github.com:lyft/envoy-mobile into assertion-filter\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa5418c59b45c8db980c0f2abeb13e45f79ddf6a", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/aa5418c59b45c8db980c0f2abeb13e45f79ddf6a", "committedDate": "2020-08-06T22:01:58Z", "message": "time\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyOTI5NDMx", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#pullrequestreview-462929431", "createdAt": "2020-08-06T22:57:51Z", "commit": {"oid": "aa5418c59b45c8db980c0f2abeb13e45f79ddf6a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjo1Nzo1MVrOG9G5DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjo1Nzo1MVrOG9G5DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyOTIyOA==", "bodyText": "\ud83d\ude22", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#discussion_r466729228", "createdAt": "2020-08-06T22:57:51Z", "author": {"login": "goaway"}, "path": ".github/workflows/coverage.yml", "diffHunk": "@@ -13,7 +13,7 @@ jobs:\n   coverage:\n     name: coverage\n     runs-on: ubuntu-18.04\n-    timeout-minutes: 60\n+    timeout-minutes: 120", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa5418c59b45c8db980c0f2abeb13e45f79ddf6a"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyOTMyNjQx", "url": "https://github.com/envoyproxy/envoy-mobile/pull/995#pullrequestreview-462932641", "createdAt": "2020-08-06T23:06:20Z", "commit": {"oid": "aa5418c59b45c8db980c0f2abeb13e45f79ddf6a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb9c3de3b35da05df0f7276a4b67ddf9e9295d5d", "author": {"user": {"login": "junr03", "name": "Jose Ulises Nino Rivera"}}, "url": "https://github.com/envoyproxy/envoy-mobile/commit/eb9c3de3b35da05df0f7276a4b67ddf9e9295d5d", "committedDate": "2020-08-06T23:32:01Z", "message": "revert coverage workflow changes\n\nSigned-off-by: Jose Nino <jnino@lyft.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4147, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}