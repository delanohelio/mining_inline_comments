{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MDA5NTIw", "number": 1056, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo0NTo1MVrOEd1i7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo0Nzo0NlrOEd1lBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzIxNDU0OnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo0NTo1MlrOHJPSXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxOTo1MzozOFrOHJSuog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ0OTY5NA==", "bodyText": "I still don't understand why this boolean is necessary. Once a stream is pending destroy, it should be gone from the map and the map lookup on stream ID should fail. Can you try to remove this boolean and simplify the logic further?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1056#discussion_r479449694", "createdAt": "2020-08-28T17:45:52Z", "author": {"login": "mattklein123"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -425,63 +412,31 @@ envoy_status_t Dispatcher::sendTrailers(envoy_stream_t stream, envoy_headers tra\n   return ENVOY_SUCCESS;\n }\n \n-envoy_status_t Dispatcher::resetStream(envoy_stream_t stream) {\n-  // Testing hook.\n-  synchronizer_.syncPoint(\"getStream_on_cancel\");\n-\n-  Dispatcher::DirectStreamSharedPtr direct_stream = getStream(stream);\n-  if (direct_stream) {\n-\n-    // Testing hook.\n-    synchronizer_.syncPoint(\"dispatch_on_cancel\");\n-\n-    // @see Dispatcher::DirectStream::dispatch_lock_ for why this lock is necessary.\n-    Thread::ReleasableLockGuard lock(direct_stream->dispatch_lock_);\n-    if (direct_stream->dispatchable(true)) {\n-      direct_stream->callbacks_->onCancel();\n-      lock.release();\n-      // n.b: this is guarded by the call above. If the onCancel is not dispatchable then that means\n-      // that another terminal callback has already happened. All terminal callbacks clean up stream\n-      // state, so there is no need to dispatch here.\n-      post([this, stream]() -> void {\n-        // TODO: delete once https://github.com/lyft/envoy-mobile/issues/1016 is fixed.\n-        RELEASE_ASSERT(this, \"callback executed after Http::Dispatcher was deleted\");\n-        Dispatcher::checkGarbage(this);\n-        Dispatcher::DirectStreamSharedPtr direct_stream = getStream(stream);\n-        if (direct_stream) {\n-          Dispatcher::checkGarbage(direct_stream.get());\n-          // This interaction is important. The runResetCallbacks call synchronously causes Envoy to\n-          // defer delete the HCM's ActiveStream. That means that the lifetime of the DirectStream\n-          // only needs to be as long as that deferred delete. Therefore, we synchronously call\n-          // cleanup here which will defer delete the DirectStream, which by definition will be\n-          // scheduled **after** the HCM's defer delete as they are scheduled on the same dispatcher\n-          // context.\n-          //\n-          // StreamResetReason::RemoteReset is used as the platform code that issues the\n-          // cancellation is considered the remote.\n-          //\n-          // This call is guarded by hcm_stream_pending_destroy_ to protect against the\n-          // following race condition:\n-          //   1. resetStream executes first on a platform thread, getting through the dispatch\n-          //   guard and posting this lambda.\n-          //   2. The event dispatcher's thread executes a terminal encoding or a reset in the\n-          //   Http::ConnectionManager, thus calling deferredDelete on the ActiveStream.\n-          //   3. The event dispatcher's thread executes this post body, thus calling\n-          //   runResetCallbacks, which ends up calling deferredDelete (for a second time!) on the\n-          //   ActiveStream.\n-          // This protection makes sure that Envoy Mobile's Http::Dispatcher::DirectStream knows\n-          // synchronously when the ActiveStream is deferredDelete'd for the first time.\n-          if (!direct_stream->hcm_stream_pending_destroy_) {\n-            direct_stream->hcm_stream_pending_destroy_ = true;\n-            direct_stream->runResetCallbacks(StreamResetReason::RemoteReset);\n-          }\n-          cleanup(direct_stream->stream_handle_);\n-        }\n-      });\n+envoy_status_t Dispatcher::cancelStream(envoy_stream_t stream) {\n+  post([this, stream]() -> void {\n+    Dispatcher::DirectStreamSharedPtr direct_stream = getStream(stream);\n+    if (direct_stream) {\n+      Dispatcher::checkGarbage(direct_stream.get());\n+      if (direct_stream->dispatchable(true)) {\n+        direct_stream->callbacks_->onCancel();\n+      }\n+      // This interaction is important. The runResetCallbacks call synchronously causes Envoy to\n+      // defer delete the HCM's ActiveStream. That means that the lifetime of the DirectStream\n+      // only needs to be as long as that deferred delete. Therefore, we synchronously call\n+      // cleanup here which will defer delete the DirectStream, which by definition will be\n+      // scheduled **after** the HCM's defer delete as they are scheduled on the same dispatcher\n+      // context.\n+      //\n+      // StreamResetReason::RemoteReset is used as the platform code that issues the\n+      // cancellation is considered the remote.\n+      if (!direct_stream->hcm_stream_pending_destroy_) {\n+        direct_stream->hcm_stream_pending_destroy_ = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbf918a0f783ae22586efea20ef2b3fc310e4469"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwNjA4Mg==", "bodyText": "I actually was thinking through whether it was stlil necessary last night. I wasn't 100% convinced it was removable and I erred on the side of changing less, but I'll walk through the paths that use it.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1056#discussion_r479506082", "createdAt": "2020-08-28T19:53:38Z", "author": {"login": "goaway"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -425,63 +412,31 @@ envoy_status_t Dispatcher::sendTrailers(envoy_stream_t stream, envoy_headers tra\n   return ENVOY_SUCCESS;\n }\n \n-envoy_status_t Dispatcher::resetStream(envoy_stream_t stream) {\n-  // Testing hook.\n-  synchronizer_.syncPoint(\"getStream_on_cancel\");\n-\n-  Dispatcher::DirectStreamSharedPtr direct_stream = getStream(stream);\n-  if (direct_stream) {\n-\n-    // Testing hook.\n-    synchronizer_.syncPoint(\"dispatch_on_cancel\");\n-\n-    // @see Dispatcher::DirectStream::dispatch_lock_ for why this lock is necessary.\n-    Thread::ReleasableLockGuard lock(direct_stream->dispatch_lock_);\n-    if (direct_stream->dispatchable(true)) {\n-      direct_stream->callbacks_->onCancel();\n-      lock.release();\n-      // n.b: this is guarded by the call above. If the onCancel is not dispatchable then that means\n-      // that another terminal callback has already happened. All terminal callbacks clean up stream\n-      // state, so there is no need to dispatch here.\n-      post([this, stream]() -> void {\n-        // TODO: delete once https://github.com/lyft/envoy-mobile/issues/1016 is fixed.\n-        RELEASE_ASSERT(this, \"callback executed after Http::Dispatcher was deleted\");\n-        Dispatcher::checkGarbage(this);\n-        Dispatcher::DirectStreamSharedPtr direct_stream = getStream(stream);\n-        if (direct_stream) {\n-          Dispatcher::checkGarbage(direct_stream.get());\n-          // This interaction is important. The runResetCallbacks call synchronously causes Envoy to\n-          // defer delete the HCM's ActiveStream. That means that the lifetime of the DirectStream\n-          // only needs to be as long as that deferred delete. Therefore, we synchronously call\n-          // cleanup here which will defer delete the DirectStream, which by definition will be\n-          // scheduled **after** the HCM's defer delete as they are scheduled on the same dispatcher\n-          // context.\n-          //\n-          // StreamResetReason::RemoteReset is used as the platform code that issues the\n-          // cancellation is considered the remote.\n-          //\n-          // This call is guarded by hcm_stream_pending_destroy_ to protect against the\n-          // following race condition:\n-          //   1. resetStream executes first on a platform thread, getting through the dispatch\n-          //   guard and posting this lambda.\n-          //   2. The event dispatcher's thread executes a terminal encoding or a reset in the\n-          //   Http::ConnectionManager, thus calling deferredDelete on the ActiveStream.\n-          //   3. The event dispatcher's thread executes this post body, thus calling\n-          //   runResetCallbacks, which ends up calling deferredDelete (for a second time!) on the\n-          //   ActiveStream.\n-          // This protection makes sure that Envoy Mobile's Http::Dispatcher::DirectStream knows\n-          // synchronously when the ActiveStream is deferredDelete'd for the first time.\n-          if (!direct_stream->hcm_stream_pending_destroy_) {\n-            direct_stream->hcm_stream_pending_destroy_ = true;\n-            direct_stream->runResetCallbacks(StreamResetReason::RemoteReset);\n-          }\n-          cleanup(direct_stream->stream_handle_);\n-        }\n-      });\n+envoy_status_t Dispatcher::cancelStream(envoy_stream_t stream) {\n+  post([this, stream]() -> void {\n+    Dispatcher::DirectStreamSharedPtr direct_stream = getStream(stream);\n+    if (direct_stream) {\n+      Dispatcher::checkGarbage(direct_stream.get());\n+      if (direct_stream->dispatchable(true)) {\n+        direct_stream->callbacks_->onCancel();\n+      }\n+      // This interaction is important. The runResetCallbacks call synchronously causes Envoy to\n+      // defer delete the HCM's ActiveStream. That means that the lifetime of the DirectStream\n+      // only needs to be as long as that deferred delete. Therefore, we synchronously call\n+      // cleanup here which will defer delete the DirectStream, which by definition will be\n+      // scheduled **after** the HCM's defer delete as they are scheduled on the same dispatcher\n+      // context.\n+      //\n+      // StreamResetReason::RemoteReset is used as the platform code that issues the\n+      // cancellation is considered the remote.\n+      if (!direct_stream->hcm_stream_pending_destroy_) {\n+        direct_stream->hcm_stream_pending_destroy_ = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ0OTY5NA=="}, "originalCommit": {"oid": "dbf918a0f783ae22586efea20ef2b3fc310e4469"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzIxOTkwOnYy", "diffSide": "RIGHT", "path": "library/common/http/dispatcher.cc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo0Nzo0NlrOHJPVzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDoyNjo0M1rOHJXb-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MDU3NQ==", "bodyText": "It is extremely difficult to reason about when the stream is removed from the map in various scenarios and with early returns. Per my other comment, can you remove the pending destroy boolean, and change the logic in all of these functions (with a cleanup RAII object, etc. whatever) to a) ASSERT the stream is still in the map, and b) remove it if end_stream/reset in a way that is easy to audit without going through every early return path?", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1056#discussion_r479450575", "createdAt": "2020-08-28T17:47:46Z", "author": {"login": "mattklein123"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -57,16 +57,12 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n     // Testing hook.\n     http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n \n-    // @see Dispatcher::DirectStream::dispatch_lock_ for why this lock is necessary.\n-    Thread::BasicLockable* mutex = end_stream ? nullptr : &direct_stream_.dispatch_lock_;\n-    Thread::OptionalReleasableLockGuard lock(mutex);\n     if (direct_stream_.dispatchable(end_stream)) {\n       ENVOY_LOG(debug,\n                 \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n                 direct_stream_.stream_handle_, end_stream, headers);\n       bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n                                    bridge_callbacks_.context);\n-      lock.release();\n       closeRemote(end_stream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbf918a0f783ae22586efea20ef2b3fc310e4469"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MzIyNA==", "bodyText": "Per some discussion, we will do additional reworking of the code here to enhance readability in a follow-up PR.", "url": "https://github.com/envoyproxy/envoy-mobile/pull/1056#discussion_r479583224", "createdAt": "2020-08-29T00:26:43Z", "author": {"login": "goaway"}, "path": "library/common/http/dispatcher.cc", "diffHunk": "@@ -57,16 +57,12 @@ void Dispatcher::DirectStreamCallbacks::encodeHeaders(const ResponseHeaderMap& h\n     // Testing hook.\n     http_dispatcher_.synchronizer_.syncPoint(\"dispatch_encode_headers\");\n \n-    // @see Dispatcher::DirectStream::dispatch_lock_ for why this lock is necessary.\n-    Thread::BasicLockable* mutex = end_stream ? nullptr : &direct_stream_.dispatch_lock_;\n-    Thread::OptionalReleasableLockGuard lock(mutex);\n     if (direct_stream_.dispatchable(end_stream)) {\n       ENVOY_LOG(debug,\n                 \"[S{}] dispatching to platform response headers for stream (end_stream={}):\\n{}\",\n                 direct_stream_.stream_handle_, end_stream, headers);\n       bridge_callbacks_.on_headers(Utility::toBridgeHeaders(headers), end_stream,\n                                    bridge_callbacks_.context);\n-      lock.release();\n       closeRemote(end_stream);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1MDU3NQ=="}, "originalCommit": {"oid": "dbf918a0f783ae22586efea20ef2b3fc310e4469"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 592, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}