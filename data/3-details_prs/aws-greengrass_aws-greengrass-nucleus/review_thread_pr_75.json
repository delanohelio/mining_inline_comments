{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5ODg1OTE3", "number": 75, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo1MTowNFrODi5Sjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoyODozMVrODjR8lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTE2ODE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo1MTowNFrOFuZjbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMToxMjo1NFrOFubLKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NzQ4NQ==", "bodyText": "[nit]\nRemove unnecessary whitespace.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384197485", "createdAt": "2020-02-25T23:51:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8eaf5250fac6c785d54f883f35ded1fd04d32ceb"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNDA0Mg==", "bodyText": "will do", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384224042", "createdAt": "2020-02-26T01:12:54Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NzQ4NQ=="}, "originalCommit": {"oid": "8eaf5250fac6c785d54f883f35ded1fd04d32ceb"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTE4MTU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo1Njo0NFrOFuZrPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMToxNjoxMVrOFubO6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5OTQ4Nw==", "bodyText": "If this doesn't absolute need to be a single thread, then just get an executor using @Inject so that the Context will provide it to you.\nProbably all these fields should be final too.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384199487", "createdAt": "2020-02-25T23:56:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33228fe81b27d37d2762684bca84d9921090e92f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNTAwMg==", "bodyText": "Agree. Thread model of PM is not emphasis of this PR. Just choose a way can work. We can come back on this later.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384225002", "createdAt": "2020-02-26T01:16:11Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5OTQ4Nw=="}, "originalCommit": {"oid": "33228fe81b27d37d2762684bca84d9921090e92f"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTE4ODIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo1OTozOFrOFuZvMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMToyMTozMVrOFubVCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMDQ5OA==", "bodyText": "Why is the package manager storing the proposed packages as a field? This would seem to be something which is specific to deployment, and really should not be a field but passed as a parameter.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384200498", "createdAt": "2020-02-25T23:59:38Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNjU2OA==", "bodyText": "This is to work with Callable. As you can see, public interface is a method taking it as parameter. To execute actual work in another thread, this is one approach. Later we will add guard rails on tracking, handling the asynchronous work.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384226568", "createdAt": "2020-02-26T01:21:31Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMDQ5OA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTE5MTQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowMTowNVrOFuZxIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMToyNDoyNVrOFubYXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMDk5Mw==", "bodyText": "Can we get a reasonable message here about what is conflicting?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384200993", "createdAt": "2020-02-26T00:01:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNzQyMA==", "bodyText": "Let me try to add more comments. The logic needs to handle many cases. I tried to make it concise, so probably need some guidance to the audience.\nHere is to say \"we want to use proposed package, but is it proposed package version meeting the constraints of all of its dependent?\"", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384227420", "createdAt": "2020-02-26T01:24:25Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMDk5Mw=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTE5NTExOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowMjo0M1rOFuZzUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOToyMTo0NVrOFu4zDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU1NQ==", "bodyText": "Just use @value as mentioned in previous PR?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384201555", "createdAt": "2020-02-26T00:02:43Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -2,29 +2,26 @@\n \n import com.aws.iot.evergreen.util.Utils;\n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n import java.util.Collections;\n import java.util.Set;\n \n @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjkyOA==", "bodyText": "I need a customized constructor, which takes version as string, so internally I can force to use NPM semver type to check.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384202928", "createdAt": "2020-02-26T00:06:57Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -2,29 +2,26 @@\n \n import com.aws.iot.evergreen.util.Utils;\n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n import java.util.Collections;\n import java.util.Set;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU1NQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzU1Ng==", "bodyText": "Let me check the customized one will replace the generated one, if yes, I will switch to use @value", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384203556", "createdAt": "2020-02-26T00:08:53Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -2,29 +2,26 @@\n \n import com.aws.iot.evergreen.util.Utils;\n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n import java.util.Collections;\n import java.util.Set;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU1NQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNTU0NQ==", "bodyText": "The customized one doesn't override the generated one, by using @value it will have a constructor than can take Semver, which could be a risk that external can mess up package manager version resolution by specifying different Semver type.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384205545", "createdAt": "2020-02-26T00:13:40Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -2,29 +2,26 @@\n \n import com.aws.iot.evergreen.util.Utils;\n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n import java.util.Collections;\n import java.util.Set;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU1NQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI1NTgzOQ==", "bodyText": "Based on this : https://projectlombok.org/features/Value\n\"any explicit constructor, no matter the arguments list, implies lombok will not generate a constructor\"\nYour custom constructor should just prevent @value from generating one", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384255839", "createdAt": "2020-02-26T03:21:41Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -2,29 +2,26 @@\n \n import com.aws.iot.evergreen.util.Utils;\n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n import java.util.Collections;\n import java.util.Set;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU1NQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2NjE3Mg==", "bodyText": "https://drive.corp.amazon.com/documents/zhengang@/Screen%20Shot%202020-02-25%20at%208.08.52%20PM.png\nI changed to use @value with customized constructors. Lombok still generates one I want to avoid.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384266172", "createdAt": "2020-02-26T04:13:00Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -2,29 +2,26 @@\n \n import com.aws.iot.evergreen.util.Utils;\n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n import java.util.Collections;\n import java.util.Set;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU1NQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMDM5Nw==", "bodyText": "Interesting, that seems different from what the doc implies. Maybe it only applies in case of Lombok generated constructors? Thanks for validating though", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384700397", "createdAt": "2020-02-26T19:04:22Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -2,29 +2,26 @@\n \n import com.aws.iot.evergreen.util.Utils;\n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n import java.util.Collections;\n import java.util.Set;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU1NQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwOTM4OA==", "bodyText": "IntelliJ is wrong. Try using the constructor and you'll see that it doesn't compile.\nhttps://drive.corp.amazon.com/documents/mdombro@/public/Screen%20Shot%202020-02-26%20at%2011.20.15%20AM.png\nhttps://drive.corp.amazon.com/documents/mdombro@/public/Screen%20Shot%202020-02-26%20at%2011.20.22%20AM.png", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384709388", "createdAt": "2020-02-26T19:21:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -2,29 +2,26 @@\n \n import com.aws.iot.evergreen.util.Utils;\n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n import java.util.Collections;\n import java.util.Set;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU1NQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTE5Nzg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowNDowNlrOFuZ1Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzozMToyOFrOFvAMtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjAwNg==", "bodyText": "Why is this correct? If we're using a new version of a package, why are we pulling the dependencies from the currently installed version?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384202006", "createdAt": "2020-02-26T00:04:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyODI0OQ==", "bodyText": "Keep in mind, we now allow one version for one package. For example, StreamManager either 1.0 or 2.0. If we would like to use 2.0, we need to check the packages depend on 1.0 whether they are ok with 2.0, also update their references to SM 2.0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384228249", "createdAt": "2020-02-26T01:27:22Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjAwNg=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5NzcyNQ==", "bodyText": "Oh, I guess I was confused by the name of dependsBy. Maybe dependedOnBy would be better.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384597725", "createdAt": "2020-02-26T16:10:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjAwNg=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NTUxMA==", "bodyText": "Yeah. It's better. I will update.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384675510", "createdAt": "2020-02-26T18:18:53Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjAwNg=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDY0NQ==", "bodyText": "Can you make that rename? The current name is still confusing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384830645", "createdAt": "2020-02-26T23:31:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjAwNg=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIwMDg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowNTozNVrOFuZ28A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMToyODo0NFrOFubdJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjQ4MA==", "bodyText": "Why is the version null?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384202480", "createdAt": "2020-02-26T00:05:35Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());\n+                devicePackages.put(proposedPackage.getName(), devicePackage);\n+\n+                for (PackageMetadata proposedDependency : proposedPackage.getDependsOn()) {\n+                    devicePackage.getDependsOn().put(proposedDependency.getName(),\n+                            new PackageRegistryEntry.Reference(proposedDependency.getName(), null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyODY0NQ==", "bodyText": "In the current loop, we haven't determined dependency verison, so version is null. We have decided current processing package version.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384228645", "createdAt": "2020-02-26T01:28:44Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());\n+                devicePackages.put(proposedPackage.getName(), devicePackage);\n+\n+                for (PackageMetadata proposedDependency : proposedPackage.getDependsOn()) {\n+                    devicePackage.getDependsOn().put(proposedDependency.getName(),\n+                            new PackageRegistryEntry.Reference(proposedDependency.getName(), null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjQ4MA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIwNjMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowODowNFrOFuZ6Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjo1Mzo0MlrOFu_Xrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzI5NA==", "bodyText": "Same as above, use @value and @Setter?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384203294", "createdAt": "2020-02-26T00:08:04Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNjYwMw==", "bodyText": "Value is immutable, if you need a setter, use @data", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384206603", "createdAt": "2020-02-26T00:16:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzI5NA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwOTM2OA==", "bodyText": "Same reason as above. Customized constructor. Let me make sure lombok behaviors.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384209368", "createdAt": "2020-02-26T00:25:37Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzI5NA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNzA3MQ==", "bodyText": "Lombok works correctly. Use @Data.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384817071", "createdAt": "2020-02-26T22:53:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzI5NA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIwNzYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowODo0N1rOFuZ69w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoyOToxMlrOFvAJ5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzUxMQ==", "bodyText": "Where'd all the comments go? The section above wait more readable. This section is quite tricky and I would benefit greatly from more comments IMO.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384203511", "createdAt": "2020-02-26T00:08:47Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNjY3NQ==", "bodyText": "Please add more comments to this section since we're all agreed that it is confusing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384816675", "createdAt": "2020-02-26T22:52:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzUxMQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyOTkyNA==", "bodyText": "added", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384829924", "createdAt": "2020-02-26T23:29:12Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzUxMQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIwODc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowOToyMlrOFuZ7rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxOTozM1rOFuaKpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzY5Mg==", "bodyText": "Should be final? Any changes during dependency resolution will show up in the output in the final Package object I think.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384203692", "createdAt": "2020-02-26T00:09:22Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter\n+@Setter\n @ToString\n-@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n @EqualsAndHashCode(onlyExplicitlyIncluded = true)\n public class PackageRegistryEntry {\n \n     @EqualsAndHashCode.Include\n-    String name;\n+    private final String name;\n \n     @EqualsAndHashCode.Include\n-    Semver version;\n+    private Semver version;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNzUyNQ==", "bodyText": "During dependency resolution, the version will be re-determined. That's why it's not final. Another approach is to always create new one so to make instance immutable. Since this is package manager internal data object, shouldn't operate in multi-threads env, I think mutating it is ok.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384207525", "createdAt": "2020-02-26T00:19:33Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter\n+@Setter\n @ToString\n-@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n @EqualsAndHashCode(onlyExplicitlyIncluded = true)\n public class PackageRegistryEntry {\n \n     @EqualsAndHashCode.Include\n-    String name;\n+    private final String name;\n \n     @EqualsAndHashCode.Include\n-    Semver version;\n+    private Semver version;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzY5Mg=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIxMTA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMDoyNFrOFuZ8_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMDoyNFrOFuZ8_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDAzMQ==", "bodyText": "All JavaDoc needs two asterisks /**.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384204031", "createdAt": "2020-02-26T00:10:24Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());\n+                devicePackages.put(proposedPackage.getName(), devicePackage);\n+\n+                for (PackageMetadata proposedDependency : proposedPackage.getDependsOn()) {\n+                    devicePackage.getDependsOn().put(proposedDependency.getName(),\n+                            new PackageRegistryEntry.Reference(proposedDependency.getName(), null,\n+                                    proposedDependency.getVersionConstraint()));\n+\n+                    PackageRegistryEntry dependencyPackageEntry = devicePackages.get(proposedDependency.getName());\n+                    if (dependencyPackageEntry == null) {\n+                        dependencyPackageEntry =\n+                                new PackageRegistryEntry(proposedDependency.getName(), null, new HashMap<>());\n+                        devicePackages.put(proposedDependency.getName(), dependencyPackageEntry);\n+                    }\n+                    PackageRegistryEntry.Reference dependBy =\n+                            dependencyPackageEntry.getDependsBy().get(proposedPackage.getName());\n+                    if (dependBy != null) {\n+                        dependBy.setVersion(proposedPackage.getVersion());\n+                        dependBy.setConstraint(proposedPackage.getVersionConstraint());\n+                    } else {\n+                        dependencyPackageEntry.getDependsBy().put(proposedPackage.getName(),\n+                                new PackageRegistryEntry.Reference(proposedPackage.getName(),\n+                                        proposedPackage.getVersion(), proposedDependency.getVersionConstraint()));\n+                    }\n+\n+                    processingQueue.offer(proposedDependency);\n+                }\n+            }\n+\n+            // third to update its dependent\n+            for (PackageRegistryEntry.Reference dependBy : devicePackage.getDependsBy().values()) {\n+                PackageRegistryEntry dependent = devicePackages.get(dependBy.getName());\n+                PackageRegistryEntry.Reference reference = dependent.getDependsOn().get(devicePackage.getName());\n+                if (reference.getVersion() == null || !reference.getVersion().isEqualTo(devicePackage.getVersion())) {\n+                    reference.setVersion(devicePackage.getVersion());\n+                }\n+            }\n+        }\n+    }\n+\n+    /*\n+     * Given a set of pending refresh packages, download the package recipes and artifacts in background\n+     * Return the packages got successfully downloaded\n+     */\n+    private Set<PackageRegistryEntry> downloadPackages(Set<PackageRegistryEntry> pendingDownloadPackages) {\n         return null;\n     }\n \n+    /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIxMTE5OnYy", "diffSide": "LEFT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMDoyOVrOFuZ9Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoyNjozMFrOFuaS1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDA1MA==", "bodyText": "we should still check and make sure the incoming semver is of type npm", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384204050", "createdAt": "2020-02-26T00:10:29Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter\n+@Setter\n @ToString\n-@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n @EqualsAndHashCode(onlyExplicitlyIncluded = true)\n public class PackageRegistryEntry {\n \n     @EqualsAndHashCode.Include\n-    String name;\n+    private final String name;\n \n     @EqualsAndHashCode.Include\n-    Semver version;\n+    private Semver version;\n \n-    Set<Reference> dependBy;\n+    private final Map<String, Reference> dependsBy;\n \n-    Set<Reference> dependOn;\n+    private final Map<String, Reference> dependsOn;\n \n-    public PackageRegistryEntry(String name, String version) {\n+    public PackageRegistryEntry(String name, Semver version, Map<String, Reference> dependsBy) {\n         this.name = name;\n-        this.version = new Semver(version, Semver.SemverType.NPM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwOTYyMg==", "bodyText": "If interface is encapsulated properly, the type is guaranteed in the storing model.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384209622", "createdAt": "2020-02-26T00:26:30Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter\n+@Setter\n @ToString\n-@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n @EqualsAndHashCode(onlyExplicitlyIncluded = true)\n public class PackageRegistryEntry {\n \n     @EqualsAndHashCode.Include\n-    String name;\n+    private final String name;\n \n     @EqualsAndHashCode.Include\n-    Semver version;\n+    private Semver version;\n \n-    Set<Reference> dependBy;\n+    private final Map<String, Reference> dependsBy;\n \n-    Set<Reference> dependOn;\n+    private final Map<String, Reference> dependsOn;\n \n-    public PackageRegistryEntry(String name, String version) {\n+    public PackageRegistryEntry(String name, Semver version, Map<String, Reference> dependsBy) {\n         this.name = name;\n-        this.version = new Semver(version, Semver.SemverType.NPM);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDA1MA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIxMjQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMTowNlrOFuZ92g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMTowNlrOFuZ92g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDI1MA==", "bodyText": "Same questions as above.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384204250", "createdAt": "2020-02-26T00:11:06Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter\n+@Setter\n @ToString\n-@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n @EqualsAndHashCode(onlyExplicitlyIncluded = true)\n public class PackageRegistryEntry {\n \n     @EqualsAndHashCode.Include\n-    String name;\n+    private final String name;\n \n     @EqualsAndHashCode.Include\n-    Semver version;\n+    private Semver version;\n \n-    Set<Reference> dependBy;\n+    private final Map<String, Reference> dependsBy;\n \n-    Set<Reference> dependOn;\n+    private final Map<String, Reference> dependsOn;\n \n-    public PackageRegistryEntry(String name, String version) {\n+    public PackageRegistryEntry(String name, Semver version, Map<String, Reference> dependsBy) {\n         this.name = name;\n-        this.version = new Semver(version, Semver.SemverType.NPM);\n-        this.dependBy = new HashSet<>();\n-        this.dependOn = new HashSet<>();\n+        this.version = version;\n+        this.dependsBy = dependsBy;\n+        this.dependsOn = new HashMap<>();\n     }\n \n-    @Getter\n-    @ToString\n-    @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n-    @EqualsAndHashCode\n+    @Data\n+    @AllArgsConstructor\n     public static class Reference {\n-        String name;\n+        private final String name;\n \n-        Semver version;\n+        private Semver version;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIxMzAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMToyM1rOFuZ-Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMToyOTowMVrOFubdcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDMzMA==", "bodyText": "Please add JavaDoc to all public interfaces.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384204330", "createdAt": "2020-02-26T00:11:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageRegistry.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+\n+import java.util.List;\n+\n+public interface PackageRegistry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyODcyMQ==", "bodyText": "Will add", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384228721", "createdAt": "2020-02-26T01:29:01Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageRegistry.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+\n+import java.util.List;\n+\n+public interface PackageRegistry {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDMzMA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIyNDc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxNDo0OFrOFuaERg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoyMzoyMVrOFuaPNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNTg5NA==", "bodyText": "Might be better to just store the entire package object after resolution based on the whiteboard discussion", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384205894", "createdAt": "2020-02-26T00:14:48Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageRegistry.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+\n+import java.util.List;\n+\n+public interface PackageRegistry {\n+\n+    List<PackageRegistryEntry> findActivePackages();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwODY5NA==", "bodyText": "Entire package including lifecycle, artifact URL seems too much to me. There is no reason to do that now I think.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384208694", "createdAt": "2020-02-26T00:23:21Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageRegistry.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+\n+import java.util.List;\n+\n+public interface PackageRegistry {\n+\n+    List<PackageRegistryEntry> findActivePackages();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNTg5NA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIzMTExOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxNzoxM1rOFuaHzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoyMTo0NVrOFuaNcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNjc5Ng==", "bodyText": "Return is being ignored here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384206796", "createdAt": "2020-02-26T00:17:13Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwODI0MQ==", "bodyText": "Yes, I will add a TODO on what we would like to do here. I can think of many things, from simply one fail all fail to partial success deployment. The 1st version we can fail it if not all the things downloaded.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384208241", "createdAt": "2020-02-26T00:21:45Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNjc5Ng=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTI0ODE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoyNTozMVrOFuaRtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoyOToyOFrOFuaWJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwOTMzNA==", "bodyText": "Based on the incoming request, devicePackages is actually the active packages currently on device right? Not the full contents of the cache?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384209334", "createdAt": "2020-02-26T00:25:31Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxMDQ2OQ==", "bodyText": "It is active packages registered in package registry. Their recipes and artifacts should also be cached. Source of truth is package registry.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384210469", "createdAt": "2020-02-26T00:29:28Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwOTMzNA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTc0NjU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjoxMzoyN1rOFuyGsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDo0MDoxMlrOFu7ZYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTczMA==", "bodyText": "Since these are PackageRegistry related, do you think some of this can be abstracted out and moved into the package registry? It feels like this method is doing too much bookkeeping in addition to the resolution. I think it should be easier to read if it just did resolution and then let the registry update the DB for bookkeeping.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384599730", "createdAt": "2020-02-26T16:13:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"\n+                                    + \" dependent %s constraint\", proposedPackage, dependsBy));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NzkzMw==", "bodyText": "The principle I use is to separate control with data flow. Since the dependency resolution is control logic. I would rather have them out of data model, so the data don't carry handling logic.\nI agree this method is heavy. Probably we can think of refactoring to smaller sub-methods.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384677933", "createdAt": "2020-02-26T18:23:19Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"\n+                                    + \" dependent %s constraint\", proposedPackage, dependsBy));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTczMA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MDIzOQ==", "bodyText": "This isn't control flow though, you're doing data manipulations here, which is why I suggested moving it to the registry class. At this point, the control is basically done since you know what version of that package you'll be using.\nAlso you told me earlier that that PackageRegistryEntry and Reference were only for the database, so why should the package manager be manipulating these data objects? It seems that that job should be handled only by the package registry.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384680239", "createdAt": "2020-02-26T18:27:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"\n+                                    + \" dependent %s constraint\", proposedPackage, dependsBy));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTczMA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTM1Nw==", "bodyText": "I can see your reasoning. IMO it's still control flow. It's continuing data manipulation logic after deciding current package version, update its dependencies and dependents. It includes inter instances operations, not only instance internal operations.\nUse the analogy in the cloud service, PackageRegistryEntry is business model, it's not necessary to persist data by that model (although most likely we will just serialize this model for now), we usually convert to physical data model when coming to storage. But neither business model nor storage model need to contain handling logic of the other instances.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384731357", "createdAt": "2020-02-26T19:58:38Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"\n+                                    + \" dependent %s constraint\", proposedPackage, dependsBy));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTczMA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0MjQ2OA==", "bodyText": "I agree with Michael. I find this block of code pretty difficult to read. It's probably cleaner to abstract the operations on PackageRegistryEntry to separate methods on PackageRegistry. For example, you can have method like:\n// Probably bad name, for explanation purpose.\nClass PackageVersion {\n    String packageName;\n    SemVer version;\n    String versionConstraint;\n}\nList<PackageVersion> getDependencies(PackageVersion pkg);\nvoid addDependency(PackageVersion depender, PackageVersion dependee);\nvoid removeDependency(PackageVersion depender, PackageVersion dependee);\nboolean dependOn(PackageVersion depender, PackageVersion dependee);\nList<PackageVersion> findConflictDependency(PackageVersion pkg1, PackageVersion pkg2);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384742468", "createdAt": "2020-02-26T20:20:52Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"\n+                                    + \" dependent %s constraint\", proposedPackage, dependsBy));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTczMA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1MTk3MQ==", "bodyText": ":) I don't deny this block is obscure. It spends me a ton of time thinking of the logic. I am welcome to refactor on this with proper encapsulation, divide to sub processes etc. But before doing that, I plan to add a ton of unit test cases to validate this pieces of logic. If it proves to be working, we can leverage the test cases when doing refactoring.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384751971", "createdAt": "2020-02-26T20:40:12Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"\n+                                    + \" dependent %s constraint\", proposedPackage, dependsBy));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTczMA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjI0ODUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyNjo0MlrOFu2_RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjo1NDoyNFrOFu_Ytw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3OTc0OA==", "bodyText": "Why adding final? Our code style guidelines say to keep things as non-final unless it is a risk. Do you think there's a risk here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384679748", "createdAt": "2020-02-26T18:26:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMzk3MQ==", "bodyText": "I mark it final in order to make it not inheritable. If package manager doesn't contain state itself, having child is not necessary, only degrade code readability.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384733971", "createdAt": "2020-02-26T20:03:36Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3OTc0OA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNzMzNQ==", "bodyText": "Remove the final. It should be open to subclassing for future expansion.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384817335", "createdAt": "2020-02-26T22:54:24Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3OTc0OA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjQ1NjIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOToyODo0MlrOFu5Ciw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0NzoxOFrOFu9gQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMzM1NQ==", "bodyText": "nit: ...List -> ...Map?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384713355", "createdAt": "2020-02-26T19:28:42Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0ODgwMw==", "bodyText": "package registry interface return list. Convert to map for operation convenience.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384748803", "createdAt": "2020-02-26T20:33:56Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMzM1NQ=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDYxNg==", "bodyText": "We could names it just activePackages, the declaration already tells you what type it is", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384774616", "createdAt": "2020-02-26T21:23:58Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMzM1NQ=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NjQ5OQ==", "bodyText": "sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384786499", "createdAt": "2020-02-26T21:47:18Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMzM1NQ=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjQ5MDczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTozNzoxM1rOFu5WbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDozNjowOVrOFu7RnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxODQ0NA==", "bodyText": "Not sure if this condition will actually occur.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384718444", "createdAt": "2020-02-26T19:37:13Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0OTk4MQ==", "bodyText": "It won't now. But could when it connects with cloud. TODO is for reconsidering how to handle partial failure cases.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384749981", "createdAt": "2020-02-26T20:36:09Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxODQ0NA=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjgyMDQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxNDo0NlrOFu8dPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoyMzoyN1rOFvACcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTM0Mg==", "bodyText": "Would anyone outside package manager need to know how the registry is initialized? If not we could initialize that inline here instead of having a constructor do it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384769342", "createdAt": "2020-02-26T21:14:46Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NjY5Nw==", "bodyText": "You are right, probably not. This is mainly for unit test mocking. We could create static factory method to properly initialize the instances.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384786697", "createdAt": "2020-02-26T21:47:39Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTM0Mg=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNjQ2MQ==", "bodyText": "This should be @Injected.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384816461", "createdAt": "2020-02-26T22:52:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTM0Mg=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyODAxNg==", "bodyText": "As Shagupta's pointing out, package registry and package store are internal to package manager. I think a static factory method to initialize the instances are more appropriate instead of relying on external inject.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384828016", "createdAt": "2020-02-26T23:23:27Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTM0Mg=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjkwNzc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0MDoyMFrOFu9SRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0ODoyMlrOFu9ikA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4MjkxNw==", "bodyText": "Is this modifying activePackageList? It's not very clear on this line", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384782917", "createdAt": "2020-02-26T21:40:20Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NzA4OA==", "bodyText": "Yes, it's updating the map.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384787088", "createdAt": "2020-02-26T21:48:22Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4MjkxNw=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjkxNzY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0MzoyNlrOFu9Ycg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo1MToxM1rOFu9oOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NDQ5OA==", "bodyText": "If beforePackageSet was initialized with all values in activePackageList then pendingDownloadPackages on this line will always be empty, unless activePackageList is modified inside resolveDependencies. This may be working this way but it's confusing to read", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384784498", "createdAt": "2020-02-26T21:43:26Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4ODUzOQ==", "bodyText": "Since the map is modified during dependency resolution, so the new package will be added.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384788539", "createdAt": "2020-02-26T21:51:13Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NDQ5OA=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzA1MjE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjoyNjoxOFrOFu-qXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjoyNjoxOFrOFu-qXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwNTQ2OA==", "bodyText": "This will fail even if the dependsOnBy is also updated in the new deployment.\nex\ncurrent version:\nA 1.0 depends on  C 1.0\nB 1.0 depende on  C 1.0\nnew deployment updates C 1.0 to C 2.0 and updates both A and B to use C 2.0.  The new deployment should not fail as both A and B updated the dependency on C, but as per this logic it will fail.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384805468", "createdAt": "2020-02-26T22:26:18Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsOnBy : devicePackage.getDependsOnBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsOnBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzIwNzg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoyODozMVrOFvAI-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoyODozMVrOFvAI-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyOTY4OQ==", "bodyText": "None of our other classes do this. Use our injection framework like everyone else unless there's a very good reason not to.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384829689", "createdAt": "2020-02-26T23:28:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,168 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n public class PackageManager {\n \n-    /*\n+    public static PackageManager createInstance() {\n+        return new PackageManager(new PackageRegistryImpl());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9badc66ec4912f24390aa73e47b5785c7b8bc84"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4803, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}