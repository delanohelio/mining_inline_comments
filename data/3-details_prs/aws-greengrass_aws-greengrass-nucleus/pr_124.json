{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwODUxMDQ1", "number": 124, "title": "Remove dangling services on config merge", "bodyText": "Description of changes:\n\nshutdown services that got removed from configuration\nclean up service reference and config entries of removed services\n\nWhy is this change necessary:\n\nwhen a service is removed from the kernel config, kernel does not shutdown/clean up service resource\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-03-19T07:54:27Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124", "merged": true, "mergeCommit": {"oid": "772e8d159880b9697a0d4478c18ebb9a104c3d8a"}, "closed": true, "closedAt": "2020-03-21T00:09:48Z", "author": {"login": "fahadmohammed01"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPHEmDAH2gAyMzkwODUxMDQ1OjBhNDI0OTg4Y2E5NTc5MjEzZmFlOWU4NjdhMmMwMThiYzZiYmM1NGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPosJRAH2gAyMzkwODUxMDQ1OmU5ZGM0OGI0MDkzZTAzZjZhZTdiYzNkMjhkMjQ4ZWYwNzg3OTM2NDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0a424988ca9579213fae9e867a2c018bc6bbc54f", "committedDate": "2020-03-19T07:49:18Z", "message": "remove dangling services on config merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3OTE3NTQ1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-377917545", "createdAt": "2020-03-19T17:01:06Z", "commit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNzowMTowNlrOF434ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNzoxMjo0MlrOF44WuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MDIyNw==", "bodyText": "nit\nmerge_removes_service instead of  merge_remove_service", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395180227", "createdAt": "2020-03-19T17:01:06Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MDM0OQ==", "bodyText": "remove -log stdout", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395180349", "createdAt": "2020-03-19T17:01:20Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MDgzMw==", "bodyText": "Use the public static service key name instead of \"services\"", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395180833", "createdAt": "2020-03-19T17:02:07Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(\"services\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MTg1NA==", "bodyText": "here \"lifecycle\" I believe we have a constant for.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395181854", "createdAt": "2020-03-19T17:03:38Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(\"services\");\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(\"lifecycle\")).put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MjUzMA==", "bodyText": "always have a timeout on our blocking calls.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395182530", "createdAt": "2020-03-19T17:04:39Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(\"services\");\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(\"lifecycle\")).put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");\n+\n+        Future<Void> future = kernel.mergeInNewConfig(\"id\", System.currentTimeMillis(), currentConfig);\n+        AtomicBoolean isSleeperAClosed = new AtomicBoolean(false);\n+        kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"sleeperA\") && newState.isClosable()) {\n+                isSleeperAClosed.set(true);\n+            }\n+        });\n+\n+        EvergreenService main = EvergreenService.locate(kernel.context, \"main\");\n+        EvergreenService sleeperB = EvergreenService.locate(kernel.context, \"sleeperB\");\n+        // wait for merge to complete\n+        future.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MjkwOA==", "bodyText": "todo seems todone, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395182908", "createdAt": "2020-03-19T17:05:16Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(\"services\");\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(\"lifecycle\")).put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");\n+\n+        Future<Void> future = kernel.mergeInNewConfig(\"id\", System.currentTimeMillis(), currentConfig);\n+        AtomicBoolean isSleeperAClosed = new AtomicBoolean(false);\n+        kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"sleeperA\") && newState.isClosable()) {\n+                isSleeperAClosed.set(true);\n+            }\n+        });\n+\n+        EvergreenService main = EvergreenService.locate(kernel.context, \"main\");\n+        EvergreenService sleeperB = EvergreenService.locate(kernel.context, \"sleeperB\");\n+        // wait for merge to complete\n+        future.get();\n+        //sleeperA should be closed\n+        assertTrue(isSleeperAClosed.get());\n+        // main and sleeperB should be running\n+        assertTrue(State.RUNNING.equals(main.getState()));\n+        assertTrue(State.RUNNING.equals(sleeperB.getState()));\n+        // ensuring config value for sleeperA is removed\n+        assertFalse(kernel.findTopics(\"services\").children.contains(\"sleeperA\"));\n+        // ensure kernel no longer holds a reference of sleeperA\n+        assertThrows(ServiceLoadException.class, () ->  EvergreenService.locate(kernel.context, \"sleeperA\"));\n+    }\n+        // TODO: Work on removing dependencies and stopping and then removing unused dependencies", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDE4Mw==", "bodyText": "I don't think that serviceName is accurate in this context. I believe that tag is more appropriate. Also the tag is an Object, not necessarily a string.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395184183", "createdAt": "2020-03-19T17:07:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -81,6 +81,10 @@ public void run() {\n         publishThread.start();\n     }\n \n+    public boolean remove(String serviceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDcxMg==", "bodyText": "Why is this in a separate thread?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395184712", "createdAt": "2020-03-19T17:07:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -658,19 +658,21 @@ protected void shutdown() {\n \n     @Override\n     public void close() {\n-        Periodicity t = periodicityInformation;\n-        if (t != null) {\n-            t.shutdown();\n-        }\n-        //TODO: make close block till the service exits or make close non blocking\n-        // currently close blocks till dependers exit which neither the above\n-        try {\n-            waitForDependersToExit();\n-        } catch (InterruptedException e) {\n-            logger.error(\"Interrupted waiting for dependers to exit\");\n-        }\n-        requestStop();\n-        isClosed.set(true);\n+        context.get(Executor.class).execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzM1MQ==", "bodyText": "Why are we limiting this to GenericExternalService? We need a way to remove any service don't we?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395187351", "createdAt": "2020-03-19T17:11:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,49 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n         return totallyCompleteFuture;\n     }\n+\n+    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n+        return orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzU0Mw==", "bodyText": "Replace with method reference EvergreenService::getName", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395187543", "createdAt": "2020-03-19T17:12:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,49 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n         return totallyCompleteFuture;\n     }\n+\n+    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n+        return orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4Nzg5Ng==", "bodyText": "Why use the keyset? Just use containsKey", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395187896", "createdAt": "2020-03-19T17:12:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,49 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n         return totallyCompleteFuture;\n     }\n+\n+    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n+        return orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName())\n+                .filter(serviceName -> !serviceConfig.keySet().contains(serviceName))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MDM2MTkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378036191", "createdAt": "2020-03-19T19:38:58Z", "commit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxOTozODo1OFrOF49pdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxOTozODo1OFrOF49pdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI3NDYxNA==", "bodyText": "nit: starting new services and shutting old ones can happen in parallel, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395274614", "createdAt": "2020-03-19T19:38:58Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,49 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794", "committedDate": "2020-03-19T19:53:45Z", "message": "addressed minor comments from pr"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MTMwNTAz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378130503", "createdAt": "2020-03-19T22:14:02Z", "commit": {"oid": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjoxNDowMlrOF5CM6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjoxNDowMlrOF5CM6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0OTIyNQ==", "bodyText": "it shouldn't directly return here. For example, user may want to update a config.yaml from\nrun: foo\n\nto\nstartup: foo\n\nIn the above case, 'run' node gets removed, but the service still exists.\nI'd prefer something like below\n// in EvergreenService.java\npublic final void close() {\n  // call shutdown;\n  // remove all listeners on the service node.\n  // other close logic\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395349225", "createdAt": "2020-03-19T22:14:02Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -41,6 +42,10 @@ public GenericExternalService(Topics c) {\n \n         // when configuration reloads and child Topic changes, restart/re-install the service.\n         c.subscribe((what, child) -> {\n+            // when the service is removed via a deployment this topic itself will be removed\n+            if (WhatHappened.removed.equals(what)) {\n+                return;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MTM4NDIz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378138423", "createdAt": "2020-03-19T22:31:47Z", "commit": {"oid": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjozMTo0N1rOF5CnWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjozMTo0N1rOF5CnWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1NTk5NA==", "bodyText": "I think this doesn't meet the requirement of deploying multiple groups on to one device. The full solution might require calculate all OrderedDependency() and stop services that's not a dependency of 'main'", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395355994", "createdAt": "2020-03-19T22:31:47Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,50 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n         return totallyCompleteFuture;\n     }\n+\n+    //TODO: handle removing services that are running within in the JVM but defined via config\n+    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n+        return orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(EvergreenService::getName)\n+                .filter(serviceName -> !serviceConfig.containsKey(serviceName))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MTYxODY0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378161864", "createdAt": "2020-03-19T23:32:51Z", "commit": {"oid": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMzozMjo1MVrOF5D1QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMzozMjo1MVrOF5D1QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM3NTkzNg==", "bodyText": "Should we close or just requestStop? I'm thinking about could a new deployment activates a closed service?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395375936", "createdAt": "2020-03-19T23:32:51Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,50 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceeb16c7f74bb1d8273a6bb6d158aff78f2ec794"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fc066f3d5f09df970de77824c4ff866bb854544", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6fc066f3d5f09df970de77824c4ff866bb854544", "committedDate": "2020-03-19T23:55:07Z", "message": "addressed minor comments in pr"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d631d2d396d5116c16c766115b1d11088b01a16d", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d631d2d396d5116c16c766115b1d11088b01a16d", "committedDate": "2020-03-20T00:13:17Z", "message": "Merge branch 'master' into remove-service-from-config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79593188b2546dcf0d0109eb1f85d99d53d51e3a", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/79593188b2546dcf0d0109eb1f85d99d53d51e3a", "committedDate": "2020-03-20T00:23:34Z", "message": "removed line for check style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e649d9b3ae22b052264b967e3eb30238f101fef5", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e649d9b3ae22b052264b967e3eb30238f101fef5", "committedDate": "2020-03-20T05:40:14Z", "message": "minor bug fix and updated test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9f6ea81cd4eecdab6bc0d56d3cc9a4eabc1c957", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a9f6ea81cd4eecdab6bc0d56d3cc9a4eabc1c957", "committedDate": "2020-03-20T06:38:33Z", "message": "fixed race condition in updating dependencies when a new service is added and exiting service is removed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzA5MDA0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378709004", "createdAt": "2020-03-20T18:10:51Z", "commit": {"oid": "a9f6ea81cd4eecdab6bc0d56d3cc9a4eabc1c957"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoxMDo1MlrOF5eW8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoxMzowNFrOF5ebDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDU0NA==", "bodyText": "use assertEquals instead.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395810544", "createdAt": "2020-03-20T18:10:52Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -217,5 +227,65 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_removes_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(EvergreenService.SERVICES_NAMESPACE_TOPIC);\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC))\n+                .put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");\n+\n+        Future<Void> future = kernel.mergeInNewConfig(\"id\", System.currentTimeMillis(), currentConfig);\n+        AtomicBoolean isSleeperAClosed = new AtomicBoolean(false);\n+        kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"sleeperA\") && newState.isClosable()) {\n+                isSleeperAClosed.set(true);\n+            }\n+        });\n+\n+        EvergreenService main = EvergreenService.locate(kernel.context, \"main\");\n+        EvergreenService sleeperB = EvergreenService.locate(kernel.context, \"sleeperB\");\n+        // wait for merge to complete\n+        future.get(60, TimeUnit.SECONDS);\n+        //sleeperA should be closed\n+        assertTrue(isSleeperAClosed.get());\n+        // main and sleeperB should be running\n+        assertTrue(State.RUNNING.equals(main.getState()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9f6ea81cd4eecdab6bc0d56d3cc9a4eabc1c957"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDYwOA==", "bodyText": "remove the todo?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395810608", "createdAt": "2020-03-20T18:11:00Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -227,5 +236,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_remove_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-r\", tempRootDir.toString(), \"-log\", \"stdout\", \"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(\"services\");\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(\"lifecycle\")).put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");\n+\n+        Future<Void> future = kernel.mergeInNewConfig(\"id\", System.currentTimeMillis(), currentConfig);\n+        AtomicBoolean isSleeperAClosed = new AtomicBoolean(false);\n+        kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"sleeperA\") && newState.isClosable()) {\n+                isSleeperAClosed.set(true);\n+            }\n+        });\n+\n+        EvergreenService main = EvergreenService.locate(kernel.context, \"main\");\n+        EvergreenService sleeperB = EvergreenService.locate(kernel.context, \"sleeperB\");\n+        // wait for merge to complete\n+        future.get();\n+        //sleeperA should be closed\n+        assertTrue(isSleeperAClosed.get());\n+        // main and sleeperB should be running\n+        assertTrue(State.RUNNING.equals(main.getState()));\n+        assertTrue(State.RUNNING.equals(sleeperB.getState()));\n+        // ensuring config value for sleeperA is removed\n+        assertFalse(kernel.findTopics(\"services\").children.contains(\"sleeperA\"));\n+        // ensure kernel no longer holds a reference of sleeperA\n+        assertThrows(ServiceLoadException.class, () ->  EvergreenService.locate(kernel.context, \"sleeperA\"));\n+    }\n+        // TODO: Work on removing dependencies and stopping and then removing unused dependencies", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4MjkwOA=="}, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMTU5Ng==", "bodyText": "Why limit ourselves with the filter? Just remove this filter and then check for the name.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395811596", "createdAt": "2020-03-20T18:13:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -631,6 +636,49 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n         return totallyCompleteFuture;\n     }\n+\n+    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n+        return orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NzM1MQ=="}, "originalCommit": {"oid": "0a424988ca9579213fae9e867a2c018bc6bbc54f"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "672ab9fabe1352467297c62e68bcf8cb0c117c53", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/672ab9fabe1352467297c62e68bcf8cb0c117c53", "committedDate": "2020-03-20T19:09:55Z", "message": "addressed minor pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c12573a59a55ceb8ff790031b00c01a9b71b2de", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6c12573a59a55ceb8ff790031b00c01a9b71b2de", "committedDate": "2020-03-20T20:46:28Z", "message": "increasing timeout for kernelTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODA0MTkz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378804193", "createdAt": "2020-03-20T20:51:10Z", "commit": {"oid": "672ab9fabe1352467297c62e68bcf8cb0c117c53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1MToxMFrOF5i13A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1MToxMFrOF5i13A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4Mzk5Ng==", "bodyText": "Do we need to check both isClosable and isClosed?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395883996", "createdAt": "2020-03-20T20:51:10Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -592,20 +593,23 @@ public Topics findServiceTopic(String name) {\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(\"services\");\n-        Map<String, CountDownLatch> latches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> latches.put((String) key, new CountDownLatch(1)));\n+        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n+\n+        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n+        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+\n+        Map<String, CountDownLatch> servicesClosedLatches = new HashMap<>();\n+        removedServices.forEach(serviceName -> servicesClosedLatches.put(serviceName, new CountDownLatch(1)));\n \n         EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n             if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                latches.get(service.getName()).countDown();\n+                servicesRunningLatches.get(service.getName()).countDown();\n             }\n-            if (latches.values().stream().allMatch(c -> c.getCount() <= 0)) {\n-                totallyCompleteFuture.complete(null);\n+\n+            if (removedServices.contains(service.getName()) && newState.isClosable() && service.isClosed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ab9fabe1352467297c62e68bcf8cb0c117c53"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODA2Mjky", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378806292", "createdAt": "2020-03-20T20:55:18Z", "commit": {"oid": "672ab9fabe1352467297c62e68bcf8cb0c117c53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1NToxOVrOF5i79A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1NToxOVrOF5i79A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NTU1Ng==", "bodyText": "Could we try to break the removing services part down to another method? I think that will make it more readable and extensible!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395885556", "createdAt": "2020-03-20T20:55:19Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -627,6 +631,54 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {\n+            try {\n+                for (CountDownLatch countDownLatch : servicesRunningLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                        eg.close();\n+                        //For services that are already finished count down latch\n+                        if (eg.getState().isClosable()) {\n+                            servicesClosedLatches.get(eg.getName()).countDown();\n+                        }\n+                    } catch (ServiceLoadException e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Could not locate EvergreenService to close service\");\n+                    }\n+                });\n+                // waiting for removed service to close before removing reference and config entry\n+                for (CountDownLatch countDownLatch : servicesClosedLatches.values()) {\n+                    countDownLatch.await();\n+                }\n+                removedServices.forEach(serviceName -> {\n+                    try {\n+                        context.remove(serviceName);\n+                        findTopics(\"services\", serviceName).remove();\n+                    } catch (Exception e) {\n+                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                                .log(\"Cloud not clean up resources while removing\");\n+                    }\n+                });\n+\n+                totallyCompleteFuture.complete(null);\n+            } catch (Throwable e) {\n+                totallyCompleteFuture.completeExceptionally(e);\n+            }\n+        });\n+        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "672ab9fabe1352467297c62e68bcf8cb0c117c53"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODA4NDM2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378808436", "createdAt": "2020-03-20T20:59:23Z", "commit": {"oid": "6c12573a59a55ceb8ff790031b00c01a9b71b2de"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1OToyM1rOF5jCUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1OToyM1rOF5jCUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NzE4Nw==", "bodyText": "Maybe add a java doc? :)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395887187", "createdAt": "2020-03-20T20:59:23Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -81,6 +81,10 @@ public void run() {\n         publishThread.start();\n     }\n \n+    public boolean remove(Object tag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c12573a59a55ceb8ff790031b00c01a9b71b2de"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODA4NjA5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378808609", "createdAt": "2020-03-20T20:59:41Z", "commit": {"oid": "6c12573a59a55ceb8ff790031b00c01a9b71b2de"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1OTo0MVrOF5jCyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1OTo0MVrOF5jCyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NzMwNg==", "bodyText": "why?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395887306", "createdAt": "2020-03-20T20:59:41Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/kernel/delta.yaml", "diffHunk": "@@ -14,8 +14,6 @@ services:\n         date; sleep 5; echo Now we\\'re in phase 3\n         done\n     dependencies:\n-      - git\n-      - mqtt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c12573a59a55ceb8ff790031b00c01a9b71b2de"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81edb3f9ef5f44d1d9f743418a907dbc2cdce049", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/81edb3f9ef5f44d1d9f743418a907dbc2cdce049", "committedDate": "2020-03-20T21:03:03Z", "message": "using future returned by close rather than waiting using latches"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODEwNzI4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378810728", "createdAt": "2020-03-20T21:03:59Z", "commit": {"oid": "6c12573a59a55ceb8ff790031b00c01a9b71b2de"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTowMzo1OVrOF5jI_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTowMzo1OVrOF5jI_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4ODg5NA==", "bodyText": "Just a thought, should we also check the ordered dependencies list?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395888894", "createdAt": "2020-03-20T21:03:59Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -217,5 +227,64 @@ void GIVEN_kernel_running_single_service_WHEN_merge_change_adding_nested_depende\n                 containsInRelativeOrder(\"new_service2\", \"new_service\", \"main\"));\n     }\n \n-    // TODO: Work on removing dependencies and stopping and then removing unused dependencies\n+\n+    @Test\n+    void GIVEN_kernel_running_services_WHEN_merge_removes_service_THEN_removed_service_is_closed()\n+            throws Throwable {\n+        // GIVEN\n+        kernel.parseArgs(\"-i\",\n+                getClass().getResource(\"long_running_services.yaml\").toString());\n+        kernel.launch();\n+\n+        CountDownLatch mainRunningLatch = new CountDownLatch(1);\n+        kernel.getMain().getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (((State) t.getOnce()).isRunning()) {\n+                mainRunningLatch.countDown();\n+            }\n+        });\n+\n+        //wait for main to run\n+        assertTrue(mainRunningLatch.await(60, TimeUnit.SECONDS));\n+\n+        Map<Object, Object> currentConfig = new HashMap<>(kernel.toPOJO());\n+        Map<String,Map> servicesConfig = (Map<String, Map>) currentConfig.get(EvergreenService.SERVICES_NAMESPACE_TOPIC);\n+        Iterator<String> itr = servicesConfig.keySet().iterator();\n+\n+        //removing all services in the current kernel config except sleeperB and main\n+        while(itr.hasNext()){\n+            String serviceName = itr.next();\n+            if(!serviceName.equals(\"sleeperB\") && !serviceName.equals(\"main\")){\n+                itr.remove();\n+            }\n+        }\n+        List<String> dependencies = new ArrayList((List<String>)servicesConfig.get(\"main\").get(\"dependencies\")) ;\n+        //removing main's dependency on sleeperA, Now sleeperA is an unused dependency\n+        dependencies.remove(\"sleeperA:RUNNING\");\n+        servicesConfig.get(\"main\").put(\"dependencies\",dependencies);\n+        // updating service B's run\n+        ((Map) servicesConfig.get(\"sleeperB\").get(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC))\n+                .put(\"run\",\"while true; do\\n echo sleeperB_running; sleep 10\\n done\");\n+\n+        Future<Void> future = kernel.mergeInNewConfig(\"id\", System.currentTimeMillis(), currentConfig);\n+        AtomicBoolean isSleeperAClosed = new AtomicBoolean(false);\n+        kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"sleeperA\") && newState.isClosable()) {\n+                isSleeperAClosed.set(true);\n+            }\n+        });\n+\n+        EvergreenService main = EvergreenService.locate(kernel.context, \"main\");\n+        EvergreenService sleeperB = EvergreenService.locate(kernel.context, \"sleeperB\");\n+        // wait for merge to complete\n+        future.get(60, TimeUnit.SECONDS);\n+        //sleeperA should be closed\n+        assertTrue(isSleeperAClosed.get());\n+        // main and sleeperB should be running\n+        assertEquals(State.RUNNING, main.getState());\n+        assertEquals(State.RUNNING, sleeperB.getState());\n+        // ensuring config value for sleeperA is removed\n+        assertFalse(kernel.findTopics(\"services\").children.contains(\"sleeperA\"));\n+        // ensure kernel no longer holds a reference of sleeperA\n+        assertThrows(ServiceLoadException.class, () ->  EvergreenService.locate(kernel.context, \"sleeperA\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c12573a59a55ceb8ff790031b00c01a9b71b2de"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODExMjkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378811291", "createdAt": "2020-03-20T21:05:05Z", "commit": {"oid": "6c12573a59a55ceb8ff790031b00c01a9b71b2de"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODM3MDY4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378837068", "createdAt": "2020-03-20T22:04:59Z", "commit": {"oid": "81edb3f9ef5f44d1d9f743418a907dbc2cdce049"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMjowNDo1OVrOF5kbGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMjowNDo1OVrOF5kbGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwOTkxNA==", "bodyText": "I'm considering if this requires a separate thread because what the tread doing is just waiting. But I'm fine with this PR", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#discussion_r395909914", "createdAt": "2020-03-20T22:04:59Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -627,6 +624,51 @@ public Topics findServiceTopic(String name) {\n             });\n         });\n \n+        context.get(Executor.class).execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81edb3f9ef5f44d1d9f743418a907dbc2cdce049"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODM3MDgy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/124#pullrequestreview-378837082", "createdAt": "2020-03-20T22:05:02Z", "commit": {"oid": "81edb3f9ef5f44d1d9f743418a907dbc2cdce049"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5194a67567de6d28d05cc56e0a9ccc1840e299f0", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5194a67567de6d28d05cc56e0a9ccc1840e299f0", "committedDate": "2020-03-20T22:21:48Z", "message": "fixed minor comments from PR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9dc48b4093e03f6ae7bc3d28d248ef078793643", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e9dc48b4093e03f6ae7bc3d28d248ef078793643", "committedDate": "2020-03-20T22:59:22Z", "message": "Merge branch 'master' into remove-service-from-config"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2354, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}