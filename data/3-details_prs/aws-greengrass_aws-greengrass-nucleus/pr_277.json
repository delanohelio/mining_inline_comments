{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMDg3NjQ0", "number": 277, "title": "New MQTT client with automatic scaling based on subscriptions", "bodyText": "Issue #, if available:\nDescription of changes:\nNew MQTT client using the AWS IoT Device SDK v2, based on the original implementation Amit had. This new client is implemented in 2 places: MqttClient and IndividualMqttClient. The MqttClient class is the external interface that we will use for pub/sub/unsub. It tracks our subscriptions and can use more than one connection at a time. Each actual cloud connection is implemented by IndividualMqttClient which wraps the SDK's client and handles keeping track of number of subscriptions and connection state.\nThis current implementation will scale up the number of connections used when all existing connections have 50 subscriptions (50 is the IoT core limit). It will then also scale down if a connection has 0 subscriptions (there is more room for improvement here to redistribute subscriptions across connections).\nAll MQTT related settings are under the config namespace system.mqtt and the clients will automatically reconnect using the new settings if they are changed.\nSubscriptions are automatically consolidated slightly intelligently (still room for improvement), by which I mean that if a subscription exists for A/B/+, we won't then also subscribe in the cloud for A/B/C because it is already covered by that subscription with a wildcard.\nFurther work:\n\nreplace existing usage of MQTT client with this one\nE2E test thoroughly\nMore advanced scale up/down\nPublish message spooling (in-memory and on-disk)\nUse TPM for hardware crypto (Greenkey)\n\nWhy is this change necessary:\nHow was this change tested:\nAdded unit tests for MqttClient and IndividualMqttClient.\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-06-09T21:58:46Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277", "merged": true, "mergeCommit": {"oid": "4e4b0027b0a6868f5fc87f15ed7c11a246594d83"}, "closed": true, "closedAt": "2020-06-17T23:12:15Z", "author": {"login": "MikeDombo"}, "timelineItems": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcps6WYABqjM0MjcwOTM1NzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsSNksAFqTQzMjgzNjk4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "23f98a53908202ef359a951fe9e5025ec57c23ca", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/23f98a53908202ef359a951fe9e5025ec57c23ca", "committedDate": "2020-06-09T21:55:09Z", "message": "New MQTT client"}, "afterCommit": {"oid": "7617445d9803d14d094b62a33cd62f48233d3321", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7617445d9803d14d094b62a33cd62f48233d3321", "committedDate": "2020-06-09T22:36:25Z", "message": "New MQTT client"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7617445d9803d14d094b62a33cd62f48233d3321", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7617445d9803d14d094b62a33cd62f48233d3321", "committedDate": "2020-06-09T22:36:25Z", "message": "New MQTT client"}, "afterCommit": {"oid": "7177432d30d880b8664f4313b4c9949c755fbdc8", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7177432d30d880b8664f4313b4c9949c755fbdc8", "committedDate": "2020-06-09T23:47:49Z", "message": "New MQTT client"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7177432d30d880b8664f4313b4c9949c755fbdc8", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7177432d30d880b8664f4313b4c9949c755fbdc8", "committedDate": "2020-06-09T23:47:49Z", "message": "New MQTT client"}, "afterCommit": {"oid": "c21c59c5f19066b25eb00c5fe0f3ef6941db0314", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c21c59c5f19066b25eb00c5fe0f3ef6941db0314", "committedDate": "2020-06-10T19:17:10Z", "message": "New MQTT client"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c21c59c5f19066b25eb00c5fe0f3ef6941db0314", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c21c59c5f19066b25eb00c5fe0f3ef6941db0314", "committedDate": "2020-06-10T19:17:10Z", "message": "New MQTT client"}, "afterCommit": {"oid": "dfb1f7137a94505ae1889e11768c6b5f8731d184", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dfb1f7137a94505ae1889e11768c6b5f8731d184", "committedDate": "2020-06-10T19:26:43Z", "message": "New MQTT client"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dfb1f7137a94505ae1889e11768c6b5f8731d184", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dfb1f7137a94505ae1889e11768c6b5f8731d184", "committedDate": "2020-06-10T19:26:43Z", "message": "New MQTT client"}, "afterCommit": {"oid": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b47038f098aeea2b9d88aefb1c3ea550ba32e7cc", "committedDate": "2020-06-10T19:58:41Z", "message": "New MQTT client"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MzMxMzA1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-428331305", "createdAt": "2020-06-10T18:41:29Z", "commit": {"oid": "7177432d30d880b8664f4313b4c9949c755fbdc8"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODo0MToyOVrOGiBy3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMDoyMjoyNFrOGiE-PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzNDE3NA==", "bodyText": "This was captured as a feedback in Mqtt discussions. I don't think this is an immediate requirement. But I was under the impression that we will figure out less costlier ways to identify connection loss when we design separate mqtt client. This comment here is not right place for it I think. We need to determine connection loss outside of this method and then trigger the onConnectionInterrupted.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438334174", "createdAt": "2020-06-10T18:41:29Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7177432d30d880b8664f4313b4c9949c755fbdc8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM0NTg2Mw==", "bodyText": "Do we need these to be applicable for all the code? Can you put it at place where you got these? That way we can see if we can fix them?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438345863", "createdAt": "2020-06-10T19:03:32Z", "author": {"login": "abanthiy"}, "path": "codestyle/findbugs-exclude.xml", "diffHunk": "@@ -9,6 +9,8 @@\n         <Or>\n             <Bug pattern=\"DM_CONVERT_CASE\"/>\n             <Bug pattern=\"SIC_INNER_SHOULD_BE_STATIC_ANON\"/>\n+            <Bug pattern=\"EI_EXPOSE_REP\"/>\n+            <Bug pattern=\"EI_EXPOSE_REP2\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7177432d30d880b8664f4313b4c9949c755fbdc8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM1NTk5Ng==", "bodyText": "Do you need the locking if only thing happening in the try block is setting the Atomic variable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438355996", "createdAt": "2020-06-10T19:23:07Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c21c59c5f19066b25eb00c5fe0f3ef6941db0314"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM1OTI3NQ==", "bodyText": "Add timeout?\nAdd exception handling? It should throw checked exceptions which the calling client can use to put appropriate handling.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438359275", "createdAt": "2020-06-10T19:29:40Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final AtomicInteger subscriptionCount = new AtomicInteger(0);\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos) throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(\"topic\", topic).kv(\"qos\", qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionCount.incrementAndGet();\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(\"topic\", topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionCount.decrementAndGet();\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(\"topic\", message.getTopic()).kv(\"qos\", qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            connect();\n+        }\n+    }\n+\n+    private void connect() throws ExecutionException, InterruptedException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");\n+                connection.connect().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfb1f7137a94505ae1889e11768c6b5f8731d184"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MDg1Mw==", "bodyText": "Do we need MqttClientConnectionEvents as well? Or a method which will be invoked as part of that?\nAnyone using this client wants to define what happens when connection is resumed/interrupted?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438360853", "createdAt": "2020-06-10T19:32:47Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final AtomicInteger subscriptionCount = new AtomicInteger(0);\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfb1f7137a94505ae1889e11768c6b5f8731d184"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NzgyMQ==", "bodyText": "Do we need this for all config changes? If anything changes that kills the connection then any reconnect attempt should read the latest config. If cert path changes and the old one still exists then we probably need to establish a new connection.\nWe should not try to reconnect everytime anything in Device config changes, since it costs. For eg. a change in credential endpoint alone does not require Mqtt connection to be restablished? So I am thinking maybe define more specifically when to attempt to reconnect?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438367821", "createdAt": "2020-06-10T19:46:04Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import org.jetbrains.annotations.NotNull;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(true).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfb1f7137a94505ae1889e11768c6b5f8731d184"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3NjQ4Nw==", "bodyText": "Why do we need WriteLockScope?\nLockScope.lock(connectionLock.writeLock()) won't work?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438376487", "createdAt": "2020-06-10T20:02:23Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import org.jetbrains.annotations.NotNull;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(true).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what)) {\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3OTI0NQ==", "bodyText": "why do you need to do this again? Isn't it happening in L190?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438379245", "createdAt": "2020-06-10T20:08:09Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import org.jetbrains.annotations.NotNull;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(true).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what)) {\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIncludes(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     */\n+    public void unsubscribe(UnsubscribeRequest request) throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIncludes(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized IndividualMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || connections.stream().noneMatch(IndividualMqttClient::canAddNewSubscription)\n+                && forSubscription) {\n+            connections.add(getNewMqttClient());\n+        } else {\n+            // Check for, and then close and remove any connection that has no subscriptions\n+            Set<IndividualMqttClient> closableConnections =\n+                    connections.stream().filter((c) -> c.subscriptionCount() == 0).collect(Collectors.toSet());\n+            for (IndividualMqttClient closableConnection : closableConnections) {\n+                // Leave the last connection alive to use for publishing\n+                if (connections.size() == 1) {\n+                    break;\n+                }\n+                closableConnection.close();\n+                connections.remove(closableConnection);\n+            }\n+        }\n+\n+        // If this connection is to add a new subscription, then don't provide a connection\n+        // which is already maxed out on subscriptions\n+        if (forSubscription) {\n+            return connections.stream().filter(IndividualMqttClient::canAddNewSubscription).findAny().orElseGet(() -> {\n+                IndividualMqttClient client = getNewMqttClient();\n+                connections.add(client);\n+                return client;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NDc2Mg==", "bodyText": "Should the callback be made optional in the unsubscribe request?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438384762", "createdAt": "2020-06-10T20:19:33Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import org.jetbrains.annotations.NotNull;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(true).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what)) {\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIncludes(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     */\n+    public void unsubscribe(UnsubscribeRequest request) throws ExecutionException, InterruptedException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4NjIzNg==", "bodyText": "seems less readable to me.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r438386236", "createdAt": "2020-06-10T20:22:24Z", "author": {"login": "abanthiy"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java", "diffHunk": "@@ -231,15 +231,15 @@ void GIVEN_kernel_WHEN_shutdown_THEN_shutsdown_services_in_order(ExtensionContex\n         CountDownLatch seenErrors = new CountDownLatch(2);\n         Pair<CompletableFuture<Void>, Consumer<EvergreenStructuredLogMessage>> listener =\n                 TestUtils.asyncAssertOnConsumer((m) -> {\n-            if(m.getEventType().equals(\"service-shutdown-error\")) {\n+            if(\"service-shutdown-error\".equals(m.getEventType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b47038f098aeea2b9d88aefb1c3ea550ba32e7cc"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a54ce7419704195293682e36ba045e0dc8657f49", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a54ce7419704195293682e36ba045e0dc8657f49", "committedDate": "2020-06-10T21:02:22Z", "message": "Address PR comments"}, "afterCommit": {"oid": "0a9411a11ce04892dbce6284c53bf9ccfe8da38d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0a9411a11ce04892dbce6284c53bf9ccfe8da38d", "committedDate": "2020-06-10T21:11:52Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a9411a11ce04892dbce6284c53bf9ccfe8da38d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0a9411a11ce04892dbce6284c53bf9ccfe8da38d", "committedDate": "2020-06-10T21:11:52Z", "message": "Address PR comments"}, "afterCommit": {"oid": "75c04df5a44bcb96105bbbd1086711d8e8b2dd65", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/75c04df5a44bcb96105bbbd1086711d8e8b2dd65", "committedDate": "2020-06-10T21:31:23Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75c04df5a44bcb96105bbbd1086711d8e8b2dd65", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/75c04df5a44bcb96105bbbd1086711d8e8b2dd65", "committedDate": "2020-06-10T21:31:23Z", "message": "Address PR comments"}, "afterCommit": {"oid": "b79328651316a9c14efce20498d04199dc7abfeb", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b79328651316a9c14efce20498d04199dc7abfeb", "committedDate": "2020-06-10T21:40:40Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b79328651316a9c14efce20498d04199dc7abfeb", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b79328651316a9c14efce20498d04199dc7abfeb", "committedDate": "2020-06-10T21:40:40Z", "message": "Address PR comments"}, "afterCommit": {"oid": "313e7152dcb48c9cb8213ed69051e1b78c5487f0", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/313e7152dcb48c9cb8213ed69051e1b78c5487f0", "committedDate": "2020-06-10T23:17:20Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "313e7152dcb48c9cb8213ed69051e1b78c5487f0", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/313e7152dcb48c9cb8213ed69051e1b78c5487f0", "committedDate": "2020-06-10T23:17:20Z", "message": "Address PR comments"}, "afterCommit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/32c4839f0e51279ed73d6309d7e10e758667b829", "committedDate": "2020-06-11T21:13:41Z", "message": "Fix topic superset test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MzU1MjY1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-429355265", "createdAt": "2020-06-11T23:14:38Z", "commit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMzoxNDozOFrOGixx8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMDo0NDo1M1rOGizh9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyMDM3MA==", "bodyText": "Curious why you need to create a new class here instead of just implementing the logic?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439120370", "createdAt": "2020-06-11T23:14:38Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttTopic.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class MqttTopic {\n+    private static final String SINGLE_LEVEL_WILDCARD = \"+\";\n+    private static final String MULTILEVEL_WILDCARD = \"#\";\n+    private static final String TOPIC_PATH_SEPARATOR = \"/\";\n+\n+    private final String topic;\n+    private final List<String> subscriptionParts;\n+\n+    public MqttTopic(String topic) {\n+        this.topic = topic;\n+        subscriptionParts = Arrays.asList(topic.split(TOPIC_PATH_SEPARATOR));\n+    }\n+\n+    /**\n+     * Returns true if the topic that is the current instance is a superset (includes) or equals the provided topic\n+     * string. For example, A/B and A/B would be true because they are equal. A/+ and A/B would also work because of the\n+     * wildcard, as would A/# and A/B/C/# because the first one's wildcard includes all of the second.\n+     *\n+     * @param testTopic topic to compare against\n+     * @return true if this instance equals or contains the testTopic\n+     */\n+    public boolean includes(String testTopic) {\n+        if (this.topic.equals(testTopic)) {\n+            return true;\n+        }\n+\n+        MqttTopic tester = new MqttTopic(testTopic);\n+\n+        int i;\n+        for (i = 0; i < Math.min(subscriptionParts.size(), tester.subscriptionParts.size()); i++) {\n+            if (MULTILEVEL_WILDCARD.equals(subscriptionParts.get(i))) {\n+                return true;\n+            }\n+            if (SINGLE_LEVEL_WILDCARD.equals(subscriptionParts.get(i))) {\n+                continue; // single wildcard, continue to match on the rest of the topic\n+            }\n+            String testStr = tester.subscriptionParts.get(i);\n+            if (!subscriptionParts.get(i).equals(testStr)) {\n+                return false;\n+            }\n+        }\n+        // If we didn't make it to the end of either topic, then it doesn't match\n+        return i >= tester.subscriptionParts.size() && i >= subscriptionParts.size();\n+    }\n+\n+    public static boolean topicIncludes(String topic, String testTopic) {\n+        return new MqttTopic(topic).includes(testTopic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyOTgyNQ==", "bodyText": "NIT: DEVICE_MQTT_NAMESPACE is duplicated here.\nI'd prefer in this way:\nCONFIG_TO_CHECK = Arrays.asList(DEVICE_PARAM_THING_NAME, DEVICE_PARAM...)\nif (node.childOf(DEVICE_MQTT_NAMESPACE) || CONFIG_TO_CHECK.contians(node.getName())) {\n}\n\nor even make these configs checks in DeviceConfiguration static class", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439129825", "createdAt": "2020-06-11T23:48:00Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH) || node\n+                        .childOf(DEVICE_MQTT_NAMESPACE))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzMDIzOA==", "bodyText": "topic subscriber is global blocking. Will this reconnect() be blocking?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439130238", "createdAt": "2020-06-11T23:49:39Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH) || node\n+                        .childOf(DEVICE_MQTT_NAMESPACE))) {\n+                    return;\n+                }\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0NjM3MQ==", "bodyText": "I'm confused between sessionPresent and currentlyConnected. What are the diffence between them?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439146371", "createdAt": "2020-06-12T00:33:49Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");\n+                boolean sessionPresent = connection.connect()\n+                        .get(Coerce.toInt(\n+                                mqttTopics.findOrDefault(DEFAULT_MQTT_CONNECT_TIMEOUT, MQTT_CONNECT_TIMEOUT_KEY)),\n+                        TimeUnit.MILLISECONDS);\n+                currentlyConnected.set(true);\n+                logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");\n+                return sessionPresent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0Nzc2OA==", "bodyText": "disconnect clear all subscriptionTopics. Is this desired behavior?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439147768", "createdAt": "2020-06-12T00:39:37Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0OTA0NQ==", "bodyText": "why not return the new mqtt client here directly?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439149045", "createdAt": "2020-06-12T00:44:53Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH) || node\n+                        .childOf(DEVICE_MQTT_NAMESPACE))) {\n+                    return;\n+                }\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIncludes(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIncludes(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized IndividualMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || forSubscription && connections.stream()\n+                .noneMatch(IndividualMqttClient::canAddNewSubscription)) {\n+            connections.add(getNewMqttClient());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5Mzk1ODMy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-429395832", "createdAt": "2020-06-12T00:55:55Z", "commit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMDo1NTo1NVrOGiztTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMDo1NTo1NVrOGiztTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MTk1MA==", "bodyText": "can getConnection return null?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439151950", "createdAt": "2020-06-12T00:55:55Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration) {\n+        this(deviceConfiguration, null);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH) || node\n+                        .childOf(DEVICE_MQTT_NAMESPACE))) {\n+                    return;\n+                }\n+                for (IndividualMqttClient connection : connections) {\n+                    try {\n+                        connection.reconnect();\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                .log(\"Error while reconnecting MQTT client\");\n+                    }\n+                }\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIncludes(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "originalPosition": 161}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "45ca8112f102a7337f154573ef94ca76ebaea015", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/45ca8112f102a7337f154573ef94ca76ebaea015", "committedDate": "2020-06-12T07:13:53Z", "message": "Rename"}, "afterCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "committedDate": "2020-06-12T07:16:58Z", "message": "Rename"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NDE2MDcy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-429416072", "createdAt": "2020-06-12T02:06:56Z", "commit": {"oid": "0dc461742b4757ec8c38ee477ca2f0fd53bff5be"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjowNjo1N1rOGi0vgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMjowNjo1N1rOGi0vgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE2ODg5Ng==", "bodyText": "I am not sure what is meaning of \"node.childOf(*)\". Seems like it should only be true is the node is not the child of any other nodes. Under what situation, it may happen?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439168896", "createdAt": "2020-06-12T02:06:57Z", "author": {"login": "awszztt"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -114,18 +119,20 @@ protected MqttClient(DeviceConfiguration deviceConfiguration,\n                 // List of configuration nodes that we need to reconfigure for if they change\n                 if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dc461742b4757ec8c38ee477ca2f0fd53bff5be"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMzM5NjMx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-430339631", "createdAt": "2020-06-15T05:56:37Z", "commit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNTo1NjozN1rOGjkEhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNjo0NzozMFrOGjlH7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NDMyNg==", "bodyText": "Then maybe connected() can return sessionPresent instead of the flag value?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439944326", "createdAt": "2020-06-15T05:56:37Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");\n+                boolean sessionPresent = connection.connect()\n+                        .get(Coerce.toInt(\n+                                mqttTopics.findOrDefault(DEFAULT_MQTT_CONNECT_TIMEOUT, MQTT_CONNECT_TIMEOUT_KEY)),\n+                        TimeUnit.MILLISECONDS);\n+                currentlyConnected.set(true);\n+                logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");\n+                return sessionPresent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0NjM3MQ=="}, "originalCommit": {"oid": "32c4839f0e51279ed73d6309d7e10e758667b829"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1Njc4NA==", "bodyText": "If forSubscription == true, You still need to check canAddNewSubscription() here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439956784", "createdAt": "2020-06-15T06:34:37Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIsSupersetOf(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized IndividualMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || forSubscription && connections.stream()\n+                .noneMatch(IndividualMqttClient::canAddNewSubscription)) {\n+            IndividualMqttClient conn = getNewMqttClient();\n+            connections.add(conn);\n+            return conn;\n+        } else {\n+            // Check for, and then close and remove any connection that has no subscriptions\n+            Set<IndividualMqttClient> closableConnections =\n+                    connections.stream().filter((c) -> c.subscriptionCount() == 0).collect(Collectors.toSet());\n+            for (IndividualMqttClient closableConnection : closableConnections) {\n+                // Leave the last connection alive to use for publishing\n+                if (connections.size() == 1) {\n+                    break;\n+                }\n+                closableConnection.close();\n+                connections.remove(closableConnection);\n+            }\n+        }\n+\n+        // Get a somewhat random, somewhat round robin connection\n+        return connections.get(connectionRoundRobin.getAndIncrement() % connections.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1OTY5NA==", "bodyText": "NIT: Maybe use MqttTopic for the Pair.left?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439959694", "createdAt": "2020-06-15T06:42:32Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1OTk3Mg==", "bodyText": "NIT: this seems inefficient as it takes N^2 time. Maybe set subscriptions to Map<MqttTopic, List> ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439959972", "createdAt": "2020-06-15T06:43:15Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2MTU4MQ==", "bodyText": "Do we guarantee mutual exclusive in subscription?\nSay, we subscribe to /foo/bar first, then fill up the 50 subscriptions. Then we subscribe to /foo next, which will create another mqtt client. Both will have a message handler. When a message comes to 'foo/bar', both connection message handler will be invoked, cause the message to be delivered twice.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r439961581", "createdAt": "2020-06-15T06:47:30Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNzUyNjcx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-430752671", "createdAt": "2020-06-15T15:25:21Z", "commit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNToyNToyMVrOGj3NMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNToyNToyMVrOGj3NMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI1Nzg0Mw==", "bodyText": "Do we need this to move readwrite lock from read lock to write lock and back ? Can we just lock/unlock the write lock  using try/finally ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440257843", "createdAt": "2020-06-15T15:25:21Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/util/WriteLockScope.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.util;\n+\n+import java.util.concurrent.locks.ReadWriteLock;\n+\n+public final class WriteLockScope implements AutoCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNzg4Mjky", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-430788292", "createdAt": "2020-06-15T16:06:26Z", "commit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjowNjoyN1rOGj46HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODo1NDo0OFrOGj-qLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTcyNQ==", "bodyText": "What are the acceptable values? Add a comment?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440285725", "createdAt": "2020-06-15T16:06:27Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/PublishRequest.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+@Builder\n+@Value\n+public class PublishRequest {\n+    @NonNull String topic;\n+    @Builder.Default\n+    @NonNull QualityOfService qos = QualityOfService.AT_LEAST_ONCE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTk4MQ==", "bodyText": "What is retain? Add a comment?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440285981", "createdAt": "2020-06-15T16:06:49Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/PublishRequest.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+@Builder\n+@Value\n+public class PublishRequest {\n+    @NonNull String topic;\n+    @Builder.Default\n+    @NonNull QualityOfService qos = QualityOfService.AT_LEAST_ONCE;\n+    boolean retain;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5Mjk3OA==", "bodyText": "Add doc?\nAlso is \"AwsIoTMqttClient\" a better name?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440292978", "createdAt": "2020-06-15T16:17:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NjY1NQ==", "bodyText": "Should we use random uuid? I think the client id should include thing name at least for easier debugging. I wouldn't mind the first connection use the thing name, the second uses \"thingname-1\", and go on, .... This way at least the first connection can use IoT thing policy variable", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440296655", "createdAt": "2020-06-15T16:23:50Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIsSupersetOf(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized IndividualMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || forSubscription && connections.stream()\n+                .noneMatch(IndividualMqttClient::canAddNewSubscription)) {\n+            IndividualMqttClient conn = getNewMqttClient();\n+            connections.add(conn);\n+            return conn;\n+        } else {\n+            // Check for, and then close and remove any connection that has no subscriptions\n+            Set<IndividualMqttClient> closableConnections =\n+                    connections.stream().filter((c) -> c.subscriptionCount() == 0).collect(Collectors.toSet());\n+            for (IndividualMqttClient closableConnection : closableConnections) {\n+                // Leave the last connection alive to use for publishing\n+                if (connections.size() == 1) {\n+                    break;\n+                }\n+                closableConnection.close();\n+                connections.remove(closableConnection);\n+            }\n+        }\n+\n+        // Get a somewhat random, somewhat round robin connection\n+        return connections.get(connectionRoundRobin.getAndIncrement() % connections.size());\n+    }\n+\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+    Consumer<MqttMessage> getMessageHandlerForClient(String clientId) {\n+        return (message) -> {\n+            logger.atTrace().kv(CLIENT_ID_KEY, clientId).kv(\"topic\", message.getTopic()).log(\"Received MQTT message\");\n+            Set<SubscribeRequest> subs =\n+                    subscriptions.stream().filter(s -> MqttTopic.topicIsSupersetOf(s.getTopic(), message.getTopic()))\n+                            .collect(Collectors.toSet());\n+            if (subs.isEmpty()) {\n+                logger.atError().kv(\"topic\", message.getTopic()).kv(CLIENT_ID_KEY, clientId)\n+                        .log(\"Somehow got message from topic that no one subscribed to\");\n+                return;\n+            }\n+            subs.forEach((h) -> {\n+                try {\n+                    h.getCallback().accept(message);\n+                } catch (Throwable t) {\n+                    logger.atError().kv(\"message\", message).kv(CLIENT_ID_KEY, clientId)\n+                            .log(\"Unhandled error in MQTT message callback\", t);\n+                }\n+            });\n+        };\n+    }\n+\n+    protected IndividualMqttClient getNewMqttClient() {\n+        String clientId = UUID.randomUUID().toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5OTA4OQ==", "bodyText": "Why do you need to lock here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440299089", "createdAt": "2020-06-15T16:27:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNDg5MQ==", "bodyText": "debug level?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440324891", "createdAt": "2020-06-15T17:12:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNDUzMA==", "bodyText": "Remove TimeoutException?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440334530", "createdAt": "2020-06-15T17:30:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNDY5Ng==", "bodyText": "Do we need to add a timeout in get()?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440334696", "createdAt": "2020-06-15T17:30:31Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MDkyNQ==", "bodyText": "It's worth adding a comment explaining why we're add handler on the onMessage() method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440350925", "createdAt": "2020-06-15T18:00:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MTQ3NQ==", "bodyText": "debug level?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440351475", "createdAt": "2020-06-15T18:01:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MTU4MA==", "bodyText": "debug level?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440351580", "createdAt": "2020-06-15T18:01:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");\n+                boolean sessionPresent = connection.connect()\n+                        .get(Coerce.toInt(\n+                                mqttTopics.findOrDefault(DEFAULT_MQTT_CONNECT_TIMEOUT, MQTT_CONNECT_TIMEOUT_KEY)),\n+                        TimeUnit.MILLISECONDS);\n+                currentlyConnected.set(true);\n+                logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2Mjk5Ng==", "bodyText": "We probably shouldn't populate ExecutionException, InterruptedException, TimeoutException up to the caller. We should handle the exception here and throw more meaningful exception back to the caller. The same applies to the other public methods in this class.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440362996", "createdAt": "2020-06-15T18:23:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIsSupersetOf(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDM2Mw==", "bodyText": "There is potentially a race condition with getMessageHandlerForClient() method. If a subscribe() fails after line 158, the subscribeRequest is added into subscriptions, even though the customer thought the subscribe() call failed. If next time the customer successfully subscribed to the same topic with a different handler, then the message hanlder in the previously failed subscribeRequest will also be triggered by a message to the topic.\nSimilar to the other comment, we should handle the exceptions of connection.subscribe() here and remove the request from subscriptions if the call fails.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440370363", "createdAt": "2020-06-15T18:36:44Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MjI1Mg==", "bodyText": "why lock?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440372252", "createdAt": "2020-06-15T18:40:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/IndividualMqttClient.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_CONNECT_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_CONNECT_TIMEOUT_KEY;\n+\n+public class IndividualMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(IndividualMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(false);\n+            }\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                currentlyConnected.set(true);\n+                // If we didn't reconnect using the same session, then resubscribe to all the topics\n+                if (!sessionPresent) {\n+                    resubscribe();\n+                }\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    private final Set<Pair<String, QualityOfService>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+\n+    IndividualMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider, Consumer<MqttMessage> messageHandler,\n+                         String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.messageHandler = messageHandler;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+            connection.subscribe(topic, qos).get();\n+            subscriptionTopics.add(new Pair<>(topic, qos));\n+        }\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+            connection.unsubscribe(topic).get();\n+            subscriptionTopics.removeIf(p -> p.getLeft().equals(topic));\n+        }\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            connect();\n+            logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                    .log(\"Publishing message\");\n+            connection.publish(message, qos, retain).get();\n+        }\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        try (WriteLockScope scope = WriteLockScope.lock(connectionLock)) {\n+            if (connected()) {\n+                return true;\n+            }\n+\n+            // Always use the builder provider here so that the builder is updated with whatever\n+            // the latest device config is\n+            try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+                builder.withConnectionEventCallbacks(connectionEventCallback);\n+                builder.withClientId(clientId);\n+\n+                connection = builder.build();\n+                connection.onMessage(messageHandler);\n+                logger.atInfo().log(\"Connecting to AWS IoT Core\");\n+                boolean sessionPresent = connection.connect()\n+                        .get(Coerce.toInt(\n+                                mqttTopics.findOrDefault(DEFAULT_MQTT_CONNECT_TIMEOUT, MQTT_CONNECT_TIMEOUT_KEY)),\n+                        TimeUnit.MILLISECONDS);\n+                currentlyConnected.set(true);\n+                logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");\n+                return sessionPresent;\n+            }\n+        }\n+    }\n+\n+    private void resubscribe() {\n+        subscriptionTopics.forEach(s -> {\n+            try {\n+                subscribe(s.getLeft(), s.getRight());\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                logger.atError().kv(TOPIC_KEY, s.getLeft()).kv(QOS_KEY, s.getRight().name())\n+                        .log(\"Unable to resubscribe to topic\");\n+            }\n+        });\n+    }\n+\n+    boolean canAddNewSubscription() {\n+        return subscriptionTopics.size() < MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+    }\n+\n+    int subscriptionCount() {\n+        return subscriptionTopics.size();\n+    }\n+\n+    boolean connected() {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3OTk1MQ==", "bodyText": "Is it true that, if tryLock() return false, then someone must be holding the readLock? What if another thread is holding the writeLock?  In that case when close() is called, readLock() is acquired, which is wrong.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r440379951", "createdAt": "2020-06-15T18:54:48Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/util/WriteLockScope.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.util;\n+\n+import java.util.concurrent.locks.ReadWriteLock;\n+\n+public final class WriteLockScope implements AutoCloseable {\n+    private final ReadWriteLock ref;\n+    private boolean heldRead = false;\n+\n+    private WriteLockScope(ReadWriteLock ref) {\n+        this.ref = ref;\n+        if (!ref.writeLock().tryLock()) {\n+            ref.readLock().unlock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc7b414a5bf3a5e4adb815a1210e3e08e4817e52", "committedDate": "2020-06-12T07:16:58Z", "message": "Rename"}, "afterCommit": {"oid": "c6942454ad79ebb344baff77851b3aa2b83c470a", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c6942454ad79ebb344baff77851b3aa2b83c470a", "committedDate": "2020-06-15T19:56:05Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c6942454ad79ebb344baff77851b3aa2b83c470a", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c6942454ad79ebb344baff77851b3aa2b83c470a", "committedDate": "2020-06-15T19:56:05Z", "message": "Address PR comments"}, "afterCommit": {"oid": "50b315aa6919888363153d5c5c8e522713779504", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/50b315aa6919888363153d5c5c8e522713779504", "committedDate": "2020-06-15T20:06:27Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "50b315aa6919888363153d5c5c8e522713779504", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/50b315aa6919888363153d5c5c8e522713779504", "committedDate": "2020-06-15T20:06:27Z", "message": "Address PR comments"}, "afterCommit": {"oid": "242f517a37a483348bcf76165f98f7207c83c65d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/242f517a37a483348bcf76165f98f7207c83c65d", "committedDate": "2020-06-15T20:15:39Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "242f517a37a483348bcf76165f98f7207c83c65d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/242f517a37a483348bcf76165f98f7207c83c65d", "committedDate": "2020-06-15T20:15:39Z", "message": "Address PR comments"}, "afterCommit": {"oid": "33fcd6f5f2638bcf8f6684a8ff7b0577021c534d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33fcd6f5f2638bcf8f6684a8ff7b0577021c534d", "committedDate": "2020-06-15T20:40:23Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33fcd6f5f2638bcf8f6684a8ff7b0577021c534d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33fcd6f5f2638bcf8f6684a8ff7b0577021c534d", "committedDate": "2020-06-15T20:40:23Z", "message": "Address PR comments"}, "afterCommit": {"oid": "ddcb664dbcc93b9163340cb6a93a13dc294b9639", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ddcb664dbcc93b9163340cb6a93a13dc294b9639", "committedDate": "2020-06-15T20:54:06Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5156dff59d8ff76794be4b4308b09d2b64f8b892", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5156dff59d8ff76794be4b4308b09d2b64f8b892", "committedDate": "2020-06-17T01:50:57Z", "message": "New MQTT client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d068d0605afb7f4c6128db84519bc1c6f92c773", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3d068d0605afb7f4c6128db84519bc1c6f92c773", "committedDate": "2020-06-17T01:50:57Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28d0e2a5faaa97b6ac664d72a998c064e5573f9d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/28d0e2a5faaa97b6ac664d72a998c064e5573f9d", "committedDate": "2020-06-17T01:50:57Z", "message": "Fix topic superset test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b9cdb5fa409fd4bbb5fbc47d2f8d8b78ebe476b", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b9cdb5fa409fd4bbb5fbc47d2f8d8b78ebe476b", "committedDate": "2020-06-17T01:50:57Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23d33f224e6783f147d5c36f2754f3d601496123", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/23d33f224e6783f147d5c36f2754f3d601496123", "committedDate": "2020-06-17T01:50:57Z", "message": "Rename"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f71f4f64f52456064eb656ea72c123584858b414", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f71f4f64f52456064eb656ea72c123584858b414", "committedDate": "2020-06-17T01:50:57Z", "message": "Deduplicate messages in callback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2f8b8181ed88b157b512601938fa1e3491023da", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d2f8b8181ed88b157b512601938fa1e3491023da", "committedDate": "2020-06-17T01:50:57Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ddcb664dbcc93b9163340cb6a93a13dc294b9639", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ddcb664dbcc93b9163340cb6a93a13dc294b9639", "committedDate": "2020-06-15T20:54:06Z", "message": "Address PR comments"}, "afterCommit": {"oid": "f023a3250d7438b53ceed241b9f5be696a332d42", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f023a3250d7438b53ceed241b9f5be696a332d42", "committedDate": "2020-06-17T01:50:57Z", "message": "Precompute client for each subscription topic"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f023a3250d7438b53ceed241b9f5be696a332d42", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f023a3250d7438b53ceed241b9f5be696a332d42", "committedDate": "2020-06-17T01:50:57Z", "message": "Precompute client for each subscription topic"}, "afterCommit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3add4b37c76c904cae81efa70659f68ed7da9a69", "committedDate": "2020-06-17T01:53:53Z", "message": "Precompute client for each subscription topic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyMDEzNzU4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-432013758", "createdAt": "2020-06-17T02:22:03Z", "commit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTc0MjUy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-432574252", "createdAt": "2020-06-17T16:31:47Z", "commit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjozMTo0N1rOGlNvdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjo1ODozMlrOGlOwqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NTYzNw==", "bodyText": "Is synchronized necessary here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441675637", "createdAt": "2020-06-17T16:31:47Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/AwsIotMqttClient.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_OPERATION_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_OPERATION_TIMEOUT_KEY;\n+\n+/**\n+ * Wrapper for a single AWS IoT MQTT client connection.\n+ * Do not use except through {@link MqttClient}.\n+ */\n+class AwsIotMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(AwsIotMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    @SuppressFBWarnings(\"IS2_INCONSISTENT_SYNC\")\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            currentlyConnected.set(false);\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            currentlyConnected.set(true);\n+            // If we didn't reconnect using the same session, then resubscribe to all the topics\n+            if (!sessionPresent) {\n+                resubscribe();\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, QualityOfService> subscriptionTopics = new ConcurrentHashMap<>();\n+\n+    AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n+                     Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n+                     String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+        this.messageHandler = messageHandler.apply(this);\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+        connection.subscribe(topic, qos).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.put(topic, qos);\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+        connection.unsubscribe(topic).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.remove(topic);\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                .log(\"Publishing message\");\n+        connection.publish(message, qos, retain).get(getTimeout(), TimeUnit.MILLISECONDS);\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        // Synchronize here instead of method signature to make mockito work without deadlocking\n+        synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NzI1OQ==", "bodyText": "Does this need to be public? Can it be package level like the other methods?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441677259", "createdAt": "2020-06-17T16:34:39Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/AwsIotMqttClient.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_OPERATION_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_OPERATION_TIMEOUT_KEY;\n+\n+/**\n+ * Wrapper for a single AWS IoT MQTT client connection.\n+ * Do not use except through {@link MqttClient}.\n+ */\n+class AwsIotMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(AwsIotMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    @SuppressFBWarnings(\"IS2_INCONSISTENT_SYNC\")\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            currentlyConnected.set(false);\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            currentlyConnected.set(true);\n+            // If we didn't reconnect using the same session, then resubscribe to all the topics\n+            if (!sessionPresent) {\n+                resubscribe();\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, QualityOfService> subscriptionTopics = new ConcurrentHashMap<>();\n+\n+    AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n+                     Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n+                     String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+        this.messageHandler = messageHandler.apply(this);\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+        connection.subscribe(topic, qos).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.put(topic, qos);\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+        connection.unsubscribe(topic).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.remove(topic);\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                .log(\"Publishing message\");\n+        connection.publish(message, qos, retain).get(getTimeout(), TimeUnit.MILLISECONDS);\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        // Synchronize here instead of method signature to make mockito work without deadlocking\n+        synchronized (this) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private synchronized boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        if (connected()) {\n+            return true;\n+        }\n+\n+        // Always use the builder provider here so that the builder is updated with whatever\n+        // the latest device config is\n+        try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+            builder.withConnectionEventCallbacks(connectionEventCallback);\n+            builder.withClientId(clientId);\n+\n+            connection = builder.build();\n+            // Set message handler for this connection to be our global message handler.\n+            // The handler will then send out the message to all subscribers.\n+            connection.onMessage(messageHandler);\n+            logger.atDebug().log(\"Connecting to AWS IoT Core\");\n+            boolean sessionPresent = connection.connect().get(getTimeout(), TimeUnit.MILLISECONDS);\n+            currentlyConnected.set(true);\n+            logger.atDebug().kv(\"sessionPresent\", sessionPresent).log(\"Successfully connected to AWS IoT Core\");\n+            return sessionPresent;\n+        }\n+    }\n+\n+    private int getTimeout() {\n+        return Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_OPERATION_TIMEOUT, MQTT_OPERATION_TIMEOUT_KEY));\n+    }\n+\n+    private void resubscribe() {\n+        subscriptionTopics.forEach((key, value) -> {\n+            try {\n+                subscribe(key, value);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                logger.atError().kv(TOPIC_KEY, key).kv(QOS_KEY, value.name()).log(\"Unable to resubscribe to topic\");\n+            }\n+        });\n+    }\n+\n+    boolean canAddNewSubscription() {\n+        return subscriptionTopics.size() < MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+    }\n+\n+    int subscriptionCount() {\n+        return subscriptionTopics.size();\n+    }\n+\n+    boolean connected() {\n+        return connection != null && currentlyConnected.get();\n+    }\n+\n+    private synchronized void disconnect() {\n+        try {\n+            currentlyConnected.set(false);\n+            if (connection != null) {\n+                logger.atDebug().log(\"Disconnecting from AWS IoT Core\");\n+                try {\n+                    connection.disconnect().get(getTimeout(), TimeUnit.MILLISECONDS);\n+                } finally {\n+                    connection.close();\n+                }\n+                logger.atDebug().log(\"Successfully disconnected from AWS IoT Core\");\n+            }\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.atError().log(\"Error while disconnecting the MQTT client\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3OTQ5OQ==", "bodyText": "Is this the right error handling?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441679499", "createdAt": "2020-06-17T16:38:18Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_OPERATION_TIMEOUT_KEY = \"operationTimeoutMs\";\n+    static final int DEFAULT_MQTT_OPERATION_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<AwsIotMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n+    private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService     executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (AwsIotMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4Mjg1Nw==", "bodyText": "I think this comment misses the key point that MqttClient handles topic filtering and triggers the message handler corresponding to each subscription.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441682857", "createdAt": "2020-06-17T16:43:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/AwsIotMqttClient.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.CRT;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnection;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import javax.inject.Provider;\n+\n+import static com.aws.iot.evergreen.mqtt.MqttClient.CLIENT_ID_KEY;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.DEFAULT_MQTT_OPERATION_TIMEOUT;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MAX_SUBSCRIPTIONS_PER_CONNECTION;\n+import static com.aws.iot.evergreen.mqtt.MqttClient.MQTT_OPERATION_TIMEOUT_KEY;\n+\n+/**\n+ * Wrapper for a single AWS IoT MQTT client connection.\n+ * Do not use except through {@link MqttClient}.\n+ */\n+class AwsIotMqttClient implements Closeable {\n+    private static final String TOPIC_KEY = \"topic\";\n+    private static final String QOS_KEY = \"qos\";\n+    private final Logger logger = LogManager.getLogger(AwsIotMqttClient.class).createChild()\n+            .dfltKv(CLIENT_ID_KEY, (Supplier<String>) this::getClientId);\n+\n+    private final Provider<AwsIotMqttConnectionBuilder> builderProvider;\n+    @Getter\n+    private final String clientId;\n+    @SuppressFBWarnings(\"IS2_INCONSISTENT_SYNC\")\n+    private MqttClientConnection connection;\n+    private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n+\n+    private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            currentlyConnected.set(false);\n+            // Error code 0 means that the disconnection was intentional, so we don't need to log it\n+            if (errorCode != 0) {\n+                logger.atWarn().kv(\"error\", CRT.awsErrorString(errorCode)).log(\"Connection interrupted\");\n+                // Copy-paste from Amit's original work, ask him about this if needed\n+                //TODO: Detect this using secondary mechanisms like checking if internet is available\n+                // instead of using ping to Mqtt server. Mqtt ping is expensive and should be used as the last resort.\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            currentlyConnected.set(true);\n+            // If we didn't reconnect using the same session, then resubscribe to all the topics\n+            if (!sessionPresent) {\n+                resubscribe();\n+            }\n+            logger.atInfo().kv(\"sessionPresent\", sessionPresent).log(\"Connection resumed\");\n+        }\n+    };\n+\n+    private final Consumer<MqttMessage> messageHandler;\n+    private final Topics mqttTopics;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, QualityOfService> subscriptionTopics = new ConcurrentHashMap<>();\n+\n+    AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n+                     Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n+                     String clientId, Topics mqttTopics) {\n+        this.builderProvider = builderProvider;\n+        this.clientId = clientId;\n+        this.mqttTopics = mqttTopics;\n+        this.messageHandler = messageHandler.apply(this);\n+    }\n+\n+    void subscribe(String topic, QualityOfService qos)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).kv(QOS_KEY, qos.name()).log(\"Subscribing to topic\");\n+        connection.subscribe(topic, qos).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.put(topic, qos);\n+    }\n+\n+    void unsubscribe(String topic) throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atDebug().kv(TOPIC_KEY, topic).log(\"Unsubscribing from topic\");\n+        connection.unsubscribe(topic).get(getTimeout(), TimeUnit.MILLISECONDS);\n+        subscriptionTopics.remove(topic);\n+    }\n+\n+    void publish(MqttMessage message, QualityOfService qos, boolean retain)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        connect();\n+        logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n+                .log(\"Publishing message\");\n+        connection.publish(message, qos, retain).get(getTimeout(), TimeUnit.MILLISECONDS);\n+    }\n+\n+    void reconnect() throws ExecutionException, InterruptedException, TimeoutException {\n+        // Synchronize here instead of method signature to make mockito work without deadlocking\n+        synchronized (this) {\n+            logger.atInfo().log(\"Reconnecting MQTT client most likely due to device configuration change\");\n+            disconnect();\n+            // If we didn't resume the session (which is unlikely), then manually resubscribe\n+            if (!connect()) {\n+                resubscribe();\n+            }\n+        }\n+    }\n+\n+    private synchronized boolean connect() throws ExecutionException, InterruptedException, TimeoutException {\n+        if (connected()) {\n+            return true;\n+        }\n+\n+        // Always use the builder provider here so that the builder is updated with whatever\n+        // the latest device config is\n+        try (AwsIotMqttConnectionBuilder builder = builderProvider.get()) {\n+            builder.withConnectionEventCallbacks(connectionEventCallback);\n+            builder.withClientId(clientId);\n+\n+            connection = builder.build();\n+            // Set message handler for this connection to be our global message handler.\n+            // The handler will then send out the message to all subscribers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4OTg4OA==", "bodyText": "Both unsubscribe and subscribe are synchronized, do you still the lock?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441689888", "createdAt": "2020-06-17T16:54:47Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_OPERATION_TIMEOUT_KEY = \"operationTimeoutMs\";\n+    static final int DEFAULT_MQTT_OPERATION_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<AwsIotMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n+    private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService     executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (AwsIotMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public synchronized void subscribe(SubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try {\n+            AwsIotMqttClient connection = null;\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> existingConnection =\n+                        findExistingSubscriberForTopic(request.getTopic());\n+                if (existingConnection.isPresent()) {\n+                    subscriptions.put(request, existingConnection.get().getValue());\n+                } else {\n+                    connection = getConnection(true);\n+                    subscriptions.put(request, connection);\n+                }\n+            }\n+\n+            try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+                // Connection isn't null, so we should subscribe to the topic\n+                if (connection != null) {\n+                    connection.subscribe(request.getTopic(), request.getQos());\n+                    subscriptionTopics.put(new MqttTopic(request.getTopic()), connection);\n+                }\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+            // If subscribing failed, then clean up the failed subscription callback\n+            subscriptions.remove(request);\n+            throw e;\n+        }\n+    }\n+\n+    private Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> findExistingSubscriberForTopic(String topic) {\n+        return subscriptionTopics.entrySet().stream().filter(s -> s.getKey().isSupersetOf(new MqttTopic(topic)))\n+                .findAny();\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public synchronized void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+        try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5MDUzNQ==", "bodyText": "I don't see reply on this comment.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441690535", "createdAt": "2020-06-17T16:55:44Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import com.aws.iot.evergreen.util.Pair;\n+import com.aws.iot.evergreen.util.WriteLockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_CONNECT_TIMEOUT_KEY = \"connectTimeoutMs\";\n+    static final int DEFAULT_MQTT_CONNECT_TIMEOUT = (int) Duration.ofSeconds(10).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<IndividualMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Set<SubscribeRequest> subscriptions = new CopyOnWriteArraySet<>();\n+    private final Set<Pair<String, IndividualMqttClient>> subscriptionTopics = new CopyOnWriteArraySet<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (IndividualMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void subscribe(SubscribeRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        IndividualMqttClient connection = null;\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.add(request);\n+\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                if (subscriptionTopics.stream()\n+                        .noneMatch(s -> MqttTopic.topicIsSupersetOf(s.getLeft(), request.getTopic()))) {\n+                    connection = getConnection(true);\n+                }\n+            }\n+\n+            // Connection isn't null, so we should subscribe to the topic\n+            if (connection != null) {\n+                connection.subscribe(request.getTopic(), request.getQos());\n+                subscriptionTopics.add(new Pair<>(request.getTopic(), connection));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+            Set<Pair<String, IndividualMqttClient>> deadSubscriptionTopics;\n+            // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+            try (WriteLockScope scope2 = WriteLockScope.lock(connectionLock)) {\n+                subscriptions.removeIf(\n+                        r -> r.getCallback() == request.getCallback() && r.getTopic().equals(request.getTopic()));\n+                // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+                deadSubscriptionTopics = subscriptionTopics.stream().filter(s -> subscriptions.stream()\n+                        .noneMatch(sub -> MqttTopic.topicIsSupersetOf(s.getLeft(), sub.getTopic())))\n+                        .collect(Collectors.toSet());\n+\n+            }\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Pair<String, IndividualMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getRight().unsubscribe(sub.getLeft());\n+                    subscriptionTopics.remove(sub);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2Mjk5Ng=="}, "originalCommit": {"oid": "dc7b414a5bf3a5e4adb815a1210e3e08e4817e52"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5MjMzMQ==", "bodyText": "Shouldn't this method be synchronized as well?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#discussion_r441692331", "createdAt": "2020-06-17T16:58:32Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/mqtt/MqttClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.mqtt;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.LockScope;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.iot.AwsIotMqttConnectionBuilder;\n+\n+import java.io.Closeable;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+\n+public class MqttClient implements Closeable {\n+    private static final Logger logger = LogManager.getLogger(MqttClient.class);\n+    private static final String MQTT_KEEP_ALIVE_TIMEOUT_KEY = \"keepAliveTimeoutMs\";\n+    private static final int DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT = (int) Duration.ofSeconds(60).toMillis();\n+    private static final String MQTT_PING_TIMEOUT_KEY = \"pingTimeoutMs\";\n+    private static final int DEFAULT_MQTT_PING_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    private static final String MQTT_THREAD_POOL_SIZE_KEY = \"threadPoolSize\";\n+    public static final int DEFAULT_MQTT_PORT = 8883;\n+    public static final String MQTT_PORT_KEY = \"port\";\n+    private static final String MQTT_SOCKET_TIMEOUT_KEY = \"socketTimeoutMs\";\n+    // Default taken from AWS SDK\n+    private static final int DEFAULT_MQTT_SOCKET_TIMEOUT = (int) Duration.ofSeconds(3).toMillis();\n+    static final String MQTT_OPERATION_TIMEOUT_KEY = \"operationTimeoutMs\";\n+    static final int DEFAULT_MQTT_OPERATION_TIMEOUT = (int) Duration.ofSeconds(30).toMillis();\n+    public static final int MAX_SUBSCRIPTIONS_PER_CONNECTION = 50;\n+    public static final String CLIENT_ID_KEY = \"clientId\";\n+\n+    // Use read lock for MQTT operations and write lock when changing the MQTT connection\n+    private final ReadWriteLock connectionLock = new ReentrantReadWriteLock(true);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Topics mqttTopics;\n+    @SuppressWarnings(\"PMD.ImmutableField\")\n+    private Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider;\n+    private final List<AwsIotMqttClient> connections = new CopyOnWriteArrayList<>();\n+    private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n+    private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n+    private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+\n+    private final EventLoopGroup eventLoopGroup;\n+    private final HostResolver hostResolver;\n+    private final ClientBootstrap clientBootstrap;\n+\n+    //\n+    // TODO: Handle timeouts and retries\n+    //\n+\n+    /**\n+     * Constructor for injection.\n+     *\n+     * @param deviceConfiguration device configuration\n+     * @param executorService     executor service\n+     */\n+    @Inject\n+    public MqttClient(DeviceConfiguration deviceConfiguration, ExecutorService executorService) {\n+        this(deviceConfiguration, null, executorService);\n+        this.builderProvider = (clientBootstrap) -> AwsIotMqttConnectionBuilder\n+                .newMtlsBuilderFromPath(Coerce.toString(deviceConfiguration.getCertificateFilePath()),\n+                        Coerce.toString(deviceConfiguration.getPrivateKeyFilePath()))\n+                .withCertificateAuthorityFromPath(null, Coerce.toString(deviceConfiguration.getRootCAFilePath()))\n+                .withEndpoint(Coerce.toString(deviceConfiguration.getIotDataEndpoint()))\n+                .withPort((short) Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PORT, MQTT_PORT_KEY)))\n+                .withCleanSession(false).withBootstrap(clientBootstrap).withKeepAliveMs(Coerce.toInt(\n+                        mqttTopics.findOrDefault(DEFAULT_MQTT_KEEP_ALIVE_TIMEOUT, MQTT_KEEP_ALIVE_TIMEOUT_KEY)))\n+                .withPingTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_PING_TIMEOUT, MQTT_PING_TIMEOUT_KEY)))\n+                .withSocketOptions(new SocketOptions()).withTimeoutMs(\n+                        Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_SOCKET_TIMEOUT, MQTT_SOCKET_TIMEOUT_KEY)));\n+    }\n+\n+    protected MqttClient(DeviceConfiguration deviceConfiguration,\n+                         Function<ClientBootstrap, AwsIotMqttConnectionBuilder> builderProvider,\n+                         ExecutorService executorService) {\n+        this.deviceConfiguration = deviceConfiguration;\n+\n+        // If anything in the device configuration changes, then we wil need to reconnect to the cloud\n+        // using the new settings. We do this by calling reconnect() on all of our connections\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                // List of configuration nodes that we need to reconfigure for if they change\n+                if (!(node.childOf(DEVICE_MQTT_NAMESPACE) || node.childOf(DEVICE_PARAM_THING_NAME) || node\n+                        .childOf(DEVICE_PARAM_IOT_DATA_ENDPOINT) || node.childOf(DEVICE_PARAM_PRIVATE_KEY_PATH) || node\n+                        .childOf(DEVICE_PARAM_CERTIFICATE_FILE_PATH) || node.childOf(DEVICE_PARAM_ROOT_CA_PATH))) {\n+                    return;\n+                }\n+                // Reconnect in separate thread to not block publish thread\n+                executorService.execute(() -> {\n+                    for (AwsIotMqttClient connection : connections) {\n+                        try {\n+                            connection.reconnect();\n+                        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                            logger.atError().setCause(e).kv(CLIENT_ID_KEY, connection.getClientId())\n+                                    .log(\"Error while reconnecting MQTT client\");\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        mqttTopics = this.deviceConfiguration.getMQTTNamespace();\n+        this.builderProvider = builderProvider;\n+\n+        eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n+        hostResolver = new HostResolver(eventLoopGroup);\n+        clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+    }\n+\n+    /**\n+     * Subscribe to a MQTT topic.\n+     *\n+     * @param request subscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while subscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public synchronized void subscribe(SubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        try {\n+            AwsIotMqttClient connection = null;\n+            // Use the write scope when identifying the subscriptionTopics that exist\n+            try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+                // TODO: Handle subscriptions with differing QoS (Upgrade 0->1->2)\n+\n+                // If none of our existing subscriptions include (through wildcards) the new topic, then\n+                // go ahead and subscribe to it\n+                Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> existingConnection =\n+                        findExistingSubscriberForTopic(request.getTopic());\n+                if (existingConnection.isPresent()) {\n+                    subscriptions.put(request, existingConnection.get().getValue());\n+                } else {\n+                    connection = getConnection(true);\n+                    subscriptions.put(request, connection);\n+                }\n+            }\n+\n+            try (LockScope scope = LockScope.lock(connectionLock.readLock())) {\n+                // Connection isn't null, so we should subscribe to the topic\n+                if (connection != null) {\n+                    connection.subscribe(request.getTopic(), request.getQos());\n+                    subscriptionTopics.put(new MqttTopic(request.getTopic()), connection);\n+                }\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+            // If subscribing failed, then clean up the failed subscription callback\n+            subscriptions.remove(request);\n+            throw e;\n+        }\n+    }\n+\n+    private Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> findExistingSubscriberForTopic(String topic) {\n+        return subscriptionTopics.entrySet().stream().filter(s -> s.getKey().isSupersetOf(new MqttTopic(topic)))\n+                .findAny();\n+    }\n+\n+    /**\n+     * Unsubscribe from a MQTT topic.\n+     *\n+     * @param request unsubscribe request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while unsubscribing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public synchronized void unsubscribe(UnsubscribeRequest request)\n+            throws ExecutionException, InterruptedException, TimeoutException {\n+        // Use the write lock because we're modifying the subscriptions and trying to consolidate them\n+        try (LockScope scope = LockScope.lock(connectionLock.writeLock())) {\n+            Set<Map.Entry<MqttTopic, AwsIotMqttClient>> deadSubscriptionTopics;\n+            for (Map.Entry<SubscribeRequest, AwsIotMqttClient> sub : subscriptions.entrySet()) {\n+                if (sub.getKey().getCallback() == request.getCallback() && sub.getKey().getTopic()\n+                        .equals(request.getTopic())) {\n+                    subscriptions.remove(sub.getKey());\n+                }\n+\n+            }\n+            // If we have no remaining subscriptions for a topic, then unsubscribe from it in the cloud\n+            deadSubscriptionTopics = subscriptionTopics.entrySet().stream().filter(s -> subscriptions.keySet().stream()\n+                    .noneMatch(sub -> s.getKey().isSupersetOf(new MqttTopic(sub.getTopic()))))\n+                    .collect(Collectors.toSet());\n+            if (!deadSubscriptionTopics.isEmpty()) {\n+                for (Map.Entry<MqttTopic, AwsIotMqttClient> sub : deadSubscriptionTopics) {\n+                    sub.getValue().unsubscribe(sub.getKey().getTopic());\n+                    subscriptionTopics.remove(sub.getKey());\n+\n+                    // Since we changed the cloud subscriptions, we need to recalculate the client to use for each\n+                    // subscription, since it may have changed\n+                    subscriptions.entrySet().stream()\n+                            // if the cloud clients are the same, and the removed topic covered the topic\n+                            // that we're looking at, then recalculate that topic's client\n+                            .filter(s -> s.getValue() == sub.getValue() && sub.getKey()\n+                                    .isSupersetOf(new MqttTopic(s.getKey().getTopic()))).forEach(e -> {\n+                        // recalculate and replace the client\n+                        Optional<Map.Entry<MqttTopic, AwsIotMqttClient>> subscriberForTopic =\n+                                findExistingSubscriberForTopic(e.getKey().getTopic());\n+                        if (subscriberForTopic.isPresent()) {\n+                            subscriptions.put(e.getKey(), subscriberForTopic.get().getValue());\n+                        }\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Publish to a MQTT topic.\n+     *\n+     * @param request publish request\n+     * @throws ExecutionException   if an error occurs\n+     * @throws InterruptedException if the thread is interrupted while publishing\n+     * @throws TimeoutException     if the request times out\n+     */\n+    public void publish(PublishRequest request) throws ExecutionException, InterruptedException, TimeoutException {\n+        getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n+                request.isRetain());\n+    }\n+\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    private synchronized AwsIotMqttClient getConnection(boolean forSubscription) {\n+        // If we have no connections, or our connections are over-subscribed, create a new connection\n+        if (connections.isEmpty() || forSubscription && connections.stream()\n+                .noneMatch(AwsIotMqttClient::canAddNewSubscription)) {\n+            AwsIotMqttClient conn = getNewMqttClient();\n+            connections.add(conn);\n+            return conn;\n+        } else {\n+            // Check for, and then close and remove any connection that has no subscriptions\n+            Set<AwsIotMqttClient> closableConnections =\n+                    connections.stream().filter((c) -> c.subscriptionCount() == 0).collect(Collectors.toSet());\n+            for (AwsIotMqttClient closableConnection : closableConnections) {\n+                // Leave the last connection alive to use for publishing\n+                if (connections.size() == 1) {\n+                    break;\n+                }\n+                closableConnection.close();\n+                connections.remove(closableConnection);\n+            }\n+        }\n+\n+        // If this connection is to add a new subscription, then don't provide a connection\n+        // which is already maxed out on subscriptions\n+        if (forSubscription) {\n+            return connections.stream().filter(AwsIotMqttClient::canAddNewSubscription).findAny().get();\n+        }\n+\n+        // Get a somewhat random, somewhat round robin connection\n+        return connections.get(connectionRoundRobin.getAndIncrement() % connections.size());\n+    }\n+\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+    Consumer<MqttMessage> getMessageHandlerForClient(AwsIotMqttClient client) {\n+        return (message) -> {\n+            logger.atTrace().kv(CLIENT_ID_KEY, client.getClientId()).kv(\"topic\", message.getTopic())\n+                    .log(\"Received MQTT message\");\n+\n+            // Each subscription is associated with a single AWSIotMqttClient even if this\n+            // on-device subscription did not cause the cloud connection to be made.\n+            // By checking that the client matches the client for the subscription, we will\n+            // prevent duplicate messages occurring due to overlapping subscriptions between\n+            // multiple clients such as A/B and A/#. Without this, an update to A/B would\n+            // trigger twice if those 2 subscriptions were in different clients because\n+            // both will receive the message from the cloud and call this handler.\n+            Set<SubscribeRequest> subs = subscriptions.entrySet().stream()\n+                    .filter(s -> s.getValue() == client && MqttTopic\n+                            .topicIsSupersetOf(s.getKey().getTopic(), message.getTopic())).map(Map.Entry::getKey)\n+                    .collect(Collectors.toSet());\n+            if (subs.isEmpty()) {\n+                logger.atError().kv(\"topic\", message.getTopic()).kv(CLIENT_ID_KEY, client.getClientId())\n+                        .log(\"Somehow got message from topic that no one subscribed to\");\n+                return;\n+            }\n+            subs.forEach((h) -> {\n+                try {\n+                    h.getCallback().accept(message);\n+                } catch (Throwable t) {\n+                    logger.atError().kv(\"message\", message).kv(CLIENT_ID_KEY, client.getClientId())\n+                            .log(\"Unhandled error in MQTT message callback\", t);\n+                }\n+            });\n+        };\n+    }\n+\n+    protected AwsIotMqttClient getNewMqttClient() {\n+        // Name client by thingName-<number> except for the first connection which will just be thingName\n+        String clientId = Coerce.toString(deviceConfiguration.getThingName()) + (connections.isEmpty() ? \"\"\n+                : \"-\" + connections.size() + 1);\n+        return new AwsIotMqttClient(() -> builderProvider.apply(clientBootstrap), this::getMessageHandlerForClient,\n+                clientId, mqttTopics);\n+    }\n+\n+    public boolean connected() {\n+        return !connections.isEmpty() && connections.stream().anyMatch(AwsIotMqttClient::connected);\n+    }\n+\n+    @Override\n+    public void close() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69"}, "originalPosition": 330}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43a319390b81d3d67382661c41b75e99feeb8c39", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/43a319390b81d3d67382661c41b75e99feeb8c39", "committedDate": "2020-06-17T17:21:14Z", "message": "Precompute client for each subscription topic"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3add4b37c76c904cae81efa70659f68ed7da9a69", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3add4b37c76c904cae81efa70659f68ed7da9a69", "committedDate": "2020-06-17T01:53:53Z", "message": "Precompute client for each subscription topic"}, "afterCommit": {"oid": "43a319390b81d3d67382661c41b75e99feeb8c39", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/43a319390b81d3d67382661c41b75e99feeb8c39", "committedDate": "2020-06-17T17:21:14Z", "message": "Precompute client for each subscription topic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff1afb701ce9e3e4ea9642cc33ad38bca481b441", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ff1afb701ce9e3e4ea9642cc33ad38bca481b441", "committedDate": "2020-06-17T17:34:04Z", "message": "Address PR Comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzE4NDk1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-432718495", "createdAt": "2020-06-17T19:41:51Z", "commit": {"oid": "ff1afb701ce9e3e4ea9642cc33ad38bca481b441"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19eb4e0596c7b44dc2570eb6c749e02e070684ea", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/19eb4e0596c7b44dc2570eb6c749e02e070684ea", "committedDate": "2020-06-17T21:38:24Z", "message": "Merge branch 'master' into mqtt"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODM2OTgx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/277#pullrequestreview-432836981", "createdAt": "2020-06-17T23:11:52Z", "commit": {"oid": "19eb4e0596c7b44dc2570eb6c749e02e070684ea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2804, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}