{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MzUxMTMz", "number": 553, "title": "in-meory-spooler with publish request", "bodyText": "Issue #, if available:\nAdd the spooler\nDescription of changes:\nAdd the In-Memory-Spool\nWhy is this change necessary:\nHow was this change tested:\nAny additional information or context required to review the change:\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-10-21T08:24:12Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553", "merged": true, "mergeCommit": {"oid": "859769a5bb8de74cddb010c9a3ed912550621647"}, "closed": true, "closedAt": "2020-11-02T00:05:44Z", "author": {"login": "awszztt"}, "timelineItems": {"totalCount": 63, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUvAW7gFqTUxMzc4MzYwMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdYZEakAFqTUyMTI3NzA1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzgzNjAy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-513783602", "createdAt": "2020-10-21T14:57:43Z", "commit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNDo1Nzo0NFrOHlw9FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNToyMDo1M1rOHlyGHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2MTQyOA==", "bodyText": "undo this change, it isn't helping anything", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509361428", "createdAt": "2020-10-21T14:57:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -122,11 +122,13 @@ public void onConnectionResumed(boolean sessionPresent) {\n     }\n \n     CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain) {\n-        return connect().thenCompose((b) -> {\n+        CompletableFuture<Integer> future = new CompletableFuture();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NTQwNw==", "bodyText": "either return a future which completes when we actually send the message, or else return an already completed future.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509365407", "createdAt": "2020-10-21T15:02:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NTkwMQ==", "bodyText": "return spool.add(request)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509365901", "createdAt": "2020-10-21T15:03:12Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NjExMw==", "bodyText": "remove this log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509366113", "createdAt": "2020-10-21T15:03:30Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NjQ2Mw==", "bodyText": "log the exception", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509366463", "createdAt": "2020-10-21T15:03:56Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while(onlineFlag && spool.messageCount() > 0) {\n+                            // TODO : add retry\n+                            PublishRequest request = spool.peek();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain());\n+                            spool.pop();\n+                        }\n+                    } catch (Throwable t) {\n+                        isSpoolingMessages.compareAndSet(true, false);\n+                        logger.atError().log(\"Caught exception while spooling the message\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NzgwNQ==", "bodyText": "you need to make sure that we only ever have 1 instance of this thread. Right now this isn't very safe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509367805", "createdAt": "2020-10-21T15:05:39Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n+\n+        ScheduledFuture<?> handler =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODM1Mw==", "bodyText": "this is going to queue all the messages for publishing all at once. You would need to wait for the publish to complete otherwise", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509368353", "createdAt": "2020-10-21T15:06:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while(onlineFlag && spool.messageCount() > 0) {\n+                            // TODO : add retry\n+                            PublishRequest request = spool.peek();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODY0Mw==", "bodyText": "synchronized", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509368643", "createdAt": "2020-10-21T15:06:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTA4Ng==", "bodyText": "make this an enum", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369086", "createdAt": "2020-10-21T15:07:17Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@AllArgsConstructor\n+public class SpoolerConfig {\n+    @Getter\n+    final String spoolStorageType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTIyMg==", "bodyText": "make this a long", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369222", "createdAt": "2020-10-21T15:07:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@AllArgsConstructor\n+public class SpoolerConfig {\n+    @Getter\n+    final String spoolStorageType;\n+    @Getter\n+    final int spoolMaxMessageQueueSizeInBytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTQ3OA==", "bodyText": "what is this ID used for?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369478", "createdAt": "2020-10-21T15:07:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import javax.validation.constraints.NotNull;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+public class SpoolMessage {\n+    @NotNull @Getter\n+    private final Long MessageID;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3MDU3OA==", "bodyText": "enum", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509370578", "createdAt": "2020-10-21T15:09:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n+    private AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;\n+\n+    // Memory storage type specification\n+    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n+    // FileSystem storage type specification\n+    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3MTE5Ng==", "bodyText": "we can get rid of the minimum", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509371196", "createdAt": "2020-10-21T15:09:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3MjM2Nw==", "bodyText": "Seems unused, remove it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509372367", "createdAt": "2020-10-21T15:11:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NDEwNg==", "bodyText": "this error message is not accurate for this exception. Don't log anything, just do Thread.currentThread().interrupt(), or, let this method throw InterruptedException", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509374106", "createdAt": "2020-10-21T15:13:24Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NDQ1OQ==", "bodyText": "why is this public?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509374459", "createdAt": "2020-10-21T15:13:52Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n+                        .kv(\"qos\", removedRequest.getQos())\n+                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n+            }\n+            if (qos == 0) {\n+                messageQueueOfQos0.putLast(message);\n+            } else {\n+                messageQueueOfQos1And2.putLast(message);\n+            }\n+            curMessageQueueSizeInBytes += messageSizeInBytes;\n+        } catch (InterruptedException e) {\n+            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())\n+                    .kv(\"qos\", request.getQos()).log(\"failed to add message into the InMemorySpooler\");\n+        }\n+        return truncated;\n+    }\n+\n+    public int messageCount() {\n+        return messageQueueOfQos0.size() + messageQueueOfQos1And2.size();\n+    }\n+\n+    @Override\n+    public int curSpoolerSizeInBytes() {\n+        return curMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public int maxSpoolerSizeInBytes() {\n+        return maxMessageQueueSizeInBytes;\n+    }\n+\n+    public PublishRequest removeOldestMessage() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NTI2Mw==", "bodyText": "let this method throw interruptedexception", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509375263", "createdAt": "2020-10-21T15:14:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n+                        .kv(\"qos\", removedRequest.getQos())\n+                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n+            }\n+            if (qos == 0) {\n+                messageQueueOfQos0.putLast(message);\n+            } else {\n+                messageQueueOfQos1And2.putLast(message);\n+            }\n+            curMessageQueueSizeInBytes += messageSizeInBytes;\n+        } catch (InterruptedException e) {\n+            logger.atError().kv(\"topic\", request.getTopic()).kv(\"payload\", request.getPayload())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NjQwMQ==", "bodyText": "curMessageQueueSizeInBytes must be an AtomicLong", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509376401", "createdAt": "2020-10-21T15:16:17Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())\n+                        .kv(\"qos\", removedRequest.getQos())\n+                        .log(\"Spooler Queue is Full. Will remove the oldest message\");\n+            }\n+            if (qos == 0) {\n+                messageQueueOfQos0.putLast(message);\n+            } else {\n+                messageQueueOfQos1And2.putLast(message);\n+            }\n+            curMessageQueueSizeInBytes += messageSizeInBytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NjU3OQ==", "bodyText": "do not log the payload", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509376579", "createdAt": "2020-10-21T15:16:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3Njk0OQ==", "bodyText": "I'm not sure about info, this may be more like debug, but I'd want to know what others think", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509376949", "createdAt": "2020-10-21T15:16:59Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {\n+                messageQueueOfQos1And2.takeFirst();\n+                return;\n+            }\n+            if (messageQueueOfQos1And2.isEmpty()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+\n+            if (messageQueueOfQos0.getFirst().getMessageID() < messageQueueOfQos1And2.getFirst().getMessageID()) {\n+                messageQueueOfQos0.takeFirst();\n+                return;\n+            }\n+            messageQueueOfQos1And2.takeFirst();\n+        } catch (InterruptedException e) {\n+            logger.atError().log(\"Failed to pop out message from the In-Memory Spooler\");\n+        }\n+    }\n+\n+    @Override\n+    public PublishRequest peek() {\n+        SpoolMessage spooledMessageFromQueueOfQos0 = null;\n+        SpoolMessage spooledMessageFromQueueOfQos1And2 = null;\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            spooledMessageFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            spooledMessageFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+\n+        if (spooledMessageFromQueueOfQos0 == null) {\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        if (spooledMessageFromQueueOfQos0 != null) {\n+            if (spooledMessageFromQueueOfQos0.getMessageID() < spooledMessageFromQueueOfQos1And2.getMessageID()) {\n+                return spooledMessageFromQueueOfQos0.getPublishRequest();\n+            }\n+            return spooledMessageFromQueueOfQos1And2.getPublishRequest();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean add(Long messageId, PublishRequest request) {\n+        SpoolMessage message = new SpoolMessage(messageId, request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+        boolean truncated = false;\n+        try {\n+            while(messageSizeInBytes + curMessageQueueSizeInBytes > maxSpoolerSizeInBytes()) {\n+                truncated = true;\n+                PublishRequest removedRequest = removeOldestMessage();\n+                logger.atInfo().kv(\"topic\", removedRequest.getTopic()).kv(\"payload\", removedRequest.getPayload())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MDEyNQ==", "bodyText": "this logic doesn't make much sense. You should be checking if the queue that you are taking from is empty or not. takeFirst is a blocking call, so it will wait forever, until it gets a value, which I don't think this is what you intend because you need to read from 2 queues, you cannot just block on one of them", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509380125", "createdAt": "2020-10-21T15:20:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private static final Logger logger = LogManager.getLogger(InMemorySpool.class);\n+\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<SpoolMessage> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+    private int curMessageQueueSizeInBytes = 0;\n+    private int maxMessageQueueSizeInBytes;\n+\n+    public InMemorySpool(int maxMessageQueueSizeInBytes) {\n+        this.maxMessageQueueSizeInBytes = maxMessageQueueSizeInBytes;\n+    }\n+\n+    @Override\n+    public void pop() {\n+        try {\n+            if (messageQueueOfQos0.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzg5Nzc3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-513789777", "createdAt": "2020-10-21T15:03:04Z", "commit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNTowMzowNFrOHlxOHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNToyOTo0MlrOHlyhRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NTc5MA==", "bodyText": "MessageID -> id", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509365790", "createdAt": "2020-10-21T15:03:04Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import javax.validation.constraints.NotNull;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+public class SpoolMessage {\n+    @NotNull @Getter\n+    private final Long MessageID;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NTk2MA==", "bodyText": "Use enum", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509365960", "createdAt": "2020-10-21T15:03:17Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@AllArgsConstructor\n+public class SpoolerConfig {\n+    @Getter\n+    final String spoolStorageType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NjcwOA==", "bodyText": "Move @Getter above the class definition.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509366708", "createdAt": "2020-10-21T15:04:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@AllArgsConstructor\n+public class SpoolerConfig {\n+    @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODM4OQ==", "bodyText": "Use enum", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509368389", "createdAt": "2020-10-21T15:06:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTMzOA==", "bodyText": "Remove commented code.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369338", "createdAt": "2020-10-21T15:07:35Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTY4Ng==", "bodyText": "Define them as Enum.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369686", "createdAt": "2020-10-21T15:08:01Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n+    private AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;\n+\n+    // Memory storage type specification\n+    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n+    // FileSystem storage type specification\n+    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2OTg2Mw==", "bodyText": "add final", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509369863", "createdAt": "2020-10-21T15:08:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n+    private AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM3NzkwMw==", "bodyText": "What's this messageQueue for?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509377903", "createdAt": "2020-10-21T15:18:06Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MDA1Mw==", "bodyText": "Curious why change this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509380053", "createdAt": "2020-10-21T15:20:48Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -122,11 +122,13 @@ public void onConnectionResumed(boolean sessionPresent) {\n     }\n \n     CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain) {\n-        return connect().thenCompose((b) -> {\n+        CompletableFuture<Integer> future = new CompletableFuture();\n+        future = connect().thenCompose((b) -> {\n             logger.atTrace().kv(TOPIC_KEY, message.getTopic()).kv(QOS_KEY, qos.name()).kv(\"retain\", retain)\n                     .log(\"Publishing message\");\n             return connection.publish(message, qos, retain);\n         });\n+        return future;\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MDg3NQ==", "bodyText": "Why is default false? Is this V1 behavior?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509380875", "createdAt": "2020-10-21T15:21:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -96,6 +101,9 @@\n     private final HostResolver hostResolver;\n     private final ClientBootstrap clientBootstrap;\n     private final CallbackEventManager callbackEventManager = new CallbackEventManager();\n+    private final Spool spool;\n+    private final ScheduledExecutorService ses;\n+    private AtomicBoolean isSpoolingMessages = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NjI5MA==", "bodyText": "Seems a very busy loop. Is this V1 behavior?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509386290", "createdAt": "2020-10-21T15:28:39Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        logger.atInfo().kv(\"MqttClient is online\", onlineFlag).log();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while(onlineFlag && spool.messageCount() > 0) {\n+                            // TODO : add retry\n+                            PublishRequest request = spool.peek();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain());\n+                            spool.pop();\n+                        }\n+                    } catch (Throwable t) {\n+                        isSpoolingMessages.compareAndSet(true, false);\n+                        logger.atError().log(\"Caught exception while spooling the message\");\n+                    }\n+                }, 0 , 5 , TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4NzA3OA==", "bodyText": "You also need to think about the cases when these configurations are dynamically updated during deployment? How would you update them?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r509387078", "createdAt": "2020-10-21T15:29:42Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+    private final BlockingDeque<Long> messageQueue = new LinkedBlockingDeque<>();\n+\n+    private CloudMessageSpool spooler;\n+    // should provide all the customer settings for the spooler\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final String DEFAULT_GG_SPOOL_STORAGE_TYPE = \"Memory\";\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int MIN_MESSAGE_QUEUE_SIZE_IN_BYTES = 256 * 1024;// 256KB\n+\n+    //private static String GG_SPOOL_STORAGE_TYPE;\n+    //private static int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+    //private static boolean GG_SPOOL_KEEP_Q0S_0_WHEN_OFFINE;\n+    private AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;\n+\n+    // Memory storage type specification\n+    private static String GG_IN_MEMORY_SPOOL = \"Memory\";\n+    // FileSystem storage type specification\n+    private static String GG_FILE_SYSTEM_SPOOL = \"FileSystem\";\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setupSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setupSpoolerConfig(Topics mqttTopics) {\n+        String GG_SPOOL_STORAGE_TYPE = Coerce.toString(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        int GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        if (GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES <  MIN_MESSAGE_QUEUE_SIZE_IN_BYTES) {\n+            GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 50}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/828a6f3681b98d96c8d41f6340511ab47e635f17", "committedDate": "2020-10-21T08:21:31Z", "message": "in-meory-spooler with publish request"}, "afterCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "committedDate": "2020-10-23T09:33:48Z", "message": "in-meory-spooler with publish request"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODU3ODQ5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-515857849", "createdAt": "2020-10-23T17:13:41Z", "commit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzoxMzo0MVrOHnWgWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzozNjozOFrOHnXOQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNTI0Mw==", "bodyText": "reformat.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511025243", "createdAt": "2020-10-23T17:13:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -121,7 +121,7 @@ public void onConnectionResumed(boolean sessionPresent) {\n \n     }\n \n-    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain) {\n+    CompletableFuture<Integer> publish(MqttMessage message, QualityOfService qos, boolean retain)      {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNjU3NA==", "bodyText": "the initial value of hasCalledback is false. So this can't possibly work.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511026574", "createdAt": "2020-10-23T17:16:15Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNzc1Ng==", "bodyText": "definitely log that we're dropping the request at debug", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511027756", "createdAt": "2020-10-23T17:18:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyOTAwMA==", "bodyText": "packetId", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511029000", "createdAt": "2020-10-23T17:20:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyOTEzOQ==", "bodyText": "probably should log the throwable if the publish failed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511029139", "createdAt": "2020-10-23T17:21:13Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyOTUxNg==", "bodyText": "you don't need this check. Just call remove", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511029516", "createdAt": "2020-10-23T17:21:56Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/InMemorySpool.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class InMemorySpool implements CloudMessageSpool {\n+\n+    private final Map<Long, SpoolMessage> messages = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return messages.get(messageId);\n+    }\n+\n+    @Override\n+    public void removeMessageById(Long messageId) {\n+        if (messages.get(messageId) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMDMxNA==", "bodyText": "you need to subscribe to these topics so that the spooler will reconfigure when it changes.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511030314", "createdAt": "2020-10-23T17:23:30Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMDc1Nw==", "bodyText": "don't trigger off of the packet id, check that the throwable is null or not", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511030757", "createdAt": "2020-10-23T17:24:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMTMxNA==", "bodyText": "catch InterruptedException separately and kill the thread if that happens. InterruptedException is telling you that someone wants the thread to stop.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511031314", "createdAt": "2020-10-23T17:25:25Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });\n+                        }\n+                    } catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMTQ3OQ==", "bodyText": "check !Thread.currentThread().isInterrupted()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511031479", "createdAt": "2020-10-23T17:25:46Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMzAyNw==", "bodyText": "you need to call get on the future, otherwise again, this is going to run through all the messages and publish them all at once which is not what we want.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511033027", "createdAt": "2020-10-23T17:28:49Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);\n+                                        } else {\n+                                            spool.addId(id);\n+                                        }\n+                                    });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMzQ1OQ==", "bodyText": "Spooler queue is full... lowercase", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511033459", "createdAt": "2020-10-23T17:29:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNDg2MA==", "bodyText": "I think this may need to be synchronized", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511034860", "createdAt": "2020-10-23T17:32:24Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNTMyNA==", "bodyText": "do these before inserting into the queue, otherwise another thread which is running this same method will have the wrong information.\nReserve the space, then use the space.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511035324", "createdAt": "2020-10-23T17:33:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNTgzNw==", "bodyText": "since this is always an array of size 2, I'm not sure that a List is appropriate. Just return a long[]", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511035837", "createdAt": "2020-10-23T17:34:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n+        return id;\n+    }\n+\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n+    }\n+\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNjY2Mw==", "bodyText": "this seems very similar to L135 can this duplication be reduced?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511036663", "createdAt": "2020-10-23T17:35:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();\n+\n+        return id;\n+    }\n+\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n+    }\n+\n+    private List<Long> getHeadOfAllTheQueues() {\n+        Long messageIdFromQueueOfQos0 = null;\n+        Long messageIdFromQueueOfQos1And2 = null;\n+\n+        if (!messageQueueOfQos0.isEmpty()) {\n+            messageIdFromQueueOfQos0 = messageQueueOfQos0.getFirst();\n+        }\n+        if (!messageQueueOfQos1And2.isEmpty()) {\n+            messageIdFromQueueOfQos1And2 = messageQueueOfQos1And2.getFirst();\n+        }\n+        return Arrays.asList(messageIdFromQueueOfQos0, messageIdFromQueueOfQos1And2);\n+    }\n+\n+    private Long peekId() {\n+        if (messageCount() == 0) {\n+            return null;\n+        }\n+        Long smallestMessageId = null;\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                smallestMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                smallestMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            smallestMessageId = messageIdFromQueueOfQos1And2;\n+        }\n+        return smallestMessageId;\n+    }\n+\n+    public SpoolMessage getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        SpoolMessage toBeRemovedMessage = getMessageById(messageId);\n+        if (toBeRemovedMessage != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedMessage.getPublishRequest().getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     * \n+     * @return message id\n+     */\n+    public Long popId() {\n+        // if both of the queues are empty, do nothing\n+        if (curMessageCount.get() == 0) {\n+            return null;\n+        }\n+\n+        List<Long> headsOfQueues = getHeadOfAllTheQueues();\n+        Long messageIdFromQueueOfQos0 = headsOfQueues.get(0);\n+        Long messageIdFromQueueOfQos1And2 = headsOfQueues.get(1);\n+        Long removedMessageId = null;\n+\n+        if (messageIdFromQueueOfQos0 != null && messageIdFromQueueOfQos1And2 != null) {\n+            if (messageIdFromQueueOfQos0 < messageIdFromQueueOfQos1And2) {\n+                removedMessageId = messageIdFromQueueOfQos0;\n+            } else {\n+                removedMessageId = messageIdFromQueueOfQos1And2;\n+            }\n+        } else if (messageIdFromQueueOfQos0 != null) {\n+            removedMessageId = messageIdFromQueueOfQos0;\n+        } else if (messageIdFromQueueOfQos1And2 != null) {\n+            removedMessageId = messageIdFromQueueOfQos1And2;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNjkwNA==", "bodyText": "Memory or MEMORY and FileSystem or FILE_SYSTEM", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511036904", "createdAt": "2020-10-23T17:36:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerStorageType.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+public enum SpoolerStorageType {\n+    memory, filesystem", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNjk5Mw==", "bodyText": "private", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511036993", "createdAt": "2020-10-23T17:36:38Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.validation.constraints.NotNull;\n+\n+@Getter\n+@Builder\n+public class SpoolMessage {\n+    @NotNull\n+    public  PublishRequest publishRequest;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "025d047eb2f3cdb8427fc04bd83e080dd918b324", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/025d047eb2f3cdb8427fc04bd83e080dd918b324", "committedDate": "2020-10-26T20:08:57Z", "message": "in-meory-spooler with publish request"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDMwMTAz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-516030103", "createdAt": "2020-10-23T21:51:32Z", "commit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1MTozMlrOHnfaYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTo0MDoxNVrOHojcfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTE2OQ==", "bodyText": "Nit: I think I'd prefer to complete this exceptionally instead of using 0 as a sentinel value. We also need to handle the scenario where the spool is full", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r511171169", "createdAt": "2020-10-23T21:51:32Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNzc1Ng=="}, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2Nzc5Mw==", "bodyText": "What does it mean for the customer to set KeepQos0WhenOffline=false? Do QoS 0 messages get purged from the spool when the MQTT connection drops? Or does it only prevent messages from being spooled when the device is disconnected? As a customer, I would think it's the former.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512267793", "createdAt": "2020-10-26T21:05:36Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3MTY2OQ==", "bodyText": "int isn't big enough - max size is ~2GB. Make this a long", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512271669", "createdAt": "2020-10-26T21:12:42Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NzcxOQ==", "bodyText": "What are these for?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512277719", "createdAt": "2020-10-26T21:24:30Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.validation.constraints.NotNull;\n+\n+@Getter\n+@Builder\n+public class SpoolMessage {\n+    @NotNull\n+    public  PublishRequest publishRequest;\n+    @Builder.Default\n+    public AtomicBoolean inService = new AtomicBoolean(false);\n+    @Builder.Default\n+    public AtomicInteger retried = new AtomicInteger(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTI0NQ==", "bodyText": "This isn't the behavior we want. If a Qos1 message is spooled, we need to keep it. We can drop qos0 messages to make room. If we can't make room, then we need to return an error to the client.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512281245", "createdAt": "2020-10-26T21:31:33Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMzQ1OQ=="}, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NTcxMw==", "bodyText": "One of the benefits of using a LinkedBlockingDeque is that it blocks :) But you're trying to use it in a non-blocking manner. Think through what interface you want this spool to have, and then choose an appropriate structure.\nIn my initial skeleton, I used this because I wanted the spool.pop() method to block. The thread waiting for messages would run when connected, and stop when disconnected. Here, you're using a scheduled executor service instead, and are polling. With this model you don't want to block. A simple linked list would work better.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512285713", "createdAt": "2020-10-26T21:40:03Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4NTgyMw==", "bodyText": "+1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512285823", "createdAt": "2020-10-26T21:40:15Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+    private static final String GG_SPOOL_MAX_RETRIED_LEY = \"maxRetried\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+    private static final int DEFAULT_GG_SPOOL_MAX_RETRIED = 3;\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final AtomicLong curMessageCount = new AtomicLong(0);\n+\n+    private final BlockingDeque<Long> messageQueueOfQos0 = new LinkedBlockingDeque<>();\n+    private final BlockingDeque<Long> messageQueueOfQos1And2 = new LinkedBlockingDeque<>();\n+\n+    private AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+    public Spool(Topics mqttTopics) {\n+        config = setSpoolerConfig(mqttTopics);\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics mqttTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffine = Coerce.toBoolean(mqttTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFINE, GG_SPOOL_KEPP_QOS_0_WHEN_OFFLINE_KEY));\n+        int ggSpoolMaxRetried = Coerce.toInt(mqttTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_RETRIED, GG_SPOOL_MAX_RETRIED_LEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes,\n+                ggSpoolKeepQos0WhenOffine, ggSpoolMaxRetried);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        int qos = getMessageById(id).getPublishRequest().getQos().getValue();\n+        if (qos == 0) {\n+            messageQueueOfQos0.addFirst(id);\n+        } else {\n+            messageQueueOfQos1And2.addFirst(id);\n+        }\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public Long addMessage(PublishRequest request) throws InterruptedException {\n+        Long id = nextId.getAndIncrement();\n+\n+        SpoolMessage message = new SpoolMessage(request);\n+        int qos = request.getQos().getValue();\n+        int messageSizeInBytes = request.getPayload().length;\n+\n+        while (messageSizeInBytes + curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            Long toBeRemovedID = popId();\n+            removeMessageById(toBeRemovedID);\n+            logger.atInfo().log(\"Spooler Queue is Full. Will remove the oldest unsent message\");\n+        }\n+        if (qos == 0) {\n+            messageQueueOfQos0.putLast(id);\n+        } else {\n+            messageQueueOfQos1And2.putLast(id);\n+        }\n+        spooler.add(id, message);\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        curMessageCount.getAndIncrement();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzNTMyNA=="}, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjAyNjU3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-517202657", "createdAt": "2020-10-26T21:50:59Z", "commit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTo1MDo1OVrOHojv7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTo1MDo1OVrOHojv7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5MDc5OA==", "bodyText": "We also need to complete the future that we returned to the client.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512290798", "createdAt": "2020-10-26T21:50:59Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }\n+\n+                            PublishRequest request = messageToBePublished.getPublishRequest();\n+                            getConnection(false)\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain())\n+                                    .whenComplete((packageId, throwable) -> {\n+                                        if (packageId != null) {\n+                                            spool.removeMessageById(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjAzMjg5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-517203289", "createdAt": "2020-10-26T21:52:04Z", "commit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTo1MjowNVrOHojyGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTo1MjowNVrOHojyGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI5MTM1NA==", "bodyText": "We can't drop messages like this. It breaks the Qos1 contract.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r512291354", "createdAt": "2020-10-26T21:52:05Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,59 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        if (willDropTheRequest) {\n+            return CompletableFuture.completedFuture(0);\n+        }\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException e) {\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        while (onlineFlag && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            SpoolMessage messageToBePublished = spool.getMessageById(id);\n+                            boolean exceedMaxRetried = messageToBePublished.getRetried().getAndIncrement()\n+                                    > spool.getSpoolConfig().maxRetried;\n+                            if (exceedMaxRetried) {\n+                                spool.removeMessageById(id);\n+                                continue;\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "committedDate": "2020-10-27T00:05:50Z", "message": "address the comment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/48671c264f5bb5d8bc72b503f46be4d78cb8d1f6", "committedDate": "2020-10-23T09:33:48Z", "message": "in-meory-spooler with publish request"}, "afterCommit": {"oid": "dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc20d113afc0babfd3cb56fd8c3d2c76577ff994", "committedDate": "2020-10-27T00:05:50Z", "message": "address the comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17f864a2299168d4efb75503a2bd4cf0a5a6eea6", "committedDate": "2020-10-27T09:07:22Z", "message": "leave one messageID queue in the spool class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91b42a722d2f3b0f7aea70fa04cb4faadf8a3ac8", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/91b42a722d2f3b0f7aea70fa04cb4faadf8a3ac8", "committedDate": "2020-10-27T22:41:46Z", "message": "in-meory-spooler with publish request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b46b0cd895ee7b189bef4516cc8e1fc34293495", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7b46b0cd895ee7b189bef4516cc8e1fc34293495", "committedDate": "2020-10-27T22:41:46Z", "message": "address the comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88d6f790b2b32af186b1c759b462343b6ec18bf4", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/88d6f790b2b32af186b1c759b462343b6ec18bf4", "committedDate": "2020-10-27T22:41:47Z", "message": "leave one messageID queue in the spool class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62db89f0b7559ceb357cef7824975fcdf75c52c8", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/62db89f0b7559ceb357cef7824975fcdf75c52c8", "committedDate": "2020-10-27T22:43:35Z", "message": "code clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MTgwOTY3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-518180967", "createdAt": "2020-10-27T21:55:33Z", "commit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMTo1NTozNFrOHpSe4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzowNDo1MVrOHpUJXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NjQ4Mg==", "bodyText": "TODO: Clean up this file", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513056482", "createdAt": "2020-10-27T21:55:34Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/config/Topics.java", "diffHunk": "@@ -380,27 +380,33 @@ public void replaceAndWait(Map<String, Object> newValue) {\n     }\n \n     protected void childChanged(WhatHappened what, Node child) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ==", "bodyText": "Why pass this into the constructor? false is the only value that logically makes sense - it can't possibly be connected until the connect() method is called", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513060231", "createdAt": "2020-10-27T22:03:35Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -88,12 +91,14 @@ public void onConnectionResumed(boolean sessionPresent) {\n     AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n                      Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n                      String clientId, Topics mqttTopics,\n-                     CallbackEventManager callbackEventManager) {\n+                     CallbackEventManager callbackEventManager,\n+                     AtomicBoolean mqttOnline) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2NDA2Mg==", "bodyText": "You're right.\nOn second look, this should actually just be private though. The public interface is publish().", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513064062", "createdAt": "2020-10-27T22:12:35Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -334,8 +346,44 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean onlineFlag = callbackEventManager.hasCallbacked();\n+        boolean willDropTheRequest = !onlineFlag && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+        if (!willDropTheRequest) {\n+            Long messageId = addPublishRequestToSpool(request);\n+            if (isSpoolingMessages.compareAndSet(false, true)){\n+                spoolMessage();\n+            }\n+        }\n+        // TODO-ztong: check whether we need to return a defined future\n+        return new CompletableFuture<Integer>();\n+    }\n+\n+    private Long addPublishRequestToSpool(PublishRequest request) {\n+        Long messageId = spool.add(request);\n+        return messageId;\n+    }\n+\n+    public void spoolMessage() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2ODY0Mw=="}, "originalCommit": {"oid": "828a6f3681b98d96c8d41f6340511ab47e635f17"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2ODMyOQ==", "bodyText": "We need to talk to kernel team to see if there are use cases for knowing when the message is published. We might be able to get away with completing this future now, but not long term.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513068329", "createdAt": "2020-10-27T22:22:57Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +354,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2OTAxMQ==", "bodyText": "I assume you're doing this for testing. I think I'd prefer to mock out the AwsIotMqttClient rather than doing this", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513069011", "createdAt": "2020-10-27T22:24:28Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -436,4 +532,8 @@ public void addToCallbackEvents(MqttClientConnectionEvents callbacks) {\n     public int getTimeout() {\n         return Coerce.toInt(mqttTopics.findOrDefault(DEFAULT_MQTT_OPERATION_TIMEOUT, MQTT_OPERATION_TIMEOUT_KEY));\n     }\n+\n+    protected void setMqttOnline(boolean networkStatus) {\n+        mqttOnline.set(networkStatus);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2OTQzMQ==", "bodyText": "Why is getSpoolerStorageType needed?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513069431", "createdAt": "2020-10-27T22:25:22Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/CloudMessageSpool.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+\n+public interface CloudMessageSpool {\n+\n+    PublishRequest getMessageById(Long id);\n+\n+    void removeMessageById(Long id);\n+\n+    void add(Long id, PublishRequest request);\n+\n+    SpoolerStorageType getSpoolerStorageType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MzA1Mg==", "bodyText": "You already have a method to get the config. Why do you need this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513083052", "createdAt": "2020-10-27T23:02:48Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics spoolerTopics = this.deviceConfiguration.getSpoolerNamespace();\n+        config = setSpoolerConfig(spoolerTopics);\n+        spooler = setupSpooler(config);\n+\n+        // subscribe the changes on the configuration of Spooler\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                if (!(node.childOf(DEVICE_SPOOLER_NAMESPACE))) {\n+                    return;\n+                }\n+\n+                logger.atDebug().log(\"the spooler has been re-configured\");\n+                // re-set the spoolerConfig\n+                setSpoolerConfig(this.deviceConfiguration.getSpoolerNamespace());\n+                // TODO: does this needed? remove the oldest message if the spooler queue should be truncated\n+                if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes() ) {\n+                    removeOldestMessage();\n+                    logger.atDebug().log(\"spooler queue is full and will remove the oldest unsent message\");\n+                }\n+\n+                // TODO: implement the storage type converter after the file-system Spooler is done\n+                if (spooler.getSpoolerStorageType() != getSpoolConfig().getSpoolStorageType()) {\n+                    spoolerStorageTypeConverter();\n+                }\n+            }\n+        });\n+    }\n+\n+    // For unit test\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(this.config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics spoolerTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, spoolerTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(spoolerTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(spoolerTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes, ggSpoolKeepQos0WhenOffline);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) throws InterruptedException {\n+        queueOfMessageId.putFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        Long id = nextId.getAndIncrement();\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > maxSpoolerSizeInBytes()) {\n+            throw new SpoolerLoadException(\"the size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        // TODO: do we need to add the removed message back if exception is thrown??\n+        if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    public void addMessageToSpooler(Long id, PublishRequest request) {\n+        spooler.add(id, request);\n+    }\n+\n+    public Long maxSpoolerSizeInBytes() {\n+        return config.getSpoolMaxMessageQueueSizeInBytes();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4Mzc0MA==", "bodyText": "private", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513083740", "createdAt": "2020-10-27T23:04:51Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics spoolerTopics = this.deviceConfiguration.getSpoolerNamespace();\n+        config = setSpoolerConfig(spoolerTopics);\n+        spooler = setupSpooler(config);\n+\n+        // subscribe the changes on the configuration of Spooler\n+        this.deviceConfiguration.onAnyChange((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                if (!(node.childOf(DEVICE_SPOOLER_NAMESPACE))) {\n+                    return;\n+                }\n+\n+                logger.atDebug().log(\"the spooler has been re-configured\");\n+                // re-set the spoolerConfig\n+                setSpoolerConfig(this.deviceConfiguration.getSpoolerNamespace());\n+                // TODO: does this needed? remove the oldest message if the spooler queue should be truncated\n+                if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes() ) {\n+                    removeOldestMessage();\n+                    logger.atDebug().log(\"spooler queue is full and will remove the oldest unsent message\");\n+                }\n+\n+                // TODO: implement the storage type converter after the file-system Spooler is done\n+                if (spooler.getSpoolerStorageType() != getSpoolConfig().getSpoolStorageType()) {\n+                    spoolerStorageTypeConverter();\n+                }\n+            }\n+        });\n+    }\n+\n+    // For unit test\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(this.config);\n+    }\n+\n+    private SpoolerConfig setSpoolerConfig(Topics spoolerTopics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, spoolerTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(spoolerTopics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(spoolerTopics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        return new SpoolerConfig(ggSpoolStorageType, ggSpoolMaxMessageQueueSizeInBytes, ggSpoolKeepQos0WhenOffline);\n+    }\n+\n+    private CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) throws InterruptedException {\n+        queueOfMessageId.putFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        Long id = nextId.getAndIncrement();\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > maxSpoolerSizeInBytes()) {\n+            throw new SpoolerLoadException(\"the size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        // TODO: do we need to add the removed message back if exception is thrown??\n+        if (curMessageQueueSizeInBytes.get() > maxSpoolerSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    public void addMessageToSpooler(Long id, PublishRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjEyNzM0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-518212734", "createdAt": "2020-10-27T23:00:23Z", "commit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzowMDoyM1rOHpUDUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMzowODozOVrOHpUOUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjE5Mw==", "bodyText": "remove this. We already catch and log errors in the publish queue", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513082193", "createdAt": "2020-10-27T23:00:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/config/Topics.java", "diffHunk": "@@ -380,27 +380,33 @@ public void replaceAndWait(Map<String, Object> newValue) {\n     }\n \n     protected void childChanged(WhatHappened what, Node child) {\n-        for (Watcher s : watchers) {\n-            if (s instanceof ChildChanged) {\n-                ((ChildChanged) s).childChanged(what, child);\n+        try {\n+            for (Watcher s : watchers) {\n+                if (s instanceof ChildChanged) {\n+                    ((ChildChanged) s).childChanged(what, child);\n+                }\n+                // TODO: detect if a subscriber fails. Possibly unsubscribe it if the fault is persistent\n             }\n-            // TODO: detect if a subscriber fails. Possibly unsubscribe it if the fault is persistent\n-        }\n \n-        if (what.equals(WhatHappened.removed)) {\n-            children.forEach((k, v) -> v.fire(WhatHappened.removed));\n-            return;\n-        }\n+            if (what.equals(WhatHappened.removed)) {\n+                children.forEach((k, v) -> v.fire(WhatHappened.removed));\n+                return;\n+            }\n \n-        if (child.modtime > this.modtime || children.isEmpty()) {\n-            this.modtime = child.modtime;\n-        } else {\n-            Optional<Node> n = children.values().stream().max(Comparator.comparingLong(node -> node.modtime));\n-            this.modtime = n.orElse(child).modtime;\n-        }\n-        if (parentNeedsToKnow()) {\n-            parent.childChanged(what, child);\n+            if (child.modtime > this.modtime || children.isEmpty()) {\n+                this.modtime = child.modtime;\n+            } else {\n+                Optional<Node> n = children.values().stream().max(Comparator.comparingLong(node -> node.modtime));\n+                this.modtime = n.orElse(child).modtime;\n+            }\n+            if (parentNeedsToKnow()) {\n+                parent.childChanged(what, child);\n+            }\n+        } catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjM0Ng==", "bodyText": "should this be under the MQTT namespace? I'd think so.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513082346", "createdAt": "2020-10-27T23:00:46Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/DeviceConfiguration.java", "diffHunk": "@@ -262,6 +263,10 @@ public Topics getMQTTNamespace() {\n         return getTopics(DEVICE_MQTT_NAMESPACE);\n     }\n \n+    public Topics getSpoolerNamespace() {\n+        return getTopics(DEVICE_SPOOLER_NAMESPACE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjU5NA==", "bodyText": "compare and set is pointless, just set it to true.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513082594", "createdAt": "2020-10-27T23:01:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -70,6 +72,7 @@ public void onConnectionInterrupted(int errorCode) {\n         @Override\n         public void onConnectionResumed(boolean sessionPresent) {\n             currentlyConnected.set(true);\n+            mqttOnline.compareAndSet(false, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjYzNg==", "bodyText": "same as below", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513082636", "createdAt": "2020-10-27T23:01:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -50,12 +50,14 @@\n     private MqttClientConnection connection;\n     private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n     private final CallbackEventManager callbackEventManager;\n+    private final AtomicBoolean mqttOnline;\n \n     @Getter(AccessLevel.PACKAGE)\n     private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n             currentlyConnected.set(false);\n+            mqttOnline.compareAndSet(true, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MzU0NA==", "bodyText": "No, do not shutdown the executor. You should quit the thread, but don't kill the executor", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513083544", "createdAt": "2020-10-27T23:04:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +354,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+\n+        // TODO : to determine whether to use ScheduledExecutor\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        if (!mqttOnline.get() && spool.getSpoolConfig().isKeepQos0WhenOffline()) {\n+                            spool.popOutMessagesWithQosZero();\n+                        }\n+\n+                        while (!Thread.currentThread().isInterrupted() && mqttOnline.get()\n+                                && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            PublishRequest request = spool.getMessageById(id);\n+                            if (request == null) {\n+                                continue;\n+                            }\n+\n+                            AwsIotMqttClient awsIotMqttClient = getConnection(false);\n+                            CompletableFuture future = awsIotMqttClient\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain());\n+\n+                                    future.whenComplete((packetId, throwable) -> {\n+                                        if (throwable != null) {\n+                                            logger.atError().log(\"failed to publish the message \"\n+                                                    + \"via Mqtt Client\", throwable);\n+                                            try {\n+                                                spool.addId(id);\n+                                            } catch (InterruptedException e) {\n+                                                // TODO: if failed, do we need to drop the message from the spooler too?\n+                                                logger.atError().log(\"failed to add the \" +\n+                                                        \"unpublished message back to spooler\");\n+                                            }\n+                                        } else {\n+                                            spool.removeMessageById(id);\n+                                        }\n+                                    });\n+                            // Right now, there is only one message sending out at the momentum.\n+                            future.get();\n+                        }\n+                    } catch (InterruptedException e) {\n+                        ses.shutdownNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MzYzNQ==", "bodyText": "Might need a timeout? @jbutler ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513083635", "createdAt": "2020-10-27T23:04:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +354,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service may try to drain the spooler queue every 5 seconds.\n+     */\n+    public void spoolMessage() {\n+\n+        // TODO : to determine whether to use ScheduledExecutor\n+        ScheduledFuture<?> handler =\n+                ses.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        if (!mqttOnline.get() && spool.getSpoolConfig().isKeepQos0WhenOffline()) {\n+                            spool.popOutMessagesWithQosZero();\n+                        }\n+\n+                        while (!Thread.currentThread().isInterrupted() && mqttOnline.get()\n+                                && spool.messageCount() > 0) {\n+                            Long id = spool.popId();\n+                            PublishRequest request = spool.getMessageById(id);\n+                            if (request == null) {\n+                                continue;\n+                            }\n+\n+                            AwsIotMqttClient awsIotMqttClient = getConnection(false);\n+                            CompletableFuture future = awsIotMqttClient\n+                                    .publish(new MqttMessage(request.getTopic(),\n+                                            request.getPayload()), request.getQos(), request.isRetain());\n+\n+                                    future.whenComplete((packetId, throwable) -> {\n+                                        if (throwable != null) {\n+                                            logger.atError().log(\"failed to publish the message \"\n+                                                    + \"via Mqtt Client\", throwable);\n+                                            try {\n+                                                spool.addId(id);\n+                                            } catch (InterruptedException e) {\n+                                                // TODO: if failed, do we need to drop the message from the spooler too?\n+                                                logger.atError().log(\"failed to add the \" +\n+                                                        \"unpublished message back to spooler\");\n+                                            }\n+                                        } else {\n+                                            spool.removeMessageById(id);\n+                                        }\n+                                    });\n+                            // Right now, there is only one message sending out at the momentum.\n+                            future.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDA4Mg==", "bodyText": "you don't need to do this, you can just subscribe to the DEVICE_SPOOLER_NAMESPACE changes", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084082", "createdAt": "2020-10-27T23:05:50Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_CERTIFICATE_FILE_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_IOT_DATA_ENDPOINT;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_PRIVATE_KEY_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_ROOT_CA_PATH;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_SPOOLER_NAMESPACE;\n+\n+\n+public class Spool {\n+\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private CloudMessageSpool spooler;\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics spoolerTopics = this.deviceConfiguration.getSpoolerNamespace();\n+        config = setSpoolerConfig(spoolerTopics);\n+        spooler = setupSpooler(config);\n+\n+        // subscribe the changes on the configuration of Spooler\n+        this.deviceConfiguration.onAnyChange((what, node) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDMyNw==", "bodyText": "formatting.\nThese should not be public.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084327", "createdAt": "2020-10-27T23:06:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolMessage.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+@Builder\n+@Value\n+@Getter\n+public class SpoolMessage {\n+    @NonNull\n+    public   PublishRequest publishRequest;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDQ0NA==", "bodyText": "why is this public? Use a setter if it needs to be changed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084444", "createdAt": "2020-10-27T23:06:50Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@Getter\n+public class SpoolerConfig {\n+    private SpoolerStorageType spoolStorageType;\n+    private Long spoolMaxMessageQueueSizeInBytes;\n+    public boolean keepQos0WhenOffline;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDY5NQ==", "bodyText": "this needs mockito and GG extensions", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084695", "createdAt": "2020-10-27T23:07:39Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerConfig;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.mqttclient.spool.SpoolerStorageType;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InMemorySpoolTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDc4MQ==", "bodyText": "instead of new Long. Just use 25L", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084781", "createdAt": "2020-10-27T23:07:54Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerConfig;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.mqttclient.spool.SpoolerStorageType;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    private SpoolerConfig config;\n+    private BlockingDeque<Long> messageQueueOfQos0;\n+    private BlockingDeque<Long> messageQueueOfQos1And2;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config = SpoolerConfig.builder().keepQos0WhenOffline(true)\n+                .spoolMaxMessageQueueSizeInBytes(new Long(25)).spoolStorageType(SpoolerStorageType.Memory)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDg1NA==", "bodyText": "do not use new Long", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513084854", "createdAt": "2020-10-27T23:08:08Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerConfig;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.mqttclient.spool.SpoolerStorageType;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    private SpoolerConfig config;\n+    private BlockingDeque<Long> messageQueueOfQos0;\n+    private BlockingDeque<Long> messageQueueOfQos1And2;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config = SpoolerConfig.builder().keepQos0WhenOffline(true)\n+                .spoolMaxMessageQueueSizeInBytes(new Long(25)).spoolStorageType(SpoolerStorageType.Memory)\n+                .build();\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_not_full_WHEN_add_message_THEN_add_message_without_message_dropped() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool = spy(new Spool(deviceConfiguration, config));\n+        doNothing().when(spool).addMessageToSpooler(any(), any());\n+        Long id = spool.addMessage(request);\n+\n+        verify(spool, never()).removeMessageById(any());\n+        verify(spool, times(1)).addMessageToSpooler(any(), any());\n+        assertEquals(1, spool.messageCount());\n+        assertEquals(new Long(0), id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NTAwOQ==", "bodyText": "fix this", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513085009", "createdAt": "2020-10-27T23:08:39Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/mqttclient/MqttClientTest.java", "diffHunk": "@@ -306,27 +328,193 @@ void GIVEN_incoming_messages_to_2clients_WHEN_received_THEN_subscribers_are_call\n         abc.getLeft().get(0, TimeUnit.SECONDS);\n     }\n \n-    @Test\n-    void GIVEN_incoming_message_WHEN_received_and_subscriber_throws_THEN_still_calls_remaining_subscriptions(\n-            ExtensionContext context) throws ExecutionException, InterruptedException, TimeoutException {\n-        ignoreExceptionWithMessage(context, \"Uncaught!\");\n-        MqttClient client = spy(new MqttClient(deviceConfiguration, (c) -> builder, executorService));\n-        AwsIotMqttClient mockIndividual = mock(AwsIotMqttClient.class);\n-        when(mockIndividual.subscribe(any(), any())).thenReturn(CompletableFuture.completedFuture(0));\n-        when(client.getNewMqttClient()).thenReturn(mockIndividual);\n-        assertFalse(client.connected());\n-\n-        client.subscribe(SubscribeRequest.builder().topic(\"A/B/+\").callback((m) -> {\n-            throw new RuntimeException(\"Uncaught!\");\n-        }).build());\n-        Pair<CompletableFuture<Void>, Consumer<MqttMessage>> abc = asyncAssertOnConsumer((m) -> {\n-            assertEquals(\"A/B/C\", m.getTopic());\n-        });\n-        client.subscribe(SubscribeRequest.builder().topic(\"A/B/C\").callback(abc.getRight()).build());\n-\n-        Consumer<MqttMessage> handler = client.getMessageHandlerForClient(mockIndividual);\n-\n-        handler.accept(new MqttMessage(\"A/B/C\", new byte[0]));\n-        abc.getLeft().get(0, TimeUnit.SECONDS);\n-    }\n+    //@Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 173}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f2c20db7ccf08d42a35d401965c6f825b438750", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2f2c20db7ccf08d42a35d401965c6f825b438750", "committedDate": "2020-10-28T10:42:20Z", "message": "clean up code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89a7b6086e026a399db84f1b738260a31852b54c", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/89a7b6086e026a399db84f1b738260a31852b54c", "committedDate": "2020-10-28T11:23:05Z", "message": "Merge branch 'spooler' of ssh://github.com/aws/aws-greengrass-kernel into spooler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17b82438e1d0a00dcabe8359d98a76b56f62e25f", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17b82438e1d0a00dcabe8359d98a76b56f62e25f", "committedDate": "2020-10-28T20:19:22Z", "message": "Merge branch 'backup' into spooler2"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89a7b6086e026a399db84f1b738260a31852b54c", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/89a7b6086e026a399db84f1b738260a31852b54c", "committedDate": "2020-10-28T11:23:05Z", "message": "Merge branch 'spooler' of ssh://github.com/aws/aws-greengrass-kernel into spooler"}, "afterCommit": {"oid": "8112725802fb408ea23ba92949f6e75899294ced", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8112725802fb408ea23ba92949f6e75899294ced", "committedDate": "2020-10-28T20:05:25Z", "message": "leave one messageID queue in the spool class"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8112725802fb408ea23ba92949f6e75899294ced", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8112725802fb408ea23ba92949f6e75899294ced", "committedDate": "2020-10-28T20:05:25Z", "message": "leave one messageID queue in the spool class"}, "afterCommit": {"oid": "17b82438e1d0a00dcabe8359d98a76b56f62e25f", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17b82438e1d0a00dcabe8359d98a76b56f62e25f", "committedDate": "2020-10-28T20:19:22Z", "message": "Merge branch 'backup' into spooler2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfa05d652136d29eb1785cc0fac5db3f87edb3db", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bfa05d652136d29eb1785cc0fac5db3f87edb3db", "committedDate": "2020-10-28T20:48:17Z", "message": "fix format"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MDg4MjU5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-519088259", "createdAt": "2020-10-28T21:12:55Z", "commit": {"oid": "17b82438e1d0a00dcabe8359d98a76b56f62e25f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMToxMjo1NVrOHp9q5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMToxMjo1NVrOHp9q5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc2NDA3MA==", "bodyText": "IDE issue, the format has been corrected in the next commit.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513764070", "createdAt": "2020-10-28T21:12:55Z", "author": {"login": "awszztt"}, "path": "src/main/java/com/aws/greengrass/config/Topics.java", "diffHunk": "@@ -113,7 +113,7 @@ private Topic createLeafChild(CaseInsensitiveString name) {\n      * @return the node\n      */\n     public Topics createInteriorChild(String name) {\n-       return createInteriorChild(new CaseInsensitiveString(name));\n+        return createInteriorChild(new CaseInsensitiveString(name));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17b82438e1d0a00dcabe8359d98a76b56f62e25f"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/df4ae162cacf78cac930ef95bfdfe4fdfd941479", "committedDate": "2020-10-28T21:24:35Z", "message": "remove unnecessary change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MDk5MDE4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-519099018", "createdAt": "2020-10-28T21:29:37Z", "commit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMToyOTozN1rOHp-M7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMTo1NTowNVrOHp--iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3Mjc4MQ==", "bodyText": "remove this from here, just register a public callback in MqttClient class for setting this flag. Same with L75.\nThis way you only set it to online in this class when the connect call completes, everything else can happen outside of this class", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513772781", "createdAt": "2020-10-28T21:29:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -50,12 +50,14 @@\n     private MqttClientConnection connection;\n     private final AtomicBoolean currentlyConnected = new AtomicBoolean();\n     private final CallbackEventManager callbackEventManager;\n+    private final AtomicBoolean mqttOnline;\n \n     @Getter(AccessLevel.PACKAGE)\n     private final MqttClientConnectionEvents connectionEventCallback = new MqttClientConnectionEvents() {\n         @Override\n         public void onConnectionInterrupted(int errorCode) {\n             currentlyConnected.set(false);\n+            mqttOnline.set(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NDQ2MQ==", "bodyText": "don't call this until someone first calls publish. Store the future for the task and check if it is null or not", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513774461", "createdAt": "2020-10-28T21:32:56Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -212,6 +222,25 @@ protected MqttClient(DeviceConfiguration deviceConfiguration,\n         eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n         hostResolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+        spool = initSpooler(deviceConfiguration);\n+        spoolMessage();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NDcwMQ==", "bodyText": "capital W", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513774701", "createdAt": "2020-10-28T21:33:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +357,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NDk2Ng==", "bodyText": "do not use toString. Log the full exception", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513774966", "createdAt": "2020-10-28T21:34:02Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +357,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NTgwMg==", "bodyText": "do not call tostring", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513775802", "createdAt": "2020-10-28T21:35:39Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +357,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e.toString());\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service try to drain the spooler queue every 5 seconds.\n+     *\n+     */\n+    private synchronized void spoolMessage() {\n+        ses.scheduleWithFixedDelay(() -> {\n+            spoolTask();\n+        }, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Iterate the spooler queue to publish all the spooled message.\n+     */\n+    protected void spoolTask() {\n+        Long id = null;\n+        try {\n+            // This should be moved to the callback event.\n+            if (!mqttOnline.get()) {\n+                boolean keepQosZeroWhenOffline = spool.getSpoolConfig().isKeepQos0WhenOffline();\n+                if (!keepQosZeroWhenOffline) {\n+                    spool.popOutMessagesWithQosZero();\n+                    return;\n+                }\n+            }\n+\n+            while (!Thread.currentThread().isInterrupted() && mqttOnline.get() && spool.getCurrentMessageCount() > 0) {\n+                id = spool.popId();\n+                PublishRequest request = spool.getMessageById(id);\n+                if (request == null) {\n+                    continue;\n+                }\n+\n+                Long finalId = id;\n+\n+                getConnection(false).publish(new MqttMessage(request.getTopic(),request.getPayload()),\n+                        request.getQos(), request.isRetain()).whenComplete((packetId, throwable) -> {\n+                    if (throwable == null) {\n+                        spool.removeMessageById(finalId);\n+                    } else {\n+                        logger.atError().log(\"failed to publish the message via Mqtt Client\", throwable.toString());\n+                        spool.addId(finalId);\n+                    }\n+                }).get();\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            logger.atError().log(\"spooler message is interrupted\");\n+        } catch (ExecutionException e) {\n+            logger.atError().log(\"failed to spool method\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NjIxNA==", "bodyText": "What does it mean to spool a method? That log doesn't make sense. Try \"Error when publishing from spooler\" or something.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513776214", "createdAt": "2020-10-28T21:36:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +357,78 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            logger.atError().log(e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"fail to add publish request to spooler queue\", e.toString());\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service try to drain the spooler queue every 5 seconds.\n+     *\n+     */\n+    private synchronized void spoolMessage() {\n+        ses.scheduleWithFixedDelay(() -> {\n+            spoolTask();\n+        }, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Iterate the spooler queue to publish all the spooled message.\n+     */\n+    protected void spoolTask() {\n+        Long id = null;\n+        try {\n+            // This should be moved to the callback event.\n+            if (!mqttOnline.get()) {\n+                boolean keepQosZeroWhenOffline = spool.getSpoolConfig().isKeepQos0WhenOffline();\n+                if (!keepQosZeroWhenOffline) {\n+                    spool.popOutMessagesWithQosZero();\n+                    return;\n+                }\n+            }\n+\n+            while (!Thread.currentThread().isInterrupted() && mqttOnline.get() && spool.getCurrentMessageCount() > 0) {\n+                id = spool.popId();\n+                PublishRequest request = spool.getMessageById(id);\n+                if (request == null) {\n+                    continue;\n+                }\n+\n+                Long finalId = id;\n+\n+                getConnection(false).publish(new MqttMessage(request.getTopic(),request.getPayload()),\n+                        request.getQos(), request.isRetain()).whenComplete((packetId, throwable) -> {\n+                    if (throwable == null) {\n+                        spool.removeMessageById(finalId);\n+                    } else {\n+                        logger.atError().log(\"failed to publish the message via Mqtt Client\", throwable.toString());\n+                        spool.addId(finalId);\n+                    }\n+                }).get();\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            logger.atError().log(\"spooler message is interrupted\");\n+        } catch (ExecutionException e) {\n+            logger.atError().log(\"failed to spool method\", e.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NTgwMg=="}, "originalCommit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3ODExNg==", "bodyText": "you can keep the method you had to get the spooler namespace, I think that makes lots of sense.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513778116", "createdAt": "2020-10-28T21:40:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+\n+public class Spool {\n+\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getMQTTNamespace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3ODU1NQ==", "bodyText": "don't check for childof mqtt, that's a guarantee since that's what you subscribed to.\nCheck that it is a childof spooler. Or just remove it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513778555", "createdAt": "2020-10-28T21:41:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static com.aws.greengrass.deployment.DeviceConfiguration.DEVICE_MQTT_NAMESPACE;\n+\n+public class Spool {\n+\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getMQTTNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to a topic\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null && node.childOf(DEVICE_MQTT_NAMESPACE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df4ae162cacf78cac930ef95bfdfe4fdfd941479"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NTQ4MA==", "bodyText": "You need the mockito extension otherwise @Mock won't work", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r513785480", "createdAt": "2020-10-28T21:55:05Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerConfig;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.mqttclient.spool.SpoolerStorageType;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+\n+import java.util.concurrent.LinkedBlockingDeque;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class InMemorySpoolTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NDY5NQ=="}, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8e6c424367207c59de9e1cec81e43cf699ef24f8", "committedDate": "2020-10-29T08:04:37Z", "message": "address the comment - 2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5ODc1NjY2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-519875666", "createdAt": "2020-10-29T16:52:02Z", "commit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjo1MjowMlrOHqlVJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzoxOTowMVrOHqmfHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQxMzg2Mg==", "bodyText": "why does this need a getter?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514413862", "createdAt": "2020-10-29T16:52:02Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -87,25 +94,44 @@\n     private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n     private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n     private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+    private final AtomicBoolean mqttOnline = new AtomicBoolean(false);\n \n     private final EventLoopGroup eventLoopGroup;\n     private final HostResolver hostResolver;\n     private final ClientBootstrap clientBootstrap;\n     private final CallbackEventManager callbackEventManager = new CallbackEventManager();\n+    private final Spool spool;\n+    private final ScheduledExecutorService ses;\n+    private final CompletableFuture<String> spoolerMonitor = CompletableFuture.completedFuture(READY_TO_SPOOL);\n+\n+\n+    @Getter(AccessLevel.PACKAGE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyOTU1NQ==", "bodyText": "inside of spoolMessage here you should have\nif (spoolingFuture.get() == null || spoolingFuture.get().isCancelled()) {\n    spoolingFuture.set(ses.schedule....)\n}\n\nWhere spoolingFuture is an AtomicReference<Future<?>>\nThis way you should just call spoolMessage for every single call to publish which will make sure that the spooler is active when needed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514429555", "createdAt": "2020-10-29T17:14:30Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +375,85 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n+                CompletableFuture.supplyAsync(() -> {\n+                    spoolMessage();\n+                    return READY_TO_SPOOL;\n+                });\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMDMwMQ==", "bodyText": "this seems like something that the spooler should be doing, is it possible to move this into the spooler class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514430301", "createdAt": "2020-10-29T17:15:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +375,85 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n+                CompletableFuture.supplyAsync(() -> {\n+                    spoolMessage();\n+                    return READY_TO_SPOOL;\n+                });\n+            }\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service try to drain the spooler queue every 5 seconds.\n+     *\n+     */\n+    private synchronized void spoolMessage() {\n+        ses.scheduleWithFixedDelay(() -> {\n+            spoolTask();\n+        }, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Iterate the spooler queue to publish all the spooled message.\n+     */\n+    protected void spoolTask() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMDU3NQ==", "bodyText": "long not Long", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514430575", "createdAt": "2020-10-29T17:15:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +375,85 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+            if (spoolerMonitor.getNow(\"spooling\").equals(READY_TO_SPOOL)) {\n+                CompletableFuture.supplyAsync(() -> {\n+                    spoolMessage();\n+                    return READY_TO_SPOOL;\n+                });\n+            }\n+        } catch (InterruptedException | SpoolerLoadException e) {\n+            logger.atError().log(\"Fail to add publish request to spooler queue\", e);\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+        return CompletableFuture.completedFuture(0);\n+    }\n+\n+    /**\n+     * The scheduled executor service try to drain the spooler queue every 5 seconds.\n+     *\n+     */\n+    private synchronized void spoolMessage() {\n+        ses.scheduleWithFixedDelay(() -> {\n+            spoolTask();\n+        }, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Iterate the spooler queue to publish all the spooled message.\n+     */\n+    protected void spoolTask() {\n+        Long id = null;\n+        try {\n+            // This should be moved to the callback event.\n+            if (!mqttOnline.get()) {\n+                boolean keepQosZeroWhenOffline = spool.getSpoolConfig().isKeepQos0WhenOffline();\n+                if (!keepQosZeroWhenOffline) {\n+                    spool.popOutMessagesWithQosZero();\n+                    return;\n+                }\n+            }\n+\n+            while (!Thread.currentThread().isInterrupted() && mqttOnline.get() && spool.getCurrentMessageCount() > 0) {\n+                id = spool.popId();\n+                PublishRequest request = spool.getMessageById(id);\n+\n+                if (request == null) {\n+                    continue;\n+                }\n+\n+                Long finalId = id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyNA==", "bodyText": "set the config? setup spooler using config?\nIf you don't want to do it in this pr, which is fine, add a todo", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514431824", "createdAt": "2020-10-29T17:17:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMjEyNg==", "bodyText": "long not Long", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514432126", "createdAt": "2020-10-29T17:17:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            throw new SpoolerLoadException(\"The size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"Spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        Long id = nextId.getAndIncrement();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMjI1NQ==", "bodyText": "long", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514432255", "createdAt": "2020-10-29T17:18:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            throw new SpoolerLoadException(\"The size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"Spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        Long id = nextId.getAndIncrement();\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    private void addMessageToSpooler(Long id, PublishRequest request) {\n+        spooler.add(id, request);\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     *\n+     * @return message id\n+     * @throws InterruptedException the thread is interrupted while popping the first id from the queue\n+     */\n+    public Long popId() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMjc5Nw==", "bodyText": "use the primitive type long for everything instead of the object type Long. This will be more efficient as Java won't have to keep boxing and unboxing. See: https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514432797", "createdAt": "2020-10-29T17:19:01Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            throw new SpoolerLoadException(\"The size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"Spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        Long id = nextId.getAndIncrement();\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    private void addMessageToSpooler(Long id, PublishRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5ODg4OTE5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-519888919", "createdAt": "2020-10-29T17:05:44Z", "commit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzowNTo0NVrOHql63w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODo0MDowNFrOHqppsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyMzUxOQ==", "bodyText": "+1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514423519", "createdAt": "2020-10-29T17:05:45Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/deployment/DeviceConfiguration.java", "diffHunk": "@@ -262,6 +263,10 @@ public Topics getMQTTNamespace() {\n         return getTopics(DEVICE_MQTT_NAMESPACE);\n     }\n \n+    public Topics getSpoolerNamespace() {\n+        return getTopics(DEVICE_SPOOLER_NAMESPACE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4MjM0Ng=="}, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyNjU1NQ==", "bodyText": "This isn't being used anywhere. You set it to true but the value is never read.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514426555", "createdAt": "2020-10-29T17:10:15Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -88,12 +91,14 @@ public void onConnectionResumed(boolean sessionPresent) {\n     AwsIotMqttClient(Provider<AwsIotMqttConnectionBuilder> builderProvider,\n                      Function<AwsIotMqttClient, Consumer<MqttMessage>> messageHandler,\n                      String clientId, Topics mqttTopics,\n-                     CallbackEventManager callbackEventManager) {\n+                     CallbackEventManager callbackEventManager,\n+                     AtomicBoolean mqttOnline) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2MDIzMQ=="}, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyODEzNQ==", "bodyText": "Nit: inline this, you're not using it anywhere other than the constructor", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514428135", "createdAt": "2020-10-29T17:12:30Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -212,6 +240,25 @@ protected MqttClient(DeviceConfiguration deviceConfiguration,\n         eventLoopGroup = new EventLoopGroup(Coerce.toInt(mqttTopics.findOrDefault(1, MQTT_THREAD_POOL_SIZE_KEY)));\n         hostResolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, hostResolver);\n+        spool = initSpooler(deviceConfiguration);\n+        addToCallbackEvents(callbacks);\n+    }\n+\n+    private Spool initSpooler(DeviceConfiguration deviceConfiguration) {\n+        return new Spool(deviceConfiguration);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NTYwOA==", "bodyText": "Let's trim it down until we need it. Can always add it later", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514455608", "createdAt": "2020-10-29T17:53:23Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/CloudMessageSpool.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+\n+public interface CloudMessageSpool {\n+\n+    PublishRequest getMessageById(Long id);\n+\n+    void removeMessageById(Long id);\n+\n+    void add(Long id, PublishRequest request);\n+\n+    SpoolerStorageType getSpoolerStorageType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2OTQzMQ=="}, "originalCommit": {"oid": "17f864a2299168d4efb75503a2bd4cf0a5a6eea6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MjA3Ng==", "bodyText": "I'm still not a fan of adding public constructors like this for testing purposes, but we can revisit later if there's a better way", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514482076", "createdAt": "2020-10-29T18:35:31Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MjI5Ng==", "bodyText": "private", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514482296", "createdAt": "2020-10-29T18:35:52Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MjkzMQ==", "bodyText": "We're using thread safe data structures so that we don't need to synchronize this.\nCan you add a TODO?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514482931", "createdAt": "2020-10-29T18:36:56Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4Mzk3Nw==", "bodyText": "This loop is going to be very expensive since it requires reading the message itself and not just the metadata. I think we can push this for now, but will need to revisit it. Please add a TODO", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514483977", "createdAt": "2020-10-29T18:38:53Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private final SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        this.config = readSpoolerConfigFromDeviceConfig(topics);\n+        spooler = setupSpooler(config);\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                readSpoolerConfigFromDeviceConfig(topics);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Here is the constructor for the test.\n+     * @param deviceConfiguration      device configuration\n+     * @param config                   spooler configuration\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration, SpoolerConfig config) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.config = config;\n+        spooler = setupSpooler(config);\n+    }\n+\n+    private SpoolerConfig readSpoolerConfigFromDeviceConfig(Topics topics) {\n+        SpoolerStorageType ggSpoolStorageType = Coerce.toEnum(SpoolerStorageType.class, topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_STORAGE_TYPE, GG_SPOOL_STORAGE_TYPE_KEY));\n+        Long ggSpoolMaxMessageQueueSizeInBytes = Coerce.toLong(topics\n+                .findOrDefault(DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES,\n+                        GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY));\n+        boolean ggSpoolKeepQos0WhenOffline = Coerce.toBoolean(topics\n+                .findOrDefault(DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE, GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY));\n+\n+        logger.atInfo().kv(GG_SPOOL_STORAGE_TYPE_KEY, ggSpoolStorageType)\n+                .kv(GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY, ggSpoolMaxMessageQueueSizeInBytes)\n+                .kv(GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY, ggSpoolKeepQos0WhenOffline)\n+                .log(\"Spooler has been configured\");\n+\n+        return SpoolerConfig.builder().spoolStorageType(ggSpoolStorageType)\n+                .spoolMaxMessageQueueSizeInBytes(ggSpoolMaxMessageQueueSizeInBytes)\n+                .keepQos0WhenOffline(ggSpoolKeepQos0WhenOffline).build();\n+    }\n+\n+    /**\n+     * create a spooler instance.\n+     * @param config                spooler configuration\n+     * @return CloudMessageSpool    spooler instance\n+     */\n+    public CloudMessageSpool setupSpooler(SpoolerConfig config) {\n+        if (config.getSpoolStorageType() == SpoolerStorageType.Memory) {\n+            return new InMemorySpool();\n+        }\n+        return null;\n+        //return new PersistentSpool();\n+    }\n+\n+    /**\n+     * Add the MessageId to the front of the queue of Id based on the Qos.\n+     *\n+     * @param id MessageId\n+     */\n+    public void addId(Long id) {\n+        queueOfMessageId.offerFirst(id);\n+    }\n+\n+    /**\n+     * Add the message to both of the Queue of Id and the spooler.\n+     * Drop the oldest message if the current queue size is greater than the settings.\n+     *\n+     * @param request publish request\n+     * @throws InterruptedException result from the queue implementation\n+     * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n+     */\n+    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {\n+        int messageSizeInBytes = request.getPayload().length;\n+        if (messageSizeInBytes > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            throw new SpoolerLoadException(\"The size of message has exceeds the maximum size of spooler.\");\n+        }\n+\n+        curMessageQueueSizeInBytes.getAndAdd(messageSizeInBytes);\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            removeOldestMessage();\n+        }\n+\n+        if (curMessageQueueSizeInBytes.get() > getSpoolConfig().getSpoolMaxMessageQueueSizeInBytes()) {\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSizeInBytes);\n+            throw new SpoolerLoadException(\"Spooler queue is full and new message would not be added into spooler\");\n+        }\n+\n+        Long id = nextId.getAndIncrement();\n+        addMessageToSpooler(id, request);\n+        queueOfMessageId.putLast(id);\n+\n+        return id;\n+    }\n+\n+    private void addMessageToSpooler(Long id, PublishRequest request) {\n+        spooler.add(id, request);\n+    }\n+\n+    /**\n+     * Pop out the id of the oldest message.\n+     *\n+     * @return message id\n+     * @throws InterruptedException the thread is interrupted while popping the first id from the queue\n+     */\n+    public Long popId() throws InterruptedException {\n+        return queueOfMessageId.takeFirst();\n+    }\n+\n+    public PublishRequest getMessageById(Long messageId) {\n+        return spooler.getMessageById(messageId);\n+    }\n+\n+    /**\n+     * Remove the Message from the spooler based on the MessageId.\n+     *\n+     * @param messageId  message id\n+     */\n+    public void removeMessageById(Long messageId) {\n+        PublishRequest toBeRemovedRequest = getMessageById(messageId);\n+        if (toBeRemovedRequest != null) {\n+            spooler.removeMessageById(messageId);\n+            int messageSize = toBeRemovedRequest.getPayload().length;\n+            curMessageQueueSizeInBytes.getAndAdd(-1 * messageSize);\n+        }\n+    }\n+\n+    public void removeOldestMessage() {\n+        removeMessagesWithQosZero(true);\n+    }\n+\n+    public void popOutMessagesWithQosZero() {\n+        removeMessagesWithQosZero(false);\n+    }\n+\n+    private void removeMessagesWithQosZero(boolean needToCheckCurSpoolerSize) {\n+        Iterator<Long> messageIdIterator = queueOfMessageId.iterator();\n+        while (messageIdIterator.hasNext() && addJudgementWithCurrentSpoolerSize(needToCheckCurSpoolerSize)) {\n+            Long idToBeRemoved = messageIdIterator.next();\n+            if (getMessageById(idToBeRemoved).getQos().getValue() == 0) {\n+                removeMessageById(idToBeRemoved);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4NDY1Ng==", "bodyText": "Nit: shorten these\nstorageType;\nspoolSizeInBytes;\nkeepQos0WhenOffline;", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514484656", "createdAt": "2020-10-29T18:40:04Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/SpoolerConfig.java", "diffHunk": "@@ -0,0 +1,17 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Builder\n+@Getter\n+public class SpoolerConfig {\n+    private SpoolerStorageType spoolStorageType;\n+    private Long spoolMaxMessageQueueSizeInBytes;\n+    private boolean keepQos0WhenOffline;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e6c424367207c59de9e1cec81e43cf699ef24f8"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d36252bdf7c36e6996321e108e71039d53b8be3b", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d36252bdf7c36e6996321e108e71039d53b8be3b", "committedDate": "2020-10-29T19:57:27Z", "message": "address comment comment -3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7718ec6dcfefe47051d97127c10a8becc3d7e53", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a7718ec6dcfefe47051d97127c10a8becc3d7e53", "committedDate": "2020-10-29T20:13:52Z", "message": "fix some format"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMDU1NjEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520055613", "createdAt": "2020-10-29T20:29:23Z", "commit": {"oid": "a7718ec6dcfefe47051d97127c10a8becc3d7e53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDoyOToyNFrOHqtcXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDoyOToyNFrOHqtcXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU0Njc4Mw==", "bodyText": "this won't be spooling, will it? It is online.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514546783", "createdAt": "2020-10-29T20:29:24Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttTest.java", "diffHunk": "@@ -64,7 +64,7 @@ void GIVEN_mqttclient_WHEN_subscribe_and_publish_THEN_receives_all_messages()\n         for (int i = 0; i < NUM_MESSAGES; i++) {\n             client.publish(PublishRequest.builder().topic(\"A/B/C\").payload(\"What's up\".getBytes(StandardCharsets.UTF_8))\n                     .build()).get(5, TimeUnit.SECONDS);\n-            logger.atInfo().kv(\"total\", i + 1).log(\"Published 1 message to cloud.\");\n+            logger.atInfo().kv(\"total\", i + 1).log(\"Added 1 message to spooler.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7718ec6dcfefe47051d97127c10a8becc3d7e53"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMDU3NTI2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520057526", "createdAt": "2020-10-29T20:32:05Z", "commit": {"oid": "a7718ec6dcfefe47051d97127c10a8becc3d7e53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDozMjowNVrOHqtijA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDozMjowNVrOHqtijA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU0ODM2NA==", "bodyText": "this need to be synchronized, use a separate synchronized method", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514548364", "createdAt": "2020-10-29T20:32:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -328,8 +369,66 @@ public synchronized void unsubscribe(UnsubscribeRequest request)\n      * @param request publish request\n      */\n     public CompletableFuture<Integer> publish(PublishRequest request) {\n-        return getConnection(false).publish(new MqttMessage(request.getTopic(), request.getPayload()), request.getQos(),\n-                request.isRetain());\n+\n+        boolean willDropTheRequest = !mqttOnline.get() && request.getQos().getValue() == 0\n+                && !spool.getSpoolConfig().isKeepQos0WhenOffline();\n+\n+        CompletableFuture<Integer> future = new CompletableFuture<>();\n+        if (willDropTheRequest) {\n+            SpoolerLoadException e = new SpoolerLoadException(\"Will not store the publish request\"\n+                    + \" with Qos 0 when MqttClient is offline\");\n+            future.completeExceptionally(e);\n+            return future;\n+        }\n+\n+        try {\n+            spool.addMessage(request);\n+            if (spoolingFuture.get() == null || spoolingFuture.get().isCancelled()) {\n+                spoolingFuture.set(ses.scheduleWithFixedDelay(() -> {\n+                    spoolTask();\n+                }, 0, 5, TimeUnit.SECONDS));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7718ec6dcfefe47051d97127c10a8becc3d7e53"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMDU4Njcw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520058670", "createdAt": "2020-10-29T20:33:47Z", "commit": {"oid": "a7718ec6dcfefe47051d97127c10a8becc3d7e53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDozNDoxOVrOHqtnBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDozNDoxOVrOHqtnBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU0OTUwOQ==", "bodyText": "Doesn't seem very useful", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514549509", "createdAt": "2020-10-29T20:34:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient.spool;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.util.Coerce;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Spool {\n+    private static final Logger logger = LogManager.getLogger(Spool.class);\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final CloudMessageSpool spooler;\n+\n+    private static final String GG_SPOOL_STORAGE_TYPE_KEY = \"spoolStorageType\";\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+    private static final String GG_SPOOL_KEEP_QOS_0_WHEN_OFFLINE_KEY = \"keepQos0WhenOffline\";\n+\n+    private static final boolean DEFAULT_KEEP_Q0S_0_WHEN_OFFLINE = false;\n+    private static final SpoolerStorageType DEFAULT_GG_SPOOL_STORAGE_TYPE\n+            = SpoolerStorageType.Memory;\n+    private static final int DEFAULT_GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES = (int)(2.5 * 1024 * 1024); // 2.5MB\n+\n+    private final AtomicLong nextId = new AtomicLong(0);\n+    private SpoolerConfig config;\n+    private final BlockingDeque<Long> queueOfMessageId = new LinkedBlockingDeque<>();\n+    private final AtomicLong curMessageQueueSizeInBytes = new AtomicLong(0);\n+\n+\n+    /**\n+     * The constructor of Spool.\n+     * @param deviceConfiguration the device configuration\n+     * @throws InterruptedException if aaa else bbb\n+     *\n+     */\n+    public Spool(DeviceConfiguration deviceConfiguration) {\n+        this.deviceConfiguration = deviceConfiguration;\n+        Topics topics = this.deviceConfiguration.getSpoolerNamespace();\n+        config = readSpoolerConfigFromDeviceConfig(topics);\n+        setSpoolerConfig(config);\n+        spooler = setupSpooler();\n+        // To subscribe to the topics of spooler configuration\n+        topics.subscribe((what, node) -> {\n+            if (WhatHappened.childChanged.equals(what) && node != null) {\n+                SpoolerConfig updatedConfig = readSpoolerConfigFromDeviceConfig(topics);\n+                setSpoolerConfig(updatedConfig);\n+            }\n+        });\n+    }\n+\n+    private void setSpoolerConfig(SpoolerConfig config) {\n+        this.config = config;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7718ec6dcfefe47051d97127c10a8becc3d7e53"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMDY3ODYw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520067860", "createdAt": "2020-10-29T20:46:45Z", "commit": {"oid": "d36252bdf7c36e6996321e108e71039d53b8be3b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDo0Njo0NlrOHquBWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDo0Njo0NlrOHquBWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU1NjI0OA==", "bodyText": "Sorry, I didn't mean to remove synchronized. As written, you need it. But we can follow up and remove it later", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514556248", "createdAt": "2020-10-29T20:46:46Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/spool/Spool.java", "diffHunk": "@@ -117,30 +111,31 @@ public void addId(Long id) {\n      * @throws InterruptedException result from the queue implementation\n      * @throws SpoolerLoadException  leads to the failure to insert the message to the spooler\n      */\n-    public synchronized Long addMessage(PublishRequest request) throws InterruptedException, SpoolerLoadException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36252bdf7c36e6996321e108e71039d53b8be3b"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e2decd2903a5088971c3c95fbe8b497e08479e6", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2e2decd2903a5088971c3c95fbe8b497e08479e6", "committedDate": "2020-10-30T00:48:21Z", "message": "Address the comments 4"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f5f6e711689b510357a4c74e8efd438ed79060f", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8f5f6e711689b510357a4c74e8efd438ed79060f", "committedDate": "2020-10-30T01:01:08Z", "message": "Ensure that EventLoopGroup is always closed if some exception occurs (#577)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b8497c9f0960674daffb2163f35f2e918c59543", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b8497c9f0960674daffb2163f35f2e918c59543", "committedDate": "2020-10-30T01:01:08Z", "message": "Suspend service lifecycle when config is being merged during deployment (#567)\n\n* Suspend service lifecycle when config is being merged.\r\n\r\nConfiguration is updated asynchronously on each node, this will cause services to start with old config.\r\nPostponse installing/starting when config is being updated in deployment,\r\nso that service won't be started with partially updated config.\r\n\r\n* Address comments\r\n\r\nCo-authored-by: Xueli Zheng <shirlez@amazon.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d3b01866ea4dc6cb6a4bb0ca066ef30b94d31a9", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d3b01866ea4dc6cb6a4bb0ca066ef30b94d31a9", "committedDate": "2020-10-30T01:01:08Z", "message": "handle config update when default value is specified in the using Parameters: (#578)\n\n* handle config update when default value is specified in the Parameters section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3024685c51fb75059db0e16672c45f2ca5f2d25d", "author": {"user": {"login": "rbattle", "name": "Robert Battle"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3024685c51fb75059db0e16672c45f2ca5f2d25d", "committedDate": "2020-10-30T01:01:08Z", "message": "Set the owner of artifacts for a service when commands are first run. (#555)\n\n* Set the owner of artifacts for a service when commands are first run.\r\n\r\nRefactored generation of the user/group to run a service with.\r\n\r\nArtifacts are set to the user/group running the service.\r\nThe run as user is set for a component in the deployment. If none is\r\nprovided, the default user/group is used. If no default is set, and\r\nthe kernel user is not root, the kernel user is used.\r\n\r\nArtifacts that are not \"run\" are left unchanged - they are owned by\r\nthe kernel user.\r\n\r\nSet artifact and artifact dir permissions\r\n\r\nPermissions will be set to world readable for artifacts - this is temporary until the component model change is consumed\r\n\r\nThe artifacts directories need to be globally readable and executable so any user can enter the directories - otherwise sharing artifacts does not work\r\n\r\nOwnership of artifacts directories is set to the nucleus user. Ownership of artifact files is set to the user running the component (or default user)\r\n\r\nFixes so tests run as non-root user\r\n\r\nAdd default user and group to easy setup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5457032bc05847d7456e49fe96effc89b29eb6f9", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5457032bc05847d7456e49fe96effc89b29eb6f9", "committedDate": "2020-10-30T01:01:08Z", "message": "Proper config interpolation using timestamps (#580)\n\n* Proper config interpolation using timestamps\r\n\r\n* Revert \"handle config update when default value is specified in the using Parameters: (#578)\"\r\n\r\nThis reverts commit 19958f5b58c11bbb668114aacccea8656d062ddd.\r\n\r\n* Add test case for resolving with different timestamps\r\n\r\n* Simplify RESET behavior"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "435f9e2ce60097bd6e27a59d7fb1f043a08af90c", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/435f9e2ce60097bd6e27a59d7fb1f043a08af90c", "committedDate": "2020-10-30T01:01:08Z", "message": "Updating IPC library for server, client and model (#583)\n\n* Updating IPC library for server, client and model\r\n\r\n* Replacing InvalidArgumentError with InvalidArgumentsError\r\n\r\nCo-authored-by: fahadmohammed01 <52720275+fahadmohammed01@users.noreply.github.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61d22c3207c8db24297118a88396810474849f96", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/61d22c3207c8db24297118a88396810474849f96", "committedDate": "2020-10-30T00:58:32Z", "message": "Updating IPC library for server, client and model (#583)\n\n* Updating IPC library for server, client and model\r\n\r\n* Replacing InvalidArgumentError with InvalidArgumentsError\r\n\r\nCo-authored-by: fahadmohammed01 <52720275+fahadmohammed01@users.noreply.github.com>"}, "afterCommit": {"oid": "435f9e2ce60097bd6e27a59d7fb1f043a08af90c", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/435f9e2ce60097bd6e27a59d7fb1f043a08af90c", "committedDate": "2020-10-30T01:01:08Z", "message": "Updating IPC library for server, client and model (#583)\n\n* Updating IPC library for server, client and model\r\n\r\n* Replacing InvalidArgumentError with InvalidArgumentsError\r\n\r\nCo-authored-by: fahadmohammed01 <52720275+fahadmohammed01@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5aee7a889cb393ce547349fe4753a29368243369", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5aee7a889cb393ce547349fe4753a29368243369", "committedDate": "2020-10-30T01:35:20Z", "message": "remove the parameter of mqttOnline from AwsMqttIotClient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b87c605cb10eb235ded5cd85f8afeccb36beeaf1", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b87c605cb10eb235ded5cd85f8afeccb36beeaf1", "committedDate": "2020-10-30T01:42:49Z", "message": "resolve the rebase issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e5e7b24857f949d365096144a558a2de45609c02", "committedDate": "2020-10-30T01:47:23Z", "message": "Merge branch 'spooler' of ssh://github.com/aws/aws-greengrass-kernel into spooler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzM0MTU5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520334159", "createdAt": "2020-10-30T02:15:09Z", "commit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoxNTowOVrOHq3YOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoxNTowOVrOHq3YOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcwOTU2Mg==", "bodyText": "pass in sessionPresent instead of just false.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514709562", "createdAt": "2020-10-30T02:15:09Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/AwsIotMqttClient.java", "diffHunk": "@@ -156,8 +155,8 @@ void reconnect() throws TimeoutException, ExecutionException, InterruptedExcepti\n             logger.atInfo().log(\"Connecting to AWS IoT Core\");\n             return connection.connect().thenApply((sessionPresent) -> {\n                 currentlyConnected.set(true);\n+                callbackEventManager.runOnConnectionResumed(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzM0NTIz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520334523", "createdAt": "2020-10-30T02:16:28Z", "commit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoxNjoyOFrOHq3ctw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMjoxNjoyOFrOHq3ctw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcxMDcxMQ==", "bodyText": "cancel this as the very first thing, otherwise it might be trying to publish messages while the mqtt client is shutting down.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514710711", "createdAt": "2020-10-30T02:16:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -427,6 +530,9 @@ public synchronized void close() {\n         } catch (TimeoutException e) {\n             logger.atError().log(\"Timed out shutting down event loop\", e);\n         }\n+        if (spoolingFuture.get() != null) {\n+            spoolingFuture.get().cancel(true);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "originalPosition": 191}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzM1NjE4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520335618", "createdAt": "2020-10-30T02:20:34Z", "commit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzcxMDIx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520371021", "createdAt": "2020-10-30T04:33:27Z", "commit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNDozMzoyN1rOHq_V3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNDozMzoyN1rOHq_V3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg0MDAyOQ==", "bodyText": "Ideally we wouldn't drop the qos 0 message here. But we can fix that later :)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514840029", "createdAt": "2020-10-30T04:33:27Z", "author": {"login": "jbutler"}, "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith({GGExtension.class, MockitoExtension.class})\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    Configuration config = new Configuration(new Context());\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config.lookup(\"spooler\", GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY).withValue(25L);\n+        lenient().when(deviceConfiguration.getSpoolerNamespace()).thenReturn(config.lookupTopics(\"spooler\"));\n+        spool = spy(new Spool(deviceConfiguration));\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_not_full_WHEN_add_message_THEN_add_message_without_message_dropped() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        long id = spool.addMessage(request);\n+\n+        verify(spool, never()).removeMessageById(anyLong());\n+        assertEquals(1, spool.getCurrentMessageCount());\n+        assertEquals(0L, id);\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_full_WHEN_add_message_THEN_drop_messages() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+        spool.addMessage(request2);\n+\n+        verify(spool, times(1)).removeMessageById(id2);\n+        assertEquals(20, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_queue_is_full_and_not_have_enough_space_for_new_message_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        PublishRequest request3 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(20).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request3); });\n+\n+        verify(spool, times(1)).removeOldestMessage();\n+        assertEquals(10, spool.getCurrentSpoolerSize());\n+        verify(spool, times(1)).removeMessageById(id2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzcxMjkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520371291", "createdAt": "2020-10-30T04:34:38Z", "commit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNDozNDozOFrOHq_Ztg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNDozNDozOFrOHq_Ztg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg0MTAxNA==", "bodyText": "You need to make sure that spooler size is increased before you can check that it decreased - make the publish request more than 0 bytes", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514841014", "createdAt": "2020-10-30T04:34:38Z", "author": {"login": "jbutler"}, "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith({GGExtension.class, MockitoExtension.class})\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    Configuration config = new Configuration(new Context());\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config.lookup(\"spooler\", GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY).withValue(25L);\n+        lenient().when(deviceConfiguration.getSpoolerNamespace()).thenReturn(config.lookupTopics(\"spooler\"));\n+        spool = spy(new Spool(deviceConfiguration));\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_not_full_WHEN_add_message_THEN_add_message_without_message_dropped() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        long id = spool.addMessage(request);\n+\n+        verify(spool, never()).removeMessageById(anyLong());\n+        assertEquals(1, spool.getCurrentMessageCount());\n+        assertEquals(0L, id);\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_full_WHEN_add_message_THEN_drop_messages() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+        spool.addMessage(request2);\n+\n+        verify(spool, times(1)).removeMessageById(id2);\n+        assertEquals(20, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_queue_is_full_and_not_have_enough_space_for_new_message_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        PublishRequest request3 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(20).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request3); });\n+\n+        verify(spool, times(1)).removeOldestMessage();\n+        assertEquals(10, spool.getCurrentSpoolerSize());\n+        verify(spool, times(1)).removeMessageById(id2);\n+    }\n+\n+    @Test\n+    void GIVEN_message_size_exceeds_max_size_of_spooler_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(30).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request); });\n+\n+        assertEquals(0, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_id_WHEN_remove_message_by_id_THEN_spooler_size_decreased() throws SpoolerLoadException, InterruptedException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(0).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        long id = spool.addMessage(request);\n+\n+        spool.removeMessageById(id);\n+\n+        assertEquals(0, spool.getCurrentSpoolerSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzczNDQ5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-520373449", "createdAt": "2020-10-30T04:43:28Z", "commit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNDo0MzoyOFrOHq_2-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNDo0MzoyOFrOHq_2-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg0ODUwNw==", "bodyText": "This doesn't test that only Qos 0 messages are removed, it only checks that 2 were removed. Also, getCurrentSpoolerSize() doesn't seem like a useful method since it doesn't actually return the number of spooled messages... it only contains the number of IDs that are queued.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r514848507", "createdAt": "2020-10-30T04:43:28Z", "author": {"login": "jbutler"}, "path": "src/test/java/com/aws/greengrass/mqttclient/InMemorySpoolTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.mqttclient;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.deployment.DeviceConfiguration;\n+import com.aws.greengrass.mqttclient.spool.Spool;\n+import com.aws.greengrass.mqttclient.spool.SpoolerLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith({GGExtension.class, MockitoExtension.class})\n+public class InMemorySpoolTest {\n+\n+    @Mock\n+    DeviceConfiguration deviceConfiguration;\n+\n+    private Spool spool;\n+    Configuration config = new Configuration(new Context());\n+    private static final String GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY = \"spoolMaxMessageQueueSizeInBytes\";\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        config.lookup(\"spooler\", GG_SPOOL_MAX_MESSAGE_QUEUE_SIZE_IN_BYTES_KEY).withValue(25L);\n+        lenient().when(deviceConfiguration.getSpoolerNamespace()).thenReturn(config.lookupTopics(\"spooler\"));\n+        spool = spy(new Spool(deviceConfiguration));\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_not_full_WHEN_add_message_THEN_add_message_without_message_dropped() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(new byte[0])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        long id = spool.addMessage(request);\n+\n+        verify(spool, never()).removeMessageById(anyLong());\n+        assertEquals(1, spool.getCurrentMessageCount());\n+        assertEquals(0L, id);\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_is_full_WHEN_add_message_THEN_drop_messages() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(new byte[10])\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+        spool.addMessage(request2);\n+\n+        verify(spool, times(1)).removeMessageById(id2);\n+        assertEquals(20, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_spooler_queue_is_full_and_not_have_enough_space_for_new_message_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(10).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        PublishRequest request3 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(20).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+\n+        spool.addMessage(request1);\n+        long id2 = spool.addMessage(request2);\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request3); });\n+\n+        verify(spool, times(1)).removeOldestMessage();\n+        assertEquals(10, spool.getCurrentSpoolerSize());\n+        verify(spool, times(1)).removeMessageById(id2);\n+    }\n+\n+    @Test\n+    void GIVEN_message_size_exceeds_max_size_of_spooler_when_add_message_THEN_throw_exception() throws InterruptedException, SpoolerLoadException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(30).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+\n+        assertThrows(SpoolerLoadException.class, () -> { spool.addMessage(request); });\n+\n+        assertEquals(0, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_id_WHEN_remove_message_by_id_THEN_spooler_size_decreased() throws SpoolerLoadException, InterruptedException {\n+        PublishRequest request = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(0).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        long id = spool.addMessage(request);\n+\n+        spool.removeMessageById(id);\n+\n+        assertEquals(0, spool.getCurrentSpoolerSize());\n+    }\n+\n+    @Test\n+    void GIVEN_message_with_qos_zero_WHEN_pop_out_messages_with_qos_zero_THEN_only_remove_message_with_qos_zero() throws SpoolerLoadException, InterruptedException {\n+\n+        PublishRequest request1 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(3).array())\n+                .qos(QualityOfService.AT_LEAST_ONCE).build();\n+        PublishRequest request2 = PublishRequest.builder().topic(\"spool\").payload(ByteBuffer.allocate(5).array())\n+                .qos(QualityOfService.AT_MOST_ONCE).build();\n+        List<PublishRequest> requests = Arrays.asList(request1, request2, request2);\n+\n+        for (PublishRequest request : requests) {\n+            spool.addMessage(request);\n+        }\n+\n+        spool.popOutMessagesWithQosZero();\n+\n+        verify(spool, times(2)).removeMessageById(anyLong());\n+        assertEquals(3, spool.getCurrentSpoolerSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5e7b24857f949d365096144a558a2de45609c02"}, "originalPosition": 134}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10ad6770337f5268f0ba2d66412d0a2fe3c12e76", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/10ad6770337f5268f0ba2d66412d0a2fe3c12e76", "committedDate": "2020-10-30T05:32:11Z", "message": "fix the unit test and shut down spooler at the beginning of mqtt closing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "300ac86141b1fdc28985d8611ebc8252d66ed5a1", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/300ac86141b1fdc28985d8611ebc8252d66ed5a1", "committedDate": "2020-10-30T05:37:06Z", "message": "rebase with master branch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDIyNjAy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-521022602", "createdAt": "2020-10-30T20:40:53Z", "commit": {"oid": "300ac86141b1fdc28985d8611ebc8252d66ed5a1"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59e301a077b13bb34e0ee7bbd7313fe15132e4a1", "author": {"user": {"login": "jbutler", "name": "Joe Butler"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/59e301a077b13bb34e0ee7bbd7313fe15132e4a1", "committedDate": "2020-10-30T21:53:48Z", "message": "Remove unnecessary stubs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2afdf6cf78df19b443139e22c527b6166bf4f48d", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2afdf6cf78df19b443139e22c527b6166bf4f48d", "committedDate": "2020-10-30T23:45:53Z", "message": "Merge branch 'spooler' into spooler-test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddf0230984d7d2e3e87c326be4acf4a4549d6452", "author": {"user": {"login": "jbutler", "name": "Joe Butler"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ddf0230984d7d2e3e87c326be4acf4a4549d6452", "committedDate": "2020-11-01T00:43:28Z", "message": "onconnect callback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8090edd59811dfc469ab3b92fac3db3f1ce8b1e1", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8090edd59811dfc469ab3b92fac3db3f1ce8b1e1", "committedDate": "2020-11-01T11:38:57Z", "message": "rebase master"}, "afterCommit": {"oid": "7ebd8e32bd6f0fa6852efe04217cc3e24f22b098", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7ebd8e32bd6f0fa6852efe04217cc3e24f22b098", "committedDate": "2020-11-01T12:11:57Z", "message": "rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deed1d896ca9d8914ac2e49eb727201e7bd63b89", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/deed1d896ca9d8914ac2e49eb727201e7bd63b89", "committedDate": "2020-11-01T12:25:18Z", "message": "rebase"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7ebd8e32bd6f0fa6852efe04217cc3e24f22b098", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7ebd8e32bd6f0fa6852efe04217cc3e24f22b098", "committedDate": "2020-11-01T12:11:57Z", "message": "rebase"}, "afterCommit": {"oid": "deed1d896ca9d8914ac2e49eb727201e7bd63b89", "author": {"user": {"login": "awszztt", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/deed1d896ca9d8914ac2e49eb727201e7bd63b89", "committedDate": "2020-11-01T12:25:18Z", "message": "rebase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMjUxMjc0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-521251274", "createdAt": "2020-11-01T19:00:48Z", "commit": {"oid": "deed1d896ca9d8914ac2e49eb727201e7bd63b89"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxOTowMDo0OVrOHrxTKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxOTowMDo0OVrOHrxTKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1ODUzOQ==", "bodyText": "Pretty sure this can just be a lambda function instead of an anonymous class", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#discussion_r515658539", "createdAt": "2020-11-01T19:00:49Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -87,25 +91,52 @@\n     private final Map<SubscribeRequest, AwsIotMqttClient> subscriptions = new ConcurrentHashMap<>();\n     private final Map<MqttTopic, AwsIotMqttClient> subscriptionTopics = new ConcurrentHashMap<>();\n     private final AtomicInteger connectionRoundRobin = new AtomicInteger(0);\n+    private final AtomicBoolean mqttOnline = new AtomicBoolean(false);\n \n     private final EventLoopGroup eventLoopGroup;\n     private final HostResolver hostResolver;\n     private final ClientBootstrap clientBootstrap;\n     private final CallbackEventManager callbackEventManager = new CallbackEventManager();\n+    private final Spool spool;\n+    private final ScheduledExecutorService ses;\n+    private final AtomicReference<Future<?>> spoolingFuture = new AtomicReference<>();\n+\n+    private final MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            setMqttOnline(false);\n+            if (!spool.getSpoolConfig().isKeepQos0WhenOffline()) {\n+                spool.popOutMessagesWithQosZero();\n+            }\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            setMqttOnline(true);\n+        }\n+    };\n+\n+    private final CallbackEventManager.OnConnectCallback onConnect = new CallbackEventManager.OnConnectCallback() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deed1d896ca9d8914ac2e49eb727201e7bd63b89"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMjc3MDUx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/553#pullrequestreview-521277051", "createdAt": "2020-11-02T00:03:52Z", "commit": {"oid": "deed1d896ca9d8914ac2e49eb727201e7bd63b89"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2806, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}