{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0ODI4MTE1", "number": 188, "title": "Add more Kernel testing", "bodyText": "Issue #, if available:\nDescription of changes:\nAdds tests for Kernel and KernelLifecycle. Found and fixed a couple issues while writing the test, specifically around locate and writeConfig. mock-maker-inline added so that we can mock EvergreenService including the methods which are final.\nWhy is this change necessary:\nHow was this change tested:\nLocally tested with mvn clean verify. Checked code coverage in IntelliJ while devleoping.\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-04-16T23:19:54Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188", "merged": true, "mergeCommit": {"oid": "074a9d2808c9fc184f8d667fae6f149292239b28"}, "closed": true, "closedAt": "2020-04-17T22:05:58Z", "author": {"login": "MikeDombo"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYVz1IgBqjMyNDIzMjMzNzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYosijgFqTM5NTc5OTYyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d734b91049f404bdbb7c5765ec7a7ffac80e0272", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d734b91049f404bdbb7c5765ec7a7ffac80e0272", "committedDate": "2020-04-16T23:18:38Z", "message": "Add more Kernel testing"}, "afterCommit": {"oid": "67af046f5c44bdc8e3816ffd8023a8d9eafe7407", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/67af046f5c44bdc8e3816ffd8023a8d9eafe7407", "committedDate": "2020-04-17T00:04:45Z", "message": "Add more Kernel testing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "67af046f5c44bdc8e3816ffd8023a8d9eafe7407", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/67af046f5c44bdc8e3816ffd8023a8d9eafe7407", "committedDate": "2020-04-17T00:04:45Z", "message": "Add more Kernel testing"}, "afterCommit": {"oid": "3a64ad7a1298b8c66dcd75b4d78b14b18928f965", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3a64ad7a1298b8c66dcd75b4d78b14b18928f965", "committedDate": "2020-04-17T00:40:32Z", "message": "Add more Kernel testing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a64ad7a1298b8c66dcd75b4d78b14b18928f965", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3a64ad7a1298b8c66dcd75b4d78b14b18928f965", "committedDate": "2020-04-17T00:40:32Z", "message": "Add more Kernel testing"}, "afterCommit": {"oid": "93f3b7ee1f62baa9ac059d166c6d1b03dff9f4f1", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/93f3b7ee1f62baa9ac059d166c6d1b03dff9f4f1", "committedDate": "2020-04-17T00:42:34Z", "message": "Add more Kernel testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77c622a7a20bef2b9bccc958fe6b907af8e80273", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/77c622a7a20bef2b9bccc958fe6b907af8e80273", "committedDate": "2020-04-17T01:08:35Z", "message": "Add more Kernel testing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93f3b7ee1f62baa9ac059d166c6d1b03dff9f4f1", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/93f3b7ee1f62baa9ac059d166c6d1b03dff9f4f1", "committedDate": "2020-04-17T00:42:34Z", "message": "Add more Kernel testing"}, "afterCommit": {"oid": "77c622a7a20bef2b9bccc958fe6b907af8e80273", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/77c622a7a20bef2b9bccc958fe6b907af8e80273", "committedDate": "2020-04-17T01:08:35Z", "message": "Add more Kernel testing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MDg1NDM5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#pullrequestreview-395085439", "createdAt": "2020-04-17T00:25:01Z", "commit": {"oid": "67af046f5c44bdc8e3816ffd8023a8d9eafe7407"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMDoyNTowMVrOGG7vRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMDoyOTo1NFrOGG70yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMzM5Ng==", "bodyText": "Nice!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r409923396", "createdAt": "2020-04-17T00:25:01Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -513,11 +509,11 @@ public String toString() {\n         return sb.toString();\n     }\n \n-    protected void addDependencies(Set<EvergreenService> deps) {\n+    protected void putDependenciesIntoSet(Set<EvergreenService> deps) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67af046f5c44bdc8e3816ffd8023a8d9eafe7407"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyNDgwOQ==", "bodyText": "I remember findbug or some check complains on creating new thread in constructor", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r409924809", "createdAt": "2020-04-17T00:29:54Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -83,6 +82,10 @@ public EvergreenService(Topics topics) {\n         this.externalDependenciesTopic = topics.createLeafChild(\"dependencies\").dflt(new ArrayList<String>());\n         this.externalDependenciesTopic.withParentNeedsToKnow(false);\n         this.lifecycle = new Lifecycle(this, state, logger);\n+\n+        initDependenciesTopic();\n+        periodicityInformation = Periodicity.of(this);\n+        lifecycle.initLifecycleThread();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67af046f5c44bdc8e3816ffd8023a8d9eafe7407"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjQ2NTQ4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#pullrequestreview-395646548", "createdAt": "2020-04-17T17:35:41Z", "commit": {"oid": "77c622a7a20bef2b9bccc958fe6b907af8e80273"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzozNTo0MVrOGHXC7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODo1MjoyOFrOGHZc8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDc5OA==", "bodyText": "Why hardcoded 2?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410370798", "createdAt": "2020-04-17T17:35:41Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.EZPlugins;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.ipc.IPCService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.EvergreenStructuredLogMessage;\n+import com.aws.iot.evergreen.logging.impl.Log4jLogEventBuilder;\n+import com.aws.iot.evergreen.testcommons.testutilities.TestUtils;\n+import com.aws.iot.evergreen.util.Pair;\n+import io.github.lukehutch.fastclasspathscanner.matchprocessor.ClassAnnotationMatchProcessor;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.InOrder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.AdditionalMatchers.not;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class KernelLifecycleTest {\n+    Kernel mockKernel;\n+    KernelCommandLine mockKernelCommandLine;\n+    KernelLifecycle kernelLifecycle;\n+    Context mockContext;\n+\n+    @TempDir\n+    protected Path tempRootDir;\n+\n+    @BeforeEach\n+    void beforeEach() throws IOException {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        mockKernel = mock(Kernel.class);\n+        mockContext = mock(Context.class);\n+        Configuration mockConfig = mock(Configuration.class);\n+        when(mockConfig.getRoot()).thenReturn(mock(Topics.class));\n+        when(mockKernel.getConfig()).thenReturn(mockConfig);\n+        when(mockKernel.getContext()).thenReturn(mockContext);\n+        when(mockKernel.getRootPath()).thenReturn(tempRootDir);\n+        when(mockKernel.getConfigPath()).thenReturn(tempRootDir.resolve(\"config\"));\n+        Files.createDirectories(tempRootDir.resolve(\"config\"));\n+        when(mockContext.get(eq(EZPlugins.class))).thenReturn(mock(EZPlugins.class));\n+\n+        mockKernelCommandLine = spy(new KernelCommandLine(mockKernel));\n+        kernelLifecycle = new KernelLifecycle(mockKernel, mockKernelCommandLine);\n+        mockKernel.setKernelLifecycle(kernelLifecycle);\n+        mockKernel.setKernelCommandLine(mockKernelCommandLine);\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_and_main_not_found_THEN_throws_RuntimeException() throws Exception {\n+        doThrow(ServiceLoadException.class).when(mockKernel).locate(eq(\"main\"));\n+\n+        RuntimeException ex = assertThrows(RuntimeException.class, kernelLifecycle::launch);\n+        assertEquals(RuntimeException.class, ex.getClass());\n+        assertEquals(ServiceLoadException.class, ex.getCause().getClass());\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_with_autostart_services_THEN_autostarts_added_as_dependencies_of_main()\n+            throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        EvergreenService mockOthers = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+        doReturn(mockOthers).when(mockKernel).locate(not(eq(\"main\")));\n+\n+        // Mock out EZPlugins so I can return a deterministic set of services to be added as auto-start\n+        EZPlugins pluginMock = mock(EZPlugins.class);\n+        when(mockContext.get(EZPlugins.class)).thenReturn(pluginMock);\n+        doAnswer((i) -> {\n+            ClassAnnotationMatchProcessor func = i.getArgument(1);\n+\n+            func.processMatch(IPCService.class);\n+            func.processMatch(DeploymentService.class);\n+\n+            return null;\n+        }).when(pluginMock).annotated(eq(ImplementsService.class), any());\n+\n+        kernelLifecycle.launch();\n+        verify(mockMain, times(2)).addOrUpdateDependency(eq(mockOthers), eq(State.RUNNING), eq(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77c622a7a20bef2b9bccc958fe6b907af8e80273"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4Njg2Mg==", "bodyText": "If services are stopped in reverse order, why \"bad2\" is seen after \"Bad\" ? Also can we name the variable more explicit of bad1Service /bad2Service ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410386862", "createdAt": "2020-04-17T18:06:12Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.EZPlugins;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.ipc.IPCService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.EvergreenStructuredLogMessage;\n+import com.aws.iot.evergreen.logging.impl.Log4jLogEventBuilder;\n+import com.aws.iot.evergreen.testcommons.testutilities.TestUtils;\n+import com.aws.iot.evergreen.util.Pair;\n+import io.github.lukehutch.fastclasspathscanner.matchprocessor.ClassAnnotationMatchProcessor;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.InOrder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.AdditionalMatchers.not;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class KernelLifecycleTest {\n+    Kernel mockKernel;\n+    KernelCommandLine mockKernelCommandLine;\n+    KernelLifecycle kernelLifecycle;\n+    Context mockContext;\n+\n+    @TempDir\n+    protected Path tempRootDir;\n+\n+    @BeforeEach\n+    void beforeEach() throws IOException {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        mockKernel = mock(Kernel.class);\n+        mockContext = mock(Context.class);\n+        Configuration mockConfig = mock(Configuration.class);\n+        when(mockConfig.getRoot()).thenReturn(mock(Topics.class));\n+        when(mockKernel.getConfig()).thenReturn(mockConfig);\n+        when(mockKernel.getContext()).thenReturn(mockContext);\n+        when(mockKernel.getRootPath()).thenReturn(tempRootDir);\n+        when(mockKernel.getConfigPath()).thenReturn(tempRootDir.resolve(\"config\"));\n+        Files.createDirectories(tempRootDir.resolve(\"config\"));\n+        when(mockContext.get(eq(EZPlugins.class))).thenReturn(mock(EZPlugins.class));\n+\n+        mockKernelCommandLine = spy(new KernelCommandLine(mockKernel));\n+        kernelLifecycle = new KernelLifecycle(mockKernel, mockKernelCommandLine);\n+        mockKernel.setKernelLifecycle(kernelLifecycle);\n+        mockKernel.setKernelCommandLine(mockKernelCommandLine);\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_and_main_not_found_THEN_throws_RuntimeException() throws Exception {\n+        doThrow(ServiceLoadException.class).when(mockKernel).locate(eq(\"main\"));\n+\n+        RuntimeException ex = assertThrows(RuntimeException.class, kernelLifecycle::launch);\n+        assertEquals(RuntimeException.class, ex.getClass());\n+        assertEquals(ServiceLoadException.class, ex.getCause().getClass());\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_with_autostart_services_THEN_autostarts_added_as_dependencies_of_main()\n+            throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        EvergreenService mockOthers = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+        doReturn(mockOthers).when(mockKernel).locate(not(eq(\"main\")));\n+\n+        // Mock out EZPlugins so I can return a deterministic set of services to be added as auto-start\n+        EZPlugins pluginMock = mock(EZPlugins.class);\n+        when(mockContext.get(EZPlugins.class)).thenReturn(pluginMock);\n+        doAnswer((i) -> {\n+            ClassAnnotationMatchProcessor func = i.getArgument(1);\n+\n+            func.processMatch(IPCService.class);\n+            func.processMatch(DeploymentService.class);\n+\n+            return null;\n+        }).when(pluginMock).annotated(eq(ImplementsService.class), any());\n+\n+        kernelLifecycle.launch();\n+        verify(mockMain, times(2)).addOrUpdateDependency(eq(mockOthers), eq(State.RUNNING), eq(true));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_without_config_THEN_config_read_from_disk() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        Configuration mockConfig = spy(mockKernel.getConfig());\n+        mockKernel.setConfig(mockConfig);\n+        doReturn(mockConfig).when(mockConfig).read(any(Path.class)); // Do nothing when \"read\" on Config\n+\n+        File configYaml = mockKernel.getConfigPath().resolve(\"config.yaml\").toFile();\n+        configYaml.createNewFile();\n+\n+        kernelLifecycle.launch();\n+        verify(mockKernel.getConfig()).read(any(Path.class));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_without_config_THEN_tlog_read_from_disk() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        Configuration mockConfig = spy(mockKernel.getConfig());\n+        mockKernel.setConfig(mockConfig);\n+        doReturn(mockConfig).when(mockConfig).read(any(Path.class)); // Do nothing when \"read\" on Config\n+\n+        File configTlog = mockKernel.getConfigPath().resolve(\"config.tlog\").toFile();\n+        configTlog.createNewFile();\n+\n+        kernelLifecycle.launch();\n+        verify(mockKernel.getConfig()).read(any(Path.class));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_with_config_THEN_effective_config_written() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        mockKernelCommandLine.haveRead = true;\n+\n+        kernelLifecycle.launch();\n+        Path configPath = mockKernel.getConfigPath().resolve(\"config.yaml\");\n+        verify(mockKernel).writeEffectiveConfig(eq(configPath));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_startupAllServices_THEN_services_started_in_order() {\n+        EvergreenService service1 = mock(EvergreenService.class);\n+        EvergreenService service2 = mock(EvergreenService.class);\n+        EvergreenService service3 = mock(EvergreenService.class);\n+        EvergreenService service4 = mock(EvergreenService.class);\n+        doNothing().when(service1).requestStart();\n+        doNothing().when(service2).requestStart();\n+        doNothing().when(service3).requestStart();\n+        doNothing().when(service4).requestStart();\n+\n+        doReturn(Arrays.asList(service1, service2, service3, service4)).when(mockKernel).orderedDependencies();\n+\n+        kernelLifecycle.startupAllServices();\n+\n+        InOrder inOrder = inOrder(service1, service2, service3, service4);\n+        inOrder.verify(service1).requestStart();\n+        inOrder.verify(service2).requestStart();\n+        inOrder.verify(service3).requestStart();\n+        inOrder.verify(service4).requestStart();\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_shutdown_twice_THEN_only_1_shutdown_happens() {\n+        doReturn(Collections.emptyList()).when(mockKernel).orderedDependencies();\n+\n+        kernelLifecycle.shutdown();\n+        kernelLifecycle.shutdown();\n+\n+        verify(mockKernel).orderedDependencies();\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_shutdown_THEN_shutsdown_services_in_order() throws Exception {\n+        EvergreenService service1 = mock(EvergreenService.class);\n+        EvergreenService service2 = mock(EvergreenService.class);\n+        EvergreenService service3 = mock(EvergreenService.class);\n+        EvergreenService service4 = mock(EvergreenService.class);\n+        EvergreenService service5 = mock(EvergreenService.class);\n+\n+        CompletableFuture<Void> fut = new CompletableFuture<>();\n+        fut.complete(null);\n+        CompletableFuture<Void> failedFut = new CompletableFuture<>();\n+        failedFut.completeExceptionally(new Exception(\"Bad\"));\n+\n+        doReturn(failedFut).when(service1).close();\n+        doReturn(fut).when(service2).close();\n+        doReturn(fut).when(service3).close();\n+        doReturn(fut).when(service4).close();\n+        doThrow(new RuntimeException(\"Bad2\")).when(service5).close();\n+\n+        doReturn(Arrays.asList(service1, service2, service3, service4, service5)).when(mockKernel).orderedDependencies();\n+\n+        // Check that logging of exceptions works as expected\n+        CountDownLatch seenErrors = new CountDownLatch(2);\n+        Pair<CompletableFuture<Void>, Consumer<EvergreenStructuredLogMessage>> listener =\n+                TestUtils.asyncAssertOnConsumer((m) -> {\n+            if(m.getEventType().equals(\"service-shutdown-error\")) {\n+                if (seenErrors.getCount() == 2) {\n+                    assertEquals(\"Bad2\", m.getCause().getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77c622a7a20bef2b9bccc958fe6b907af8e80273"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwOTE0NA==", "bodyText": "NIT: I'd prefer parsing the output through yaml and compare the map object.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410409144", "createdAt": "2020-04-17T18:50:19Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.exceptions.InputValidationException;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.StringWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.anyOf;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+class KernelTest {\n+    private static final String EXPECTED_CONFIG_OUTPUT =\n+            \"---\\n\"\n+            + \"services:\\n\"\n+            + \"  service1:\\n\"\n+            + \"    dependencies: []\\n\"\n+            + \"    lifecycle:\\n\"\n+            + \"      run:\\n\"\n+            + \"        script: \\\"test script\\\"\\n\"\n+            + \"  main:\\n\"\n+            + \"    dependencies:\\n\"\n+            + \"    - \\\"service1\\\"\\n\";\n+\n+    @TempDir\n+    protected Path tempRootDir;\n+    private Kernel kernel;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+        kernel = new Kernel();\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        kernel.shutdown(1);\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_and_services_WHEN_orderedDependencies_THEN_dependencies_are_returned_in_order()\n+            throws InputValidationException {\n+        KernelLifecycle kernelLifecycle = spy(new KernelLifecycle(kernel, new KernelCommandLine(kernel)));\n+        kernel.setKernelLifecycle(kernelLifecycle);\n+\n+        EvergreenService mockMain =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"main\"));\n+        when(kernelLifecycle.getMain()).thenReturn(mockMain);\n+\n+        EvergreenService service1 =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"service1\"));\n+        EvergreenService service2 =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"service2\"));\n+\n+        List<EvergreenService> od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(1));\n+        assertEquals(mockMain, od.get(0));\n+\n+        mockMain.addOrUpdateDependency(service1, State.RUNNING, false);\n+\n+        od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(2));\n+\n+        assertEquals(service1, od.get(0));\n+        assertEquals(mockMain, od.get(1));\n+\n+        mockMain.addOrUpdateDependency(service2, State.RUNNING, false);\n+\n+        od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(3));\n+\n+        // Since service 1 and 2 are equal in the tree, they may come back as either position 1 or 2\n+        assertThat(od.get(0), anyOf(is(service1), is(service2)));\n+        assertThat(od.get(1), anyOf(is(service1), is(service2)));\n+        assertEquals(mockMain, od.get(2));\n+\n+        service1.addOrUpdateDependency(service2, State.RUNNING, false);\n+\n+        od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(3));\n+\n+        // Now that 2 is a dependency of 1, there is a strict order required\n+        assertEquals(service2, od.get(0));\n+        assertEquals(service1, od.get(1));\n+        assertEquals(mockMain, od.get(2));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_and_services_WHEN_orderedDependencies_with_a_cycle_THEN_no_dependencies_returned()\n+            throws InputValidationException {\n+        KernelLifecycle kernelLifecycle = mock(KernelLifecycle.class);\n+        kernel.setKernelLifecycle(kernelLifecycle);\n+\n+        EvergreenService mockMain =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"main\"));\n+        when(kernelLifecycle.getMain()).thenReturn(mockMain);\n+\n+        EvergreenService service1 =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"service1\"));\n+\n+        // Introduce a dependency cycle\n+        service1.addOrUpdateDependency(mockMain, State.RUNNING, false);\n+        mockMain.addOrUpdateDependency(service1, State.RUNNING, false);\n+\n+        List<EvergreenService> od = new ArrayList<>(kernel.orderedDependencies());\n+        assertNotNull(od);\n+        assertThat(od, hasSize(0));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_with_services_WHEN_writeConfig_THEN_service_config_written_to_file()\n+            throws Exception {\n+        kernel.parseArgs();\n+\n+        KernelLifecycle kernelLifecycle = mock(KernelLifecycle.class);\n+        kernel.setKernelLifecycle(kernelLifecycle);\n+\n+        EvergreenService mockMain =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"main\"));\n+        when(kernelLifecycle.getMain()).thenReturn(mockMain);\n+        EvergreenService service1 =\n+                new EvergreenService(kernel.getConfig()\n+                        .lookupTopics(EvergreenService.SERVICES_NAMESPACE_TOPIC, \"service1\"));\n+\n+        // Add dependency on service1 to main\n+        mockMain.addOrUpdateDependency(service1, State.RUNNING, false);\n+        ((List<String>) kernel.findServiceTopic(\"main\").findLeafChild(\"dependencies\").getOnce())\n+                .add(\"service1\");\n+        kernel.findServiceTopic(\"service1\")\n+                .lookup(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, \"run\", \"script\")\n+                .withValue(\"test script\");\n+\n+        StringWriter writer = new StringWriter();\n+        kernel.writeConfig(writer);\n+        assertEquals(EXPECTED_CONFIG_OUTPUT, writer.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77c622a7a20bef2b9bccc958fe6b907af8e80273"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMDIyNg==", "bodyText": "Where is configTlog used?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410410226", "createdAt": "2020-04-17T18:52:28Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelLifecycleTest.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.EZPlugins;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.ipc.IPCService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.EvergreenStructuredLogMessage;\n+import com.aws.iot.evergreen.logging.impl.Log4jLogEventBuilder;\n+import com.aws.iot.evergreen.testcommons.testutilities.TestUtils;\n+import com.aws.iot.evergreen.util.Pair;\n+import io.github.lukehutch.fastclasspathscanner.matchprocessor.ClassAnnotationMatchProcessor;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.InOrder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.AdditionalMatchers.not;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class KernelLifecycleTest {\n+    Kernel mockKernel;\n+    KernelCommandLine mockKernelCommandLine;\n+    KernelLifecycle kernelLifecycle;\n+    Context mockContext;\n+\n+    @TempDir\n+    protected Path tempRootDir;\n+\n+    @BeforeEach\n+    void beforeEach() throws IOException {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        mockKernel = mock(Kernel.class);\n+        mockContext = mock(Context.class);\n+        Configuration mockConfig = mock(Configuration.class);\n+        when(mockConfig.getRoot()).thenReturn(mock(Topics.class));\n+        when(mockKernel.getConfig()).thenReturn(mockConfig);\n+        when(mockKernel.getContext()).thenReturn(mockContext);\n+        when(mockKernel.getRootPath()).thenReturn(tempRootDir);\n+        when(mockKernel.getConfigPath()).thenReturn(tempRootDir.resolve(\"config\"));\n+        Files.createDirectories(tempRootDir.resolve(\"config\"));\n+        when(mockContext.get(eq(EZPlugins.class))).thenReturn(mock(EZPlugins.class));\n+\n+        mockKernelCommandLine = spy(new KernelCommandLine(mockKernel));\n+        kernelLifecycle = new KernelLifecycle(mockKernel, mockKernelCommandLine);\n+        mockKernel.setKernelLifecycle(kernelLifecycle);\n+        mockKernel.setKernelCommandLine(mockKernelCommandLine);\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_and_main_not_found_THEN_throws_RuntimeException() throws Exception {\n+        doThrow(ServiceLoadException.class).when(mockKernel).locate(eq(\"main\"));\n+\n+        RuntimeException ex = assertThrows(RuntimeException.class, kernelLifecycle::launch);\n+        assertEquals(RuntimeException.class, ex.getClass());\n+        assertEquals(ServiceLoadException.class, ex.getCause().getClass());\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_with_autostart_services_THEN_autostarts_added_as_dependencies_of_main()\n+            throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        EvergreenService mockOthers = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+        doReturn(mockOthers).when(mockKernel).locate(not(eq(\"main\")));\n+\n+        // Mock out EZPlugins so I can return a deterministic set of services to be added as auto-start\n+        EZPlugins pluginMock = mock(EZPlugins.class);\n+        when(mockContext.get(EZPlugins.class)).thenReturn(pluginMock);\n+        doAnswer((i) -> {\n+            ClassAnnotationMatchProcessor func = i.getArgument(1);\n+\n+            func.processMatch(IPCService.class);\n+            func.processMatch(DeploymentService.class);\n+\n+            return null;\n+        }).when(pluginMock).annotated(eq(ImplementsService.class), any());\n+\n+        kernelLifecycle.launch();\n+        verify(mockMain, times(2)).addOrUpdateDependency(eq(mockOthers), eq(State.RUNNING), eq(true));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_without_config_THEN_config_read_from_disk() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        Configuration mockConfig = spy(mockKernel.getConfig());\n+        mockKernel.setConfig(mockConfig);\n+        doReturn(mockConfig).when(mockConfig).read(any(Path.class)); // Do nothing when \"read\" on Config\n+\n+        File configYaml = mockKernel.getConfigPath().resolve(\"config.yaml\").toFile();\n+        configYaml.createNewFile();\n+\n+        kernelLifecycle.launch();\n+        verify(mockKernel.getConfig()).read(any(Path.class));\n+    }\n+\n+    @Test\n+    void GIVEN_kernel_WHEN_launch_without_config_THEN_tlog_read_from_disk() throws Exception {\n+        EvergreenService mockMain = mock(EvergreenService.class);\n+        doReturn(mockMain).when(mockKernel).locate(eq(\"main\"));\n+\n+        Configuration mockConfig = spy(mockKernel.getConfig());\n+        mockKernel.setConfig(mockConfig);\n+        doReturn(mockConfig).when(mockConfig).read(any(Path.class)); // Do nothing when \"read\" on Config\n+\n+        File configTlog = mockKernel.getConfigPath().resolve(\"config.tlog\").toFile();\n+        configTlog.createNewFile();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77c622a7a20bef2b9bccc958fe6b907af8e80273"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzEyMDAw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#pullrequestreview-395712000", "createdAt": "2020-04-17T19:18:17Z", "commit": {"oid": "6eb307152fa9bf5378149355f61480ef384069c6"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Nzc0NzE3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#pullrequestreview-395774717", "createdAt": "2020-04-17T21:10:18Z", "commit": {"oid": "6eb307152fa9bf5378149355f61480ef384069c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToxMDoxOVrOGHdMyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToxMDoxOVrOGHdMyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTYyNQ==", "bodyText": "nit rename l?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#discussion_r410471625", "createdAt": "2020-04-17T21:10:19Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -137,12 +143,12 @@ public synchronized void clearODcache() {\n         }\n \n         final HashSet<EvergreenService> pending = new LinkedHashSet<>();\n-        getMain().addDependencies(pending);\n+        getMain().putDependenciesIntoSet(pending);\n         final HashSet<EvergreenService> ready = new LinkedHashSet<>();\n         while (!pending.isEmpty()) {\n             int sz = pending.size();\n             pending.removeIf(l -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6eb307152fa9bf5378149355f61480ef384069c6"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "committedDate": "2020-04-17T21:27:54Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6eb307152fa9bf5378149355f61480ef384069c6", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6eb307152fa9bf5378149355f61480ef384069c6", "committedDate": "2020-04-17T19:10:57Z", "message": "Address comments"}, "afterCommit": {"oid": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bd05e878aa2c67be2222aebf93a95f0cee2b4ea6", "committedDate": "2020-04-17T21:27:54Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Nzg0MDcz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#pullrequestreview-395784073", "createdAt": "2020-04-17T21:29:48Z", "commit": {"oid": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Nzk5NjI0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/188#pullrequestreview-395799624", "createdAt": "2020-04-17T22:05:07Z", "commit": {"oid": "bd05e878aa2c67be2222aebf93a95f0cee2b4ea6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2127, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}