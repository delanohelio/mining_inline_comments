{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0NjkzNzg5", "number": 324, "title": "Add first draft for AuthZ module", "bodyText": "Basic authZ functionality for evergreen. This change tries to define the interface for authZ handler to unblock integration with services. Follow up changes will include end to end integration with other services like TES, secrets, pub sub and stream manager.\nIssue #, if available:\nDescription of changes:\nAdd an authZ interface for evergreen. This would be used by services like secrets, tes, pubsub, config to authorize requests. Customers would specify permission blocks in config under a specific service defining the access controls for that service. Service would then be responsible for registering itself and load policies from config. configuration updates and subsequent management is services responsibility. After registration and loading policies a service can check whether a certain flow is authorized or not. It will be up to the service to take final call. AuthZ module only manages the access control table and defines interfaces for managing that configuration. All the input for AuthZ module are considered opaque data and its not treated confidential by authZ module.\nWhy is this change necessary:\nThis change would let customers define access controls for services on evergreen. This is mainly for parity with v1, where customers need to define access to pub sub topics, secrets and stream manager.\nHow was this change tested:\nUT. Need to add more UT, sending this out for early feedback on interfaces.\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-07-21T19:11:38Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324", "merged": true, "mergeCommit": {"oid": "224cb23b6fa231c06d81029748b833ae661defbb"}, "closed": true, "closedAt": "2020-07-29T23:44:16Z", "author": {"login": "prateek-y"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3LCriAH2gAyNDU0NjkzNzg5OjUwMTFmZjY0ZDg3NjQzODlmZmZiOGVjZTM2YjVmM2UwNTlkZjRjNGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5zBWgAH2gAyNDU0NjkzNzg5OmNiMTNjNzlkM2MzNTRiNjBhYzI5ZGY5MWU3YmNhOTdkZWZlYjRmODI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5011ff64d8764389fffb8ece36b5f3e059df4c4a", "committedDate": "2020-07-21T19:03:48Z", "message": "Add first draft for AuthZ module\n\nBasic authZ functionality for evergreen. This change tries to define\nthe interface for authZ handler to unblock integration with services.\nFollow up changes will include end to end integration with other\nservices."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzU1MTk1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-452755195", "createdAt": "2020-07-21T19:14:33Z", "commit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToxNDozNFrOG1GMeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToxNDozNFrOG1GMeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMyOTIwOA==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and put() may not be thread-safe at lines: 115 and 123. Two threads can perform this same check at the same time and one thread can overwrite the value written by the other thread.\nFix\nConsider replacing put() with putIfAbsent() to help prevent accidental overwriting. putIfAbsent() puts the value only if the ConcurrentHashMap does not contain the key and therefore avoids overwriting the value written there by the other thread's putIfAbsent().\nMore info\nIf the key already exists, the code should throw an error at line: 116. putIfAbsent() returns null if the value did not exist and returns the value in the map if one already exists.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458329208", "createdAt": "2020-07-21T19:14:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        List<String> operationsCopy = new ArrayList<>(operations);\n+        if (!operationsCopy.contains(ANY_REGEX)) {\n+            operationsCopy.add(ANY_REGEX);\n+        }\n+        serviceToOperationsMap.put(serviceName, operationsCopy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzYwNTQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-452760546", "createdAt": "2020-07-21T19:22:27Z", "commit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyMjoyN1rOG1GdPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOTozMDoxMlrOG1Gs9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzMzUwMQ==", "bodyText": "inject the auth module for easier testing", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458333501", "createdAt": "2020-07-21T19:22:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTExMQ==", "bodyText": "maybe use a Set instead? Then you can just add ANY_REGEX", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458335111", "createdAt": "2020-07-21T19:25:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        List<String> operationsCopy = new ArrayList<>(operations);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTY1NA==", "bodyText": "use Utils.isEmpty?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458335654", "createdAt": "2020-07-21T19:26:39Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzIyNg==", "bodyText": "may want to make these lists into sets so the contains check is faster", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458337226", "createdAt": "2020-07-21T19:29:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+import java.util.List;\n+\n+@Value\n+@Builder\n+public class AuthZPolicy {\n+    @NonNull String policyId;\n+    String policyDescription;\n+    @NonNull List<String> sources;\n+    @NonNull List<String> operations;\n+    List<String> resources;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzUyNg==", "bodyText": "maybe also assert on what the message is in the exception", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458337526", "createdAt": "2020-07-21T19:30:12Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthZHandlerTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthZHandlerTest {\n+\n+    @Mock\n+    private Kernel mockKernel;\n+\n+    @Mock\n+    private Topics mockTopics;\n+\n+    private AuthZPolicy getAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"compA\", \"compB\"))\n+                .operations(Arrays.asList(\"OpA\", \"OpB\", \"OpC\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getAuthZPolicyB() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id2\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"ServiceC\", \"ServiceD\"))\n+                .operations(Arrays.asList(\"OpD\", \"OpE\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getStarOperationsAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"compA\", \"compB\"))\n+                .operations(Arrays.asList(\"*\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getStarSourcesAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"*\"))\n+                .operations(Arrays.asList(\"OpA\", \"OpB\", \"OpC\"))\n+                .build();\n+    }\n+\n+    @Test\n+    void GIVEN_AuthZ_manager_WHEN_service_registered_twice_THEN_errors() throws AuthZException {\n+        AuthZHandler authZHandler = new AuthZHandler(mockKernel);\n+        final List<String> serviceOps = Arrays.asList(\"OpA\", \"OpB\", \"OpC\");\n+        authZHandler.registerService(\"ServiceA\", serviceOps);\n+\n+        assertThrows(AuthZException.class, () -> authZHandler.registerService(\"ServiceA\", serviceOps));\n+        final List<String> serviceOps_2 = Arrays.asList(\"OpA\");\n+        assertThrows(AuthZException.class, () -> authZHandler.registerService(\"ServiceA\", serviceOps_2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ff2ee02726c325fc7e3d1453999f68d75d442a2", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9ff2ee02726c325fc7e3d1453999f68d75d442a2", "committedDate": "2020-07-21T21:27:57Z", "message": "Apply feedback, modify type to Set for policy elements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyODU1NDEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-452855413", "createdAt": "2020-07-21T21:51:13Z", "commit": {"oid": "9ff2ee02726c325fc7e3d1453999f68d75d442a2"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTo1MToxM1rOG1LGwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTo1MToxM1rOG1LGwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwOTY2Ng==", "bodyText": "why copy it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458409666", "createdAt": "2020-07-21T21:51:13Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ff2ee02726c325fc7e3d1453999f68d75d442a2"}, "originalPosition": 121}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0908e6cd982710af8b4ba270ef442e6a85d8cd7d", "committedDate": "2020-07-22T06:52:58Z", "message": "Add more UT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNTEwODMw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-453510830", "createdAt": "2020-07-22T16:58:16Z", "commit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "state": "DISMISSED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNjo1ODoxNlrOG1rrYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzowMzowNlrOG1r29g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0MzMzMQ==", "bodyText": "just set these in the field definition?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458943331", "createdAt": "2020-07-22T16:58:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NDU3Mw==", "bodyText": "[nit]\nFormatting, reformat all files just in case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458944573", "createdAt": "2020-07-22T17:00:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)\n+            throws AuthZException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(serviceName)) {\n+            throw new AuthZException(\"Service name is not specified\");\n+        }\n+        if (config == null) {\n+            throw new AuthZException(\"config is null\");\n+        }\n+        isServiceRegistered(serviceName);\n+\n+        // First validate if all sources and operations are valid\n+        for (AuthZPolicy policy: config) {\n+            validateSources(policy);\n+            validateOperations(serviceName, policy);\n+        }\n+        // now start adding the config as permissions\n+        for (AuthZPolicy policy: config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NTU5Mw==", "bodyText": "[nit]\nWhen you have all the data in one place, just use the constructor instead of builder.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458945593", "createdAt": "2020-07-22T17:01:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)\n+            throws AuthZException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(serviceName)) {\n+            throw new AuthZException(\"Service name is not specified\");\n+        }\n+        if (config == null) {\n+            throw new AuthZException(\"config is null\");\n+        }\n+        isServiceRegistered(serviceName);\n+\n+        // First validate if all sources and operations are valid\n+        for (AuthZPolicy policy: config) {\n+            validateSources(policy);\n+            validateOperations(serviceName, policy);\n+        }\n+        // now start adding the config as permissions\n+        for (AuthZPolicy policy: config) {\n+            addPermission(serviceName, policy.getSources(), policy.getOperations(), policy.getResources());\n+        }\n+        this.serviceToAuthZConfig.put(serviceName, config);\n+    }\n+\n+    private void isServiceRegistered(String serviceName) throws AuthZException {\n+        if (Utils.isEmpty(serviceName)) {\n+            throw new AuthZException(\"Invalid service name: \" + serviceName);\n+        }\n+        if (!serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service not registered: \" + serviceName);\n+        }\n+    }\n+\n+    private void isOperationValid(String serviceName, String operation)\n+            throws AuthZException {\n+        isServiceRegistered(serviceName);\n+        if (!serviceToOperationsMap.get(serviceName).contains(operation)) {\n+            throw new AuthZException(String.format(\"Service %s not registered for operation %s\",\n+                    serviceName, operation));\n+        }\n+\n+    }\n+\n+    private void validateOperations(String serviceName, AuthZPolicy policy) throws AuthZException {\n+        Set<String> operations = policy.getOperations();\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"Malformed policy with invalid/empty operations: \"\n+                    + policy.getPolicyId());\n+        }\n+        Set<String> supportedOps = serviceToOperationsMap.get(serviceName);\n+        // check if operations are valid and registered.\n+        if (operations.stream().anyMatch(o -> !supportedOps.contains(o))) {\n+            throw new AuthZException(String.format(\"Operation not registered with service %s\", serviceName));\n+        }\n+    }\n+\n+    private void validateSources(AuthZPolicy policy) throws AuthZException {\n+        Set<String> sources = policy.getSources();\n+        if (Utils.isEmpty(sources)) {\n+            throw new AuthZException(\"Malformed policy with invalid/empty source: \" + policy.getPolicyId());\n+        }\n+        // check if source is a valid EG service\n+        List<String> unknownSources = sources.stream().filter(s -> !s.equals(ANY_REGEX)).filter(s ->\n+                kernel.findServiceTopic(s) == null).collect(Collectors.toList());\n+\n+        if (!unknownSources.isEmpty()) {\n+            throw new AuthZException(String.format(\"Source %s in auth policy are not valid services\", unknownSources));\n+        }\n+    }\n+\n+    private void addPermission(String destination,\n+                               Set<String> sources,\n+                               Set<String> operations,\n+                               Set<String> resources) throws AuthZException {\n+        // Method assumes that all inputs are valid now\n+        for (String source: sources) {\n+            for (String operation: operations) {\n+                if (resources == null || resources.isEmpty()) {\n+                    authModule.addPermission(destination,\n+                            Permission.builder().source(source).operation(operation).resource(null).build());\n+                } else {\n+                    for (String resource : resources) {\n+                        authModule.addPermission(destination,\n+                                Permission.builder().source(source).operation(operation).resource(resource).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NTczOQ==", "bodyText": "just set in field definition?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458945739", "createdAt": "2020-07-22T17:02:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {\n+    ConcurrentHashMap<String, List<Permission>> permissions;\n+\n+    AuthZModule() {\n+        permissions = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NjI5NA==", "bodyText": "consider using DefaultConcurrentHashMap which implements get in this same way, so you can do permissions.get(destination).add(permission), without needing a nullcheck or computeIfAbsent.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458946294", "createdAt": "2020-07-22T17:03:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {\n+    ConcurrentHashMap<String, List<Permission>> permissions;\n+\n+    AuthZModule() {\n+        permissions = new ConcurrentHashMap<>();\n+    }\n+\n+    /**\n+     * Add permission for the given input set.\n+     * @param destination destination entity\n+     * @param permission set of source, operation, resource.\n+     * @throws AuthZException when arguments are invalid\n+     */\n+    public void addPermission(final String destination, Permission permission) throws AuthZException {\n+        // resource is allowed to be null\n+        if (Utils.isEmpty(permission.getSource())\n+                || Utils.isEmpty(destination)\n+                || Utils.isEmpty(permission.getOperation())) {\n+            throw new AuthZException(\"Either one parameter is empty\");\n+        }\n+        // resource as null is ok, but it should not be empty\n+        String resource = permission.getResource();\n+        if (resource != null && Utils.isEmpty(resource)) {\n+            throw new AuthZException(\"Resource cannot be empty\");\n+        }\n+        permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNzI3ODU5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-453727859", "createdAt": "2020-07-22T22:25:48Z", "commit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjoyNTo0OVrOG12XpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMzo1MzozM1rOG14H5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExODUwMA==", "bodyText": "Use full name? AuthorizationException", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459118500", "createdAt": "2020-07-22T22:25:49Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthZException.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.iot.evergreen.auth.exceptions;\n+\n+public class AuthZException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTExMg==", "bodyText": "Use Principal? source is a bit vague.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459119112", "createdAt": "2020-07-22T22:27:28Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/Permission.java", "diffHunk": "@@ -0,0 +1,16 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+@Builder\n+@Value\n+public class Permission {\n+    @NonNull String source;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTcxNw==", "bodyText": "Use full name: AuthorizationPolicy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459119717", "createdAt": "2020-07-22T22:29:17Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+import java.util.Set;\n+\n+@Value\n+@Builder\n+public class AuthZPolicy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMzA0NQ==", "bodyText": "nit: AuthorizationHandler?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459123045", "createdAt": "2020-07-22T22:38:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDYyMA==", "bodyText": "What is flow? It's a weird name. Why not just isAuthorized? Also do you separate destination and permission? Can't they be modeled in one object, such as AuthorizationRequest?\nclass AuthorizationRequest {\nString principal;\nString operation;\nResource resource;\n}\n\nclass Resource {\nString target;\nList<String> subresources;\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459124620", "createdAt": "2020-07-22T22:42:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTg5Ng==", "bodyText": "Who will call this method? Why is it needed? is this registering the principal? Also I would not sure the name \"service\". It's an overloaded term.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459129896", "createdAt": "2020-07-22T22:57:27Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMTYwNA==", "bodyText": "Call it loadAuthorizationPolicy(). Don't introduce another term Config if it's already called Policy.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459131604", "createdAt": "2020-07-22T23:02:35Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0NzIzOQ==", "bodyText": "Why modeling this as as a separate class in stead of part of AuthZHandler?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459147239", "createdAt": "2020-07-22T23:53:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2eaf57acea4d712ad23d4bb19c5554d717cb45b1", "committedDate": "2020-07-23T23:24:26Z", "message": "Add feedback, renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecaf782ff24c4e775a8653c1c483cdabf591b55e", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ecaf782ff24c4e775a8653c1c483cdabf591b55e", "committedDate": "2020-07-24T00:18:54Z", "message": "rename principal to principle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NTgyMzgw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-454582380", "createdAt": "2020-07-24T00:44:37Z", "commit": {"oid": "ecaf782ff24c4e775a8653c1c483cdabf591b55e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMDo0NDozN1rOG2gIPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMDo0NDozN1rOG2gIPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMjY4NQ==", "bodyText": "Should this also be renamed to use the full form instead of AuthZ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459802685", "createdAt": "2020-07-24T00:44:37Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecaf782ff24c4e775a8653c1c483cdabf591b55e"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afb3120b4920be00c1a0473c15c03f823e4fcdde", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afb3120b4920be00c1a0473c15c03f823e4fcdde", "committedDate": "2020-07-24T01:01:24Z", "message": "Revert \"rename principal to principle\"\n\nThis reverts commit ecaf782ff24c4e775a8653c1c483cdabf591b55e."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5b8b8e3acb556921aec53ff98cfa28955771652", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d5b8b8e3acb556921aec53ff98cfa28955771652", "committedDate": "2020-07-24T23:51:38Z", "message": "rename AuthZmodule"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MDM1MTc0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-456035174", "createdAt": "2020-07-27T18:33:39Z", "commit": {"oid": "d5b8b8e3acb556921aec53ff98cfa28955771652"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98891ce147221429a604624786f056454a819c84", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/98891ce147221429a604624786f056454a819c84", "committedDate": "2020-07-27T18:33:50Z", "message": "Merge branch 'master' into authZ_interface"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MTkxMjAw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-456191200", "createdAt": "2020-07-27T22:58:37Z", "commit": {"oid": "98891ce147221429a604624786f056454a819c84"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5bd74ad716d86b902b67c90d686e648cc93cd64", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d5bd74ad716d86b902b67c90d686e648cc93cd64", "committedDate": "2020-07-28T06:25:17Z", "message": "Add first draft for AuthZ module\n\nBasic authZ functionality for evergreen. This change tries to define\nthe interface for authZ handler to unblock integration with services.\nFollow up changes will include end to end integration with other\nservices."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8026c189df076ae069a9c5f122778b42a2e316a5", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8026c189df076ae069a9c5f122778b42a2e316a5", "committedDate": "2020-07-28T06:25:17Z", "message": "Apply feedback, modify type to Set for policy elements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bce7aa491afe48b1e03c1935cdc51aae02d66066", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bce7aa491afe48b1e03c1935cdc51aae02d66066", "committedDate": "2020-07-28T06:25:17Z", "message": "Add more UT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "896f4fe145f54bd03fecdd8342d9d546dcef0f43", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/896f4fe145f54bd03fecdd8342d9d546dcef0f43", "committedDate": "2020-07-28T06:25:18Z", "message": "Add feedback, renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f004e45036bb605fb5f9765d1a201012e115dad4", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f004e45036bb605fb5f9765d1a201012e115dad4", "committedDate": "2020-07-28T06:25:18Z", "message": "rename principal to principle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0ee8ac4fc29386c13d1eeae2fcc60a1326bd2cf", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d0ee8ac4fc29386c13d1eeae2fcc60a1326bd2cf", "committedDate": "2020-07-28T06:25:18Z", "message": "Revert \"rename principal to principle\"\n\nThis reverts commit ecaf782ff24c4e775a8653c1c483cdabf591b55e."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d21a8514a4f92af6d5d288485a2771f7ac8ccab", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d21a8514a4f92af6d5d288485a2771f7ac8ccab", "committedDate": "2020-07-28T06:25:18Z", "message": "rename AuthZmodule"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "907b66886b8fa99e134ce0d0763045aa6935d9f7", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/907b66886b8fa99e134ce0d0763045aa6935d9f7", "committedDate": "2020-07-28T06:26:22Z", "message": "Merge branch 'master' into authZ_interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ca91ec138acee96a6be83c107f87a30fbfbbfb5", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1ca91ec138acee96a6be83c107f87a30fbfbbfb5", "committedDate": "2020-07-28T06:30:03Z", "message": "Merge branch 'authZ_interface' of https://github.com/aws/aws-greengrass-kernel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eeee6595323ef5321d83685abb97a5763d67ef60", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eeee6595323ef5321d83685abb97a5763d67ef60", "committedDate": "2020-07-28T06:30:25Z", "message": "increase auth coverage to 100%"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9edb443d4ce0b35bc89c33057567f790f376a1e", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e9edb443d4ce0b35bc89c33057567f790f376a1e", "committedDate": "2020-07-29T18:56:05Z", "message": "Reduce the coverage bar for integration tests\n\nWe do not include all tests in integration tests folder as part of\ncoverage. We exclude tests with E2E annotation from integ test\ncoverage. After adding auth module which has integ test with TES,\nthe coverage dropped because TES is not part of integ test coverage."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c96b0f5903952f1afcffe01d76fe8021c44417fd", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c96b0f5903952f1afcffe01d76fe8021c44417fd", "committedDate": "2020-07-29T19:05:59Z", "message": "Add copyright header"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95f2cdd1a6ab734365139009f2e5d121fb98eb50", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/95f2cdd1a6ab734365139009f2e5d121fb98eb50", "committedDate": "2020-07-29T20:14:09Z", "message": "rename service to component"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8888b998132ae00c76f6ab4bda5be9814e50afcb", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8888b998132ae00c76f6ab4bda5be9814e50afcb", "committedDate": "2020-07-29T21:21:24Z", "message": "Merge branch 'master' into authZ_interface"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTA3ODEy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-457907812", "createdAt": "2020-07-29T21:22:41Z", "commit": {"oid": "95f2cdd1a6ab734365139009f2e5d121fb98eb50"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTA3OTQy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-457907942", "createdAt": "2020-07-29T21:22:52Z", "commit": {"oid": "8888b998132ae00c76f6ab4bda5be9814e50afcb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTA5OTgw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-457909980", "createdAt": "2020-07-29T21:26:23Z", "commit": {"oid": "8888b998132ae00c76f6ab4bda5be9814e50afcb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTIxNTYy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#pullrequestreview-457921562", "createdAt": "2020-07-29T21:46:58Z", "commit": {"oid": "8888b998132ae00c76f6ab4bda5be9814e50afcb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb13c79d3c354b60ac29df91e7bca97defeb4f82", "author": {"user": {"login": "prateek-y", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cb13c79d3c354b60ac29df91e7bca97defeb4f82", "committedDate": "2020-07-29T22:46:24Z", "message": "Merge branch 'master' into authZ_interface"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2916, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}