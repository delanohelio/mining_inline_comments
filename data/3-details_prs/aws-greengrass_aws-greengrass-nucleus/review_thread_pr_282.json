{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NTYzODMw", "number": 282, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMjozMzowMFrOEGLBdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNTozMlrOEPowQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTA3NTExOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMjozMzowMFrOGkzhxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDoxOTo1M1rOGl-2Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NjE1MA==", "bodyText": "why are you changing the mod time, but not the value? The mod time should reflect the value's time, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r441246150", "createdAt": "2020-06-17T02:33:00Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -105,7 +105,14 @@ public Topic withNewerValue(long proposedModtime, final Object proposed) {\n     public synchronized Topic withNewerValue(long proposedModtime, final Object proposed, boolean forceTimestamp) {\n         final Object currentValue = value;\n         final long currentModtime = modtime;\n-        if (Objects.equals(proposed, currentValue) || !forceTimestamp && (proposedModtime < currentModtime)) {\n+        if (Objects.equals(proposed, currentValue)) {\n+            if (forceTimestamp || currentModtime < proposedModtime) {\n+                modtime = proposedModtime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85265c32d5894bacd6ca5ded0949c5e4277a8c46"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2MjI1Ng==", "bodyText": "If the new proposed value is same as old proposed value, then only update the modTime.\nConsider when user update topic with value1 at t1, then update with the same value at t2. If another update happens at t3 when t1< t3< t2, then the update will take effect, but this is not the intention", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r441762256", "createdAt": "2020-06-17T18:53:58Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -105,7 +105,14 @@ public Topic withNewerValue(long proposedModtime, final Object proposed) {\n     public synchronized Topic withNewerValue(long proposedModtime, final Object proposed, boolean forceTimestamp) {\n         final Object currentValue = value;\n         final long currentModtime = modtime;\n-        if (Objects.equals(proposed, currentValue) || !forceTimestamp && (proposedModtime < currentModtime)) {\n+        if (Objects.equals(proposed, currentValue)) {\n+            if (forceTimestamp || currentModtime < proposedModtime) {\n+                modtime = proposedModtime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NjE1MA=="}, "originalCommit": {"oid": "85265c32d5894bacd6ca5ded0949c5e4277a8c46"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4MDE5MA==", "bodyText": "Actually I don't know if it's a desired behavior. I'll revert this change for now", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r442480190", "createdAt": "2020-06-18T20:19:53Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -105,7 +105,14 @@ public Topic withNewerValue(long proposedModtime, final Object proposed) {\n     public synchronized Topic withNewerValue(long proposedModtime, final Object proposed, boolean forceTimestamp) {\n         final Object currentValue = value;\n         final long currentModtime = modtime;\n-        if (Objects.equals(proposed, currentValue) || !forceTimestamp && (proposedModtime < currentModtime)) {\n+        if (Objects.equals(proposed, currentValue)) {\n+            if (forceTimestamp || currentModtime < proposedModtime) {\n+                modtime = proposedModtime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NjE1MA=="}, "originalCommit": {"oid": "85265c32d5894bacd6ca5ded0949c5e4277a8c46"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTA3OTcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMjozNTo1NVrOGkzkkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDowNTo1MVrOGtlZQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0Njg2Nw==", "bodyText": "I don't really think we should call remove here because that will remove the watchers and send updates that it was removed. But what you really want is to just replace it atomically, not delete and then add.\nYou might want to create a Topics, copy the watchers over, then directly remove it from the children so that it never fires the WhatHappened.Removed, because that isn't really accurate.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r441246867", "createdAt": "2020-06-17T02:35:55Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,38 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild != null && !(existingChild instanceof Topics)) {\n+                    remove(existingChild);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85265c32d5894bacd6ca5ded0949c5e4277a8c46"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2ODg4Nw==", "bodyText": "'copy the watchers over' doesn't work because the subscriber for Topics is ChildChanged and the subscriber for Topic is Subscriber, they have different interface. One is taking Node parameter, another is taking Topic parameter. Topics node also have child nodes, and these child nodes also have watchers. We do want to notify child watchers with 'removed' event.\nI also considered creating a new WhatHappened enum value, nodeTypeChanged, and unify the Subscriber and ChildChanged interface. That requires a bigger change though.\nCurrently, if you call lookupTopics() on a Topic node path (or vice versa), it will throw an illegalArg exception. If you call findTopics() on a Topic node path (or vice versa), it will return null. I guess we need to re-think these to consider how to properly switch a node between Topics and Topic. This is not high priority right now, I can add a TODO here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r441768887", "createdAt": "2020-06-17T19:01:13Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,38 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild != null && !(existingChild instanceof Topics)) {\n+                    remove(existingChild);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0Njg2Nw=="}, "originalCommit": {"oid": "85265c32d5894bacd6ca5ded0949c5e4277a8c46"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MTA3MA==", "bodyText": "I think I might be happier with the unified subscriber interface so that you don't remove and then add it back. Not sure that we currently have a situation where this matters (I think that we always subscribe to a higher Topics which we know won't change types).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r441771070", "createdAt": "2020-06-17T19:05:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,38 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild != null && !(existingChild instanceof Topics)) {\n+                    remove(existingChild);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0Njg2Nw=="}, "originalCommit": {"oid": "85265c32d5894bacd6ca5ded0949c5e4277a8c46"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4MDg5Mg==", "bodyText": "Some subscribers are taking Topic state. eg: _State topic. I can go through the codebase to check.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r442480892", "createdAt": "2020-06-18T20:21:21Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,38 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild != null && !(existingChild instanceof Topics)) {\n+                    remove(existingChild);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0Njg2Nw=="}, "originalCommit": {"oid": "85265c32d5894bacd6ca5ded0949c5e4277a8c46"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ1MTc3Nw==", "bodyText": "I tried implementing switching node between container/leaf, find out it's too big a change for this PR. I'll leave it for now and add TODO", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r450451777", "createdAt": "2020-07-06T20:05:51Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,38 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild != null && !(existingChild instanceof Topics)) {\n+                    remove(existingChild);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0Njg2Nw=="}, "originalCommit": {"oid": "85265c32d5894bacd6ca5ded0949c5e4277a8c46"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjI4MzA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Node.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTo1NzoxN1rOGr2p_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNjowMTo1M1rOGr-gjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzNzQzNw==", "bodyText": "why do we need these?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r448637437", "createdAt": "2020-07-01T21:57:17Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Node.java", "diffHunk": "@@ -28,6 +28,14 @@ protected Node(Context c, String n, Topics p) {\n         fnc = calcFnc();\n     }\n \n+    public synchronized Topics getParent() {\n+        return parent;\n+    }\n+\n+    protected synchronized void setParent(Topics p) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2NjA5Mg==", "bodyText": "to set parent for a node", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r448766092", "createdAt": "2020-07-02T06:01:53Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Node.java", "diffHunk": "@@ -28,6 +28,14 @@ protected Node(Context c, String n, Topics p) {\n         fnc = calcFnc();\n     }\n \n+    public synchronized Topics getParent() {\n+        return parent;\n+    }\n+\n+    protected synchronized void setParent(Topics p) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzNzQzNw=="}, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjI4NzkxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTo1OToyMVrOGr2tEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNjozNDowOVrOGtKbCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzODIyNw==", "bodyText": "this shouldn't really be necessary, right? Can we just use lookupTopic which will create the node properly without this manual work?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r448638227", "createdAt": "2020-07-01T21:59:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild instanceof Topic) {\n+                    Topics newNode = new Topics(context, key, null);\n+                    newNode.replaceMap(lastModified, (Map) value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2NTk5OA==", "bodyText": "lookUpTopic will throw illegalArgException since the node already exist and is not Topic instance", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r448765998", "createdAt": "2020-07-02T06:01:35Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild instanceof Topic) {\n+                    Topics newNode = new Topics(context, key, null);\n+                    newNode.replaceMap(lastModified, (Map) value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzODIyNw=="}, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3NTg4Mg==", "bodyText": "Then we could add a method to \"override\" properly I guess. At least encapsulate this logic.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449175882", "createdAt": "2020-07-02T17:43:54Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild instanceof Topic) {\n+                    Topics newNode = new Topics(context, key, null);\n+                    newNode.replaceMap(lastModified, (Map) value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzODIyNw=="}, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI0NTU5OA==", "bodyText": "I don't think it's necessary now. So far replaceMap() is the only place where a node type can change", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449245598", "createdAt": "2020-07-02T20:16:46Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild instanceof Topic) {\n+                    Topics newNode = new Topics(context, key, null);\n+                    newNode.replaceMap(lastModified, (Map) value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzODIyNw=="}, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2ODc3OQ==", "bodyText": "+1, I would also prefer if it was done through lookupTopic such that we wouldn't need two ways to change nodes", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449268779", "createdAt": "2020-07-02T21:14:10Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild instanceof Topic) {\n+                    Topics newNode = new Topics(context, key, null);\n+                    newNode.replaceMap(lastModified, (Map) value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzODIyNw=="}, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAwOTg2NQ==", "bodyText": "LookupTopic/LookupTopics doesn't change value of a node, it just creates new nodes (creating new node doesn't fire publishing event). The value is changed through Topic.WithNewerValue(), which notify the subscribers in the publish queue. If we try to implement removing/replacing logic in LookupTopic/LookupTopics, the order of publishing queue can be tricky.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r450009865", "createdAt": "2020-07-06T06:34:09Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild instanceof Topic) {\n+                    Topics newNode = new Topics(context, key, null);\n+                    newNode.replaceMap(lastModified, (Map) value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzODIyNw=="}, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjI4OTc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMjowMDoxMFrOGr2uJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNjoxMjo1NFrOGr-vlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzODUwMw==", "bodyText": "this shouldn't be needed since the existing child is going away, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r448638503", "createdAt": "2020-07-01T22:00:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild instanceof Topic) {\n+                    Topics newNode = new Topics(context, key, null);\n+                    newNode.replaceMap(lastModified, (Map) value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);\n+                        // set watcher here so that the watcher doesn't receive notification from\n+                        // the above replaceMap() invocation\n+                        newNode.watchers.addAll(existingChild.watchers);\n+                        existingChild.watchers.clear();\n+                        newNode.fire(WhatHappened.nodeTypeChanged);\n+                    });\n+                } else {\n+                    createInteriorChild(key).replaceMap(lastModified, (Map) value);\n+                }\n+            } else {\n+                // if a container node is replaced with leaf node\n+                if (existingChild instanceof Topics) {\n+                    Topic newNode = new Topic(context, key, null);\n+                    newNode.withNewerValue(lastModified, value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2OTk0Mw==", "bodyText": "Not really, parent node need to remove the child from children and child need to remove reference to parent. Otherwise, when informing the children in the old container node of removal, the 'childRemoved' event will bubble up to root parent.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r448769943", "createdAt": "2020-07-02T06:12:54Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -205,6 +207,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node\n+                if (existingChild instanceof Topic) {\n+                    Topics newNode = new Topics(context, key, null);\n+                    newNode.replaceMap(lastModified, (Map) value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);\n+                        // set watcher here so that the watcher doesn't receive notification from\n+                        // the above replaceMap() invocation\n+                        newNode.watchers.addAll(existingChild.watchers);\n+                        existingChild.watchers.clear();\n+                        newNode.fire(WhatHappened.nodeTypeChanged);\n+                    });\n+                } else {\n+                    createInteriorChild(key).replaceMap(lastModified, (Map) value);\n+                }\n+            } else {\n+                // if a container node is replaced with leaf node\n+                if (existingChild instanceof Topics) {\n+                    Topic newNode = new Topic(context, key, null);\n+                    newNode.withNewerValue(lastModified, value);\n+\n+                    context.runOnPublishQueue(() -> {\n+                        children.put(key, newNode);\n+                        newNode.setParent(this);\n+                        existingChild.setParent(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzODUwMw=="}, "originalCommit": {"oid": "67b3be162d1732cf54c183ce5d3f6aec3db12755"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTYwNzUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoxOTozNFrOGsWw7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoxOTozNFrOGsWw7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2MzUwMg==", "bodyText": "does this TODO still apply?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449163502", "createdAt": "2020-07-02T17:19:34Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationWriter.java", "diffHunk": "@@ -124,6 +124,6 @@ public synchronized void childChanged(WhatHappened what, Node n) {\n     }\n \n     public void writeAll() { //TODO double check this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTYxNTI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/WhatHappened.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyMjowM1rOGsW1sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyMjowM1rOGsW1sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2NDcyMQ==", "bodyText": "not sure do we want to be more specific to differentiate btw \"changed to Topics \" vs \"changed to Topic\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449164721", "createdAt": "2020-07-02T17:22:03Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/config/WhatHappened.java", "diffHunk": "@@ -4,5 +4,5 @@\n package com.aws.iot.evergreen.config;\n \n public enum WhatHappened {\n-    changed, initialized, childChanged, removed, childRemoved\n+    changed, initialized, childChanged, removed, childRemoved, nodeTypeChanged", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTYxOTEzOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyMzoxNFrOGsW4BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyMzoxNFrOGsW4BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2NTMxNg==", "bodyText": "Like the naming here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449165316", "createdAt": "2020-07-02T17:23:14Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "diffHunk": "@@ -302,4 +304,203 @@ public void GIVEN_config_to_merge_WHEN_read_with_current_timestamp_THEN_merge()\n         assertEquals(\"echo main service installed\",\n                 config.find(SERVICES_NAMESPACE_TOPIC, \"main\", \"lifecycle\", \"install\").getOnce());\n     }\n+\n+    @Test\n+    public void GIVEN_topics_WHEN_call_replace_map_THEN_content_replaced_and_subscribers_invoked() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeToBeRemoved:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  leafToBeUpdated: val2\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeRemoved: dummy\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTYyNjcwOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyNTozMFrOGsW8oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzowNTozMFrOGtpwlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2NjQ5Ng==", "bodyText": "should we consider providing an override method without taking timestamp, which sets current timestamp? This magical number has always been confusing...", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449166496", "createdAt": "2020-07-02T17:25:30Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "diffHunk": "@@ -302,4 +304,203 @@ public void GIVEN_config_to_merge_WHEN_read_with_current_timestamp_THEN_merge()\n         assertEquals(\"echo main service installed\",\n                 config.find(SERVICES_NAMESPACE_TOPIC, \"main\", \"lifecycle\", \"install\").getOnce());\n     }\n+\n+    @Test\n+    public void GIVEN_topics_WHEN_call_replace_map_THEN_content_replaced_and_subscribers_invoked() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeToBeRemoved:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  leafToBeUpdated: val2\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeRemoved: dummy\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeAdded: val1\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeUpdated: updatedValue\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyMzI4NA==", "bodyText": "I'd keep the explicit timestamp for now. So far mergeMap is only called in DeploymentMerger, with the timestamp of deploymentDoc. If in the future we need overriding method we can add that.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r450523284", "createdAt": "2020-07-06T23:05:30Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "diffHunk": "@@ -302,4 +304,203 @@ public void GIVEN_config_to_merge_WHEN_read_with_current_timestamp_THEN_merge()\n         assertEquals(\"echo main service installed\",\n                 config.find(SERVICES_NAMESPACE_TOPIC, \"main\", \"lifecycle\", \"install\").getOnce());\n     }\n+\n+    @Test\n+    public void GIVEN_topics_WHEN_call_replace_map_THEN_content_replaced_and_subscribers_invoked() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeToBeRemoved:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  leafToBeUpdated: val2\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeRemoved: dummy\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeAdded: val1\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeUpdated: updatedValue\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2NjQ5Ng=="}, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTYzNDEwOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyNzo0MVrOGsXBCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyNzo0MVrOGsXBCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2NzYyNA==", "bodyText": "nit - I guess you didn't use AtomicBoolean because you want to ensure the count is exactly 1 - If that's the case could you rename the containerNodeRemoved to be containerNodeRemovedCount?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449167624", "createdAt": "2020-07-02T17:27:41Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "diffHunk": "@@ -302,4 +304,203 @@ public void GIVEN_config_to_merge_WHEN_read_with_current_timestamp_THEN_merge()\n         assertEquals(\"echo main service installed\",\n                 config.find(SERVICES_NAMESPACE_TOPIC, \"main\", \"lifecycle\", \"install\").getOnce());\n     }\n+\n+    @Test\n+    public void GIVEN_topics_WHEN_call_replace_map_THEN_content_replaced_and_subscribers_invoked() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeToBeRemoved:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  leafToBeUpdated: val2\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeRemoved: dummy\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeAdded: val1\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeUpdated: updatedValue\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger containerNodeRemoved = new AtomicInteger(0);\n+        config.findTopics(\"foo\", \"nodeToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                containerNodeRemoved.incrementAndGet();\n+            }\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTY0MDYyOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyOTo0NlrOGsXFAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyOTo0NlrOGsXFAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2ODY0MQ==", "bodyText": "Very clear and easy to follow!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449168641", "createdAt": "2020-07-02T17:29:46Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "diffHunk": "@@ -302,4 +304,203 @@ public void GIVEN_config_to_merge_WHEN_read_with_current_timestamp_THEN_merge()\n         assertEquals(\"echo main service installed\",\n                 config.find(SERVICES_NAMESPACE_TOPIC, \"main\", \"lifecycle\", \"install\").getOnce());\n     }\n+\n+    @Test\n+    public void GIVEN_topics_WHEN_call_replace_map_THEN_content_replaced_and_subscribers_invoked() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeToBeRemoved:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  leafToBeUpdated: val2\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeRemoved: dummy\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeAdded: val1\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeUpdated: updatedValue\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger containerNodeRemoved = new AtomicInteger(0);\n+        config.findTopics(\"foo\", \"nodeToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                containerNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicInteger leafNodeRemoved = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                leafNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicBoolean nodeUnchangedNotified = new AtomicBoolean(false);\n+        config.find(\"foo\", \"nodeUnchanged\").subscribe((what, c) -> {\n+            if (WhatHappened.initialized != what) {\n+                nodeUnchangedNotified.set(true);\n+            }\n+        });\n+\n+        AtomicInteger leafNodeUpdated = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeUpdated\").subscribe((what, node) -> {\n+            Topic t = (Topic) node;\n+            if (WhatHappened.changed == what && t.getOnce().equals(\"updatedValue\")) {\n+                leafNodeUpdated.incrementAndGet();\n+            }\n+        });\n+\n+        // WHEN\n+        Map<Object, Object> updateConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(updateConfig.getBytes())) {\n+            updateConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.root.replaceMap(2, updateConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        // THEN\n+        assertEquals(updateConfigMap, config.toPOJO());\n+\n+        assertEquals(1, leafNodeRemoved.get());\n+        assertEquals(1, containerNodeRemoved.get());\n+        assertEquals(1, leafNodeUpdated.get());\n+        assertFalse(nodeUnchangedNotified.get());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTY0MzUwOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozMDo0MFrOGsXGuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowMzoxNFrOGsYH4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2OTA4MQ==", "bodyText": "was this for debugging?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449169081", "createdAt": "2020-07-02T17:30:40Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "diffHunk": "@@ -302,4 +304,203 @@ public void GIVEN_config_to_merge_WHEN_read_with_current_timestamp_THEN_merge()\n         assertEquals(\"echo main service installed\",\n                 config.find(SERVICES_NAMESPACE_TOPIC, \"main\", \"lifecycle\", \"install\").getOnce());\n     }\n+\n+    @Test\n+    public void GIVEN_topics_WHEN_call_replace_map_THEN_content_replaced_and_subscribers_invoked() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeToBeRemoved:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  leafToBeUpdated: val2\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeRemoved: dummy\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeAdded: val1\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeUpdated: updatedValue\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger containerNodeRemoved = new AtomicInteger(0);\n+        config.findTopics(\"foo\", \"nodeToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                containerNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicInteger leafNodeRemoved = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                leafNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicBoolean nodeUnchangedNotified = new AtomicBoolean(false);\n+        config.find(\"foo\", \"nodeUnchanged\").subscribe((what, c) -> {\n+            if (WhatHappened.initialized != what) {\n+                nodeUnchangedNotified.set(true);\n+            }\n+        });\n+\n+        AtomicInteger leafNodeUpdated = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeUpdated\").subscribe((what, node) -> {\n+            Topic t = (Topic) node;\n+            if (WhatHappened.changed == what && t.getOnce().equals(\"updatedValue\")) {\n+                leafNodeUpdated.incrementAndGet();\n+            }\n+        });\n+\n+        // WHEN\n+        Map<Object, Object> updateConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(updateConfig.getBytes())) {\n+            updateConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.root.replaceMap(2, updateConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        // THEN\n+        assertEquals(updateConfigMap, config.toPOJO());\n+\n+        assertEquals(1, leafNodeRemoved.get());\n+        assertEquals(1, containerNodeRemoved.get());\n+        assertEquals(1, leafNodeUpdated.get());\n+        assertFalse(nodeUnchangedNotified.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_config_with_subscribers_WHEN_topic_type_changed_THEN_subscribers_notified() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  node2: val2\\n\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1: val1\\n\"\n+                + \"  node2:\\n\"\n+                + \"    key2: val2\\n\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        Pair<CompletableFuture<Void>, Subscriber> node1Changed = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.nodeTypeChanged, what, node.getFullName() + node.toPOJO());\n+                    assertEquals(\"val1\", ((Topic) node).getOnce());\n+                });\n+        config.findTopics(\"foo\", \"node1\").subscribe(node1Changed.getRight());\n+\n+        Pair<CompletableFuture<Void>, Subscriber> nodeRemoved = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.removed, what, node.getFullName());\n+                });\n+        config.find(\"foo\", \"node1\", \"key1\").subscribe(nodeRemoved.getRight());\n+\n+        Pair<CompletableFuture<Void>, Subscriber> node2Changed = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.nodeTypeChanged, what, node.getFullName());\n+                    assertEquals(\"val2\", ((Topics) node).find(\"key2\").getOnce());\n+                });\n+        config.find(\"foo\", \"node2\").subscribe(node2Changed.getRight());\n+\n+        // WHEN\n+        Map<Object, Object> updateConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(updateConfig.getBytes())) {\n+            updateConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.root.replaceMap(2, updateConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        // THEN\n+        node1Changed.getLeft().get(100, TimeUnit.MILLISECONDS);\n+        node2Changed.getLeft().get(100, TimeUnit.MILLISECONDS);\n+        nodeRemoved.getLeft().get(100, TimeUnit.MILLISECONDS);\n+\n+        assertEquals(updateConfigMap, config.toPOJO());\n+    }\n+\n+    @Test\n+    public void GIVEN_config_with_subscribers_WHEN_topic_type_changed_THEN_parent_node_notified() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  node2: val2\\n\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1: val1\\n\"\n+                + \"  node2:\\n\"\n+                + \"    key2: val2\\n\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger node1Changed = new AtomicInteger();\n+        AtomicInteger node2Changed = new AtomicInteger();\n+        config.findTopics(\"foo\").subscribe((what, node) -> {\n+            if (WhatHappened.childChanged == what) {\n+                System.err.println(\"child changed\" + node.getFullName() + \" \" + node.toPOJO());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTc2MQ==", "bodyText": "oops", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449185761", "createdAt": "2020-07-02T18:03:14Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "diffHunk": "@@ -302,4 +304,203 @@ public void GIVEN_config_to_merge_WHEN_read_with_current_timestamp_THEN_merge()\n         assertEquals(\"echo main service installed\",\n                 config.find(SERVICES_NAMESPACE_TOPIC, \"main\", \"lifecycle\", \"install\").getOnce());\n     }\n+\n+    @Test\n+    public void GIVEN_topics_WHEN_call_replace_map_THEN_content_replaced_and_subscribers_invoked() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeToBeRemoved:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  leafToBeUpdated: val2\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeRemoved: dummy\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeAdded: val1\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeUpdated: updatedValue\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger containerNodeRemoved = new AtomicInteger(0);\n+        config.findTopics(\"foo\", \"nodeToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                containerNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicInteger leafNodeRemoved = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                leafNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicBoolean nodeUnchangedNotified = new AtomicBoolean(false);\n+        config.find(\"foo\", \"nodeUnchanged\").subscribe((what, c) -> {\n+            if (WhatHappened.initialized != what) {\n+                nodeUnchangedNotified.set(true);\n+            }\n+        });\n+\n+        AtomicInteger leafNodeUpdated = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeUpdated\").subscribe((what, node) -> {\n+            Topic t = (Topic) node;\n+            if (WhatHappened.changed == what && t.getOnce().equals(\"updatedValue\")) {\n+                leafNodeUpdated.incrementAndGet();\n+            }\n+        });\n+\n+        // WHEN\n+        Map<Object, Object> updateConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(updateConfig.getBytes())) {\n+            updateConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.root.replaceMap(2, updateConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        // THEN\n+        assertEquals(updateConfigMap, config.toPOJO());\n+\n+        assertEquals(1, leafNodeRemoved.get());\n+        assertEquals(1, containerNodeRemoved.get());\n+        assertEquals(1, leafNodeUpdated.get());\n+        assertFalse(nodeUnchangedNotified.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_config_with_subscribers_WHEN_topic_type_changed_THEN_subscribers_notified() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  node2: val2\\n\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1: val1\\n\"\n+                + \"  node2:\\n\"\n+                + \"    key2: val2\\n\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        Pair<CompletableFuture<Void>, Subscriber> node1Changed = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.nodeTypeChanged, what, node.getFullName() + node.toPOJO());\n+                    assertEquals(\"val1\", ((Topic) node).getOnce());\n+                });\n+        config.findTopics(\"foo\", \"node1\").subscribe(node1Changed.getRight());\n+\n+        Pair<CompletableFuture<Void>, Subscriber> nodeRemoved = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.removed, what, node.getFullName());\n+                });\n+        config.find(\"foo\", \"node1\", \"key1\").subscribe(nodeRemoved.getRight());\n+\n+        Pair<CompletableFuture<Void>, Subscriber> node2Changed = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.nodeTypeChanged, what, node.getFullName());\n+                    assertEquals(\"val2\", ((Topics) node).find(\"key2\").getOnce());\n+                });\n+        config.find(\"foo\", \"node2\").subscribe(node2Changed.getRight());\n+\n+        // WHEN\n+        Map<Object, Object> updateConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(updateConfig.getBytes())) {\n+            updateConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.root.replaceMap(2, updateConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        // THEN\n+        node1Changed.getLeft().get(100, TimeUnit.MILLISECONDS);\n+        node2Changed.getLeft().get(100, TimeUnit.MILLISECONDS);\n+        nodeRemoved.getLeft().get(100, TimeUnit.MILLISECONDS);\n+\n+        assertEquals(updateConfigMap, config.toPOJO());\n+    }\n+\n+    @Test\n+    public void GIVEN_config_with_subscribers_WHEN_topic_type_changed_THEN_parent_node_notified() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  node2: val2\\n\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1: val1\\n\"\n+                + \"  node2:\\n\"\n+                + \"    key2: val2\\n\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger node1Changed = new AtomicInteger();\n+        AtomicInteger node2Changed = new AtomicInteger();\n+        config.findTopics(\"foo\").subscribe((what, node) -> {\n+            if (WhatHappened.childChanged == what) {\n+                System.err.println(\"child changed\" + node.getFullName() + \" \" + node.toPOJO());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2OTA4MQ=="}, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTY0ODE3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozMTo1OFrOGsXJeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowMzozNlrOGsYIkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2OTc4NQ==", "bodyText": "will we receive \"nodeTypeChanged\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449169785", "createdAt": "2020-07-02T17:31:58Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "diffHunk": "@@ -302,4 +304,203 @@ public void GIVEN_config_to_merge_WHEN_read_with_current_timestamp_THEN_merge()\n         assertEquals(\"echo main service installed\",\n                 config.find(SERVICES_NAMESPACE_TOPIC, \"main\", \"lifecycle\", \"install\").getOnce());\n     }\n+\n+    @Test\n+    public void GIVEN_topics_WHEN_call_replace_map_THEN_content_replaced_and_subscribers_invoked() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeToBeRemoved:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  leafToBeUpdated: val2\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeRemoved: dummy\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeAdded: val1\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeUpdated: updatedValue\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger containerNodeRemoved = new AtomicInteger(0);\n+        config.findTopics(\"foo\", \"nodeToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                containerNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicInteger leafNodeRemoved = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                leafNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicBoolean nodeUnchangedNotified = new AtomicBoolean(false);\n+        config.find(\"foo\", \"nodeUnchanged\").subscribe((what, c) -> {\n+            if (WhatHappened.initialized != what) {\n+                nodeUnchangedNotified.set(true);\n+            }\n+        });\n+\n+        AtomicInteger leafNodeUpdated = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeUpdated\").subscribe((what, node) -> {\n+            Topic t = (Topic) node;\n+            if (WhatHappened.changed == what && t.getOnce().equals(\"updatedValue\")) {\n+                leafNodeUpdated.incrementAndGet();\n+            }\n+        });\n+\n+        // WHEN\n+        Map<Object, Object> updateConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(updateConfig.getBytes())) {\n+            updateConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.root.replaceMap(2, updateConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        // THEN\n+        assertEquals(updateConfigMap, config.toPOJO());\n+\n+        assertEquals(1, leafNodeRemoved.get());\n+        assertEquals(1, containerNodeRemoved.get());\n+        assertEquals(1, leafNodeUpdated.get());\n+        assertFalse(nodeUnchangedNotified.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_config_with_subscribers_WHEN_topic_type_changed_THEN_subscribers_notified() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  node2: val2\\n\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1: val1\\n\"\n+                + \"  node2:\\n\"\n+                + \"    key2: val2\\n\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        Pair<CompletableFuture<Void>, Subscriber> node1Changed = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.nodeTypeChanged, what, node.getFullName() + node.toPOJO());\n+                    assertEquals(\"val1\", ((Topic) node).getOnce());\n+                });\n+        config.findTopics(\"foo\", \"node1\").subscribe(node1Changed.getRight());\n+\n+        Pair<CompletableFuture<Void>, Subscriber> nodeRemoved = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.removed, what, node.getFullName());\n+                });\n+        config.find(\"foo\", \"node1\", \"key1\").subscribe(nodeRemoved.getRight());\n+\n+        Pair<CompletableFuture<Void>, Subscriber> node2Changed = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.nodeTypeChanged, what, node.getFullName());\n+                    assertEquals(\"val2\", ((Topics) node).find(\"key2\").getOnce());\n+                });\n+        config.find(\"foo\", \"node2\").subscribe(node2Changed.getRight());\n+\n+        // WHEN\n+        Map<Object, Object> updateConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(updateConfig.getBytes())) {\n+            updateConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.root.replaceMap(2, updateConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        // THEN\n+        node1Changed.getLeft().get(100, TimeUnit.MILLISECONDS);\n+        node2Changed.getLeft().get(100, TimeUnit.MILLISECONDS);\n+        nodeRemoved.getLeft().get(100, TimeUnit.MILLISECONDS);\n+\n+        assertEquals(updateConfigMap, config.toPOJO());\n+    }\n+\n+    @Test\n+    public void GIVEN_config_with_subscribers_WHEN_topic_type_changed_THEN_parent_node_notified() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  node2: val2\\n\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1: val1\\n\"\n+                + \"  node2:\\n\"\n+                + \"    key2: val2\\n\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger node1Changed = new AtomicInteger();\n+        AtomicInteger node2Changed = new AtomicInteger();\n+        config.findTopics(\"foo\").subscribe((what, node) -> {\n+            if (WhatHappened.childChanged == what) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTkzOA==", "bodyText": "this is the parent node. It will only get childChanged notification", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449185938", "createdAt": "2020-07-02T18:03:36Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/config/ConfigurationTest.java", "diffHunk": "@@ -302,4 +304,203 @@ public void GIVEN_config_to_merge_WHEN_read_with_current_timestamp_THEN_merge()\n         assertEquals(\"echo main service installed\",\n                 config.find(SERVICES_NAMESPACE_TOPIC, \"main\", \"lifecycle\", \"install\").getOnce());\n     }\n+\n+    @Test\n+    public void GIVEN_topics_WHEN_call_replace_map_THEN_content_replaced_and_subscribers_invoked() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeToBeRemoved:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  leafToBeUpdated: val2\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeRemoved: dummy\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  nodeAdded: val1\\n\"\n+                + \"  nodeUnchanged: unchanged\\n\"\n+                + \"  leafToBeUpdated: updatedValue\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger containerNodeRemoved = new AtomicInteger(0);\n+        config.findTopics(\"foo\", \"nodeToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                containerNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicInteger leafNodeRemoved = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeRemoved\").subscribe((what, c) -> {\n+            if (WhatHappened.removed == what) {\n+                leafNodeRemoved.incrementAndGet();\n+            }\n+        });\n+\n+        AtomicBoolean nodeUnchangedNotified = new AtomicBoolean(false);\n+        config.find(\"foo\", \"nodeUnchanged\").subscribe((what, c) -> {\n+            if (WhatHappened.initialized != what) {\n+                nodeUnchangedNotified.set(true);\n+            }\n+        });\n+\n+        AtomicInteger leafNodeUpdated = new AtomicInteger(0);\n+        config.find(\"foo\", \"leafToBeUpdated\").subscribe((what, node) -> {\n+            Topic t = (Topic) node;\n+            if (WhatHappened.changed == what && t.getOnce().equals(\"updatedValue\")) {\n+                leafNodeUpdated.incrementAndGet();\n+            }\n+        });\n+\n+        // WHEN\n+        Map<Object, Object> updateConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(updateConfig.getBytes())) {\n+            updateConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.root.replaceMap(2, updateConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        // THEN\n+        assertEquals(updateConfigMap, config.toPOJO());\n+\n+        assertEquals(1, leafNodeRemoved.get());\n+        assertEquals(1, containerNodeRemoved.get());\n+        assertEquals(1, leafNodeUpdated.get());\n+        assertFalse(nodeUnchangedNotified.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_config_with_subscribers_WHEN_topic_type_changed_THEN_subscribers_notified() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  node2: val2\\n\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1: val1\\n\"\n+                + \"  node2:\\n\"\n+                + \"    key2: val2\\n\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        Pair<CompletableFuture<Void>, Subscriber> node1Changed = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.nodeTypeChanged, what, node.getFullName() + node.toPOJO());\n+                    assertEquals(\"val1\", ((Topic) node).getOnce());\n+                });\n+        config.findTopics(\"foo\", \"node1\").subscribe(node1Changed.getRight());\n+\n+        Pair<CompletableFuture<Void>, Subscriber> nodeRemoved = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.removed, what, node.getFullName());\n+                });\n+        config.find(\"foo\", \"node1\", \"key1\").subscribe(nodeRemoved.getRight());\n+\n+        Pair<CompletableFuture<Void>, Subscriber> node2Changed = createSingleAssertSubscriber((what, node) -> {\n+                    assertEquals(WhatHappened.nodeTypeChanged, what, node.getFullName());\n+                    assertEquals(\"val2\", ((Topics) node).find(\"key2\").getOnce());\n+                });\n+        config.find(\"foo\", \"node2\").subscribe(node2Changed.getRight());\n+\n+        // WHEN\n+        Map<Object, Object> updateConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(updateConfig.getBytes())) {\n+            updateConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.root.replaceMap(2, updateConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        // THEN\n+        node1Changed.getLeft().get(100, TimeUnit.MILLISECONDS);\n+        node2Changed.getLeft().get(100, TimeUnit.MILLISECONDS);\n+        nodeRemoved.getLeft().get(100, TimeUnit.MILLISECONDS);\n+\n+        assertEquals(updateConfigMap, config.toPOJO());\n+    }\n+\n+    @Test\n+    public void GIVEN_config_with_subscribers_WHEN_topic_type_changed_THEN_parent_node_notified() throws Exception {\n+        // GIVEN\n+        // set up initial config and listeners\n+        String initConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1:\\n\"\n+                + \"    key1: val1\\n\"\n+                + \"  node2: val2\\n\";\n+\n+        String updateConfig = \"---\\n\"\n+                + \"foo:\\n\"\n+                + \"  node1: val1\\n\"\n+                + \"  node2:\\n\"\n+                + \"    key2: val2\\n\";\n+\n+        Map<Object, Object> initConfigMap;\n+        try (InputStream inputStream = new ByteArrayInputStream(initConfig.getBytes())) {\n+            initConfigMap = (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream);\n+        }\n+        config.mergeMap(1, initConfigMap);\n+        config.context.runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicInteger node1Changed = new AtomicInteger();\n+        AtomicInteger node2Changed = new AtomicInteger();\n+        config.findTopics(\"foo\").subscribe((what, node) -> {\n+            if (WhatHappened.childChanged == what) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2OTc4NQ=="}, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTY1Mzc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozMzo1MFrOGsXNKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMjoyNjoyNVrOGu_e4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDcyOA==", "bodyText": "edge case - check if map is null or empty.  Especially when it is null, map.forEach will throw NPE...", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449170728", "createdAt": "2020-07-02T17:33:50Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -209,6 +211,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyODUyOQ==", "bodyText": "I don't know what's the expected behavior of null map. Should it fail silently?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449228529", "createdAt": "2020-07-02T19:35:56Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -209,6 +211,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDcyOA=="}, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgyNDg5MA==", "bodyText": "I think it should either fail or just skip. Right now it will throw NPE at line 232. Maybe we can add a TODO and merge this in first?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r451824890", "createdAt": "2020-07-08T21:05:23Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -209,6 +211,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDcyOA=="}, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkyNzc3OQ==", "bodyText": "I added null check to skip", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r451927779", "createdAt": "2020-07-09T02:26:25Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -209,6 +211,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDcyOA=="}, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTY3Mzg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozOTo1N1rOGsXZOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDoxOFrOGsYJ6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MzgxNw==", "bodyText": "I see you are approaching this with 4 branches here: leaf -> container, leaf -> leaf, container -> container, and container -> leaf.\nSo I would suggest move this comment down btw current line 229 and 230. And also add the missing comment for leaf -> leaf and container -> container just to be clear and consistent.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449173817", "createdAt": "2020-07-02T17:39:57Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -209,6 +211,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjI4MQ==", "bodyText": "sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449186281", "createdAt": "2020-07-02T18:04:18Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -209,6 +211,70 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        Set<String> childToRemove = new HashSet<>(children.keySet());\n+\n+        map.forEach((okey, value) -> {\n+            String key = okey.toString();\n+            childToRemove.remove(key);\n+            Node existingChild = children.get(key);\n+            if (value instanceof Map) {\n+                // if a leaf node is replaced with container node", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MzgxNw=="}, "originalCommit": {"oid": "7c3dedee224bdaf2200d6e0ac2b3d4c67744be4a"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMDI2MjMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/WhatHappened.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMTowODoyOVrOGsdD6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzowODo0MVrOGtgBlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NjY2Ng==", "bodyText": "These additional enum values here look redundant to me. I think what you're using these for can be achieved using the existing childChanged event because you fire changedToTopics / changedToTopic event in Topics->replaceMap() only to transform them to WhatHappened.childChanged at Topics.java:364 and Topic.java:151. Other than that these are only used in a test class for assertions, can't we do that without introducing new events? Or am I missing something?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r449266666", "createdAt": "2020-07-02T21:08:29Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/WhatHappened.java", "diffHunk": "@@ -4,5 +4,5 @@\n package com.aws.iot.evergreen.config;\n \n public enum WhatHappened {\n-    changed, initialized, childChanged, removed, childRemoved\n+    changed, initialized, childChanged, removed, childRemoved, changedToTopic, changedToTopics", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "938499640d173d9ae2585bd7cda9eafcb8928b11"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2Mzc5OQ==", "bodyText": "I plan to separate out the PR of node type switching.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r450363799", "createdAt": "2020-07-06T17:08:41Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/WhatHappened.java", "diffHunk": "@@ -4,5 +4,5 @@\n package com.aws.iot.evergreen.config;\n \n public enum WhatHappened {\n-    changed, initialized, childChanged, removed, childRemoved\n+    changed, initialized, childChanged, removed, childRemoved, changedToTopic, changedToTopics", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NjY2Ng=="}, "originalCommit": {"oid": "938499640d173d9ae2585bd7cda9eafcb8928b11"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDI0MjM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNjowMjoxOVrOGvXzVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNjo0NzoxMlrOGvZe-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMyNjIzMA==", "bodyText": "return?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r452326230", "createdAt": "2020-07-09T16:02:19Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -209,6 +225,46 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    @SuppressFBWarnings(\"NP_NULL_ON_SOME_PATH\")\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        if (map == null) {\n+            logger.atInfo().kv(\"node\", getFullName()).log(\"Null map received in mergeMap(), ignoring.\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05d97a862d1736a932372a2b4ba30fded3a3de97"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1Mzc4NA==", "bodyText": "Ooops", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r452353784", "createdAt": "2020-07-09T16:47:12Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -209,6 +225,46 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    @SuppressFBWarnings(\"NP_NULL_ON_SOME_PATH\")\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        if (map == null) {\n+            logger.atInfo().kv(\"node\", getFullName()).log(\"Null map received in mergeMap(), ignoring.\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjMyNjIzMA=="}, "originalCommit": {"oid": "05d97a862d1736a932372a2b4ba30fded3a3de97"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTU5MDM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzoxODozM1rOGydQUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTo1NDo0N1rOGyxgQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2MTI5OQ==", "bodyText": "this warning means that a null dereference is inevitable. Shouldn't it be fixed instead of ignored?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r455561299", "createdAt": "2020-07-16T07:18:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -192,13 +195,27 @@ public Topics findTopics(String... path) {\n         return n;\n     }\n \n+    protected Node findNode(String... path) {\n+        int limit = path.length - 1;\n+        Topics n = this;\n+        for (int i = 0; i < limit && n != null; i++) {\n+            n = n.findInteriorChild(path[i]);\n+        }\n+        return n == null ? null : n.getChild(path[limit]);\n+    }\n+\n     /**\n      * Add the given map to this Topics tree.\n      *\n      * @param lastModified last modified time\n      * @param map          map to merge in\n      */\n+    @SuppressFBWarnings(\"NP_NULL_ON_SOME_PATH\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84b7335f6789359dcb1fc804be00d0c9eb9ec361"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5MzA1OQ==", "bodyText": "Not really. This warning just means there exist a code path that the value is always null. It doesn't check whether you refer to the value in the code path. http://findbugs.sourceforge.net/bugDescriptions.html", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r455893059", "createdAt": "2020-07-16T15:54:47Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -192,13 +195,27 @@ public Topics findTopics(String... path) {\n         return n;\n     }\n \n+    protected Node findNode(String... path) {\n+        int limit = path.length - 1;\n+        Topics n = this;\n+        for (int i = 0; i < limit && n != null; i++) {\n+            n = n.findInteriorChild(path[i]);\n+        }\n+        return n == null ? null : n.getChild(path[limit]);\n+    }\n+\n     /**\n      * Add the given map to this Topics tree.\n      *\n      * @param lastModified last modified time\n      * @param map          map to merge in\n      */\n+    @SuppressFBWarnings(\"NP_NULL_ON_SOME_PATH\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2MTI5OQ=="}, "originalCommit": {"oid": "84b7335f6789359dcb1fc804be00d0c9eb9ec361"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTU5Nzg1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzoyMDozOFrOGydUuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTo1MDo1OVrOGyxVWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2MjQyNQ==", "bodyText": "why do we need this change? This code was working before somehow", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r455562425", "createdAt": "2020-07-16T07:20:38Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -197,8 +198,9 @@ public void GIVEN_waitForServicesToStart_WHEN_service_reached_desired_state_THEN\n         assertFalse(serviceStarted.await(3*WAIT_SVC_START_POLL_INTERVAL_MILLISEC, TimeUnit.MILLISECONDS));\n \n         // WHEN\n-        when(mockService.getState()).thenReturn(State.RUNNING);\n-        when(mockService.reachedDesiredState()).thenReturn(true);\n+        // use doReturn() here: https://stackoverflow.com/questions/11121772\n+        doReturn(State.RUNNING).when(mockService).getState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84b7335f6789359dcb1fc804be00d0c9eb9ec361"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5MDI2Ng==", "bodyText": "I see the test case fails intermittently in github actions with WrongTypeOfReturnValue", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r455890266", "createdAt": "2020-07-16T15:50:59Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -197,8 +198,9 @@ public void GIVEN_waitForServicesToStart_WHEN_service_reached_desired_state_THEN\n         assertFalse(serviceStarted.await(3*WAIT_SVC_START_POLL_INTERVAL_MILLISEC, TimeUnit.MILLISECONDS));\n \n         // WHEN\n-        when(mockService.getState()).thenReturn(State.RUNNING);\n-        when(mockService.reachedDesiredState()).thenReturn(true);\n+        // use doReturn() here: https://stackoverflow.com/questions/11121772\n+        doReturn(State.RUNNING).when(mockService).getState();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2MjQyNQ=="}, "originalCommit": {"oid": "84b7335f6789359dcb1fc804be00d0c9eb9ec361"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODMxODA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNTozMlrOGzdRzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNTozMlrOGzdRzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMDI1Mg==", "bodyText": "nit: error message should be replaceMap", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/282#discussion_r456610252", "createdAt": "2020-07-17T18:35:32Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topics.java", "diffHunk": "@@ -209,6 +226,47 @@ public void mergeMap(long lastModified, Map<Object, Object> map) {\n         });\n     }\n \n+    /**\n+     * Replace the given map to this Topics tree.\n+     *\n+     * @param lastModified last modified time\n+     * @param map          map to merge in\n+     */\n+    @SuppressFBWarnings(\"NP_NULL_ON_SOME_PATH\")\n+    public void replaceMap(long lastModified, Map<Object, Object> map) {\n+        if (map == null) {\n+            logger.atInfo().kv(\"node\", getFullName()).log(\"Null map received in mergeMap(), ignoring.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "009b69d8d0cea0c61c2508b52c65f805384c86f5"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4349, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}