{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMzczMTc0", "number": 162, "reviewThreads": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNjozMDoxN1rODvpMBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwMDowNjoxNVrODw48zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjg0NDg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNjozMDoxN1rOGCMCXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjoyMzo1MVrOGEr_9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0NzU1MQ==", "bodyText": "Do we really want an Iterator, or just an Iterable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r404947551", "createdAt": "2020-04-07T16:30:17Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -137,22 +135,20 @@\n         logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(PACKAGE_NAME_KEY, pkgName).log();\n \n         // Compile a list of versions to explore for this package in order\n-        //TODO return iterator\n-        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n-        if (versionsToExplore.isEmpty()) {\n+        Iterator<PackageMetadata> versionsToExplore =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1OTMxMQ==", "bodyText": "Iterator. We want to do next() on it instead of for each lop.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405159311", "createdAt": "2020-04-07T22:51:24Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -137,22 +135,20 @@\n         logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(PACKAGE_NAME_KEY, pkgName).log();\n \n         // Compile a list of versions to explore for this package in order\n-        //TODO return iterator\n-        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n-        if (versionsToExplore.isEmpty()) {\n+        Iterator<PackageMetadata> versionsToExplore =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0NzU1MQ=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM0NTcxNg==", "bodyText": "Couldn't you return a list from the method and do .iterator() on it where you call the method?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406345716", "createdAt": "2020-04-09T16:59:48Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -137,22 +135,20 @@\n         logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(PACKAGE_NAME_KEY, pkgName).log();\n \n         // Compile a list of versions to explore for this package in order\n-        //TODO return iterator\n-        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n-        if (versionsToExplore.isEmpty()) {\n+        Iterator<PackageMetadata> versionsToExplore =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0NzU1MQ=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2ODM3Mw==", "bodyText": "In the next step, we are going to implement our customized iterator, which would enable 'lazy' iteration, instead of always reading the whole list from disk (imagining we have many versions locally). List is a temporary solution to take us there step by step :)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407568373", "createdAt": "2020-04-13T16:23:51Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -137,22 +135,20 @@\n         logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(PACKAGE_NAME_KEY, pkgName).log();\n \n         // Compile a list of versions to explore for this package in order\n-        //TODO return iterator\n-        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n-        if (versionsToExplore.isEmpty()) {\n+        Iterator<PackageMetadata> versionsToExplore =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0NzU1MQ=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE1MjU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo0NjozNFrOGCPF4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjo1MjoyNFrOGCY--w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5NzYwMA==", "bodyText": "Isn't this log wrong? Can you actually print just the version instead of whatever else is in the metadata?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r404997600", "createdAt": "2020-04-07T17:46:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -137,22 +135,20 @@\n         logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(PACKAGE_NAME_KEY, pkgName).log();\n \n         // Compile a list of versions to explore for this package in order\n-        //TODO return iterator\n-        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n-        if (versionsToExplore.isEmpty()) {\n+        Iterator<PackageMetadata> versionsToExplore =\n+                listPackageMetadataToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n+        if (!versionsToExplore.hasNext()) {\n             errorMessage = Optional.of(buildErrorMessage(pkgName, resolvedPackageNameToVersion,\n                     packageNameToVersionConstraints.get(pkgName)));\n         }\n \n-        for (Semver version : versionsToExplore) {\n+        while (versionsToExplore.hasNext()) {\n+            PackageMetadata packageMetadata = versionsToExplore.next();\n             logger.atTrace().setEventType(\"resolve-package-attempt\").addKeyValue(PACKAGE_NAME_KEY, pkgName)\n-                    .addKeyValue(VERSION_KEY, version).log();\n-\n-            // Get package recipe\n-            Package pkgRecipe = getPackage(pkgName, version);\n+                    .addKeyValue(VERSION_KEY, packageMetadata).log();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1OTY3NQ==", "bodyText": "I can. Changed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405159675", "createdAt": "2020-04-07T22:52:24Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -137,22 +135,20 @@\n         logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(PACKAGE_NAME_KEY, pkgName).log();\n \n         // Compile a list of versions to explore for this package in order\n-        //TODO return iterator\n-        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n-        if (versionsToExplore.isEmpty()) {\n+        Iterator<PackageMetadata> versionsToExplore =\n+                listPackageMetadataToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n+        if (!versionsToExplore.hasNext()) {\n             errorMessage = Optional.of(buildErrorMessage(pkgName, resolvedPackageNameToVersion,\n                     packageNameToVersionConstraints.get(pkgName)));\n         }\n \n-        for (Semver version : versionsToExplore) {\n+        while (versionsToExplore.hasNext()) {\n+            PackageMetadata packageMetadata = versionsToExplore.next();\n             logger.atTrace().setEventType(\"resolve-package-attempt\").addKeyValue(PACKAGE_NAME_KEY, pkgName)\n-                    .addKeyValue(VERSION_KEY, version).log();\n-\n-            // Get package recipe\n-            Package pkgRecipe = getPackage(pkgName, version);\n+                    .addKeyValue(VERSION_KEY, packageMetadata).log();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5NzYwMA=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE1NDUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo0NzowNFrOGCPHDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjo1MzowMlrOGCZABw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5NzkwMA==", "bodyText": "Use your VERSION key, and then same comment as above.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r404997900", "createdAt": "2020-04-07T17:47:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -191,7 +187,7 @@\n                 continue;\n             }\n             packagesToResolve.addAll(newDependencyPackagesToResolve);\n-            logger.atTrace().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(\"packageVersion\", version)\n+            logger.atTrace().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(\"packageVersion\", packageMetadata)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1OTk0Mw==", "bodyText": "Good catch. Didn't pay too much attention to the log when moving the logic. Changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405159943", "createdAt": "2020-04-07T22:53:02Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -191,7 +187,7 @@\n                 continue;\n             }\n             packagesToResolve.addAll(newDependencyPackagesToResolve);\n-            logger.atTrace().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(\"packageVersion\", version)\n+            logger.atTrace().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(\"packageVersion\", packageMetadata)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5NzkwMA=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE1NzE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo0Nzo0OFrOGCPI6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjo1MzoxMlrOGCZAMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5ODM3Nw==", "bodyText": "typo: map from depending...", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r404998377", "createdAt": "2020-04-07T17:47:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -238,22 +234,21 @@\n     }\n \n     /**\n-     * // TODO move to local package store\n-     * Get a ordered list of possible versions to explore for the given package.\n+     * Returns a iterator of ordered available PackageMetadata to explore for the given package.\n      *\n      * @param pkgName                     name of the package to be explored\n-     * @param packageToVersionConstraints list of version constraints for the package\n-     * @return list of versions as Semver instances\n+     * @param packageToVersionConstraints map from of depending package's name, to it's version constraint", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1OTk4Ng==", "bodyText": "Done.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405159986", "createdAt": "2020-04-07T22:53:12Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -238,22 +234,21 @@\n     }\n \n     /**\n-     * // TODO move to local package store\n-     * Get a ordered list of possible versions to explore for the given package.\n+     * Returns a iterator of ordered available PackageMetadata to explore for the given package.\n      *\n      * @param pkgName                     name of the package to be explored\n-     * @param packageToVersionConstraints list of version constraints for the package\n-     * @return list of versions as Semver instances\n+     * @param packageToVersionConstraints map from of depending package's name, to it's version constraint", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5ODM3Nw=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE1Nzk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo0ODowMVrOGCPJZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjo1MzoxN1rOGCZAUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5ODUwMA==", "bodyText": "typo: an iterator.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r404998500", "createdAt": "2020-04-07T17:48:01Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -238,22 +234,21 @@\n     }\n \n     /**\n-     * // TODO move to local package store\n-     * Get a ordered list of possible versions to explore for the given package.\n+     * Returns a iterator of ordered available PackageMetadata to explore for the given package.\n      *\n      * @param pkgName                     name of the package to be explored\n-     * @param packageToVersionConstraints list of version constraints for the package\n-     * @return list of versions as Semver instances\n+     * @param packageToVersionConstraints map from of depending package's name, to it's version constraint\n+     * @return a iterator of ordered available PackageMetadata", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2MDAxOQ==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405160019", "createdAt": "2020-04-07T22:53:17Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -238,22 +234,21 @@\n     }\n \n     /**\n-     * // TODO move to local package store\n-     * Get a ordered list of possible versions to explore for the given package.\n+     * Returns a iterator of ordered available PackageMetadata to explore for the given package.\n      *\n      * @param pkgName                     name of the package to be explored\n-     * @param packageToVersionConstraints list of version constraints for the package\n-     * @return list of versions as Semver instances\n+     * @param packageToVersionConstraints map from of depending package's name, to it's version constraint\n+     * @return a iterator of ordered available PackageMetadata", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5ODUwMA=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE3NDg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo1MjoyOVrOGCPUVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMzowMDo1OVrOGCZL_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwMTMwMA==", "bodyText": "Why are you adding to the beginning and then removing the same thing?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405001300", "createdAt": "2020-04-07T17:52:29Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -49,14 +68,46 @@ public PackageStore(Path packageStorePath) {\n     }\n \n     /**\n-     * Get package versions with the most preferred version first.\n-     * @param pkgName the package name\n-     * @param versionConstraint a version range\n-     * @return a iterator for package metadata with the most preferred one first\n+     * List the package metadata for available package versions that satisfy the requirement.\n+     * It is ordered by the active version first if found, followed by available versions locally.\n+     *\n+     * @param packageName        the package name\n+     * @param versionRequirement the version requirement for this package\n+     * @return a iterator of PackageMetadata, with the active version first if found, followed by available versions\n+     *     locally.\n      */\n-    Iterator<PackageMetadata> getPackageMetadata(String pkgName, String versionConstraint) {\n-        // TODO to be implemented\n-        return null;\n+    Iterator<PackageMetadata> listAvailablePackageMetadata(String packageName, Requirement versionRequirement)\n+            throws PackagingException, IOException {\n+        // TODO Switch to customized Iterator to enable lazy iteration\n+\n+        // 1. Find the version if this package is currently active with some version and it is satisfied by requirement\n+        Optional<PackageMetadata> optionalActivePackageMetadata =\n+                findActiveAndSatisfiedPackageMetadata(packageName, versionRequirement);\n+\n+        // 2. list available packages locally\n+        List<PackageMetadata> packageMetadataList = listAvailablePackageMetadataFromLocal(packageName, versionRequirement);\n+\n+        // 3. If the active satisfied version presents, set it as the head of list.\n+        if (optionalActivePackageMetadata.isPresent()) {\n+            PackageMetadata activePackageMetadata = optionalActivePackageMetadata.get();\n+\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .addKeyValue(VERSION_KEY, activePackageMetadata.getPackageIdentifier().getVersion())\n+                    .log(\"Found active version for dependency package and it is satisfied by the version requirement.\"\n+                            + \" Setting it as the head of the available package list.\");\n+\n+            packageMetadataList.add(0, activePackageMetadata);\n+            packageMetadataList.remove(activePackageMetadata);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzMTczMQ==", "bodyText": "You should probably remove first then add at index 0, remove operation removes the first occurrence of the element", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405131731", "createdAt": "2020-04-07T21:44:14Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -49,14 +68,46 @@ public PackageStore(Path packageStorePath) {\n     }\n \n     /**\n-     * Get package versions with the most preferred version first.\n-     * @param pkgName the package name\n-     * @param versionConstraint a version range\n-     * @return a iterator for package metadata with the most preferred one first\n+     * List the package metadata for available package versions that satisfy the requirement.\n+     * It is ordered by the active version first if found, followed by available versions locally.\n+     *\n+     * @param packageName        the package name\n+     * @param versionRequirement the version requirement for this package\n+     * @return a iterator of PackageMetadata, with the active version first if found, followed by available versions\n+     *     locally.\n      */\n-    Iterator<PackageMetadata> getPackageMetadata(String pkgName, String versionConstraint) {\n-        // TODO to be implemented\n-        return null;\n+    Iterator<PackageMetadata> listAvailablePackageMetadata(String packageName, Requirement versionRequirement)\n+            throws PackagingException, IOException {\n+        // TODO Switch to customized Iterator to enable lazy iteration\n+\n+        // 1. Find the version if this package is currently active with some version and it is satisfied by requirement\n+        Optional<PackageMetadata> optionalActivePackageMetadata =\n+                findActiveAndSatisfiedPackageMetadata(packageName, versionRequirement);\n+\n+        // 2. list available packages locally\n+        List<PackageMetadata> packageMetadataList = listAvailablePackageMetadataFromLocal(packageName, versionRequirement);\n+\n+        // 3. If the active satisfied version presents, set it as the head of list.\n+        if (optionalActivePackageMetadata.isPresent()) {\n+            PackageMetadata activePackageMetadata = optionalActivePackageMetadata.get();\n+\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .addKeyValue(VERSION_KEY, activePackageMetadata.getPackageIdentifier().getVersion())\n+                    .log(\"Found active version for dependency package and it is satisfied by the version requirement.\"\n+                            + \" Setting it as the head of the available package list.\");\n+\n+            packageMetadataList.add(0, activePackageMetadata);\n+            packageMetadataList.remove(activePackageMetadata);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwMTMwMA=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2MjQwMg==", "bodyText": "Why are you adding to the beginning and then removing the same thing?\n\nBecause it is very silly mistake. \ud83d\ude02", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405162402", "createdAt": "2020-04-07T22:59:25Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -49,14 +68,46 @@ public PackageStore(Path packageStorePath) {\n     }\n \n     /**\n-     * Get package versions with the most preferred version first.\n-     * @param pkgName the package name\n-     * @param versionConstraint a version range\n-     * @return a iterator for package metadata with the most preferred one first\n+     * List the package metadata for available package versions that satisfy the requirement.\n+     * It is ordered by the active version first if found, followed by available versions locally.\n+     *\n+     * @param packageName        the package name\n+     * @param versionRequirement the version requirement for this package\n+     * @return a iterator of PackageMetadata, with the active version first if found, followed by available versions\n+     *     locally.\n      */\n-    Iterator<PackageMetadata> getPackageMetadata(String pkgName, String versionConstraint) {\n-        // TODO to be implemented\n-        return null;\n+    Iterator<PackageMetadata> listAvailablePackageMetadata(String packageName, Requirement versionRequirement)\n+            throws PackagingException, IOException {\n+        // TODO Switch to customized Iterator to enable lazy iteration\n+\n+        // 1. Find the version if this package is currently active with some version and it is satisfied by requirement\n+        Optional<PackageMetadata> optionalActivePackageMetadata =\n+                findActiveAndSatisfiedPackageMetadata(packageName, versionRequirement);\n+\n+        // 2. list available packages locally\n+        List<PackageMetadata> packageMetadataList = listAvailablePackageMetadataFromLocal(packageName, versionRequirement);\n+\n+        // 3. If the active satisfied version presents, set it as the head of list.\n+        if (optionalActivePackageMetadata.isPresent()) {\n+            PackageMetadata activePackageMetadata = optionalActivePackageMetadata.get();\n+\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .addKeyValue(VERSION_KEY, activePackageMetadata.getPackageIdentifier().getVersion())\n+                    .log(\"Found active version for dependency package and it is satisfied by the version requirement.\"\n+                            + \" Setting it as the head of the available package list.\");\n+\n+            packageMetadataList.add(0, activePackageMetadata);\n+            packageMetadataList.remove(activePackageMetadata);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwMTMwMA=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2MzAwNA==", "bodyText": "You should probably remove first then add at index 0, remove operation removes the first occurrence of the element\n\nYes. Changed. \ud83d\ude02", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405163004", "createdAt": "2020-04-07T23:00:59Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -49,14 +68,46 @@ public PackageStore(Path packageStorePath) {\n     }\n \n     /**\n-     * Get package versions with the most preferred version first.\n-     * @param pkgName the package name\n-     * @param versionConstraint a version range\n-     * @return a iterator for package metadata with the most preferred one first\n+     * List the package metadata for available package versions that satisfy the requirement.\n+     * It is ordered by the active version first if found, followed by available versions locally.\n+     *\n+     * @param packageName        the package name\n+     * @param versionRequirement the version requirement for this package\n+     * @return a iterator of PackageMetadata, with the active version first if found, followed by available versions\n+     *     locally.\n      */\n-    Iterator<PackageMetadata> getPackageMetadata(String pkgName, String versionConstraint) {\n-        // TODO to be implemented\n-        return null;\n+    Iterator<PackageMetadata> listAvailablePackageMetadata(String packageName, Requirement versionRequirement)\n+            throws PackagingException, IOException {\n+        // TODO Switch to customized Iterator to enable lazy iteration\n+\n+        // 1. Find the version if this package is currently active with some version and it is satisfied by requirement\n+        Optional<PackageMetadata> optionalActivePackageMetadata =\n+                findActiveAndSatisfiedPackageMetadata(packageName, versionRequirement);\n+\n+        // 2. list available packages locally\n+        List<PackageMetadata> packageMetadataList = listAvailablePackageMetadataFromLocal(packageName, versionRequirement);\n+\n+        // 3. If the active satisfied version presents, set it as the head of list.\n+        if (optionalActivePackageMetadata.isPresent()) {\n+            PackageMetadata activePackageMetadata = optionalActivePackageMetadata.get();\n+\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .addKeyValue(VERSION_KEY, activePackageMetadata.getPackageIdentifier().getVersion())\n+                    .log(\"Found active version for dependency package and it is satisfied by the version requirement.\"\n+                            + \" Setting it as the head of the available package list.\");\n+\n+            packageMetadataList.add(0, activePackageMetadata);\n+            packageMetadataList.remove(activePackageMetadata);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwMTMwMA=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE5MjIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo1NzoxMlrOGCPf3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMzowNDo0NlrOGCZRIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNDI1NQ==", "bodyText": "combine these strings since they're on the same line now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405004255", "createdAt": "2020-04-07T17:57:12Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -66,8 +117,8 @@ public PackageStore(Path packageStorePath) {\n      * @param pkgs a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n+    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\",\n+            justification = \"Waiting for package cache \" + \"implementation to be completed\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NDMyMQ==", "bodyText": "Sure.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405164321", "createdAt": "2020-04-07T23:04:46Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -66,8 +117,8 @@ public PackageStore(Path packageStorePath) {\n      * @param pkgs a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n+    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\",\n+            justification = \"Waiting for package cache \" + \"implementation to be completed\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNDI1NQ=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE5NjI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo1ODoxMVrOGCPiiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMzo1OToxNFrOGCaV-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNDkzNw==", "bodyText": "You need to check for null and handle the case that the version is missing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405004937", "createdAt": "2020-04-07T17:58:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     *  Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return  the package version from the active Evergreen service\n+     */\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NTAyNQ==", "bodyText": "Yeah. We need to do a revisit of Exception handling for packaging so I haven't worked on too much on these.\nWhen could a version be null from EvergreenService?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405165025", "createdAt": "2020-04-07T23:06:54Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     *  Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return  the package version from the active Evergreen service\n+     */\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNDkzNw=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NTQ2Nw==", "bodyText": "Ideally it wouldn't be, but if the EvergreenService that you found was a builtin service then, (at least right now), it wouldn't have a version.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405165467", "createdAt": "2020-04-07T23:08:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     *  Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return  the package version from the active Evergreen service\n+     */\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNDkzNw=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4MTk0NA==", "bodyText": "I see. Thanks for the reminder. For this PR, I will leave a just a TODO. Sounds good?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405181944", "createdAt": "2020-04-07T23:59:14Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     *  Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return  the package version from the active Evergreen service\n+     */\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNDkzNw=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzIwNjk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODowMDo1OFrOGCPpbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMzowNzo0NFrOGCZU9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNjcwMQ==", "bodyText": "use e.getLocalizedMessage() instead of toString().", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405006701", "createdAt": "2020-04-07T18:00:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     *  Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return  the package version from the active Evergreen service\n+     */\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+        return new Semver(Coerce.toString(versionNode));\n+    }\n+\n+    /**\n+     * Find the package metadata for a package if it's active version satisfies the requirement\n      *\n+     * @param packageName the package name\n+     * @param requirement the version requirement\n+     * @return Optional of the package metadata for the package; empty if this package doesn't have active version or\n+     * the active version doesn't satisfy the requirement.\n+     * @throws IOException  if fails to read from disk\n+     * @throws PackagingException   if fails to find the target recipe or parse the recipe\n+     */\n+    private Optional<PackageMetadata> findActiveAndSatisfiedPackageMetadata(String packageName, Requirement requirement)\n+            throws IOException, PackagingException {\n+        Optional<Semver> activeVersionOptional = findActiveVersion(packageName);\n+\n+        if (!activeVersionOptional.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        Semver activeVersion = activeVersionOptional.get();\n+\n+        if (!requirement.isSatisfiedBy(activeVersion)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(getPackageMetadata(packageName, activeVersion));\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n      *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     * @throws IOException                  if fails to read from disk\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n+    private List<PackageMetadata> listAvailablePackageMetadataFromLocal(final String packageName, Requirement requirement)\n+            throws PackagingException, IOException {\n         Path srcPkgRoot = getPackageStorageRoot(packageName, packageStorePath);\n-        List<Semver> versions = new ArrayList<>();\n \n         if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n         File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n         if (versionDirs == null || versionDirs.length == 0) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n-        try {\n-            for (File versionDir : versionDirs) {\n-                // TODO: Depending on platform, this may need to avoid failures on other things\n-                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+        List<PackageMetadata> packageMetadataList = new ArrayList<>();\n+\n+        for (File versionDir : versionDirs) {\n+            Semver version;\n+            try {\n+                version = new Semver(versionDir.getName(), Semver.SemverType.NPM);\n+            } catch (SemverException e) {\n+                throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NTMwMQ==", "bodyText": "Done.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405165301", "createdAt": "2020-04-07T23:07:44Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     *  Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return  the package version from the active Evergreen service\n+     */\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+        return new Semver(Coerce.toString(versionNode));\n+    }\n+\n+    /**\n+     * Find the package metadata for a package if it's active version satisfies the requirement\n      *\n+     * @param packageName the package name\n+     * @param requirement the version requirement\n+     * @return Optional of the package metadata for the package; empty if this package doesn't have active version or\n+     * the active version doesn't satisfy the requirement.\n+     * @throws IOException  if fails to read from disk\n+     * @throws PackagingException   if fails to find the target recipe or parse the recipe\n+     */\n+    private Optional<PackageMetadata> findActiveAndSatisfiedPackageMetadata(String packageName, Requirement requirement)\n+            throws IOException, PackagingException {\n+        Optional<Semver> activeVersionOptional = findActiveVersion(packageName);\n+\n+        if (!activeVersionOptional.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        Semver activeVersion = activeVersionOptional.get();\n+\n+        if (!requirement.isSatisfiedBy(activeVersion)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(getPackageMetadata(packageName, activeVersion));\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n      *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     * @throws IOException                  if fails to read from disk\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n+    private List<PackageMetadata> listAvailablePackageMetadataFromLocal(final String packageName, Requirement requirement)\n+            throws PackagingException, IOException {\n         Path srcPkgRoot = getPackageStorageRoot(packageName, packageStorePath);\n-        List<Semver> versions = new ArrayList<>();\n \n         if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n         File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n         if (versionDirs == null || versionDirs.length == 0) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n-        try {\n-            for (File versionDir : versionDirs) {\n-                // TODO: Depending on platform, this may need to avoid failures on other things\n-                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+        List<PackageMetadata> packageMetadataList = new ArrayList<>();\n+\n+        for (File versionDir : versionDirs) {\n+            Semver version;\n+            try {\n+                version = new Semver(versionDir.getName(), Semver.SemverType.NPM);\n+            } catch (SemverException e) {\n+                throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNjcwMQ=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzIxMDQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODowMTo1MFrOGCProg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODowMTo1MFrOGCProg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNzI2Ng==", "bodyText": "use constructors instead of builders.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405007266", "createdAt": "2020-04-07T18:01:50Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     *  Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return  the package version from the active Evergreen service\n+     */\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+        return new Semver(Coerce.toString(versionNode));\n+    }\n+\n+    /**\n+     * Find the package metadata for a package if it's active version satisfies the requirement\n      *\n+     * @param packageName the package name\n+     * @param requirement the version requirement\n+     * @return Optional of the package metadata for the package; empty if this package doesn't have active version or\n+     * the active version doesn't satisfy the requirement.\n+     * @throws IOException  if fails to read from disk\n+     * @throws PackagingException   if fails to find the target recipe or parse the recipe\n+     */\n+    private Optional<PackageMetadata> findActiveAndSatisfiedPackageMetadata(String packageName, Requirement requirement)\n+            throws IOException, PackagingException {\n+        Optional<Semver> activeVersionOptional = findActiveVersion(packageName);\n+\n+        if (!activeVersionOptional.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        Semver activeVersion = activeVersionOptional.get();\n+\n+        if (!requirement.isSatisfiedBy(activeVersion)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(getPackageMetadata(packageName, activeVersion));\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n      *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     * @throws IOException                  if fails to read from disk\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n+    private List<PackageMetadata> listAvailablePackageMetadataFromLocal(final String packageName, Requirement requirement)\n+            throws PackagingException, IOException {\n         Path srcPkgRoot = getPackageStorageRoot(packageName, packageStorePath);\n-        List<Semver> versions = new ArrayList<>();\n \n         if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n         File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n         if (versionDirs == null || versionDirs.length == 0) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n-        try {\n-            for (File versionDir : versionDirs) {\n-                // TODO: Depending on platform, this may need to avoid failures on other things\n-                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+        List<PackageMetadata> packageMetadataList = new ArrayList<>();\n+\n+        for (File versionDir : versionDirs) {\n+            Semver version;\n+            try {\n+                version = new Semver(versionDir.getName(), Semver.SemverType.NPM);\n+            } catch (SemverException e) {\n+                throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);\n+            }\n+            if (requirement.isSatisfiedBy(version)) {\n+                packageMetadataList.add(getPackageMetadata(packageName, version));\n             }\n-        } catch (SemverException e) {\n-            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);\n+\n         }\n \n-        return versions;\n+        return packageMetadataList;\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param packageName package name\n+     * @param version     version\n+     * @return PackageMetadata; non-null\n+     * @throws IOException        if fails to read from disk\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(String packageName, Semver version) throws IOException, PackagingException {\n+        Package retrievedPackage = getPackage(packageName, version).get();\n+\n+        return PackageMetadata.builder().packageIdentifier(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzIxMjM3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODowMjoyMlrOGCPs8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMzozODowNVrOGCZ78w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNzYwMQ==", "bodyText": "I don't think we need the builder.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405007601", "createdAt": "2020-04-07T18:02:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "diffHunk": "@@ -15,6 +16,7 @@\n @EqualsAndHashCode\n @AllArgsConstructor\n @NoArgsConstructor\n+@Builder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNDQxMQ==", "bodyText": "+1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405134411", "createdAt": "2020-04-07T21:49:58Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "diffHunk": "@@ -15,6 +16,7 @@\n @EqualsAndHashCode\n @AllArgsConstructor\n @NoArgsConstructor\n+@Builder", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNzYwMQ=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE3NTI4Mw==", "bodyText": "I personally like the builder pattern a lot, even for a class with two parameter, because it simplifies reader's life a lot as they don't need to remember what's the first argument, and what's the second argument. It is also less error-prone, especially when you have a constructor like (String name, String version, String arn) and I've seen numerous cases people accidentally have bugs because of doing new Obj(arn, name, version)\nIt is a very subjective thing. Again, consistency is what we want - so I will bring this as a question to our Evergreen code practice doc.\nFor now I will keep using constructor.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405175283", "createdAt": "2020-04-07T23:38:05Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "diffHunk": "@@ -15,6 +16,7 @@\n @EqualsAndHashCode\n @AllArgsConstructor\n @NoArgsConstructor\n+@Builder", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNzYwMQ=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzIxNDEzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODowMjo0MFrOGCPt8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODowMjo0MFrOGCPt8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNzg1Nw==", "bodyText": "Again, don't think we need the builder.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405007857", "createdAt": "2020-04-07T18:02:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -1,64 +1,17 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n-import com.aws.iot.evergreen.util.Utils;\n-import com.vdurmont.semver4j.Semver;\n-import lombok.EqualsAndHashCode;\n+import lombok.Builder;\n import lombok.Value;\n \n-import java.util.Collections;\n-import java.util.Set;\n+import java.util.Map;\n \n @Value\n+@Builder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzk3NDU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMTozODoxMVrOGCXGdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMzo1ODoyM1rOGCaU4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEyODgyMw==", "bodyText": "Nit- When you don't find the active version for a package, a valid reason would be when the package is brand new so the service in it isn't yet running. But this log may suggest that package manager failed to load it for some reason, can we rephrase this message to say that no active version found, so the package is new?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405128823", "createdAt": "2020-04-07T21:38:11Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2Njk2Ng==", "bodyText": "You are absolutely correct. In fact, although I didn't change the code, I did change the name from getActiveVersion -> findActiveVersion to indicate that it is totally valid if not found.\nSo the log shouldn't setCause and I also rephrased the message.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405166966", "createdAt": "2020-04-07T23:12:42Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEyODgyMw=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NzU5MQ==", "bodyText": "Also - I was thinking that Kernel should probably expose some methods for us to check if a service is running - instead of each caller relies on try catch on this locate method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405167591", "createdAt": "2020-04-07T23:14:16Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEyODgyMw=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE3ODgzNQ==", "bodyText": "In my ongoing PR, I have moved the locate method to Kernel as discussed in one of the standups, so this will effectively do what you're suggesting, only it doesn't have a method to give us a boolean result like you want, it either gives you the service instance if it exists, or throws load exception if it doesn't", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405178835", "createdAt": "2020-04-07T23:49:16Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEyODgyMw=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4MTY2NA==", "bodyText": "Nice. We can have both find and get alike method where find returns nullable or Optional of the service, get throws exception if not found. I can add the find method it we agree.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405181664", "createdAt": "2020-04-07T23:58:23Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +146,117 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n+     *\n+     * @param packageName   the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Failed to get active package in Kernel\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEyODgyMw=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDAyMTEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMTo1Mzo1M1rOGCXjMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODoyMDozNVrOGECEag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjE3Ng==", "bodyText": "Do we really need another POJO for packages when we already have the package identifier and the package class that represents the whole parsed recipe, the only thing this class has in addition to the identifier class is the dependencies which should be easily accessible from the Package.java object? I do understand the benefit of organization within the dependency resolution code it's brining but a couple of sprint ago we simplified the POJOs and that's how PackageIdentifier was created, and now we will have another model class. I maybe missing something though", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405136176", "createdAt": "2020-04-07T21:53:53Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -1,64 +1,17 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n-import com.aws.iot.evergreen.util.Utils;\n-import com.vdurmont.semver4j.Semver;\n-import lombok.EqualsAndHashCode;\n+import lombok.Builder;\n import lombok.Value;\n \n-import java.util.Collections;\n-import java.util.Set;\n+import java.util.Map;\n \n @Value\n+@Builder\n public class PackageMetadata {\n \n-    String name;\n+    PackageIdentifier packageIdentifier;\n \n-    Semver version;\n+    Map<String, String> dependencies;   // from dependency package name to version requirement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE3MjUwMA==", "bodyText": "Your thoughts are valid. When I discussed with Feng and Jason, we want the PackageIdentifier as the unique id, Package as the ultimate package object, and PackageMetadata as the metadata info for the package. The query/list APIs for packageStore would need to return a list of metadata info, which PackageIdentifier is not enough, but Package it too big, that's why we have the PacakageMetadata.\nBut now thinking it twice, is Package really too big, or it is going to become too big? Anyway we've loaded it into memory to construct a PackageMetadata. Let us know your thoughts, @wikimonkey and @fengwa-aws.\nTo give a real example, changing\nIterator<PackageMetadata> listAvailablePackageMetadata(String packageName, Requirement versionRequirement)\n\nto\nIterator<Package> listAvailablePackages(String packageName, Requirement versionRequirement)\n\n\nlooks even better to me, for now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405172500", "createdAt": "2020-04-07T23:29:09Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -1,64 +1,17 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n-import com.aws.iot.evergreen.util.Utils;\n-import com.vdurmont.semver4j.Semver;\n-import lombok.EqualsAndHashCode;\n+import lombok.Builder;\n import lombok.Value;\n \n-import java.util.Collections;\n-import java.util.Set;\n+import java.util.Map;\n \n @Value\n+@Builder\n public class PackageMetadata {\n \n-    String name;\n+    PackageIdentifier packageIdentifier;\n \n-    Semver version;\n+    Map<String, String> dependencies;   // from dependency package name to version requirement", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjE3Ng=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNzA4Nw==", "bodyText": "Package is the in memory representation of the recipe file. Since we'll need at least one copy of the recipe file in memory anyway (for dependency resolution, parameter resolution, and config generation), I'm fine just using Package.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405237087", "createdAt": "2020-04-08T03:26:23Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -1,64 +1,17 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n-import com.aws.iot.evergreen.util.Utils;\n-import com.vdurmont.semver4j.Semver;\n-import lombok.EqualsAndHashCode;\n+import lombok.Builder;\n import lombok.Value;\n \n-import java.util.Collections;\n-import java.util.Set;\n+import java.util.Map;\n \n @Value\n+@Builder\n public class PackageMetadata {\n \n-    String name;\n+    PackageIdentifier packageIdentifier;\n \n-    Semver version;\n+    Map<String, String> dependencies;   // from dependency package name to version requirement", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjE3Ng=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4MTM4Ng==", "bodyText": "On this topic, I prefer separating the models, because PackageMetadata and Package has its own lifecycle, for example, use Package in DR probably would confuse the user that most of fields in Package are empty which can cause unexpected failure. Having dedicated model for the function will make it less error prone I think. Also in terms of memory footprint, I don't think having separate models would hurt.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406881386", "createdAt": "2020-04-10T18:20:35Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -1,64 +1,17 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n-import com.aws.iot.evergreen.util.Utils;\n-import com.vdurmont.semver4j.Semver;\n-import lombok.EqualsAndHashCode;\n+import lombok.Builder;\n import lombok.Value;\n \n-import java.util.Collections;\n-import java.util.Set;\n+import java.util.Map;\n \n @Value\n+@Builder\n public class PackageMetadata {\n \n-    String name;\n+    PackageIdentifier packageIdentifier;\n \n-    Semver version;\n+    Map<String, String> dependencies;   // from dependency package name to version requirement", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjE3Ng=="}, "originalCommit": {"oid": "c185bb32d304d7cc5713e3bc0aab6ace0f203ccf"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDY3NDE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMzoyMDo1OFrOGCdoMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1MjoxM1rOGDG4gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNTc2MA==", "bodyText": "I would catch the exceptions and handle them here instead of populating them up. We don't want to fail the listAvailablePackageMetadata() call because we cannot read active package metadata for some reason. In this case, we can just log an warn and move to step 2.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405235760", "createdAt": "2020-04-08T03:20:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -49,14 +68,47 @@ public PackageStore(Path packageStorePath) {\n     }\n \n     /**\n-     * Get package versions with the most preferred version first.\n-     * @param pkgName the package name\n-     * @param versionConstraint a version range\n-     * @return a iterator for package metadata with the most preferred one first\n+     * List the package metadata for available package versions that satisfy the requirement.\n+     * It is ordered by the active version first if found, followed by available versions locally.\n+     *\n+     * @param packageName        the package name\n+     * @param versionRequirement the version requirement for this package\n+     * @return an iterator of PackageMetadata, with the active version first if found, followed by available versions\n+     * locally.\n      */\n-    Iterator<PackageMetadata> getPackageMetadata(String pkgName, String versionConstraint) {\n-        // TODO to be implemented\n-        return null;\n+    Iterator<PackageMetadata> listAvailablePackageMetadata(String packageName, Requirement versionRequirement)\n+            throws PackagingException, IOException {\n+        // TODO Switch to customized Iterator to enable lazy iteration\n+\n+        // 1. Find the version if this package is currently active with some version and it is satisfied by requirement\n+        Optional<PackageMetadata> optionalActivePackageMetadata =\n+                findActiveAndSatisfiedPackageMetadata(packageName, versionRequirement);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMTY4Mw==", "bodyText": "Very good suggestion. I haven't looked into exception handling too much for the initial happy path revision but I think we should fallback instead of failing. I will add a TODO so that I can pick it up in the next revision.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405911683", "createdAt": "2020-04-09T01:52:13Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -49,14 +68,47 @@ public PackageStore(Path packageStorePath) {\n     }\n \n     /**\n-     * Get package versions with the most preferred version first.\n-     * @param pkgName the package name\n-     * @param versionConstraint a version range\n-     * @return a iterator for package metadata with the most preferred one first\n+     * List the package metadata for available package versions that satisfy the requirement.\n+     * It is ordered by the active version first if found, followed by available versions locally.\n+     *\n+     * @param packageName        the package name\n+     * @param versionRequirement the version requirement for this package\n+     * @return an iterator of PackageMetadata, with the active version first if found, followed by available versions\n+     * locally.\n      */\n-    Iterator<PackageMetadata> getPackageMetadata(String pkgName, String versionConstraint) {\n-        // TODO to be implemented\n-        return null;\n+    Iterator<PackageMetadata> listAvailablePackageMetadata(String packageName, Requirement versionRequirement)\n+            throws PackagingException, IOException {\n+        // TODO Switch to customized Iterator to enable lazy iteration\n+\n+        // 1. Find the version if this package is currently active with some version and it is satisfied by requirement\n+        Optional<PackageMetadata> optionalActivePackageMetadata =\n+                findActiveAndSatisfiedPackageMetadata(packageName, versionRequirement);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNTc2MA=="}, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDY3NDc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMzoyMToyNlrOGCdolg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1MjoyMFrOGDG4oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNTg2Mg==", "bodyText": "Same here. I would handle the exceptions from listAvailablePackageMetadataFromLocal().", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405235862", "createdAt": "2020-04-08T03:21:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -49,14 +68,47 @@ public PackageStore(Path packageStorePath) {\n     }\n \n     /**\n-     * Get package versions with the most preferred version first.\n-     * @param pkgName the package name\n-     * @param versionConstraint a version range\n-     * @return a iterator for package metadata with the most preferred one first\n+     * List the package metadata for available package versions that satisfy the requirement.\n+     * It is ordered by the active version first if found, followed by available versions locally.\n+     *\n+     * @param packageName        the package name\n+     * @param versionRequirement the version requirement for this package\n+     * @return an iterator of PackageMetadata, with the active version first if found, followed by available versions\n+     * locally.\n      */\n-    Iterator<PackageMetadata> getPackageMetadata(String pkgName, String versionConstraint) {\n-        // TODO to be implemented\n-        return null;\n+    Iterator<PackageMetadata> listAvailablePackageMetadata(String packageName, Requirement versionRequirement)\n+            throws PackagingException, IOException {\n+        // TODO Switch to customized Iterator to enable lazy iteration\n+\n+        // 1. Find the version if this package is currently active with some version and it is satisfied by requirement\n+        Optional<PackageMetadata> optionalActivePackageMetadata =\n+                findActiveAndSatisfiedPackageMetadata(packageName, versionRequirement);\n+\n+        // 2. list available packages locally\n+        List<PackageMetadata> packageMetadataList =\n+                listAvailablePackageMetadataFromLocal(packageName, versionRequirement);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMTcxMg==", "bodyText": "Same as above.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405911712", "createdAt": "2020-04-09T01:52:20Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -49,14 +68,47 @@ public PackageStore(Path packageStorePath) {\n     }\n \n     /**\n-     * Get package versions with the most preferred version first.\n-     * @param pkgName the package name\n-     * @param versionConstraint a version range\n-     * @return a iterator for package metadata with the most preferred one first\n+     * List the package metadata for available package versions that satisfy the requirement.\n+     * It is ordered by the active version first if found, followed by available versions locally.\n+     *\n+     * @param packageName        the package name\n+     * @param versionRequirement the version requirement for this package\n+     * @return an iterator of PackageMetadata, with the active version first if found, followed by available versions\n+     * locally.\n      */\n-    Iterator<PackageMetadata> getPackageMetadata(String pkgName, String versionConstraint) {\n-        // TODO to be implemented\n-        return null;\n+    Iterator<PackageMetadata> listAvailablePackageMetadata(String packageName, Requirement versionRequirement)\n+            throws PackagingException, IOException {\n+        // TODO Switch to customized Iterator to enable lazy iteration\n+\n+        // 1. Find the version if this package is currently active with some version and it is satisfied by requirement\n+        Optional<PackageMetadata> optionalActivePackageMetadata =\n+                findActiveAndSatisfiedPackageMetadata(packageName, versionRequirement);\n+\n+        // 2. list available packages locally\n+        List<PackageMetadata> packageMetadataList =\n+                listAvailablePackageMetadataFromLocal(packageName, versionRequirement);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNTg2Mg=="}, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNDY4OTExOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMzoyOTo1NVrOGCdwzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODo1MDoxN1rOGEw8GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNzk2NQ==", "bodyText": "This method doesn't do much. I would merge it back into listAvailablePackageMetadata().", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405237965", "createdAt": "2020-04-08T03:29:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +147,116 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n      *\n+     * @param packageName the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Didn't find a active service for this package running in the kernel.\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     * Get the package version from the active Evergreen service.\n      *\n+     * @param service the active evergreen service\n+     * @return the package version from the active Evergreen service\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+        return new Semver(Coerce.toString(versionNode));\n+    }\n+\n+    /**\n+     * Find the package metadata for a package if it's active version satisfies the requirement\n+     *\n+     * @param packageName the package name\n+     * @param requirement the version requirement\n+     * @return Optional of the package metadata for the package; empty if this package doesn't have active version or\n+     * the active version doesn't satisfy the requirement.\n+     * @throws IOException        if fails to read from disk\n+     * @throws PackagingException if fails to find the target recipe or parse the recipe\n+     */\n+    private Optional<PackageMetadata> findActiveAndSatisfiedPackageMetadata(String packageName, Requirement requirement)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0OTMwNQ==", "bodyText": "listAvailablePackageMetadata deals with the higher level of abstraction - getting active version from kernel, getting versions from disk and getting versions from cloud.\nI didn't want to put the lower level of how to find active version logic together with the higher level.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407649305", "createdAt": "2020-04-13T18:50:17Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +147,116 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n      *\n+     * @param packageName the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Didn't find a active service for this package running in the kernel.\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     * Get the package version from the active Evergreen service.\n      *\n+     * @param service the active evergreen service\n+     * @return the package version from the active Evergreen service\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+        return new Semver(Coerce.toString(versionNode));\n+    }\n+\n+    /**\n+     * Find the package metadata for a package if it's active version satisfies the requirement\n+     *\n+     * @param packageName the package name\n+     * @param requirement the version requirement\n+     * @return Optional of the package metadata for the package; empty if this package doesn't have active version or\n+     * the active version doesn't satisfy the requirement.\n+     * @throws IOException        if fails to read from disk\n+     * @throws PackagingException if fails to find the target recipe or parse the recipe\n+     */\n+    private Optional<PackageMetadata> findActiveAndSatisfiedPackageMetadata(String packageName, Requirement requirement)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzNzk2NQ=="}, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzYxMDYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzo0MzozNlrOGC6D8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1Nzo0NVrOGDG-oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMTYxOA==", "bodyText": "nit: this kv is more than \"version\". Same elsewhere", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405701618", "createdAt": "2020-04-08T17:43:36Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -191,7 +187,7 @@\n                 continue;\n             }\n             packagesToResolve.addAll(newDependencyPackagesToResolve);\n-            logger.atTrace().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(\"packageVersion\", version)\n+            logger.atTrace().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(VERSION_KEY, packageMetadata)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMzI0OA==", "bodyText": "Good catch! Changed!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405913248", "createdAt": "2020-04-09T01:57:45Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -191,7 +187,7 @@\n                 continue;\n             }\n             packagesToResolve.addAll(newDependencyPackagesToResolve);\n-            logger.atTrace().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(\"packageVersion\", version)\n+            logger.atTrace().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(VERSION_KEY, packageMetadata)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMTYxOA=="}, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzY4MDY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODowMzoxNFrOGC6w2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1NzoyNFrOGDG-Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxMzExMw==", "bodyText": "I thought there would be a cloud API to get package metadata. Is it not true?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405713113", "createdAt": "2020-04-08T18:03:14Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +147,116 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n      *\n+     * @param packageName the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Didn't find a active service for this package running in the kernel.\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     * Get the package version from the active Evergreen service.\n      *\n+     * @param service the active evergreen service\n+     * @return the package version from the active Evergreen service\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+        return new Semver(Coerce.toString(versionNode));\n+    }\n+\n+    /**\n+     * Find the package metadata for a package if it's active version satisfies the requirement\n+     *\n+     * @param packageName the package name\n+     * @param requirement the version requirement\n+     * @return Optional of the package metadata for the package; empty if this package doesn't have active version or\n+     * the active version doesn't satisfy the requirement.\n+     * @throws IOException        if fails to read from disk\n+     * @throws PackagingException if fails to find the target recipe or parse the recipe\n+     */\n+    private Optional<PackageMetadata> findActiveAndSatisfiedPackageMetadata(String packageName, Requirement requirement)\n+            throws IOException, PackagingException {\n+        Optional<Semver> activeVersionOptional = findActiveVersion(packageName);\n+\n+        if (!activeVersionOptional.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        Semver activeVersion = activeVersionOptional.get();\n+\n+        if (!requirement.isSatisfiedBy(activeVersion)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(getPackageMetadata(packageName, activeVersion));\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     * @throws IOException                  if fails to read from disk\n+     */\n+    private List<PackageMetadata> listAvailablePackageMetadataFromLocal(final String packageName,\n+                                                                        Requirement requirement)\n+            throws PackagingException, IOException {\n         Path srcPkgRoot = getPackageStorageRoot(packageName, packageStorePath);\n-        List<Semver> versions = new ArrayList<>();\n \n         if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n         File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n         if (versionDirs == null || versionDirs.length == 0) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n-        try {\n-            for (File versionDir : versionDirs) {\n-                // TODO: Depending on platform, this may need to avoid failures on other things\n-                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+        List<PackageMetadata> packageMetadataList = new ArrayList<>();\n+\n+        for (File versionDir : versionDirs) {\n+            Semver version;\n+            try {\n+                version = new Semver(versionDir.getName(), Semver.SemverType.NPM);\n+            } catch (SemverException e) {\n+                throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.getLocalizedMessage(), e);\n+            }\n+            if (requirement.isSatisfiedBy(version)) {\n+                packageMetadataList.add(getPackageMetadata(packageName, version));\n             }\n-        } catch (SemverException e) {\n-            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);\n+\n         }\n \n-        return versions;\n+        return packageMetadataList;\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param packageName package name\n+     * @param version     version\n+     * @return PackageMetadata; non-null\n+     * @throws IOException        if fails to read from disk\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(String packageName, Semver version) throws IOException, PackagingException {\n+        Package retrievedPackage = getPackage(packageName, version).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMzE0Mw==", "bodyText": "It is true. This is to get it from local storage. Exactly for the reason that this top level should be able to get from both local and cloud, we are thinking should also add a separate level for CRUD operations from the local storage for better encapsulation.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405913143", "createdAt": "2020-04-09T01:57:24Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -95,33 +147,116 @@ public Package getRecipe(PackageIdentifier pkg) {\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the active version for a package.\n      *\n+     * @param packageName the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n+     */\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n+        try {\n+            service = EvergreenService.locate(kernel.context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Didn't find a active service for this package running in the kernel.\");\n+            return Optional.empty();\n+        }\n+        return Optional.of(getPackageVersionFromService(service));\n+    }\n+\n+    /**\n+     * Get the package version from the active Evergreen service.\n      *\n+     * @param service the active evergreen service\n+     * @return the package version from the active Evergreen service\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.config.getChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+        return new Semver(Coerce.toString(versionNode));\n+    }\n+\n+    /**\n+     * Find the package metadata for a package if it's active version satisfies the requirement\n+     *\n+     * @param packageName the package name\n+     * @param requirement the version requirement\n+     * @return Optional of the package metadata for the package; empty if this package doesn't have active version or\n+     * the active version doesn't satisfy the requirement.\n+     * @throws IOException        if fails to read from disk\n+     * @throws PackagingException if fails to find the target recipe or parse the recipe\n+     */\n+    private Optional<PackageMetadata> findActiveAndSatisfiedPackageMetadata(String packageName, Requirement requirement)\n+            throws IOException, PackagingException {\n+        Optional<Semver> activeVersionOptional = findActiveVersion(packageName);\n+\n+        if (!activeVersionOptional.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        Semver activeVersion = activeVersionOptional.get();\n+\n+        if (!requirement.isSatisfiedBy(activeVersion)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(getPackageMetadata(packageName, activeVersion));\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     * @throws IOException                  if fails to read from disk\n+     */\n+    private List<PackageMetadata> listAvailablePackageMetadataFromLocal(final String packageName,\n+                                                                        Requirement requirement)\n+            throws PackagingException, IOException {\n         Path srcPkgRoot = getPackageStorageRoot(packageName, packageStorePath);\n-        List<Semver> versions = new ArrayList<>();\n \n         if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n         File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n         if (versionDirs == null || versionDirs.length == 0) {\n-            return versions;\n+            return Collections.emptyList();\n         }\n \n-        try {\n-            for (File versionDir : versionDirs) {\n-                // TODO: Depending on platform, this may need to avoid failures on other things\n-                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n+        List<PackageMetadata> packageMetadataList = new ArrayList<>();\n+\n+        for (File versionDir : versionDirs) {\n+            Semver version;\n+            try {\n+                version = new Semver(versionDir.getName(), Semver.SemverType.NPM);\n+            } catch (SemverException e) {\n+                throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.getLocalizedMessage(), e);\n+            }\n+            if (requirement.isSatisfiedBy(version)) {\n+                packageMetadataList.add(getPackageMetadata(packageName, version));\n             }\n-        } catch (SemverException e) {\n-            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);\n+\n         }\n \n-        return versions;\n+        return packageMetadataList;\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param packageName package name\n+     * @param version     version\n+     * @return PackageMetadata; non-null\n+     * @throws IOException        if fails to read from disk\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(String packageName, Semver version) throws IOException, PackagingException {\n+        Package retrievedPackage = getPackage(packageName, version).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxMzExMw=="}, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzY4NDIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODowNDoxMFrOGC6zEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTo1Mzo0M1rOGDG6Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxMzY4MQ==", "bodyText": "Unused import?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405713681", "createdAt": "2020-04-08T18:04:10Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "diffHunk": "@@ -5,6 +5,7 @@\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n+import lombok.Builder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMjExNA==", "bodyText": "Yeah. Removed. Thanks!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r405912114", "createdAt": "2020-04-09T01:53:43Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "diffHunk": "@@ -5,6 +5,7 @@\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n+import lombok.Builder;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxMzY4MQ=="}, "originalCommit": {"oid": "cf257dcf0bc5fe1d932ee0ceac33d0c49ed3c699"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTE2MzE5OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/deployment/DeploymentE2ETest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODowMToxM1rOGEBlnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODo0NDo0NVrOGEwvyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3MzUwMA==", "bodyText": "Should we find some place to define this method only once?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406873500", "createdAt": "2020-04-10T18:01:13Z", "author": {"login": "wikimonkey"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/deployment/DeploymentE2ETest.java", "diffHunk": "@@ -219,10 +221,21 @@ private void setupIotResourcesAndInjectIntoKernel() throws IOException {\n         deploymentServiceTopics.createLeafChild(DEVICE_PARAM_ROOT_CA_PATH).withValue(rootCaFilePath);\n     }\n \n-    private void injectKernelPackageManagementDependencies() {\n-        //TODO use DI for creating package store instance, the package store path is defined in context\n-        //currently this is to use a pre-loaded folder in working directory as package store cache\n-        kernel.context.getv(DependencyResolver.class)\n-                .put(new DependencyResolver(new PackageStore(), kernel));\n+    private static void copyFolderRecursively(Path src, Path des) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NjE1NA==", "bodyText": "I thought about making a util but I ended up putting them separately into the Integration test and E2E test because I think will be changed at the different time for different reasons.\nFor example, E2E would just need a clean package cache to download recipes from cloud, while IntegrationTest still need this to pre-load.\nOf course we could merge them together if we see they always change together.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407646154", "createdAt": "2020-04-13T18:44:45Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/deployment/DeploymentE2ETest.java", "diffHunk": "@@ -219,10 +221,21 @@ private void setupIotResourcesAndInjectIntoKernel() throws IOException {\n         deploymentServiceTopics.createLeafChild(DEVICE_PARAM_ROOT_CA_PATH).withValue(rootCaFilePath);\n     }\n \n-    private void injectKernelPackageManagementDependencies() {\n-        //TODO use DI for creating package store instance, the package store path is defined in context\n-        //currently this is to use a pre-loaded folder in working directory as package store cache\n-        kernel.context.getv(DependencyResolver.class)\n-                .put(new DependencyResolver(new PackageStore(), kernel));\n+    private static void copyFolderRecursively(Path src, Path des) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3MzUwMA=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTE4MzY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODowODo1MlrOGEBx6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODoxODoyN1rOGEv3Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3NjY1MA==", "bodyText": "Isn't service config tracking its version? Are we trying to encapsulate the info in the package store? If so, should package store/manager access kernel for service info instead?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406876650", "createdAt": "2020-04-10T18:08:52Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -236,126 +240,31 @@\n         return errorMessage;\n     }\n \n-    /**\n-     * // TODO move to local package store\n-     * Get a ordered list of possible versions to explore for the given package.\n-     *\n-     * @param pkgName                     name of the package to be explored\n-     * @param packageToVersionConstraints list of version constraints for the package\n-     * @return list of versions as Semver instances\n-     * @throws UnexpectedPackagingException when a package cannot be retrieved from the package store\n-     */\n-    protected List<Semver> getVersionsToExplore(final String pkgName,\n-                                                final Map<String, String> packageToVersionConstraints)\n-            throws UnexpectedPackagingException, PackageVersionConflictException {\n-\n-        List<Semver> versionList = new ArrayList<>();\n-        logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, pkgName)\n-                .addKeyValue(\"versionConstraints\", packageToVersionConstraints)\n-                .log(\"Parsing version constraints for dependency package\");\n-        Requirement req = Requirement.buildNPM(mergeSemverRequirements(packageToVersionConstraints.values()));\n-\n-        if (packageToVersionConstraints.containsKey(ROOT_REQUIREMENT_KEY)) {\n-            // Assume all root packages should use the pinned version.\n-            Semver pinnedVersion = new Semver(packageToVersionConstraints.get(ROOT_REQUIREMENT_KEY));\n-            if (!req.isSatisfiedBy(pinnedVersion)) {\n-                throw new PackageVersionConflictException(String.format(\n-                        \"Conflicts in root package version constraints. Package: %s, version constraints: %s\", pkgName,\n-                        req));\n-            }\n-            versionList.add(pinnedVersion);\n-            return versionList;\n-        }\n-\n-        // Add active package version running on the device\n-        Optional<String> version = getPackageVersionIfActive(pkgName);\n-        Semver activeVersion = null;\n-        if (version.isPresent() && req.isSatisfiedBy(version.get())) {\n-            activeVersion = new Semver(version.get());\n-            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(VERSION_KEY, activeVersion)\n-                    .log(\"Found current active version for dependency package\");\n-            versionList.add(activeVersion);\n-        }\n-\n-        // Find out all available versions in package store\n-        // TODO: shuyeh Update priorities to be \"version available on disk > latest version on the cloud > other\n-        //  versions on the cloud\n-        // TODO clarify with Feng\n-        List<Semver> allVersions = packageStore.getPackageVersionsIfExists(pkgName);\n-        for (Semver v : allVersions) {\n-            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n-                versionList.add(v);\n-            }\n-        }\n-        logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(\"versionList\", versionList)\n-                .log(\"Found possible versions for dependency package\");\n-        return versionList;\n-    }\n-\n-    protected String mergeSemverRequirements(final Collection<String> packageVersionConstraintList) {\n+    String mergeSemverRequirements(final Collection<String> packageVersionConstraintList) {\n         // TODO: See if there's a better way to get the union of version constraints\n         return packageVersionConstraintList.stream().map(Requirement::buildNPM).map(Requirement::toString)\n                 .collect(Collectors.joining(\" \"));\n     }\n \n-    protected Optional<String> getPackageVersionIfActive(final String packageName) {\n-        EvergreenService service;\n-        try {\n-            service = kernel.locate(packageName);\n-        } catch (ServiceLoadException e) {\n-            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n-                    .log(\"Failed to get active package in Kernel\");\n-            return Optional.empty();\n-        }\n-        return getServiceVersion(service);\n-    }\n-\n     private void mergeActiveRootPackages(Set<String> rootPackagesToResolve,\n                                          Map<String, Map<String, String>> packageNameToVersionConstraints) {\n \n         Set<EvergreenService> activeServices = kernel.getMain().getDependencies().keySet();\n         for (EvergreenService evergreenService : activeServices) {\n             String serviceName = evergreenService.getName();\n-            // add version constraints for package not in deployment document but is active in device\n+            // Multi-group deployment support\n+            // add active service in device but the version constraints not in the deployment document\n             if (rootPackagesToResolve.contains(serviceName) && !packageNameToVersionConstraints.keySet()\n                     .contains(serviceName)) {\n-                String version = getServiceVersion(evergreenService).get();\n+                Semver version = packageStore.getPackageVersionFromService(evergreenService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxOTg2Ng==", "bodyText": "Jason is correct that version is stored in the kernel config. So this resolver could read from there. Or package store could.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406919866", "createdAt": "2020-04-10T20:03:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -236,126 +240,31 @@\n         return errorMessage;\n     }\n \n-    /**\n-     * // TODO move to local package store\n-     * Get a ordered list of possible versions to explore for the given package.\n-     *\n-     * @param pkgName                     name of the package to be explored\n-     * @param packageToVersionConstraints list of version constraints for the package\n-     * @return list of versions as Semver instances\n-     * @throws UnexpectedPackagingException when a package cannot be retrieved from the package store\n-     */\n-    protected List<Semver> getVersionsToExplore(final String pkgName,\n-                                                final Map<String, String> packageToVersionConstraints)\n-            throws UnexpectedPackagingException, PackageVersionConflictException {\n-\n-        List<Semver> versionList = new ArrayList<>();\n-        logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, pkgName)\n-                .addKeyValue(\"versionConstraints\", packageToVersionConstraints)\n-                .log(\"Parsing version constraints for dependency package\");\n-        Requirement req = Requirement.buildNPM(mergeSemverRequirements(packageToVersionConstraints.values()));\n-\n-        if (packageToVersionConstraints.containsKey(ROOT_REQUIREMENT_KEY)) {\n-            // Assume all root packages should use the pinned version.\n-            Semver pinnedVersion = new Semver(packageToVersionConstraints.get(ROOT_REQUIREMENT_KEY));\n-            if (!req.isSatisfiedBy(pinnedVersion)) {\n-                throw new PackageVersionConflictException(String.format(\n-                        \"Conflicts in root package version constraints. Package: %s, version constraints: %s\", pkgName,\n-                        req));\n-            }\n-            versionList.add(pinnedVersion);\n-            return versionList;\n-        }\n-\n-        // Add active package version running on the device\n-        Optional<String> version = getPackageVersionIfActive(pkgName);\n-        Semver activeVersion = null;\n-        if (version.isPresent() && req.isSatisfiedBy(version.get())) {\n-            activeVersion = new Semver(version.get());\n-            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(VERSION_KEY, activeVersion)\n-                    .log(\"Found current active version for dependency package\");\n-            versionList.add(activeVersion);\n-        }\n-\n-        // Find out all available versions in package store\n-        // TODO: shuyeh Update priorities to be \"version available on disk > latest version on the cloud > other\n-        //  versions on the cloud\n-        // TODO clarify with Feng\n-        List<Semver> allVersions = packageStore.getPackageVersionsIfExists(pkgName);\n-        for (Semver v : allVersions) {\n-            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n-                versionList.add(v);\n-            }\n-        }\n-        logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(\"versionList\", versionList)\n-                .log(\"Found possible versions for dependency package\");\n-        return versionList;\n-    }\n-\n-    protected String mergeSemverRequirements(final Collection<String> packageVersionConstraintList) {\n+    String mergeSemverRequirements(final Collection<String> packageVersionConstraintList) {\n         // TODO: See if there's a better way to get the union of version constraints\n         return packageVersionConstraintList.stream().map(Requirement::buildNPM).map(Requirement::toString)\n                 .collect(Collectors.joining(\" \"));\n     }\n \n-    protected Optional<String> getPackageVersionIfActive(final String packageName) {\n-        EvergreenService service;\n-        try {\n-            service = kernel.locate(packageName);\n-        } catch (ServiceLoadException e) {\n-            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n-                    .log(\"Failed to get active package in Kernel\");\n-            return Optional.empty();\n-        }\n-        return getServiceVersion(service);\n-    }\n-\n     private void mergeActiveRootPackages(Set<String> rootPackagesToResolve,\n                                          Map<String, Map<String, String>> packageNameToVersionConstraints) {\n \n         Set<EvergreenService> activeServices = kernel.getMain().getDependencies().keySet();\n         for (EvergreenService evergreenService : activeServices) {\n             String serviceName = evergreenService.getName();\n-            // add version constraints for package not in deployment document but is active in device\n+            // Multi-group deployment support\n+            // add active service in device but the version constraints not in the deployment document\n             if (rootPackagesToResolve.contains(serviceName) && !packageNameToVersionConstraints.keySet()\n                     .contains(serviceName)) {\n-                String version = getServiceVersion(evergreenService).get();\n+                Semver version = packageStore.getPackageVersionFromService(evergreenService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3NjY1MA=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzMTcwNw==", "bodyText": "Yeah. I was debating with myself and the conclusion was: Right now, we think Kernel is responsible for the running service, but not version. The package store manages version. So PackageStore asks Kernel for the running service config, and extract version from it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407631707", "createdAt": "2020-04-13T18:18:27Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -236,126 +240,31 @@\n         return errorMessage;\n     }\n \n-    /**\n-     * // TODO move to local package store\n-     * Get a ordered list of possible versions to explore for the given package.\n-     *\n-     * @param pkgName                     name of the package to be explored\n-     * @param packageToVersionConstraints list of version constraints for the package\n-     * @return list of versions as Semver instances\n-     * @throws UnexpectedPackagingException when a package cannot be retrieved from the package store\n-     */\n-    protected List<Semver> getVersionsToExplore(final String pkgName,\n-                                                final Map<String, String> packageToVersionConstraints)\n-            throws UnexpectedPackagingException, PackageVersionConflictException {\n-\n-        List<Semver> versionList = new ArrayList<>();\n-        logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, pkgName)\n-                .addKeyValue(\"versionConstraints\", packageToVersionConstraints)\n-                .log(\"Parsing version constraints for dependency package\");\n-        Requirement req = Requirement.buildNPM(mergeSemverRequirements(packageToVersionConstraints.values()));\n-\n-        if (packageToVersionConstraints.containsKey(ROOT_REQUIREMENT_KEY)) {\n-            // Assume all root packages should use the pinned version.\n-            Semver pinnedVersion = new Semver(packageToVersionConstraints.get(ROOT_REQUIREMENT_KEY));\n-            if (!req.isSatisfiedBy(pinnedVersion)) {\n-                throw new PackageVersionConflictException(String.format(\n-                        \"Conflicts in root package version constraints. Package: %s, version constraints: %s\", pkgName,\n-                        req));\n-            }\n-            versionList.add(pinnedVersion);\n-            return versionList;\n-        }\n-\n-        // Add active package version running on the device\n-        Optional<String> version = getPackageVersionIfActive(pkgName);\n-        Semver activeVersion = null;\n-        if (version.isPresent() && req.isSatisfiedBy(version.get())) {\n-            activeVersion = new Semver(version.get());\n-            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(VERSION_KEY, activeVersion)\n-                    .log(\"Found current active version for dependency package\");\n-            versionList.add(activeVersion);\n-        }\n-\n-        // Find out all available versions in package store\n-        // TODO: shuyeh Update priorities to be \"version available on disk > latest version on the cloud > other\n-        //  versions on the cloud\n-        // TODO clarify with Feng\n-        List<Semver> allVersions = packageStore.getPackageVersionsIfExists(pkgName);\n-        for (Semver v : allVersions) {\n-            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n-                versionList.add(v);\n-            }\n-        }\n-        logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, pkgName).addKeyValue(\"versionList\", versionList)\n-                .log(\"Found possible versions for dependency package\");\n-        return versionList;\n-    }\n-\n-    protected String mergeSemverRequirements(final Collection<String> packageVersionConstraintList) {\n+    String mergeSemverRequirements(final Collection<String> packageVersionConstraintList) {\n         // TODO: See if there's a better way to get the union of version constraints\n         return packageVersionConstraintList.stream().map(Requirement::buildNPM).map(Requirement::toString)\n                 .collect(Collectors.joining(\" \"));\n     }\n \n-    protected Optional<String> getPackageVersionIfActive(final String packageName) {\n-        EvergreenService service;\n-        try {\n-            service = kernel.locate(packageName);\n-        } catch (ServiceLoadException e) {\n-            logger.atDebug().setCause(e).addKeyValue(PACKAGE_NAME_KEY, packageName)\n-                    .log(\"Failed to get active package in Kernel\");\n-            return Optional.empty();\n-        }\n-        return getServiceVersion(service);\n-    }\n-\n     private void mergeActiveRootPackages(Set<String> rootPackagesToResolve,\n                                          Map<String, Map<String, String>> packageNameToVersionConstraints) {\n \n         Set<EvergreenService> activeServices = kernel.getMain().getDependencies().keySet();\n         for (EvergreenService evergreenService : activeServices) {\n             String serviceName = evergreenService.getName();\n-            // add version constraints for package not in deployment document but is active in device\n+            // Multi-group deployment support\n+            // add active service in device but the version constraints not in the deployment document\n             if (rootPackagesToResolve.contains(serviceName) && !packageNameToVersionConstraints.keySet()\n                     .contains(serviceName)) {\n-                String version = getServiceVersion(evergreenService).get();\n+                Semver version = packageStore.getPackageVersionFromService(evergreenService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3NjY1MA=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTE4NjU2OnYy", "diffSide": "LEFT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODoxMDowNFrOGEBzrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODoxNjozMlrOGEvzVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3NzEwMg==", "bodyText": "Good catch on this. Package id may or may not have ARN. For package retrieving from EG cloud, it needs ARN.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406877102", "createdAt": "2020-04-10T18:10:04Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "diffHunk": "@@ -27,7 +27,6 @@\n      * @param name package name\n      * @param version package version in semver\n      */\n-    @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzMDY3Ng==", "bodyText": "Thanks Jason!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407630676", "createdAt": "2020-04-13T18:16:32Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageIdentifier.java", "diffHunk": "@@ -27,7 +27,6 @@\n      * @param name package name\n      * @param version package version in semver\n      */\n-    @Deprecated", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3NzEwMg=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTE4ODEzOnYy", "diffSide": "LEFT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODoxMDozOFrOGEB0lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODoxMDozOFrOGEB0lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3NzMzNQ==", "bodyText": "Great simplification.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406877335", "createdAt": "2020-04-10T18:10:38Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -1,64 +1,14 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n-import com.aws.iot.evergreen.util.Utils;\n-import com.vdurmont.semver4j.Semver;\n-import lombok.EqualsAndHashCode;\n+import lombok.AllArgsConstructor;\n import lombok.Value;\n \n-import java.util.Collections;\n-import java.util.Set;\n+import java.util.Map;\n \n @Value\n+@AllArgsConstructor\n public class PackageMetadata {\n+    PackageIdentifier packageIdentifier;\n \n-    String name;\n-\n-    Semver version;\n-\n-    String versionConstraint;\n-\n-    @EqualsAndHashCode.Exclude\n-    Set<PackageMetadata> dependsOn;\n-\n-    Set<PackageParameter> parameters;\n-\n-    /**\n-     * Constructor for PackageMetadata.\n-     *\n-     * @param name              package name\n-     * @param version           package version\n-     * @param versionConstraint package version constraint\n-     * @param dependsOn         dependency package information\n-     * @param parameters        parameters for the package\n-     * @throws IllegalArgumentException if any of the inputs is improper\n-     */\n-    public PackageMetadata(String name, String version, String versionConstraint, Set<PackageMetadata> dependsOn,\n-                           Set<PackageParameter> parameters) {\n-        if (Utils.isEmpty(name)) {\n-            throw new IllegalArgumentException(\"package name can't be empty\");\n-        }\n-        if (Utils.isEmpty(version)) {\n-            throw new IllegalArgumentException(\"package version can't be empty\");\n-        }\n-        if (Utils.isEmpty(versionConstraint)) {\n-            throw new IllegalArgumentException(\"package version constraint can't be empty\");\n-        }\n-        this.name = name;\n-        this.version = new Semver(version, Semver.SemverType.NPM);\n-        this.versionConstraint = versionConstraint;\n-        this.dependsOn = dependsOn == null ? Collections.emptySet() : dependsOn;\n-        this.parameters = parameters == null ? Collections.emptySet() : Collections.unmodifiableSet(parameters);\n-    }\n-\n-    /**\n-     * Constructor for PackageMetadata when no dependency information is known.\n-     *\n-     * @param name       package name\n-     * @param version    package version\n-     * @param constraint package version constraint\n-     */\n-    public PackageMetadata(String name, String version, String constraint) {\n-        this(name, version, constraint, null, null);\n-    }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTQ1MDcwOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/deployment/DeploymentE2ETest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDowMDo1MFrOGEEXRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjo1OTo1OVrOGEtOLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxODk4Mg==", "bodyText": "catch exception or copy with overwrite.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406918982", "createdAt": "2020-04-10T20:00:50Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/deployment/DeploymentE2ETest.java", "diffHunk": "@@ -219,10 +221,21 @@ private void setupIotResourcesAndInjectIntoKernel() throws IOException {\n         deploymentServiceTopics.createLeafChild(DEVICE_PARAM_ROOT_CA_PATH).withValue(rootCaFilePath);\n     }\n \n-    private void injectKernelPackageManagementDependencies() {\n-        //TODO use DI for creating package store instance, the package store path is defined in context\n-        //currently this is to use a pre-loaded folder in working directory as package store cache\n-        kernel.context.getv(DependencyResolver.class)\n-                .put(new DependencyResolver(new PackageStore(), kernel));\n+    private static void copyFolderRecursively(Path src, Path des) throws IOException {\n+        Files.walkFileTree(src, new SimpleFileVisitor<Path>() {\n+\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                Files.createDirectories(des.resolve(src.relativize(dir)));\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.copy(file, des.resolve(src.relativize(file)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4ODM5OA==", "bodyText": "I intentionally didn't use copy with REPLACE_EXISTING because the package cache should be clean at the beginning (for now). If it is not, it will fail with \"File already exists\"...", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407588398", "createdAt": "2020-04-13T16:59:59Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/deployment/DeploymentE2ETest.java", "diffHunk": "@@ -219,10 +221,21 @@ private void setupIotResourcesAndInjectIntoKernel() throws IOException {\n         deploymentServiceTopics.createLeafChild(DEVICE_PARAM_ROOT_CA_PATH).withValue(rootCaFilePath);\n     }\n \n-    private void injectKernelPackageManagementDependencies() {\n-        //TODO use DI for creating package store instance, the package store path is defined in context\n-        //currently this is to use a pre-loaded folder in working directory as package store cache\n-        kernel.context.getv(DependencyResolver.class)\n-                .put(new DependencyResolver(new PackageStore(), kernel));\n+    private static void copyFolderRecursively(Path src, Path des) throws IOException {\n+        Files.walkFileTree(src, new SimpleFileVisitor<Path>() {\n+\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                Files.createDirectories(des.resolve(src.relativize(dir)));\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                Files.copy(file, des.resolve(src.relativize(file)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxODk4Mg=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTQ1MjEyOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/e2e/deployment/local_store_content/recipe/YellowSignal-1.0.0.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDowMTozM1rOGEEYOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjo1Nzo1MlrOGEtJJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxOTIyNQ==", "bodyText": "Make sure to remove the old files in the local cache as well as adding these new ones.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406919225", "createdAt": "2020-04-10T20:01:33Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/e2e/deployment/local_store_content/recipe/YellowSignal-1.0.0.yaml", "diffHunk": "@@ -0,0 +1,13 @@\n+---\n+RecipeTemplateVersion: '2020-01-25'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4NzExMA==", "bodyText": "Yeah. All files should be moved here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407587110", "createdAt": "2020-04-13T16:57:52Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/e2e/deployment/local_store_content/recipe/YellowSignal-1.0.0.yaml", "diffHunk": "@@ -0,0 +1,13 @@\n+---\n+RecipeTemplateVersion: '2020-01-25'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxOTIyNQ=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTQ1NzgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDowMzo1N1rOGEEboQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjoyNjoxM1rOGEsFBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMDA5Nw==", "bodyText": "Why are you making this sneaky? This should use checked exceptions if possible", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406920097", "createdAt": "2020-04-10T20:03:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -68,9 +69,10 @@\n     /*\n      * Processes lifecycle section of each package and add it to the config.\n      */\n+    @SneakyThrows", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2OTY2OA==", "bodyText": "Removed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407569668", "createdAt": "2020-04-13T16:26:13Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -68,9 +69,10 @@\n     /*\n      * Processes lifecycle section of each package and add it to the config.\n      */\n+    @SneakyThrows", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMDA5Nw=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTQ1OTU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDowNDo1MlrOGEEcvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDowNDo1MlrOGEEcvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMDM4Mw==", "bodyText": "missing\nthis.packageStoreDirectory = packageStoreDirectory;", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406920383", "createdAt": "2020-04-10T20:04:52Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -70,27 +69,33 @@\n     @Inject\n     private ExecutorService executorService;\n \n-    // Workaround using InjectionActions since constructor named pattern injection is not supported yet\n     @Inject\n     @Named(\"packageStoreDirectory\")\n     private Path packageStoreDirectory;\n \n+    @Inject\n+    private Kernel kernel;\n+\n     /**\n      * PackageStore constructor.\n      *\n      * @param packageStoreDirectory directory for caching package recipes and artifacts\n      * @param packageServiceHelper  greengrass package service client helper\n      * @param artifactDownloader    artifact downloader\n      * @param executorService       executor service\n+     * @param kernel                kernel\n      */\n     public PackageStore(Path packageStoreDirectory, GreengrassPackageServiceHelper packageServiceHelper,\n-                        GreengrassRepositoryDownloader artifactDownloader, ExecutorService executorService) {\n+                        GreengrassRepositoryDownloader artifactDownloader, ExecutorService executorService,\n+                        Kernel kernel) {\n         initializeSubDirectories(packageStoreDirectory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTQ2MjYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDowNjozM1rOGEEe0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjo1NDoyOVrOGEtB4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMDkxMw==", "bodyText": "use findLeafChild so that you're assured to get a Topic.\nThen also check for null.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406920913", "createdAt": "2020-04-10T20:06:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -266,103 +324,125 @@ private ArtifactDownloader selectArtifactDownloader(URI artifactUri) throws Pack\n         throw new PackageLoadingException(String.format(\"artifact URI scheme %s is not supported yet\", scheme));\n     }\n \n+\n     /**\n-     * Retrieve the recipe of a package.\n+     * Find the active version for a package.\n      *\n-     * @param pkg package identifier\n-     * @return package recipe\n+     * @param packageName the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n      */\n-    public Package getRecipe(PackageIdentifier pkg) {\n-        // TODO: to be implemented.\n-        LocalPackageStoreDeprecated localPackageStore = new LocalPackageStoreDeprecated(LOCAL_CACHE_PATH);\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n         try {\n-            return localPackageStore.getPackage(pkg.getName(), pkg.getVersion()).get();\n-        } catch (PackagingException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n+            service = kernel.locate(packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Didn't find a active service for this package running in the kernel.\");\n+            return Optional.empty();\n         }\n-        return null;\n+        return Optional.of(getPackageVersionFromService(service));\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return the package version from the active Evergreen service\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n-        Path srcPkgRoot = getPackageStorageRoot(packageName, LOCAL_CACHE_PATH);\n-        List<Semver> versions = new ArrayList<>();\n-\n-        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return versions;\n-        }\n-\n-        File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n-        if (versionDirs == null || versionDirs.length == 0) {\n-            return versions;\n-        }\n-\n-        try {\n-            for (File versionDir : versionDirs) {\n-                // TODO: Depending on platform, this may need to avoid failures on other things\n-                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n-            }\n-        } catch (SemverException e) {\n-            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);\n-        }\n-\n-        return versions;\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.getServiceConfig().getChild(KernelConfigResolver.VERSION_CONFIG_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4NTI0OA==", "bodyText": "Yeah. As discussed before, I think using findLeafChild  here is a lot better. Changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407585248", "createdAt": "2020-04-13T16:54:29Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -266,103 +324,125 @@ private ArtifactDownloader selectArtifactDownloader(URI artifactUri) throws Pack\n         throw new PackageLoadingException(String.format(\"artifact URI scheme %s is not supported yet\", scheme));\n     }\n \n+\n     /**\n-     * Retrieve the recipe of a package.\n+     * Find the active version for a package.\n      *\n-     * @param pkg package identifier\n-     * @return package recipe\n+     * @param packageName the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n      */\n-    public Package getRecipe(PackageIdentifier pkg) {\n-        // TODO: to be implemented.\n-        LocalPackageStoreDeprecated localPackageStore = new LocalPackageStoreDeprecated(LOCAL_CACHE_PATH);\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n         try {\n-            return localPackageStore.getPackage(pkg.getName(), pkg.getVersion()).get();\n-        } catch (PackagingException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n+            service = kernel.locate(packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Didn't find a active service for this package running in the kernel.\");\n+            return Optional.empty();\n         }\n-        return null;\n+        return Optional.of(getPackageVersionFromService(service));\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return the package version from the active Evergreen service\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n-        Path srcPkgRoot = getPackageStorageRoot(packageName, LOCAL_CACHE_PATH);\n-        List<Semver> versions = new ArrayList<>();\n-\n-        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return versions;\n-        }\n-\n-        File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n-        if (versionDirs == null || versionDirs.length == 0) {\n-            return versions;\n-        }\n-\n-        try {\n-            for (File versionDir : versionDirs) {\n-                // TODO: Depending on platform, this may need to avoid failures on other things\n-                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n-            }\n-        } catch (SemverException e) {\n-            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);\n-        }\n-\n-        return versions;\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.getServiceConfig().getChild(KernelConfigResolver.VERSION_CONFIG_KEY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMDkxMw=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTQ2NjQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDowODoyNVrOGEEhGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjo1MTo0NVrOGEs77g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMTQ5Nw==", "bodyText": "this won't be correct if the package name has -. Use [length -1] instead to be assured that you got the version which is always after the package name.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406921497", "createdAt": "2020-04-10T20:08:25Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -266,103 +324,125 @@ private ArtifactDownloader selectArtifactDownloader(URI artifactUri) throws Pack\n         throw new PackageLoadingException(String.format(\"artifact URI scheme %s is not supported yet\", scheme));\n     }\n \n+\n     /**\n-     * Retrieve the recipe of a package.\n+     * Find the active version for a package.\n      *\n-     * @param pkg package identifier\n-     * @return package recipe\n+     * @param packageName the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n      */\n-    public Package getRecipe(PackageIdentifier pkg) {\n-        // TODO: to be implemented.\n-        LocalPackageStoreDeprecated localPackageStore = new LocalPackageStoreDeprecated(LOCAL_CACHE_PATH);\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n         try {\n-            return localPackageStore.getPackage(pkg.getName(), pkg.getVersion()).get();\n-        } catch (PackagingException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n+            service = kernel.locate(packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Didn't find a active service for this package running in the kernel.\");\n+            return Optional.empty();\n         }\n-        return null;\n+        return Optional.of(getPackageVersionFromService(service));\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return the package version from the active Evergreen service\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n-        Path srcPkgRoot = getPackageStorageRoot(packageName, LOCAL_CACHE_PATH);\n-        List<Semver> versions = new ArrayList<>();\n-\n-        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return versions;\n-        }\n-\n-        File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n-        if (versionDirs == null || versionDirs.length == 0) {\n-            return versions;\n-        }\n-\n-        try {\n-            for (File versionDir : versionDirs) {\n-                // TODO: Depending on platform, this may need to avoid failures on other things\n-                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n-            }\n-        } catch (SemverException e) {\n-            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);\n-        }\n-\n-        return versions;\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.getServiceConfig().getChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+        //TODO handle null case\n+        return new Semver(Coerce.toString(versionNode));\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the package metadata for a package if it's active version satisfies the requirement.\n      *\n-     * @return Optional containing package recipe as a String\n+     * @param packageName the package name\n+     * @param requirement the version requirement\n+     * @return Optional of the package metadata for the package; empty if this package doesn't have active version or\n+     *     the active version doesn't satisfy the requirement.\n+     * @throws PackagingException if fails to find the target recipe or parse the recipe\n      */\n-    Optional<Package> getPackage(final String packageName, final Semver packageVersion)\n-            throws PackagingException, IOException {\n-        Optional<String> packageRecipeContent = getPackageRecipe(packageName, packageVersion);\n-        if (!packageRecipeContent.isPresent()) {\n+    private Optional<PackageMetadata> findActiveAndSatisfiedPackageMetadata(String packageName, Requirement requirement)\n+            throws PackagingException {\n+        Optional<Semver> activeVersionOptional = findActiveVersion(packageName);\n+\n+        if (!activeVersionOptional.isPresent()) {\n             return Optional.empty();\n         }\n-        try {\n-            Package pkgRecipe = OBJECT_MAPPER.readValue(packageRecipeContent.get(), Package.class);\n-            return Optional.ofNullable(pkgRecipe);\n-        } catch (IOException e) {\n-            throw new UnsupportedRecipeFormatException(Constants.UNABLE_TO_PARSE_RECIPE_EXCEPTION_MSG, e);\n+\n+        Semver activeVersion = activeVersionOptional.get();\n+\n+        if (!requirement.isSatisfiedBy(activeVersion)) {\n+            return Optional.empty();\n         }\n+\n+        return Optional.of(getPackageMetadata(new PackageIdentifier(packageName, activeVersion)));\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * list PackageMetadata for available packages that satisfies the requirement.\n      *\n-     * @return Optional containing package recipe as a String\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n      */\n-    private Optional<String> getPackageRecipe(final String packageName, final Semver packageVersion)\n-            throws PackagingException, IOException {\n-        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(), LOCAL_CACHE_PATH);\n+    private List<PackageMetadata> listAvailablePackageMetadataFromLocal(final String packageName,\n+                                                                        Requirement requirement)\n+            throws PackagingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n \n-        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return Optional.empty();\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Collections.emptyList();\n         }\n-        // TODO: Move to a Common list of Constants\n-        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n \n-        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n-            throw new PackagingException(\"Package manager cache is corrupt\");\n-            // TODO Take some corrective actions before throwing\n+        Arrays.sort(recipeFiles);\n+\n+        List<PackageMetadata> packageMetadataList = new ArrayList<>();\n+\n+        for (File recipeFile : recipeFiles) {\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+\n+            if (requirement.isSatisfiedBy(version)) {\n+                packageMetadataList.add(getPackageMetadata(new PackageIdentifier(packageName, version)));\n+            }\n+\n         }\n \n-        return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        return packageMetadataList;\n     }\n \n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        Package retrievedPackage = getPackageRecipe(pkgId);\n \n-    private static Path getPackageStorageRoot(final String packageName, final Path cacheFolder) {\n-        return cacheFolder.resolve(packageName);\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackage.getPackageName(), retrievedPackage.getVersion()),\n+                retrievedPackage.getDependencies());\n     }\n \n-    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n-                                                     final Path cacheFolder) {\n-        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+\n+    private static Semver parseVersionFromFileName(String filename) throws UnexpectedPackagingException {\n+        // TODO validate filename\n+\n+        // MonitoringService-1.0.0.yaml\n+        String suffix = \".yaml\";\n+        String versionStr = filename.split(suffix)[0].split(\"-\")[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MzcyNg==", "bodyText": "Very very good catch. Changed it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407583726", "createdAt": "2020-04-13T16:51:45Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -266,103 +324,125 @@ private ArtifactDownloader selectArtifactDownloader(URI artifactUri) throws Pack\n         throw new PackageLoadingException(String.format(\"artifact URI scheme %s is not supported yet\", scheme));\n     }\n \n+\n     /**\n-     * Retrieve the recipe of a package.\n+     * Find the active version for a package.\n      *\n-     * @param pkg package identifier\n-     * @return package recipe\n+     * @param packageName the package name\n+     * @return Optional of version; Empty if no active version for this package found.\n      */\n-    public Package getRecipe(PackageIdentifier pkg) {\n-        // TODO: to be implemented.\n-        LocalPackageStoreDeprecated localPackageStore = new LocalPackageStoreDeprecated(LOCAL_CACHE_PATH);\n+    private Optional<Semver> findActiveVersion(final String packageName) {\n+        EvergreenService service;\n         try {\n-            return localPackageStore.getPackage(pkg.getName(), pkg.getVersion()).get();\n-        } catch (PackagingException e) {\n-            e.printStackTrace();\n-        } catch (IOException e) {\n-            e.printStackTrace();\n+            service = kernel.locate(packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atDebug().addKeyValue(PACKAGE_NAME_KEY, packageName)\n+                    .log(\"Didn't find a active service for this package running in the kernel.\");\n+            return Optional.empty();\n         }\n-        return null;\n+        return Optional.of(getPackageVersionFromService(service));\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Get the package version from the active Evergreen service.\n+     *\n+     * @param service the active evergreen service\n+     * @return the package version from the active Evergreen service\n      */\n-    List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n-        Path srcPkgRoot = getPackageStorageRoot(packageName, LOCAL_CACHE_PATH);\n-        List<Semver> versions = new ArrayList<>();\n-\n-        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return versions;\n-        }\n-\n-        File[] versionDirs = srcPkgRoot.toFile().listFiles(File::isDirectory);\n-        if (versionDirs == null || versionDirs.length == 0) {\n-            return versions;\n-        }\n-\n-        try {\n-            for (File versionDir : versionDirs) {\n-                // TODO: Depending on platform, this may need to avoid failures on other things\n-                versions.add(new Semver(versionDir.getName(), Semver.SemverType.NPM));\n-            }\n-        } catch (SemverException e) {\n-            throw new UnexpectedPackagingException(\"Package Cache is corrupted! \" + e.toString(), e);\n-        }\n-\n-        return versions;\n+    Semver getPackageVersionFromService(final EvergreenService service) {\n+        Node versionNode = service.getServiceConfig().getChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+        //TODO handle null case\n+        return new Semver(Coerce.toString(versionNode));\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * Find the package metadata for a package if it's active version satisfies the requirement.\n      *\n-     * @return Optional containing package recipe as a String\n+     * @param packageName the package name\n+     * @param requirement the version requirement\n+     * @return Optional of the package metadata for the package; empty if this package doesn't have active version or\n+     *     the active version doesn't satisfy the requirement.\n+     * @throws PackagingException if fails to find the target recipe or parse the recipe\n      */\n-    Optional<Package> getPackage(final String packageName, final Semver packageVersion)\n-            throws PackagingException, IOException {\n-        Optional<String> packageRecipeContent = getPackageRecipe(packageName, packageVersion);\n-        if (!packageRecipeContent.isPresent()) {\n+    private Optional<PackageMetadata> findActiveAndSatisfiedPackageMetadata(String packageName, Requirement requirement)\n+            throws PackagingException {\n+        Optional<Semver> activeVersionOptional = findActiveVersion(packageName);\n+\n+        if (!activeVersionOptional.isPresent()) {\n             return Optional.empty();\n         }\n-        try {\n-            Package pkgRecipe = OBJECT_MAPPER.readValue(packageRecipeContent.get(), Package.class);\n-            return Optional.ofNullable(pkgRecipe);\n-        } catch (IOException e) {\n-            throw new UnsupportedRecipeFormatException(Constants.UNABLE_TO_PARSE_RECIPE_EXCEPTION_MSG, e);\n+\n+        Semver activeVersion = activeVersionOptional.get();\n+\n+        if (!requirement.isSatisfiedBy(activeVersion)) {\n+            return Optional.empty();\n         }\n+\n+        return Optional.of(getPackageMetadata(new PackageIdentifier(packageName, activeVersion)));\n     }\n \n     /**\n-     * Get package from cache if it exists.\n+     * list PackageMetadata for available packages that satisfies the requirement.\n      *\n-     * @return Optional containing package recipe as a String\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n      */\n-    private Optional<String> getPackageRecipe(final String packageName, final Semver packageVersion)\n-            throws PackagingException, IOException {\n-        Path srcPkgRoot = getPackageVersionStorageRoot(packageName, packageVersion.toString(), LOCAL_CACHE_PATH);\n+    private List<PackageMetadata> listAvailablePackageMetadataFromLocal(final String packageName,\n+                                                                        Requirement requirement)\n+            throws PackagingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n \n-        if (!Files.exists(srcPkgRoot) || !Files.isDirectory(srcPkgRoot)) {\n-            return Optional.empty();\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Collections.emptyList();\n         }\n-        // TODO: Move to a Common list of Constants\n-        Path recipePath = srcPkgRoot.resolve(Constants.RECIPE_FILE_NAME);\n \n-        if (!Files.exists(recipePath) && Files.isRegularFile(recipePath)) {\n-            throw new PackagingException(\"Package manager cache is corrupt\");\n-            // TODO Take some corrective actions before throwing\n+        Arrays.sort(recipeFiles);\n+\n+        List<PackageMetadata> packageMetadataList = new ArrayList<>();\n+\n+        for (File recipeFile : recipeFiles) {\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+\n+            if (requirement.isSatisfiedBy(version)) {\n+                packageMetadataList.add(getPackageMetadata(new PackageIdentifier(packageName, version)));\n+            }\n+\n         }\n \n-        return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n+        return packageMetadataList;\n     }\n \n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        Package retrievedPackage = getPackageRecipe(pkgId);\n \n-    private static Path getPackageStorageRoot(final String packageName, final Path cacheFolder) {\n-        return cacheFolder.resolve(packageName);\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackage.getPackageName(), retrievedPackage.getVersion()),\n+                retrievedPackage.getDependencies());\n     }\n \n-    private static Path getPackageVersionStorageRoot(final String packageName, final String packageVersion,\n-                                                     final Path cacheFolder) {\n-        return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n+\n+    private static Semver parseVersionFromFileName(String filename) throws UnexpectedPackagingException {\n+        // TODO validate filename\n+\n+        // MonitoringService-1.0.0.yaml\n+        String suffix = \".yaml\";\n+        String versionStr = filename.split(suffix)[0].split(\"-\")[1];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMTQ5Nw=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 374}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTQ3MzYzOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDoxMTozNFrOGEElSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjo0NjozNFrOGEswgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMjU3MA==", "bodyText": "do we need trace? Extra logging slows down our tests, so unless we need it I'd want to remove it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406922570", "createdAt": "2020-04-10T20:11:34Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java", "diffHunk": "@@ -57,20 +59,16 @@\n \n     @Mock\n     private EvergreenService mainService;\n+\n     @BeforeAll\n-    public static void setup() {\n-        System.setProperty(\"log.fmt\", \"TEXT\");\n-        System.setProperty(\"log.store\", \"CONSOLE\");\n+    static void setup() {\n         System.setProperty(\"log.level\", \"TRACE\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MDgwMw==", "bodyText": "I think Hui put it originally to debug the logic as it is complicated. It is good to leave it for now because some of the atTrace() logs are very helpful for debugging the test.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407580803", "createdAt": "2020-04-13T16:46:34Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java", "diffHunk": "@@ -57,20 +59,16 @@\n \n     @Mock\n     private EvergreenService mainService;\n+\n     @BeforeAll\n-    public static void setup() {\n-        System.setProperty(\"log.fmt\", \"TEXT\");\n-        System.setProperty(\"log.store\", \"CONSOLE\");\n+    static void setup() {\n         System.setProperty(\"log.level\", \"TRACE\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMjU3MA=="}, "originalCommit": {"oid": "154ea732a053ddabe1597b7a4327d6535ff33ac3"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTkxMzEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwMDowNjoxNVrOGEIpSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODoxNjoxM1rOGEvyvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4OTEyOQ==", "bodyText": "this cannot throw interrupted exception, so you can remove it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r406989129", "createdAt": "2020-04-11T00:06:15Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -52,13 +52,16 @@\n      * @param document         deployment document\n      * @param rootPackages     root level packages\n      * @return a kernel config map\n+     * @throws PackageLoadingException if any service package was unable to be loaded\n      * @throws InterruptedException when the running thread is interrupted\n      */\n     public Map<Object, Object> resolve(List<PackageIdentifier> packagesToDeploy, DeploymentDocument document,\n-                                       List<String> rootPackages) throws InterruptedException {\n+                                       List<String> rootPackages) throws PackageLoadingException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f6da58a7a0e2b5ff2ec929292b8007f05047da8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3ODgwNQ==", "bodyText": "Removing it breaks this unit test... It also needs to be fixed but I'd do it as a separate PR.\nLeaving a TODO here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407578805", "createdAt": "2020-04-13T16:42:53Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -52,13 +52,16 @@\n      * @param document         deployment document\n      * @param rootPackages     root level packages\n      * @return a kernel config map\n+     * @throws PackageLoadingException if any service package was unable to be loaded\n      * @throws InterruptedException when the running thread is interrupted\n      */\n     public Map<Object, Object> resolve(List<PackageIdentifier> packagesToDeploy, DeploymentDocument document,\n-                                       List<String> rootPackages) throws InterruptedException {\n+                                       List<String> rootPackages) throws PackageLoadingException, InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4OTEyOQ=="}, "originalCommit": {"oid": "6f6da58a7a0e2b5ff2ec929292b8007f05047da8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MDAyNw==", "bodyText": "That mock is wrong, just replace it with the exception type that it can actually throw: PackageLoadingException", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407580027", "createdAt": "2020-04-13T16:45:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -52,13 +52,16 @@\n      * @param document         deployment document\n      * @param rootPackages     root level packages\n      * @return a kernel config map\n+     * @throws PackageLoadingException if any service package was unable to be loaded\n      * @throws InterruptedException when the running thread is interrupted\n      */\n     public Map<Object, Object> resolve(List<PackageIdentifier> packagesToDeploy, DeploymentDocument document,\n-                                       List<String> rootPackages) throws InterruptedException {\n+                                       List<String> rootPackages) throws PackageLoadingException, InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4OTEyOQ=="}, "originalCommit": {"oid": "6f6da58a7a0e2b5ff2ec929292b8007f05047da8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzMDUyNA==", "bodyText": "Changed it!\nI realized it before... I almost started changing it but I also saw there are other improvements for DeploymentTaskTest needed like removing public, and Collections.EMPTY_LIST -> Collections.emptyList().  I was afraid it would be harder for other reviewers who didn't have context as we are including more and more things in the PR.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/162#discussion_r407630524", "createdAt": "2020-04-13T18:16:13Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -52,13 +52,16 @@\n      * @param document         deployment document\n      * @param rootPackages     root level packages\n      * @return a kernel config map\n+     * @throws PackageLoadingException if any service package was unable to be loaded\n      * @throws InterruptedException when the running thread is interrupted\n      */\n     public Map<Object, Object> resolve(List<PackageIdentifier> packagesToDeploy, DeploymentDocument document,\n-                                       List<String> rootPackages) throws InterruptedException {\n+                                       List<String> rootPackages) throws PackageLoadingException, InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4OTEyOQ=="}, "originalCommit": {"oid": "6f6da58a7a0e2b5ff2ec929292b8007f05047da8"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 6, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}