{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MDM0MzQx", "number": 391, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOToxMjoyNVrOEctlgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTo1NDo1M1rOEfod6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTQyNDY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOToxMjoyNVrOHHaH-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDo0MToyM1rOHHc9WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzMDEwNg==", "bodyText": "IMO this check is too complex for M2. Is it enough to just check if component version is changed? If version isn't changed can we assume that the validation logic hasn't changed? Even the service might restart due the lifecycle change (eg, envVar), the service can still validate config before restarting", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r477530106", "createdAt": "2020-08-26T19:12:25Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also has changes for it that\n+     * will cause restart, e.g. version change/lifecycle change etc. This helps prevent failures when the\n+     * configuration to be validated has new keys or schema that the running version of the component doesn't\n+     * understand and won't be able to validate. We rely on the fact that component startup logic will need to\n+     * handle any configuration usage since it would be needed for the 1st time startup anyway.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            if (!willServiceRestart(proposedServiceConfig, currentServiceConfig, proposedTimestamp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d12e648c1f9ae23aaa7ce931fa3767b145af89a"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0NTUzNQ==", "bodyText": "I agree, if we just check version, then this validation logic is still functional. I added lifecycle check because even if version doesn't change, lifecycle commands may still change if only parameter values change in the deployment, in that case asking service to validate will be redundant IPC overhead because service would be restarting anyway. I can remove this for now like you're suggesting though because it will help us start simpler while still addressing the core issue", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r477545535", "createdAt": "2020-08-26T19:41:49Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also has changes for it that\n+     * will cause restart, e.g. version change/lifecycle change etc. This helps prevent failures when the\n+     * configuration to be validated has new keys or schema that the running version of the component doesn't\n+     * understand and won't be able to validate. We rely on the fact that component startup logic will need to\n+     * handle any configuration usage since it would be needed for the 1st time startup anyway.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            if (!willServiceRestart(proposedServiceConfig, currentServiceConfig, proposedTimestamp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzMDEwNg=="}, "originalCommit": {"oid": "2d12e648c1f9ae23aaa7ce931fa3767b145af89a"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3NjUzNw==", "bodyText": "I think it's valid use case that service want to validate the new config before restarting and apply the new config directly. If invalid, service can just reject the deployment and it doesn't need to restart.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r477576537", "createdAt": "2020-08-26T20:41:23Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also has changes for it that\n+     * will cause restart, e.g. version change/lifecycle change etc. This helps prevent failures when the\n+     * configuration to be validated has new keys or schema that the running version of the component doesn't\n+     * understand and won't be able to validate. We rely on the fact that component startup logic will need to\n+     * handle any configuration usage since it would be needed for the 1st time startup anyway.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            if (!willServiceRestart(proposedServiceConfig, currentServiceConfig, proposedTimestamp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzMDEwNg=="}, "originalCommit": {"oid": "2d12e648c1f9ae23aaa7ce931fa3767b145af89a"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzI4NTA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODoyMDozN1rOHKDhiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMToxOToyNFrOHKSACw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMwNTU0NA==", "bodyText": "DynamicComponentConfigurationValidator.class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480305544", "createdAt": "2020-08-31T18:20:37Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU0MjczMQ==", "bodyText": "Oops, fixed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480542731", "createdAt": "2020-09-01T01:19:24Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMwNTU0NA=="}, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzMwOTIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODoyNzoxOVrOHKDv_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMToxOTo1OVrOHKSCew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMwOTI0NQ==", "bodyText": "What if proposed is null? (the new serviceConfig doesn't have \"parameter\" part)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480309245", "createdAt": "2020-08-31T18:27:19Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        Topics current = currentServiceConfig.findTopics(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU0MzM1NQ==", "bodyText": "It's handled in willNodeChange(), instanceof doesn't need null check", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480543355", "createdAt": "2020-09-01T01:19:59Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        Topics current = currentServiceConfig.findTopics(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMwOTI0NQ=="}, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzMyNjY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODozMjoxOVrOHKD6rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMToyMzowMVrOHKSPHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxMTk4Mw==", "bodyText": "This can cause one report blocking on future reports. Could you add a TODo here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480311983", "createdAt": "2020-08-31T18:32:19Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        Topics current = currentServiceConfig.findTopics(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects.deepEquals(proposedConfig,\n+                        currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component\" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;\n+                }\n+            }\n+            if (validationRequested) {\n+                try {\n+                    // TODO : Use configurable timeout from deployment document\n+                    CompletableFuture.allOf(componentsToValidate.stream().map(ComponentToValidate::getResponse)\n+                            .collect(Collectors.toSet()).toArray(new CompletableFuture[0]))\n+                            .get(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n+                    failureMsg = \"Components reported that their to-be-deployed configuration is invalid\";\n+                    for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                        ConfigurationValidityReport report = componentToValidate.response.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU0NjU4OA==", "bodyText": "Technically, it cannot block, because there's code before this that waits for all futures in parallel and has a timeout so reaching this point means all future either completed successfully or were cancelled(currently no one cancels the future by this point).\nCompletableFuture.allOf(componentsToValidate.stream().map(ComponentToValidate::getResponse)\n                            .collect(Collectors.toSet()).toArray(new CompletableFuture[0]))\n                            .get(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480546588", "createdAt": "2020-09-01T01:23:01Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        Topics current = currentServiceConfig.findTopics(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects.deepEquals(proposedConfig,\n+                        currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component\" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;\n+                }\n+            }\n+            if (validationRequested) {\n+                try {\n+                    // TODO : Use configurable timeout from deployment document\n+                    CompletableFuture.allOf(componentsToValidate.stream().map(ComponentToValidate::getResponse)\n+                            .collect(Collectors.toSet()).toArray(new CompletableFuture[0]))\n+                            .get(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n+                    failureMsg = \"Components reported that their to-be-deployed configuration is invalid\";\n+                    for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                        ConfigurationValidityReport report = componentToValidate.response.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxMTk4Mw=="}, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzMzOTg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODozNTo1MFrOHKECaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMToyMzozMlrOHKSRRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxMzk2MA==", "bodyText": "Will this override the previous failure message?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480313960", "createdAt": "2020-08-31T18:35:50Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        Topics current = currentServiceConfig.findTopics(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects.deepEquals(proposedConfig,\n+                        currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component\" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;\n+                }\n+            }\n+            if (validationRequested) {\n+                try {\n+                    // TODO : Use configurable timeout from deployment document\n+                    CompletableFuture.allOf(componentsToValidate.stream().map(ComponentToValidate::getResponse)\n+                            .collect(Collectors.toSet()).toArray(new CompletableFuture[0]))\n+                            .get(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n+                    failureMsg = \"Components reported that their to-be-deployed configuration is invalid\";\n+                    for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                        ConfigurationValidityReport report = componentToValidate.response.join();\n+                        if (ConfigurationValidityStatus.INVALID.equals(report.getStatus())) {\n+                            failureMsg = String.format(\"%s { name = %s, message = %s }\", failureMsg,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU0NzE0MQ==", "bodyText": "No, it is appending", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480547141", "createdAt": "2020-09-01T01:23:32Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        Topics current = currentServiceConfig.findTopics(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects.deepEquals(proposedConfig,\n+                        currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component\" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;\n+                }\n+            }\n+            if (validationRequested) {\n+                try {\n+                    // TODO : Use configurable timeout from deployment document\n+                    CompletableFuture.allOf(componentsToValidate.stream().map(ComponentToValidate::getResponse)\n+                            .collect(Collectors.toSet()).toArray(new CompletableFuture[0]))\n+                            .get(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n+                    failureMsg = \"Components reported that their to-be-deployed configuration is invalid\";\n+                    for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                        ConfigurationValidityReport report = componentToValidate.response.join();\n+                        if (ConfigurationValidityStatus.INVALID.equals(report.getStatus())) {\n+                            failureMsg = String.format(\"%s { name = %s, message = %s }\", failureMsg,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxMzk2MA=="}, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzM0NTcxOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODozNzoyOFrOHKEF9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMToyNToyNFrOHKSZNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNDg3MA==", "bodyText": "make this a private method such as\neventReceivedByClient = subscribeValidator((configMap) -> {\n  assertThat(configMap, IsMapContaining.hasEntry(\"\"));\n  return VALID;\n});", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480314870", "createdAt": "2020-08-31T18:37:28Z", "author": {"login": "ShirleyZheng92"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.DeploymentSafetyPolicy;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStore;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.exceptions.ConfigStoreIPCException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.DEFAULT;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.GenericExternalService.LIFECYCLE_RUN_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DynamicComponentConfigurationValidationTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    private IPCClient client;\n+    private Kernel kernel;\n+    private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @BeforeEach\n+    void before() throws Exception {\n+        kernel = new Kernel();\n+        deploymentConfigMerger = new DeploymentConfigMerger(kernel);\n+\n+        // launch kernel\n+        kernel.launch();\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+\n+        // Start a new service\n+        AtomicBoolean mainRestarted = new AtomicBoolean(false);\n+        AtomicBoolean serviceStarted = new AtomicBoolean(false);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.set(true);\n+            }\n+            if (service.getName().equals(\"OldService\") && newState.equals(State.RUNNING) && oldState\n+                    .equals(State.STARTING)) {\n+                serviceStarted.set(true);\n+            }\n+        });\n+        HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+            put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                put(\"OldService\", new HashMap<Object, Object>() {{\n+                    put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                        put(\"ConfigKey1\", \"ConfigValue1\");\n+                    }});\n+                    put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                        put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                    }});\n+                    put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                }});\n+            }});\n+        }};\n+        deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+\n+        assertTrue(mainRestarted.get());\n+        assertTrue(serviceStarted.get());\n+    }\n+\n+    @AfterEach\n+    void after() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_validates_config_THEN_deployment_is_successful()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU0OTE3Mg==", "bodyText": "I tried this but it didn't seem to benefit readability since I still want to assert on the CDL and also both test cases are reporting different statuses, so I left it unchanged.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480549172", "createdAt": "2020-09-01T01:25:24Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.DeploymentSafetyPolicy;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStore;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.exceptions.ConfigStoreIPCException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.DEFAULT;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.GenericExternalService.LIFECYCLE_RUN_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DynamicComponentConfigurationValidationTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    private IPCClient client;\n+    private Kernel kernel;\n+    private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @BeforeEach\n+    void before() throws Exception {\n+        kernel = new Kernel();\n+        deploymentConfigMerger = new DeploymentConfigMerger(kernel);\n+\n+        // launch kernel\n+        kernel.launch();\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+\n+        // Start a new service\n+        AtomicBoolean mainRestarted = new AtomicBoolean(false);\n+        AtomicBoolean serviceStarted = new AtomicBoolean(false);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.set(true);\n+            }\n+            if (service.getName().equals(\"OldService\") && newState.equals(State.RUNNING) && oldState\n+                    .equals(State.STARTING)) {\n+                serviceStarted.set(true);\n+            }\n+        });\n+        HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+            put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                put(\"OldService\", new HashMap<Object, Object>() {{\n+                    put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                        put(\"ConfigKey1\", \"ConfigValue1\");\n+                    }});\n+                    put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                        put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                    }});\n+                    put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                }});\n+            }});\n+        }};\n+        deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+\n+        assertTrue(mainRestarted.get());\n+        assertTrue(serviceStarted.get());\n+    }\n+\n+    @AfterEach\n+    void after() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_validates_config_THEN_deployment_is_successful()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNDg3MA=="}, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzM2MzQwOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODo0MjozMFrOHKEQwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMToyNTozMFrOHKSZog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNzYzMg==", "bodyText": "NIT: rename to createTestDeployment()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480317632", "createdAt": "2020-08-31T18:42:30Z", "author": {"login": "ShirleyZheng92"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.DeploymentSafetyPolicy;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStore;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.exceptions.ConfigStoreIPCException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.DEFAULT;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.GenericExternalService.LIFECYCLE_RUN_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DynamicComponentConfigurationValidationTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    private IPCClient client;\n+    private Kernel kernel;\n+    private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @BeforeEach\n+    void before() throws Exception {\n+        kernel = new Kernel();\n+        deploymentConfigMerger = new DeploymentConfigMerger(kernel);\n+\n+        // launch kernel\n+        kernel.launch();\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+\n+        // Start a new service\n+        AtomicBoolean mainRestarted = new AtomicBoolean(false);\n+        AtomicBoolean serviceStarted = new AtomicBoolean(false);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.set(true);\n+            }\n+            if (service.getName().equals(\"OldService\") && newState.equals(State.RUNNING) && oldState\n+                    .equals(State.STARTING)) {\n+                serviceStarted.set(true);\n+            }\n+        });\n+        HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+            put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                put(\"OldService\", new HashMap<Object, Object>() {{\n+                    put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                        put(\"ConfigKey1\", \"ConfigValue1\");\n+                    }});\n+                    put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                        put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                    }});\n+                    put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                }});\n+            }});\n+        }};\n+        deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+\n+        assertTrue(mainRestarted.get());\n+        assertTrue(serviceStarted.get());\n+    }\n+\n+    @AfterEach\n+    void after() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_validates_config_THEN_deployment_is_successful()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.SUCCESSFUL, result.getDeploymentStatus());\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_invalidates_config_THEN_deployment_fails()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.INVALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE, result.getDeploymentStatus());\n+            assertTrue(result.getFailureCause() instanceof DynamicConfigurationValidationException);\n+            assertTrue(result.getFailureCause().getMessage() != null && result.getFailureCause().getMessage().contains(\"Components reported that their to-be-deployed configuration is invalid\"));\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }\n+    }\n+\n+    private Deployment testDeployment() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU0OTI4Mg==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480549282", "createdAt": "2020-09-01T01:25:30Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.DeploymentSafetyPolicy;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStore;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.exceptions.ConfigStoreIPCException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.DEFAULT;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.GenericExternalService.LIFECYCLE_RUN_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DynamicComponentConfigurationValidationTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    private IPCClient client;\n+    private Kernel kernel;\n+    private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @BeforeEach\n+    void before() throws Exception {\n+        kernel = new Kernel();\n+        deploymentConfigMerger = new DeploymentConfigMerger(kernel);\n+\n+        // launch kernel\n+        kernel.launch();\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+\n+        // Start a new service\n+        AtomicBoolean mainRestarted = new AtomicBoolean(false);\n+        AtomicBoolean serviceStarted = new AtomicBoolean(false);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.set(true);\n+            }\n+            if (service.getName().equals(\"OldService\") && newState.equals(State.RUNNING) && oldState\n+                    .equals(State.STARTING)) {\n+                serviceStarted.set(true);\n+            }\n+        });\n+        HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+            put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                put(\"OldService\", new HashMap<Object, Object>() {{\n+                    put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                        put(\"ConfigKey1\", \"ConfigValue1\");\n+                    }});\n+                    put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                        put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                    }});\n+                    put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                }});\n+            }});\n+        }};\n+        deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+\n+        assertTrue(mainRestarted.get());\n+        assertTrue(serviceStarted.get());\n+    }\n+\n+    @AfterEach\n+    void after() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_validates_config_THEN_deployment_is_successful()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.SUCCESSFUL, result.getDeploymentStatus());\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_invalidates_config_THEN_deployment_fails()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.INVALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE, result.getDeploymentStatus());\n+            assertTrue(result.getFailureCause() instanceof DynamicConfigurationValidationException);\n+            assertTrue(result.getFailureCause().getMessage() != null && result.getFailureCause().getMessage().contains(\"Components reported that their to-be-deployed configuration is invalid\"));\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }\n+    }\n+\n+    private Deployment testDeployment() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNzYzMg=="}, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzQyMzI3OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODo1OTo0NlrOHKE1Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMToyNTozNVrOHKSaAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMyNjkyMg==", "bodyText": "This can be in afterEach", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480326922", "createdAt": "2020-08-31T18:59:46Z", "author": {"login": "ShirleyZheng92"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.DeploymentSafetyPolicy;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStore;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.exceptions.ConfigStoreIPCException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.DEFAULT;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.GenericExternalService.LIFECYCLE_RUN_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DynamicComponentConfigurationValidationTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    private IPCClient client;\n+    private Kernel kernel;\n+    private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @BeforeEach\n+    void before() throws Exception {\n+        kernel = new Kernel();\n+        deploymentConfigMerger = new DeploymentConfigMerger(kernel);\n+\n+        // launch kernel\n+        kernel.launch();\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+\n+        // Start a new service\n+        AtomicBoolean mainRestarted = new AtomicBoolean(false);\n+        AtomicBoolean serviceStarted = new AtomicBoolean(false);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.set(true);\n+            }\n+            if (service.getName().equals(\"OldService\") && newState.equals(State.RUNNING) && oldState\n+                    .equals(State.STARTING)) {\n+                serviceStarted.set(true);\n+            }\n+        });\n+        HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+            put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                put(\"OldService\", new HashMap<Object, Object>() {{\n+                    put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                        put(\"ConfigKey1\", \"ConfigValue1\");\n+                    }});\n+                    put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                        put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                    }});\n+                    put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                }});\n+            }});\n+        }};\n+        deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+\n+        assertTrue(mainRestarted.get());\n+        assertTrue(serviceStarted.get());\n+    }\n+\n+    @AfterEach\n+    void after() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_validates_config_THEN_deployment_is_successful()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.SUCCESSFUL, result.getDeploymentStatus());\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_invalidates_config_THEN_deployment_fails()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.INVALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE, result.getDeploymentStatus());\n+            assertTrue(result.getFailureCause() instanceof DynamicConfigurationValidationException);\n+            assertTrue(result.getFailureCause().getMessage() != null && result.getFailureCause().getMessage().contains(\"Components reported that their to-be-deployed configuration is invalid\"));\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU0OTM3OQ==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480549379", "createdAt": "2020-09-01T01:25:35Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.DeploymentSafetyPolicy;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStore;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.exceptions.ConfigStoreIPCException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.DEFAULT;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.GenericExternalService.LIFECYCLE_RUN_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DynamicComponentConfigurationValidationTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    private IPCClient client;\n+    private Kernel kernel;\n+    private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @BeforeEach\n+    void before() throws Exception {\n+        kernel = new Kernel();\n+        deploymentConfigMerger = new DeploymentConfigMerger(kernel);\n+\n+        // launch kernel\n+        kernel.launch();\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+\n+        // Start a new service\n+        AtomicBoolean mainRestarted = new AtomicBoolean(false);\n+        AtomicBoolean serviceStarted = new AtomicBoolean(false);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.set(true);\n+            }\n+            if (service.getName().equals(\"OldService\") && newState.equals(State.RUNNING) && oldState\n+                    .equals(State.STARTING)) {\n+                serviceStarted.set(true);\n+            }\n+        });\n+        HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+            put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                put(\"OldService\", new HashMap<Object, Object>() {{\n+                    put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                        put(\"ConfigKey1\", \"ConfigValue1\");\n+                    }});\n+                    put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                        put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                    }});\n+                    put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                }});\n+            }});\n+        }};\n+        deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+\n+        assertTrue(mainRestarted.get());\n+        assertTrue(serviceStarted.get());\n+    }\n+\n+    @AfterEach\n+    void after() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_validates_config_THEN_deployment_is_successful()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.SUCCESSFUL, result.getDeploymentStatus());\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_invalidates_config_THEN_deployment_fails()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.INVALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE, result.getDeploymentStatus());\n+            assertTrue(result.getFailureCause() instanceof DynamicConfigurationValidationException);\n+            assertTrue(result.getFailureCause().getMessage() != null && result.getFailureCause().getMessage().contains(\"Components reported that their to-be-deployed configuration is invalid\"));\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMyNjkyMg=="}, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzQ0NzA5OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxOTowNjo1MFrOHKFDgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMToyNTo1MVrOHKSbEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzMDYyNg==", "bodyText": "Why using lenient here?Is it expected that the API not called?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480330626", "createdAt": "2020-08-31T19:06:50Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidatorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class DynamicComponentConfigurationValidatorTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_EXISTING_NODE_MOD_TIME = 10;\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    @Mock\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    @Mock\n+    private Kernel kernel;\n+\n+    @Mock\n+    private Context context;\n+\n+    @Mock\n+    private CompletableFuture<DeploymentResult> deploymentResultFuture;\n+\n+    private DynamicComponentConfigurationValidator validator;\n+\n+    @BeforeEach\n+    public void beforeEach() throws Exception {\n+        lenient().when(kernel.getContext()).thenReturn(context);\n+        validator = new DynamicComponentConfigurationValidator(kernel, configStoreIPCAgent);\n+    }\n+\n+    @AfterEach\n+    public void afterEach() throws Exception {\n+        context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_deployment_changes_service_config_WHEN_service_validates_config_THEN_succeed() throws Exception {\n+        lenient().when(configStoreIPCAgent.validateConfiguration(any(), any(), any())).thenAnswer(invocationOnMock -> {\n+            CompletableFuture<ConfigurationValidityReport> validityReportFuture = invocationOnMock.getArgument(2);\n+            validityReportFuture\n+                    .complete(ConfigurationValidityReport.builder().status(ConfigurationValidityStatus.VALID).build());\n+            return true;\n+        });\n+        createMockGenericExternalService(\"OldService\");\n+        HashMap<String, Object> servicesConfig = new HashMap<String, Object>() {{\n+            put(\"OldService\", new HashMap<Object, Object>() {{\n+                put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                    put(\"ConfigKey1\", \"ConfigValue2\");\n+                }});\n+                put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+            }});\n+        }};\n+        assertTrue(validator.validate(servicesConfig, createTestDeployment(), deploymentResultFuture));\n+    }\n+\n+    @Test\n+    public void GIVEN_deployment_changes_service_config_WHEN_service_invalidates_config_THEN_fail_deployment()\n+            throws Exception {\n+        lenient().when(configStoreIPCAgent.validateConfiguration(any(), any(), any())).thenAnswer(invocationOnMock -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU0OTY1MA==", "bodyText": "Right, I didn't need it, changed it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480549650", "createdAt": "2020-09-01T01:25:51Z", "author": {"login": "shaguptashaikh"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidatorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class DynamicComponentConfigurationValidatorTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_EXISTING_NODE_MOD_TIME = 10;\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    @Mock\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    @Mock\n+    private Kernel kernel;\n+\n+    @Mock\n+    private Context context;\n+\n+    @Mock\n+    private CompletableFuture<DeploymentResult> deploymentResultFuture;\n+\n+    private DynamicComponentConfigurationValidator validator;\n+\n+    @BeforeEach\n+    public void beforeEach() throws Exception {\n+        lenient().when(kernel.getContext()).thenReturn(context);\n+        validator = new DynamicComponentConfigurationValidator(kernel, configStoreIPCAgent);\n+    }\n+\n+    @AfterEach\n+    public void afterEach() throws Exception {\n+        context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_deployment_changes_service_config_WHEN_service_validates_config_THEN_succeed() throws Exception {\n+        lenient().when(configStoreIPCAgent.validateConfiguration(any(), any(), any())).thenAnswer(invocationOnMock -> {\n+            CompletableFuture<ConfigurationValidityReport> validityReportFuture = invocationOnMock.getArgument(2);\n+            validityReportFuture\n+                    .complete(ConfigurationValidityReport.builder().status(ConfigurationValidityStatus.VALID).build());\n+            return true;\n+        });\n+        createMockGenericExternalService(\"OldService\");\n+        HashMap<String, Object> servicesConfig = new HashMap<String, Object>() {{\n+            put(\"OldService\", new HashMap<Object, Object>() {{\n+                put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                    put(\"ConfigKey1\", \"ConfigValue2\");\n+                }});\n+                put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+            }});\n+        }};\n+        assertTrue(validator.validate(servicesConfig, createTestDeployment(), deploymentResultFuture));\n+    }\n+\n+    @Test\n+    public void GIVEN_deployment_changes_service_config_WHEN_service_invalidates_config_THEN_fail_deployment()\n+            throws Exception {\n+        lenient().when(configStoreIPCAgent.validateConfiguration(any(), any(), any())).thenAnswer(invocationOnMock -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzMDYyNg=="}, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDQ5MjcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjozMTozNlrOHLKf1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODowMDo1M1rOHL6-hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2ODM3Mw==", "bodyText": "If currentConfig is null then if proposedConfig is null then it should return false right? Isn't this going to return true right now?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r481468373", "createdAt": "2020-09-01T22:31:36Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjY2Mg==", "bodyText": "Good catch, fixed it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r482262662", "createdAt": "2020-09-02T18:00:53Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2ODM3Mw=="}, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDUyMzQ5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo0NToxMFrOHLKyUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNzoyOTo0N1rOHMwswQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3MzEwNw==", "bodyText": "Why marking validationRequested and valid as false when a service has not subscribed? Those which have subscribed will not be evaluated then ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r481473107", "createdAt": "2020-09-01T22:45:10Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects\n+                        .deepEquals(proposedConfig, currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component \" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjU1Ng==", "bodyText": "I'm not marking valid as false when the service hasn't subscribed, the Do nothing if service has not subscribed for validation comment is after the if block, meaning there is no else block since if service hasn't subscribed then it's a no op. The comment is not for the catch block", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r482262556", "createdAt": "2020-09-02T18:00:42Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects\n+                        .deepEquals(proposedConfig, currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component \" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3MzEwNw=="}, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEzNTMwNg==", "bodyText": "We probably need retries in such cases. I am still wondering if there is exception thrown when there is error in validating one component (lets say the connection was bad), we don't care about other components in that case right? I guess its either all the configuration gets deployed or none.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r483135306", "createdAt": "2020-09-03T17:16:24Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects\n+                        .deepEquals(proposedConfig, currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component \" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3MzEwNw=="}, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0Mjg0OQ==", "bodyText": "That's correct, if any component fails the deployment fails, for retries, we will know better if we need it and how to go about it once we have the new server I think", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r483142849", "createdAt": "2020-09-03T17:29:47Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects\n+                        .deepEquals(proposedConfig, currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component \" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3MzEwNw=="}, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDUzOTE0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo1MjoxOVrOHLK7dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNzoxMjowMFrOHMwF8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTQ0NA==", "bodyText": "Isn't this exception thrown when IPC is already waiting for response from the component? Whereas here we want to identify if the service never subscribed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r481475444", "createdAt": "2020-09-01T22:52:19Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects\n+                        .deepEquals(proposedConfig, currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MTAxMQ==", "bodyText": "I changed the exception handling in ConfigStoreIPCAgent.java a bit, the ValidateEventRegistrationException will be thrown when there is error requesting validation, I realized that we do not need to worry about the case when IPC is already waiting for response from the component anymore because with the new implementation in this PR, the deployment workflow will always clear out old requests so we shouldn't land into this case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r482261011", "createdAt": "2020-09-02T17:58:09Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects\n+                        .deepEquals(proposedConfig, currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTQ0NA=="}, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEzMjkxMw==", "bodyText": "Ok, somehow I did not see this change last time I reviewed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r483132913", "createdAt": "2020-09-03T17:12:00Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects\n+                        .deepEquals(proposedConfig, currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTQ0NA=="}, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjA0MzMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTo1NDo1M1rOHMBx8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDoxMTowMVrOHMDHew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM3NDEzMQ==", "bodyText": "Why skip here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r482374131", "createdAt": "2020-09-02T19:54:53Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d8cc5063ac78fdbcf33131bb35d9ee45cc3103"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM5NjAyNw==", "bodyText": "Ideally this will never happen, because a GenericExternalService has to have service config so currentServiceConfig should always be non null, but getServiceConfig() can theoretically return null. So this block will not do anything because it does not have any service topics to check against to see if version /parameters are changing", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r482396027", "createdAt": "2020-09-02T20:11:01Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM3NDEzMQ=="}, "originalCommit": {"oid": "21d8cc5063ac78fdbcf33131bb35d9ee45cc3103"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 723, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}