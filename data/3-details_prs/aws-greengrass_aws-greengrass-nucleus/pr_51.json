{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNTY5NjM0", "number": 51, "title": "Switch to using Netty for IPC server", "bodyText": "Issue #, if available:\nDescription of changes:\nRemoves our own implementation using Java sockets in favor or using Netty for the server instead.\nThis update still works with the client, and the tests are still passing.\nWhat's missing: Some more exception handling is needed, consideration around timeouts, input/output validation, and removal of listeners when a client disconnects. Additional unit testing is also needed to validate the server behavior.\nAll omitted for now to keep this commit as small as is reasonable.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-02-03T23:15:38Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51", "merged": true, "mergeCommit": {"oid": "8f19fc219cf3d17be63abffdff0f171e4368a3d8"}, "closed": true, "closedAt": "2020-02-05T22:23:47Z", "author": {"login": "MikeDombo"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcA1Z-EgH2gAyMzcwNTY5NjM0OjE0MzQ5ZGUzNTBmNWZiMjg3Y2IxYzdmYjkxNjBmOTA2NTIzNzZkNTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBc2kSgFqTM1NDA0NTk4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/14349de350f5fb287cb1c7fb9160f90652376d57", "committedDate": "2020-02-03T23:19:25Z", "message": "Switch to using Netty for IPC server"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8901cd5a954d0dfb766a29263d4f082b41f1eb21", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8901cd5a954d0dfb766a29263d4f082b41f1eb21", "committedDate": "2020-02-03T23:12:47Z", "message": "Switch to using Netty for IPC server"}, "afterCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/14349de350f5fb287cb1c7fb9160f90652376d57", "committedDate": "2020-02-03T23:19:25Z", "message": "Switch to using Netty for IPC server"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNzIwNzEx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#pullrequestreview-352720711", "createdAt": "2020-02-04T04:40:41Z", "commit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDo0MDo0MVrOFlH6zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNToyODozOFrOFlIe6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MTM3NQ==", "bodyText": "Shouldn't it be logged at error level? Also log the exception?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374471375", "createdAt": "2020-02-04T04:40:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCService.java", "diffHunk": "@@ -89,41 +70,53 @@ public IPCService(Topics c) {\n     public void startup() {\n         log.log(Level.Note, \"Startup called for IPC service\");\n         try {\n-            server.startup();\n+            port = listen();\n+\n+            String serverUri = \"tcp://\" + LOCAL_IP + \":\" + port;\n+            log.log(Log.Level.Note, \"IPC service URI: \", serverUri);\n+            // adding KERNEL_URI under setenv of the root topic. All subsequent processes will have KERNEL_URI\n+            // set via environment variables\n+            config.parent.lookup(\"setenv\", KERNEL_URI_ENV_VARIABLE_NAME).setValue(serverUri);\n+\n             super.startup();\n-        } catch (IPCException e) {\n-            log.error(\"Error starting IPC service\", e);\n-            //            setState(State.Unstable);\n-            recover();\n+        } catch (InterruptedException e) {\n+            log.warn(\"Failed IPC server startup\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MTYzNg==", "bodyText": "Update comments", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374471636", "createdAt": "2020-02-04T04:42:09Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCService.java", "diffHunk": "@@ -89,41 +70,53 @@ public IPCService(Topics c) {\n     public void startup() {\n         log.log(Level.Note, \"Startup called for IPC service\");\n         try {\n-            server.startup();\n+            port = listen();\n+\n+            String serverUri = \"tcp://\" + LOCAL_IP + \":\" + port;\n+            log.log(Log.Level.Note, \"IPC service URI: \", serverUri);\n+            // adding KERNEL_URI under setenv of the root topic. All subsequent processes will have KERNEL_URI\n+            // set via environment variables\n+            config.parent.lookup(\"setenv\", KERNEL_URI_ENV_VARIABLE_NAME).setValue(serverUri);\n+\n             super.startup();\n-        } catch (IPCException e) {\n-            log.error(\"Error starting IPC service\", e);\n-            //            setState(State.Unstable);\n-            recover();\n+        } catch (InterruptedException e) {\n+            log.warn(\"Failed IPC server startup\");\n         }\n     }\n \n+    private int listen() throws InterruptedException {\n+        ServerBootstrap b = new ServerBootstrap();\n+\n+        b.group(bossGroup, workerGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    public void initChannel(SocketChannel ch) {\n+                        ChannelPipeline p = ch.pipeline();\n+\n+                        p.addLast(new MessageFrameDecoder());\n+                        p.addLast(new MessageFrameEncoder());\n+                        p.addLast(messageHandler);\n+                    }\n+                })\n+                .option(ChannelOption.SO_BACKLOG, MAX_SO_BACKLOG)\n+                .childOption(ChannelOption.SO_KEEPALIVE, true);\n+\n+        // Bind and start to accept incoming connections.\n+        ChannelFuture f = b.bind(InetAddress.getLoopbackAddress(), 0).sync();\n+        int port = ((InetSocketAddress) f.channel().localAddress()).getPort();\n+\n+        log.note(\"IPC ready to accept connections on port\", port);\n+        return port;\n+    }\n+\n     /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MTc1Mw==", "bodyText": "do you need this log?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374471753", "createdAt": "2020-02-04T04:42:46Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCService.java", "diffHunk": "@@ -89,41 +70,53 @@ public IPCService(Topics c) {\n     public void startup() {\n         log.log(Level.Note, \"Startup called for IPC service\");\n         try {\n-            server.startup();\n+            port = listen();\n+\n+            String serverUri = \"tcp://\" + LOCAL_IP + \":\" + port;\n+            log.log(Log.Level.Note, \"IPC service URI: \", serverUri);\n+            // adding KERNEL_URI under setenv of the root topic. All subsequent processes will have KERNEL_URI\n+            // set via environment variables\n+            config.parent.lookup(\"setenv\", KERNEL_URI_ENV_VARIABLE_NAME).setValue(serverUri);\n+\n             super.startup();\n-        } catch (IPCException e) {\n-            log.error(\"Error starting IPC service\", e);\n-            //            setState(State.Unstable);\n-            recover();\n+        } catch (InterruptedException e) {\n+            log.warn(\"Failed IPC server startup\");\n         }\n     }\n \n+    private int listen() throws InterruptedException {\n+        ServerBootstrap b = new ServerBootstrap();\n+\n+        b.group(bossGroup, workerGroup)\n+                .channel(NioServerSocketChannel.class)\n+                .childHandler(new ChannelInitializer<SocketChannel>() {\n+                    @Override\n+                    public void initChannel(SocketChannel ch) {\n+                        ChannelPipeline p = ch.pipeline();\n+\n+                        p.addLast(new MessageFrameDecoder());\n+                        p.addLast(new MessageFrameEncoder());\n+                        p.addLast(messageHandler);\n+                    }\n+                })\n+                .option(ChannelOption.SO_BACKLOG, MAX_SO_BACKLOG)\n+                .childOption(ChannelOption.SO_KEEPALIVE, true);\n+\n+        // Bind and start to accept incoming connections.\n+        ChannelFuture f = b.bind(InetAddress.getLoopbackAddress(), 0).sync();\n+        int port = ((InetSocketAddress) f.channel().localAddress()).getPort();\n+\n+        log.note(\"IPC ready to accept connections on port\", port);\n+        return port;\n+    }\n+\n     /**\n      * Blocks indefinitely listening for new connection. If the server socket errors while listening, the exception\n      * is bubbled up and IPCService will transition to Errored state.\n      */\n     @Override\n     public void run() {\n         log.log(Level.Note, \"Run called for IPC service\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDM0NQ==", "bodyText": "Why are you using RePlayingDecoder? Also can you add a comment describing the message frame? Similar to the style we have in stream manager", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374474345", "createdAt": "2020-02-04T04:57:01Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.codec;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.ReplayingDecoder;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+\n+public class MessageFrameDecoder extends ReplayingDecoder<Void> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NTgyNA==", "bodyText": "What is \"2\"? Can you not use magic number here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374475824", "createdAt": "2020-02-04T05:05:32Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.codec;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.ReplayingDecoder;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+\n+public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n+    private static final int BYTE_MASK = 0xff;\n+    private static final int IS_RESPONSE_MASK = 0x01;\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n+        byteBuf.markReaderIndex();\n+\n+        if (actualReadableBytes() < 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NjI1OA==", "bodyText": "Where is actualReadableBytes() method defined?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374476258", "createdAt": "2020-02-04T05:07:52Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.codec;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.ReplayingDecoder;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+\n+public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n+    private static final int BYTE_MASK = 0xff;\n+    private static final int IS_RESPONSE_MASK = 0x01;\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n+        byteBuf.markReaderIndex();\n+\n+        if (actualReadableBytes() < 2) {\n+            byteBuf.resetReaderIndex();\n+            return;\n+        }\n+\n+        int firstByte = ((int) byteBuf.readByte()) & BYTE_MASK;\n+        int version = firstByte >> 1;\n+        FrameReader.FrameType type = FrameReader.FrameType.fromOrdinal(firstByte & IS_RESPONSE_MASK);\n+\n+        int destinationNameLength = byteBuf.readByte();\n+\n+        if (actualReadableBytes() < destinationNameLength) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NjkyNQ==", "bodyText": "If you decide to use ReplayingDecoder, you could use checkpoint() method to avoid rewinding to the beginning.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374476925", "createdAt": "2020-02-04T05:10:49Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/codec/MessageFrameDecoder.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.codec;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.ReplayingDecoder;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+\n+public class MessageFrameDecoder extends ReplayingDecoder<Void> {\n+    private static final int BYTE_MASK = 0xff;\n+    private static final int IS_RESPONSE_MASK = 0x01;\n+\n+    @Override\n+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {\n+        byteBuf.markReaderIndex();\n+\n+        if (actualReadableBytes() < 2) {\n+            byteBuf.resetReaderIndex();\n+            return;\n+        }\n+\n+        int firstByte = ((int) byteBuf.readByte()) & BYTE_MASK;\n+        int version = firstByte >> 1;\n+        FrameReader.FrameType type = FrameReader.FrameType.fromOrdinal(firstByte & IS_RESPONSE_MASK);\n+\n+        int destinationNameLength = byteBuf.readByte();\n+\n+        if (actualReadableBytes() < destinationNameLength) {\n+            byteBuf.resetReaderIndex();\n+            return;\n+        }\n+\n+        byte[] destinationNameByte = new byte[destinationNameLength];\n+        byteBuf.readBytes(destinationNameByte);\n+\n+        if (actualReadableBytes() < 6) {\n+            byteBuf.resetReaderIndex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NzMyMQ==", "bodyText": "Why not just reuse the log message?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374477321", "createdAt": "2020-02-04T05:12:47Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCCallback;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.GenericErrorCodes;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.util.AttributeKey;\n+\n+import java.io.IOException;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static com.aws.iot.evergreen.ipc.common.ResponseHelper.sendResponse;\n+import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n+\n+/**\n+ * Handles all incoming messages to the IPC server and authorizes, then appropriately\n+ * routes the message to the correct handler.\n+ */\n+@ChannelHandler.Sharable\n+public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private AuthHandler auth;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ctx.channel().attr(CONNECTION_CONTEXT_KEY).set(null);\n+        super.channelRegistered(ctx);\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        super.channelUnregistered(ctx);\n+        // TODO: Handle de-registration of any listeners such as Lifecycle\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        final FrameReader.MessageFrame message = (FrameReader.MessageFrame) msg;\n+\n+        // When there isn't context yet, we expect a call to be authorized first\n+        if (ctx.channel().attr(CONNECTION_CONTEXT_KEY).get() == null) {\n+            handleAuth(ctx, message);\n+            return;\n+        }\n+\n+        IPCCallback cb = router.getCallbackForDestination(message.destination);\n+        if (cb == null) {\n+            log.warn(\"Destination not found for packet from client\",\n+                    ctx.channel().remoteAddress(), message.destination);\n+            sendResponse(new FrameReader.Message(\n+                            SendAndReceiveIPCUtil.encode(GeneralResponse.builder()\n+                                    .error(GenericErrorCodes.Unknown)\n+                                    .errorMessage(\"Destination handler not found\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NzY4MQ==", "bodyText": "Why is the error code Unknown in this case?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374477681", "createdAt": "2020-02-04T05:14:40Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCCallback;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.GenericErrorCodes;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.util.AttributeKey;\n+\n+import java.io.IOException;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static com.aws.iot.evergreen.ipc.common.ResponseHelper.sendResponse;\n+import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n+\n+/**\n+ * Handles all incoming messages to the IPC server and authorizes, then appropriately\n+ * routes the message to the correct handler.\n+ */\n+@ChannelHandler.Sharable\n+public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private AuthHandler auth;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ctx.channel().attr(CONNECTION_CONTEXT_KEY).set(null);\n+        super.channelRegistered(ctx);\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        super.channelUnregistered(ctx);\n+        // TODO: Handle de-registration of any listeners such as Lifecycle\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        final FrameReader.MessageFrame message = (FrameReader.MessageFrame) msg;\n+\n+        // When there isn't context yet, we expect a call to be authorized first\n+        if (ctx.channel().attr(CONNECTION_CONTEXT_KEY).get() == null) {\n+            handleAuth(ctx, message);\n+            return;\n+        }\n+\n+        IPCCallback cb = router.getCallbackForDestination(message.destination);\n+        if (cb == null) {\n+            log.warn(\"Destination not found for packet from client\",\n+                    ctx.channel().remoteAddress(), message.destination);\n+            sendResponse(new FrameReader.Message(\n+                            SendAndReceiveIPCUtil.encode(GeneralResponse.builder()\n+                                    .error(GenericErrorCodes.Unknown)\n+                                    .errorMessage(\"Destination handler not found\")\n+                                    .build())),\n+                    message.sequenceNumber,\n+                    message.destination, ctx, false);\n+            return;\n+        }\n+\n+        try {\n+            // TODO: Be smart about timeouts? https://issues.amazon.com/issues/86453f7c-c94e-4a3c-b8ff-679767e7443c\n+            FrameReader.Message responseMessage = cb.onMessage(message.message,\n+                    ctx.channel().attr(CONNECTION_CONTEXT_KEY).get(),\n+                    ctx.channel())\n+                    // This .get() blocks forever waiting for the response to the request\n+                    .get();\n+            sendResponse(responseMessage,\n+                    message.sequenceNumber,\n+                    message.destination, ctx, false);\n+        } catch (Throwable throwable) {\n+            sendResponse(new FrameReader.Message(\n+                            SendAndReceiveIPCUtil.encode(GeneralResponse.builder()\n+                                    .error(GenericErrorCodes.Unknown)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3ODYwMQ==", "bodyText": "Add SIM?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374478601", "createdAt": "2020-02-04T05:19:09Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCCallback;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.GenericErrorCodes;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.util.AttributeKey;\n+\n+import java.io.IOException;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static com.aws.iot.evergreen.ipc.common.ResponseHelper.sendResponse;\n+import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n+\n+/**\n+ * Handles all incoming messages to the IPC server and authorizes, then appropriately\n+ * routes the message to the correct handler.\n+ */\n+@ChannelHandler.Sharable\n+public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private AuthHandler auth;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ctx.channel().attr(CONNECTION_CONTEXT_KEY).set(null);\n+        super.channelRegistered(ctx);\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        super.channelUnregistered(ctx);\n+        // TODO: Handle de-registration of any listeners such as Lifecycle", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3OTMxMQ==", "bodyText": "Why do you need to pass in channel? I didn't see it getting used.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374479311", "createdAt": "2020-02-04T05:22:30Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import io.netty.channel.Channel;\n+\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Interface for IPC message handlers\n+ */\n+@FunctionalInterface\n+public interface IPCCallback {\n+    Future<FrameReader.Message> onMessage(FrameReader.Message m, RequestContext ctx, Channel channel) throws Throwable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4MDYxNw==", "bodyText": "Why use an empty message? Do you handle the empty message at the caller side?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374480617", "createdAt": "2020-02-04T05:28:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/ServiceDiscoveryService.java", "diffHunk": "@@ -89,20 +92,20 @@ public Message handleMessage(Message request, RequestContext context) {\n                     genResp.setErrorMessage(\"Unknown request type \" + obj.getType());\n                     break;\n             }\n-            return new Message(SendAndReceiveIPCUtil.encode(genResp));\n-\n+            fut.complete(new Message(SendAndReceiveIPCUtil.encode(genResp)));\n         } catch (Throwable e) {\n             log.log(Level.Error, \"Failed to respond to handleMessage\", e);\n \n             GeneralResponse<Void, ServiceDiscoveryResponseStatus> errorResponse = GeneralResponse.<Void,\n                     ServiceDiscoveryResponseStatus>builder().error(ServiceDiscoveryResponseStatus.Unknown).errorMessage(e.getMessage()).build();\n \n             try {\n-                return new Message(SendAndReceiveIPCUtil.encode(errorResponse));\n+                fut.complete(new Message(SendAndReceiveIPCUtil.encode(errorResponse)));\n             } catch (IOException ex) {\n                 log.log(Level.Error, \"Couldn't even send them the error back\", e);\n             }\n         }\n-        return null;\n+        fut.complete(new Message(new byte[0]));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNzU2MzY3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#pullrequestreview-352756367", "createdAt": "2020-02-04T06:58:43Z", "commit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNjo1ODo0M1rOFlJvHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNjo1ODo0M1rOFlJvHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMTE1MQ==", "bodyText": "Can we try not to leak ipc service implementation, services registering callbacks should not know about channel.\nI would also prefer the IPCService to maintain the list of active connections, offloading that to callers would lead to repeated code for adding, removing connections.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374501151", "createdAt": "2020-02-04T06:58:43Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCCallback.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import io.netty.channel.Channel;\n+\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Interface for IPC message handlers\n+ */\n+@FunctionalInterface\n+public interface IPCCallback {\n+    Future<FrameReader.Message> onMessage(FrameReader.Message m, RequestContext ctx, Channel channel) throws Throwable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNzU4MTgy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#pullrequestreview-352758182", "createdAt": "2020-02-04T07:04:15Z", "commit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzowNDoxNVrOFlJ02Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzowNDoxNVrOFlJ02Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjYxNw==", "bodyText": "rename to messageRouter?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374502617", "createdAt": "2020-02-04T07:04:15Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCService.java", "diffHunk": "@@ -17,65 +27,36 @@\n /**\n  * Entry point to the kernel service IPC mechanism. IPC service manages the lifecycle of all IPC components\n  * <p>\n- * Server:\n- * Listens for new connections and passes new connections to connection manager\n- * <p>\n- * Connection Manager:\n- * Manages connections created by Server, connection manager is responsible for\n- * - Authenticating a new connection\n- * - Creating readers and writers for a connection\n- * - Closes connection when read or write message has IOErrors\n- * - Closes connection during shutdown\n- * <p>\n- * ConnectionReader:\n- * - Reads messages from the connection input stream and forwards them to message dispatcher\n- * - Forwards IOErrors to connection manager\n- * <p>\n- * ConnectionWriter:\n- * - Writes messages to the connection output stream\n- * - Forwards IOErrors to connection manager\n- * <p>\n- * Message Dispatcher:\n- * - Handles incoming messages from connections\n- * - Acts as an interface for modules inside the kernel to\n- * - Register call backs for a destination\n- * - Send messages to an outside process\n- * - Manages the thread pool which process all incoming and outgoing messages\n- * <p>\n  * IPCService relies on the kernel to synchronize between startup() and run() calls.\n  * <p>\n  * How messages flow:\n  * <p>\n  * New connection:\n- * Server listens for new connections, new connections are forwarded to connection manager.\n- * Connection manager authorizes connection and creates connection reader and writer\n- * <p>\n- * Incoming message from an external process\n- * Connection reader is run on a separate thread which does the blocking read on connection input stream,\n- * Message read by connection reader is forwarded to connection dispatcher, if the message is a new request,\n- * dispatcher looks up the call back based on the request destination and invokes the callback. The result of the\n- * callback is sent out via the same connection.\n- * If the message is a response to a previous request, dispatcher looks up the future object associated with the\n- * request using the sequence number and updates the future.\n+ * Server listens for new connections, new connections are forwarded to MessageRouter using the Netty pipeline.\n+ * MessageRouter authorizes connection and will then allow further queries to be routed.\n  * <p>\n  * Outgoing messages:\n- * Modules in the kernel that need to send messages to an external process would inject into itself a\n- * reference of the message dispatcher. Module can send message using client Id of the process via\n- * dispatcher. Dispatcher will look up the connection associated with the clientId using connection manager\n- * and write the message to the connection. Dispatcher will return a future object to the module which\n- * will be marked as complete when connection responds to the message.\n+ * The client must first send a request to setup a \"listener\" on the server. As part of handling that request,\n+ * the service will receive a pointer to the channel that they will then be able to use to push messages\n+ * to the client at any time in the future.\n  */\n \n @ImplementsService(name = \"IPCService\", autostart = true)\n public class IPCService extends EvergreenService {\n+    private static final int MAX_SO_BACKLOG = 128;\n+\n+    public static final String KERNEL_URI_ENV_VARIABLE_NAME = \"AWS_GG_KERNEL_URI\";\n+    private static final String LOCAL_IP = \"127.0.0.1\";\n \n     @Inject\n     Log log;\n-    //TODO: figure out how to inject the interface ConnectionManager\n-    @Inject\n-    private ConnectionManager connectionManager;\n+\n+    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n+    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n+    private int port;\n+\n     @Inject\n-    private Server server;\n+    private MessageRouter messageHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNzY2ODI3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#pullrequestreview-352766827", "createdAt": "2020-02-04T07:28:26Z", "commit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzoyODoyNlrOFlKPbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzoyODoyNlrOFlKPbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwOTQyMw==", "bodyText": "For channels that are not authenticated , where do we specify a timeout to prevent clients that connect and do not produce an auth token", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#discussion_r374509423", "createdAt": "2020-02-04T07:28:26Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCCallback;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.GenericErrorCodes;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.util.AttributeKey;\n+\n+import java.io.IOException;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static com.aws.iot.evergreen.ipc.common.ResponseHelper.sendResponse;\n+import static com.aws.iot.evergreen.util.Utils.getUltimateMessage;\n+\n+/**\n+ * Handles all incoming messages to the IPC server and authorizes, then appropriately\n+ * routes the message to the correct handler.\n+ */\n+@ChannelHandler.Sharable\n+public class MessageRouter extends ChannelInboundHandlerAdapter {\n+    public static final AttributeKey<RequestContext> CONNECTION_CONTEXT_KEY = AttributeKey.newInstance(\"ctx\");\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private AuthHandler auth;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        ctx.channel().attr(CONNECTION_CONTEXT_KEY).set(null);\n+        super.channelRegistered(ctx);\n+    }\n+\n+    @Override\n+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n+        super.channelUnregistered(ctx);\n+        // TODO: Handle de-registration of any listeners such as Lifecycle\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        final FrameReader.MessageFrame message = (FrameReader.MessageFrame) msg;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14349de350f5fb287cb1c7fb9160f90652376d57"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65a7b6d1bc9698e7f08a78f6efb226828a28e686", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/65a7b6d1bc9698e7f08a78f6efb226828a28e686", "committedDate": "2020-02-04T16:53:05Z", "message": "Refactor EvergreenService with initial unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8899bcb1307f83409c1f3a9492108737960cc7ca", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8899bcb1307f83409c1f3a9492108737960cc7ca", "committedDate": "2020-02-04T16:53:05Z", "message": "Revert \"Refactor EvergreenService with initial unit test\"\n\nThis reverts commit 773693892cd8e3e2db5ba89738ba4457fd5d5e57."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d4803a6302200ff4212f6fb4f763afdf6a2aa5dd", "committedDate": "2020-02-04T16:53:05Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa3aaf651a8878b094d9293581e1c058f2c6e574", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aa3aaf651a8878b094d9293581e1c058f2c6e574", "committedDate": "2020-02-04T16:55:26Z", "message": "Merge branch 'master' into netty"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MDEzODc2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#pullrequestreview-354013876", "createdAt": "2020-02-05T20:20:53Z", "commit": {"oid": "aa3aaf651a8878b094d9293581e1c058f2c6e574"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MDQ1OTg0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/51#pullrequestreview-354045984", "createdAt": "2020-02-05T21:16:57Z", "commit": {"oid": "aa3aaf651a8878b094d9293581e1c058f2c6e574"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2459, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}