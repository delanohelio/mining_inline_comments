{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MzY5NzU0", "number": 35, "title": "POC implementation of service discovery", "bodyText": "POC implementation of service discovery. Implements auth for IPC connections by generate 256 secure random bits for each service. Provides the token over environment variables to the service.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-01-18T00:33:43Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35", "merged": true, "mergeCommit": {"oid": "6c7b3cdf041a2819a91426f45199c32053a0ca86"}, "closed": true, "closedAt": "2020-01-23T21:14:47Z", "author": {"login": "MikeDombo"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8aEBzgFqTM0NTU5MDM5Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb860LIABqjI5NzEyOTU3MDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTkwMzk2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#pullrequestreview-345590396", "createdAt": "2020-01-21T01:14:12Z", "commit": {"oid": "25270eac0d9f5e1858f269d51e2def815ea128a4"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwMToxNDoxMlrOFfsKCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwNToxMTozOFrOFfunsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc3MzY0MQ==", "bodyText": "Missing Java docs. We should have java doc for all public classes and methods.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368773641", "createdAt": "2020-01-21T01:14:12Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+\n+public class SDAResource {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25270eac0d9f5e1858f269d51e2def815ea128a4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc3OTI2Nw==", "bodyText": "so it seems the path might not be unique for two different resources if there are overlapping values across the different fields:\nFor example,\nResource A: {\"name\": \"A\", \"serviceSubtype\": foo, \"domain\": \"bar\"}\nResource B: {\"name\": \"A\", \"serviceType\": foo, \"domain\": \"bar\"}\nthey're different resources but will be resolved into the same path.\nAlso are we sure \".\"  is not part of character set of the field values?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368779267", "createdAt": "2020-01-21T01:47:19Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    private final static Map<String, Set<String>> serviceSubtypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> serviceTypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> nameResourceNamesMap = new ConcurrentHashMap<>();\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.AlreadyRegistered;\n+            response.errorMessage = String.format(\"%s already exists\", resourcePath);\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = new SDAResource();\n+        sdaResource.resource = request.resource;\n+        sdaResource.publishedToDNSSD = request.publishToDNSSD;\n+        sdaResource.owningService = serviceName;\n+        config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+        BiFunction<? super String, ? super Set<String>, ? extends Set<String>> addOrCreate =\n+                (key, old) -> {\n+                    if (old == null) {\n+                        old = new HashSet<>();\n+                    }\n+                    old.add(resourcePath);\n+                    return old;\n+                };\n+        if (sdaResource.resource.serviceSubtype != null)\n+            serviceSubtypeResourceNamesMap.compute(sdaResource.resource.serviceSubtype, addOrCreate);\n+        if (sdaResource.resource.serviceType != null)\n+            serviceTypeResourceNamesMap.compute(sdaResource.resource.serviceType, addOrCreate);\n+        if (sdaResource.resource.name != null)\n+            nameResourceNamesMap.compute(sdaResource.resource.name, addOrCreate);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        response.response = request.resource;\n+        return response;\n+    }\n+\n+    private boolean isRegistered(String resourcePath) {\n+        return config.find(REGISTERED_RESOURCES, resourcePath) != null;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // update resource (only some fields are updatable)\n+        resource.resource.txtRecords = request.resource.txtRecords;\n+        resource.resource.uri = request.resource.uri;\n+        resource.publishedToDNSSD = request.publishToDNSSD;\n+        config.find(REGISTERED_RESOURCES, resourcePath).fire(WhatHappened.changed);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        return response;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> removeResource(RemoveResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to remove %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // Remove from quick lookup tables\n+        if (resource.resource.name != null)\n+            nameResourceNamesMap.get(resource.resource.name).remove(resourcePath);\n+        if (resource.resource.serviceSubtype != null)\n+            serviceSubtypeResourceNamesMap.get(resource.resource.serviceSubtype).remove(resourcePath);\n+        if (resource.resource.serviceType != null)\n+            serviceTypeResourceNamesMap.get(resource.resource.serviceType).remove(resourcePath);\n+\n+        // Remove from master list\n+        config.find(REGISTERED_RESOURCES, resourcePath).remove();\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        return response;\n+    }\n+\n+    public GeneralResponse<List<Resource>, ServiceDiscoveryResponseStatus> lookupResources(LookupResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<List<Resource>, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO: input validation\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        List<Resource> matchingResources = new ArrayList<>();\n+\n+        // Try a direct lookup\n+        response.response = matchingResources;\n+        if (isRegistered(resourcePath)) {\n+            matchingResources.add(((SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce()).resource);\n+            return response;\n+        }\n+\n+        // Exact match not found, try a fuzzy search\n+        if (request.resource.name != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, nameResourceNamesMap, request.resource.name));\n+        }\n+        if (!matchingResources.isEmpty()) {\n+            return response;\n+        }\n+\n+        if (request.resource.serviceSubtype != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, serviceSubtypeResourceNamesMap, request.resource.serviceSubtype));\n+        }\n+        if (!matchingResources.isEmpty()) {\n+            return response;\n+        }\n+\n+        if (request.resource.serviceType != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, serviceTypeResourceNamesMap, request.resource.serviceType));\n+        }\n+\n+        return response;\n+    }\n+\n+    private List<Resource> findMatchingResourcesInMap(LookupResourceRequest request, Map<String, Set<String>> map, String fieldValue) {\n+        return map.\n+                get(fieldValue).stream()\n+                .map(s -> ((SDAResource) config.find(REGISTERED_RESOURCES, s).getOnce()).resource)\n+                .filter(r -> matchResourceFields(request.resource, r))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static String resourceToPath(Resource r) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25270eac0d9f5e1858f269d51e2def815ea128a4"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc3OTQ2NQ==", "bodyText": "Maybe changing the method name to \"nullOrEqual\" is better?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368779465", "createdAt": "2020-01-21T01:48:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    private final static Map<String, Set<String>> serviceSubtypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> serviceTypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> nameResourceNamesMap = new ConcurrentHashMap<>();\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.AlreadyRegistered;\n+            response.errorMessage = String.format(\"%s already exists\", resourcePath);\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = new SDAResource();\n+        sdaResource.resource = request.resource;\n+        sdaResource.publishedToDNSSD = request.publishToDNSSD;\n+        sdaResource.owningService = serviceName;\n+        config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+        BiFunction<? super String, ? super Set<String>, ? extends Set<String>> addOrCreate =\n+                (key, old) -> {\n+                    if (old == null) {\n+                        old = new HashSet<>();\n+                    }\n+                    old.add(resourcePath);\n+                    return old;\n+                };\n+        if (sdaResource.resource.serviceSubtype != null)\n+            serviceSubtypeResourceNamesMap.compute(sdaResource.resource.serviceSubtype, addOrCreate);\n+        if (sdaResource.resource.serviceType != null)\n+            serviceTypeResourceNamesMap.compute(sdaResource.resource.serviceType, addOrCreate);\n+        if (sdaResource.resource.name != null)\n+            nameResourceNamesMap.compute(sdaResource.resource.name, addOrCreate);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        response.response = request.resource;\n+        return response;\n+    }\n+\n+    private boolean isRegistered(String resourcePath) {\n+        return config.find(REGISTERED_RESOURCES, resourcePath) != null;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // update resource (only some fields are updatable)\n+        resource.resource.txtRecords = request.resource.txtRecords;\n+        resource.resource.uri = request.resource.uri;\n+        resource.publishedToDNSSD = request.publishToDNSSD;\n+        config.find(REGISTERED_RESOURCES, resourcePath).fire(WhatHappened.changed);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        return response;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> removeResource(RemoveResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to remove %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // Remove from quick lookup tables\n+        if (resource.resource.name != null)\n+            nameResourceNamesMap.get(resource.resource.name).remove(resourcePath);\n+        if (resource.resource.serviceSubtype != null)\n+            serviceSubtypeResourceNamesMap.get(resource.resource.serviceSubtype).remove(resourcePath);\n+        if (resource.resource.serviceType != null)\n+            serviceTypeResourceNamesMap.get(resource.resource.serviceType).remove(resourcePath);\n+\n+        // Remove from master list\n+        config.find(REGISTERED_RESOURCES, resourcePath).remove();\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        return response;\n+    }\n+\n+    public GeneralResponse<List<Resource>, ServiceDiscoveryResponseStatus> lookupResources(LookupResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<List<Resource>, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO: input validation\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        List<Resource> matchingResources = new ArrayList<>();\n+\n+        // Try a direct lookup\n+        response.response = matchingResources;\n+        if (isRegistered(resourcePath)) {\n+            matchingResources.add(((SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce()).resource);\n+            return response;\n+        }\n+\n+        // Exact match not found, try a fuzzy search\n+        if (request.resource.name != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, nameResourceNamesMap, request.resource.name));\n+        }\n+        if (!matchingResources.isEmpty()) {\n+            return response;\n+        }\n+\n+        if (request.resource.serviceSubtype != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, serviceSubtypeResourceNamesMap, request.resource.serviceSubtype));\n+        }\n+        if (!matchingResources.isEmpty()) {\n+            return response;\n+        }\n+\n+        if (request.resource.serviceType != null) {\n+            matchingResources.addAll(findMatchingResourcesInMap(request, serviceTypeResourceNamesMap, request.resource.serviceType));\n+        }\n+\n+        return response;\n+    }\n+\n+    private List<Resource> findMatchingResourcesInMap(LookupResourceRequest request, Map<String, Set<String>> map, String fieldValue) {\n+        return map.\n+                get(fieldValue).stream()\n+                .map(s -> ((SDAResource) config.find(REGISTERED_RESOURCES, s).getOnce()).resource)\n+                .filter(r -> matchResourceFields(request.resource, r))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static String resourceToPath(Resource r) {\n+        return Stream.of(r.name, r.serviceSubtype, r.serviceType, r.domain)\n+                .filter(s -> s != null && !s.isEmpty())\n+                .collect(Collectors.joining(\".\"));\n+    }\n+\n+    private static boolean matchResourceFields(Resource input, Resource validateAgainst) {\n+        return equalOrNull(input.name, validateAgainst.name)\n+                && equalOrNull(input.serviceType, validateAgainst.serviceType)\n+                && equalOrNull(input.serviceSubtype, validateAgainst.serviceSubtype)\n+                && equalOrNull(input.domain, validateAgainst.domain);\n+    }\n+\n+    private static boolean equalOrNull(String input, String validateAgainst) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25270eac0d9f5e1858f269d51e2def815ea128a4"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgwNzA1Ng==", "bodyText": "Why not return RequestContext object instead? Then you can get rid of clientIdToServiceMap.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368807056", "createdAt": "2020-01-21T04:29:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,98 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+    public static final String AUTH_TOKEN_ENV_VAR = \"AWS_GG_AUTH\";\n+    private final Map<String, String> clientIdToServiceMap = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+    private Topics tokenTopic;\n+    private final SecureRandom random = new SecureRandom();\n+\n+    @Override\n+    public void postInject() {\n+        tokenTopic = config.lookupTopics(AUTH_TOKEN_TOPIC_NAME);\n+        // Generate tokens for each service to talk over IPC\n+        kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+\n+        // Ideally we would get called when a new service is added\n+        config.getRoot().subscribe((w, c) -> {\n+            if (!w.equals(WhatHappened.childAdded)) {\n+                return;\n+            }\n+            if (c.parent != config.getRoot()) {\n+                return;\n+            }\n+            kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+        });\n+    }\n+\n+    private void generateAuthTokenForService(String serviceName) {\n+        // 256 bits of secure randomness should be enough, though we can always increase this\n+        byte[] secureBytes = new byte[32];\n+        random.nextBytes(secureBytes);\n+        String authToken = Base64.getEncoder().encodeToString(secureBytes);\n+        config.lookup(serviceName, \"setenv\", AUTH_TOKEN_ENV_VAR)\n+                .setValue(authToken);\n+        tokenTopic.createLeafChild(serviceName).setValue(authToken);\n+    }\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public String doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25270eac0d9f5e1858f269d51e2def815ea128a4"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxNDAwMg==", "bodyText": "These maps are not synchronized with the \"master\" config. It's possible there can be race conditions between lookupResources() and registerResource() method. Why not just use a trie to store the whole thing?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r368814002", "createdAt": "2020-01-21T05:11:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    private final static Map<String, Set<String>> serviceSubtypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> serviceTypeResourceNamesMap = new ConcurrentHashMap<>();\n+    private final static Map<String, Set<String>> nameResourceNamesMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25270eac0d9f5e1858f269d51e2def815ea128a4"}, "originalPosition": 33}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "25270eac0d9f5e1858f269d51e2def815ea128a4", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/25270eac0d9f5e1858f269d51e2def815ea128a4", "committedDate": "2020-01-18T00:32:10Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}, "afterCommit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/57c57018e618808acf8e44bb47fc51b04f9f1f16", "committedDate": "2020-01-21T17:51:50Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTQ3MzIw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#pullrequestreview-346147320", "createdAt": "2020-01-21T19:51:12Z", "commit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOTo1MToxM1rOFgGvJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOTo1MToxM1rOFgGvJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIwOTEyNg==", "bodyText": "Do we have any use case for this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369209126", "createdAt": "2020-01-21T19:51:13Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.AlreadyRegistered;\n+            response.errorMessage = String.format(\"%s already exists\", resourcePath);\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = new SDAResource();\n+        sdaResource.resource = request.resource;\n+        sdaResource.publishedToDNSSD = request.publishToDNSSD;\n+        sdaResource.owningService = serviceName;\n+        config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+        response.error = ServiceDiscoveryResponseStatus.Success;\n+        response.response = request.resource;\n+        return response;\n+    }\n+\n+    private boolean isRegistered(String resourcePath) {\n+        return config.find(REGISTERED_RESOURCES, resourcePath) != null;\n+    }\n+\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotFound;\n+            response.errorMessage = String.format(\"%s was not found\", resourcePath);\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.owningService.equals(serviceName)) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+\n+        // update resource (only some fields are updatable)\n+        resource.resource.txtRecords = request.resource.txtRecords;\n+        resource.resource.uri = request.resource.uri;\n+        resource.publishedToDNSSD = request.publishToDNSSD;\n+        config.find(REGISTERED_RESOURCES, resourcePath).fire(WhatHappened.changed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTQ3NTc3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#pullrequestreview-346147577", "createdAt": "2020-01-21T19:51:37Z", "commit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOTo1MTozN1rOFgGv_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOTo1MTozN1rOFgGv_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIwOTM0MQ==", "bodyText": "If two requests reach this line concurrently, then both would succeed. Can we add locks around register/update/delete requests.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369209341", "createdAt": "2020-01-21T19:51:37Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.resource);\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.error = ServiceDiscoveryResponseStatus.ResourceNotOwned;\n+            response.errorMessage = String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath);\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.error = ServiceDiscoveryResponseStatus.AlreadyRegistered;\n+            response.errorMessage = String.format(\"%s already exists\", resourcePath);\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = new SDAResource();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTUyMTcx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#pullrequestreview-346152171", "createdAt": "2020-01-21T19:58:40Z", "commit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOTo1ODo0MVrOFgG-XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxOTo1ODo0MVrOFgG-XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxMzAyMA==", "bodyText": "Going forward can we have separate cr's for bug fixes not logically related to what the cr is addressing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369213020", "createdAt": "2020-01-21T19:58:41Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/config/WhatHappened.java", "diffHunk": "@@ -3,5 +3,5 @@\n package com.aws.iot.evergreen.config;\n \n public enum WhatHappened {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTUzMDEw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#pullrequestreview-346153010", "createdAt": "2020-01-21T20:00:03Z", "commit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDowMDowM1rOFgHA6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDowMDowM1rOFgHA6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxMzY3NQ==", "bodyText": "Kernel already inject two tokens via env variables to every external process created using shell runner.  Can we use those instead of injecting another token. I am not sure we need a token for service that are running inside the kernel process space", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369213675", "createdAt": "2020-01-21T20:00:03Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,98 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+    public static final String AUTH_TOKEN_ENV_VAR = \"AWS_GG_AUTH\";\n+    private final Map<String, String> clientIdToServiceMap = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+    private Topics tokenTopic;\n+    private final SecureRandom random = new SecureRandom();\n+\n+    @Override\n+    public void postInject() {\n+        tokenTopic = config.lookupTopics(AUTH_TOKEN_TOPIC_NAME);\n+        // Generate tokens for each service to talk over IPC\n+        kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTU3MzE0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#pullrequestreview-346157314", "createdAt": "2020-01-21T20:07:18Z", "commit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDowNzoxOFrOFgHN1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDowNzoxOFrOFgHN1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxNjk4MA==", "bodyText": "If the only place this will be called is when creating the connection reader, can we return the service name/client id when auth method is called instead of storing it in a map.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369216980", "createdAt": "2020-01-21T20:07:18Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,98 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+    public static final String AUTH_TOKEN_ENV_VAR = \"AWS_GG_AUTH\";\n+    private final Map<String, String> clientIdToServiceMap = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+    private Topics tokenTopic;\n+    private final SecureRandom random = new SecureRandom();\n+\n+    @Override\n+    public void postInject() {\n+        tokenTopic = config.lookupTopics(AUTH_TOKEN_TOPIC_NAME);\n+        // Generate tokens for each service to talk over IPC\n+        kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+\n+        // Ideally we would get called when a new service is added\n+        config.getRoot().subscribe((w, c) -> {\n+            if (!w.equals(WhatHappened.childAdded)) {\n+                return;\n+            }\n+            if (c.parent != config.getRoot()) {\n+                return;\n+            }\n+            kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+        });\n+    }\n+\n+    private void generateAuthTokenForService(String serviceName) {\n+        // 256 bits of secure randomness should be enough, though we can always increase this\n+        byte[] secureBytes = new byte[32];\n+        random.nextBytes(secureBytes);\n+        String authToken = Base64.getEncoder().encodeToString(secureBytes);\n+        config.lookup(serviceName, \"setenv\", AUTH_TOKEN_ENV_VAR)\n+                .setValue(authToken);\n+        tokenTopic.createLeafChild(serviceName).setValue(authToken);\n+    }\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public String doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();\n+\n+        // Lookup the provided auth token to associate it with a service (or reject it)\n+        String serviceName = null;\n+        for (Map.Entry<String, Object> entry : tokenTopic.toPOJO().entrySet()) {\n+            String value = (String) entry.getValue();\n+            if (value.equals(authToken)) {\n+                serviceName = entry.getKey();\n+            }\n         }\n-        //TODO: do this in a backward compatible way\n-        String clientId = new String(request.message.getPayload());\n-        if(clientId.isEmpty()){\n-            throw new IPCClientNotAuthorizedException(\"ClientId is empty\");\n+        if (serviceName == null) {\n+            throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n+\n+        clientIdToServiceMap.put(clientId, serviceName);\n         return clientId;\n     }\n \n+    public String getServiceNameFromClientId(String clientId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MTU4NzA1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#pullrequestreview-346158705", "createdAt": "2020-01-21T20:09:39Z", "commit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDowOTozOVrOFgHSCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDowOTozOVrOFgHSCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIxODA1OA==", "bodyText": "Is the intent in using a separate UUID for client ID to support multiple connections from the same service? Is there any other concern in using the auth token as the clientId", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/35#discussion_r369218058", "createdAt": "2020-01-21T20:09:39Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,98 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.config.WhatHappened;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+    public static final String AUTH_TOKEN_ENV_VAR = \"AWS_GG_AUTH\";\n+    private final Map<String, String> clientIdToServiceMap = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+    private Topics tokenTopic;\n+    private final SecureRandom random = new SecureRandom();\n+\n+    @Override\n+    public void postInject() {\n+        tokenTopic = config.lookupTopics(AUTH_TOKEN_TOPIC_NAME);\n+        // Generate tokens for each service to talk over IPC\n+        kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+\n+        // Ideally we would get called when a new service is added\n+        config.getRoot().subscribe((w, c) -> {\n+            if (!w.equals(WhatHappened.childAdded)) {\n+                return;\n+            }\n+            if (c.parent != config.getRoot()) {\n+                return;\n+            }\n+            kernel.orderedDependencies().forEach(s -> generateAuthTokenForService(s.getName()));\n+        });\n+    }\n+\n+    private void generateAuthTokenForService(String serviceName) {\n+        // 256 bits of secure randomness should be enough, though we can always increase this\n+        byte[] secureBytes = new byte[32];\n+        random.nextBytes(secureBytes);\n+        String authToken = Base64.getEncoder().encodeToString(secureBytes);\n+        config.lookup(serviceName, \"setenv\", AUTH_TOKEN_ENV_VAR)\n+                .setValue(authToken);\n+        tokenTopic.createLeafChild(serviceName).setValue(authToken);\n+    }\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public String doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16"}, "originalPosition": 85}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "57c57018e618808acf8e44bb47fc51b04f9f1f16", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/57c57018e618808acf8e44bb47fc51b04f9f1f16", "committedDate": "2020-01-21T17:51:50Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}, "afterCommit": {"oid": "6fb8b1939a8b7c3730c96b25383c9a6e22e1d47c", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6fb8b1939a8b7c3730c96b25383c9a6e22e1d47c", "committedDate": "2020-01-22T01:03:26Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6fb8b1939a8b7c3730c96b25383c9a6e22e1d47c", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6fb8b1939a8b7c3730c96b25383c9a6e22e1d47c", "committedDate": "2020-01-22T01:03:26Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}, "afterCommit": {"oid": "13887c33eb07123b4cbd410c894e9aa5ed893f7a", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/13887c33eb07123b4cbd410c894e9aa5ed893f7a", "committedDate": "2020-01-22T03:39:29Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "13887c33eb07123b4cbd410c894e9aa5ed893f7a", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/13887c33eb07123b4cbd410c894e9aa5ed893f7a", "committedDate": "2020-01-22T03:39:29Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}, "afterCommit": {"oid": "2fd20672a2a78a4d3054af0f9ab3a52744cddaf8", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2fd20672a2a78a4d3054af0f9ab3a52744cddaf8", "committedDate": "2020-01-22T17:37:27Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fd20672a2a78a4d3054af0f9ab3a52744cddaf8", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2fd20672a2a78a4d3054af0f9ab3a52744cddaf8", "committedDate": "2020-01-22T17:37:27Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}, "afterCommit": {"oid": "ed6819e4f7b0642f8857e015c91b89485ec7e62b", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ed6819e4f7b0642f8857e015c91b89485ec7e62b", "committedDate": "2020-01-22T18:33:20Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c7b3cdf041a2819a91426f45199c32053a0ca86", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6c7b3cdf041a2819a91426f45199c32053a0ca86", "committedDate": "2020-01-22T19:21:36Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed6819e4f7b0642f8857e015c91b89485ec7e62b", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ed6819e4f7b0642f8857e015c91b89485ec7e62b", "committedDate": "2020-01-22T18:33:20Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}, "afterCommit": {"oid": "6c7b3cdf041a2819a91426f45199c32053a0ca86", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6c7b3cdf041a2819a91426f45199c32053a0ca86", "committedDate": "2020-01-22T19:21:36Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2438, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}