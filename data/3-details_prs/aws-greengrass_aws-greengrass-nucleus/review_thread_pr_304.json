{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4NTMzMjQw", "number": 304, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNDoyNDo1NVrOEOGHWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo0MTo1MlrOEOcVkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMjE1NzA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/pubsub/PubSubIPCAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNDoyNDo1NVrOGxDi0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwNDo0MTo1M1rOGxD00Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA5MTQ3NQ==", "bodyText": "Is this intended to be used by other internal services in the same JVM through method invocation?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/304#discussion_r454091475", "createdAt": "2020-07-14T04:24:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/pubsub/PubSubIPCAgent.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.pubsub;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.pubsub.MessagePublishedEvent;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubPublishRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubSubscribeRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all PubSub requests over IPC.\n+ */\n+public class PubSubIPCAgent {\n+    // Map from connection --> Function to call for each published message\n+    private static final Map<String, Set<Object>> listeners = new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(PubSubIPCAgent.class);\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param publishRequest publish request\n+     * @return response\n+     */\n+    public PubSubGenericResponse publish(PubSubPublishRequest publishRequest) {\n+        if (!listeners.containsKey(publishRequest.getTopic())) {\n+            // Still technically successful, just no one was subscribed\n+            return new PubSubGenericResponse(PubSubResponseStatus.Success, null);\n+        }\n+        Set<Object> contexts = listeners.get(publishRequest.getTopic());\n+\n+        executor.execute(() -> {\n+            contexts.forEach(c -> {\n+                publishToTopic(new MessagePublishedEvent(publishRequest.getTopic(), publishRequest.getPayload()), c);\n+            });\n+        });\n+        return new PubSubGenericResponse(PubSubResponseStatus.Success, null);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param context          connection context\n+     * @return response code Success if all went well\n+     */\n+    public PubSubGenericResponse subscribe(PubSubSubscribeRequest subscribeRequest, ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.debug(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), context);\n+        listeners.get(subscribeRequest.getTopic()).add(context);\n+        context.onDisconnect(() -> {\n+            if (listeners.containsKey(subscribeRequest.getTopic())) {\n+                if (listeners.get(subscribeRequest.getTopic()).remove(context)) {\n+                    log.debug(\"Client {} disconnected, removing subscription {}\", context, subscribeRequest.getTopic());\n+                }\n+            }\n+        });\n+\n+        return new PubSubGenericResponse(PubSubResponseStatus.Success, null);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(PubSubSubscribeRequest subscribeRequest, Consumer<MessagePublishedEvent> cb) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "572c0f9f6cab065ad6a30d9519fbe16b71921c19"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA5NjA4MQ==", "bodyText": "Yes, that's the idea with exposing this method. That way we can use it for the lambda stuff.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/304#discussion_r454096081", "createdAt": "2020-07-14T04:41:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/pubsub/PubSubIPCAgent.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.pubsub;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.pubsub.MessagePublishedEvent;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubPublishRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubSubscribeRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all PubSub requests over IPC.\n+ */\n+public class PubSubIPCAgent {\n+    // Map from connection --> Function to call for each published message\n+    private static final Map<String, Set<Object>> listeners = new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(PubSubIPCAgent.class);\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param publishRequest publish request\n+     * @return response\n+     */\n+    public PubSubGenericResponse publish(PubSubPublishRequest publishRequest) {\n+        if (!listeners.containsKey(publishRequest.getTopic())) {\n+            // Still technically successful, just no one was subscribed\n+            return new PubSubGenericResponse(PubSubResponseStatus.Success, null);\n+        }\n+        Set<Object> contexts = listeners.get(publishRequest.getTopic());\n+\n+        executor.execute(() -> {\n+            contexts.forEach(c -> {\n+                publishToTopic(new MessagePublishedEvent(publishRequest.getTopic(), publishRequest.getPayload()), c);\n+            });\n+        });\n+        return new PubSubGenericResponse(PubSubResponseStatus.Success, null);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param context          connection context\n+     * @return response code Success if all went well\n+     */\n+    public PubSubGenericResponse subscribe(PubSubSubscribeRequest subscribeRequest, ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.debug(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), context);\n+        listeners.get(subscribeRequest.getTopic()).add(context);\n+        context.onDisconnect(() -> {\n+            if (listeners.containsKey(subscribeRequest.getTopic())) {\n+                if (listeners.get(subscribeRequest.getTopic()).remove(context)) {\n+                    log.debug(\"Client {} disconnected, removing subscription {}\", context, subscribeRequest.getTopic());\n+                }\n+            }\n+        });\n+\n+        return new PubSubGenericResponse(PubSubResponseStatus.Success, null);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(PubSubSubscribeRequest subscribeRequest, Consumer<MessagePublishedEvent> cb) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA5MTQ3NQ=="}, "originalCommit": {"oid": "572c0f9f6cab065ad6a30d9519fbe16b71921c19"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc3MDU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/pubsub/PubSubIPCAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTozMjozNlrOGxmIpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1MjozMlrOGxmsCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1ODIxMw==", "bodyText": "what kind of guarantee does this publish operation need to support?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/304#discussion_r454658213", "createdAt": "2020-07-14T21:32:36Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/pubsub/PubSubIPCAgent.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.pubsub;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.pubsub.MessagePublishedEvent;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubPublishRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubSubscribeRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all PubSub requests over IPC.\n+ */\n+public class PubSubIPCAgent {\n+    // Map from connection --> Function to call for each published message\n+    private static final Map<String, Set<Object>> listeners = new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(PubSubIPCAgent.class);\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param publishRequest publish request\n+     * @return response\n+     */\n+    public PubSubGenericResponse publish(PubSubPublishRequest publishRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f8ca148265a221a262b9c18a4da3cfff68bf8c"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NzI3NQ==", "bodyText": "Right now, as you can see, the only guarantee is that we add it into the executor to be run at some point. I don't really think we need a stronger guarantee like qos 1, especially I don't really want to block the thread waiting for all consumers to finish. I'll sync with Feng on the guarantee.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/304#discussion_r454667275", "createdAt": "2020-07-14T21:52:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/pubsub/PubSubIPCAgent.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.pubsub;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.pubsub.MessagePublishedEvent;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubPublishRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubSubscribeRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all PubSub requests over IPC.\n+ */\n+public class PubSubIPCAgent {\n+    // Map from connection --> Function to call for each published message\n+    private static final Map<String, Set<Object>> listeners = new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(PubSubIPCAgent.class);\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param publishRequest publish request\n+     * @return response\n+     */\n+    public PubSubGenericResponse publish(PubSubPublishRequest publishRequest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1ODIxMw=="}, "originalCommit": {"oid": "34f8ca148265a221a262b9c18a4da3cfff68bf8c"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNTc5Nzk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/pubsub/PubSubIPCAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo0MTo1MlrOGxmZyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo1MDowNVrOGxmn6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2MjYwMQ==", "bodyText": "why a CopyOnWriteArraySet? is order important? Would a set backed by concurrentHaspMap be more efficient?\nex Set myConcurrentSet = ConcurrentHashMap.newKeySet();", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/304#discussion_r454662601", "createdAt": "2020-07-14T21:41:52Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/pubsub/PubSubIPCAgent.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.pubsub;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.pubsub.MessagePublishedEvent;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubPublishRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubSubscribeRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all PubSub requests over IPC.\n+ */\n+public class PubSubIPCAgent {\n+    // Map from connection --> Function to call for each published message\n+    private static final Map<String, Set<Object>> listeners = new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f8ca148265a221a262b9c18a4da3cfff68bf8c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NjIxOQ==", "bodyText": "I'm using a set because the order isn't important (not an array). I don't see how using the keyset would be better, a cow set is threadsafe for all operations (especially iteration which we need).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/304#discussion_r454666219", "createdAt": "2020-07-14T21:50:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/pubsub/PubSubIPCAgent.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.pubsub;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.pubsub.MessagePublishedEvent;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubPublishRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubSubscribeRequest;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all PubSub requests over IPC.\n+ */\n+public class PubSubIPCAgent {\n+    // Map from connection --> Function to call for each published message\n+    private static final Map<String, Set<Object>> listeners = new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2MjYwMQ=="}, "originalCommit": {"oid": "34f8ca148265a221a262b9c18a4da3cfff68bf8c"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4395, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}