{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzMjUyMjAy", "number": 133, "title": "Fix kernel blocking when merging same config twice", "bodyText": "Fix condition to check whether kernel merge completed successfully.\nFix ipc test\n\nIssue #, if available:\nPreviously, if a config file is merged twice , the second merge is blocking\nThis PR is a subset of #123 .\nDescription of changes:\nWhy is this change necessary:\nHow was this change tested:\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-03-24T20:58:08Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133", "merged": true, "mergeCommit": {"oid": "3205b1089f2f6c52fd8241ce3c3cfdbd5aa7737e"}, "closed": true, "closedAt": "2020-03-26T15:16:17Z", "author": {"login": "ShirleyZheng92"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQ6PeYAFqTM4MDcyODI3MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRdpojgFqTM4MjExMjEyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzI4Mjcx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-380728271", "createdAt": "2020-03-24T22:00:15Z", "commit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMDoxNlrOF7EunQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMDoxNlrOF7EunQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4Nzc3Mw==", "bodyText": "this needs a comment for why it is a global lock", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397487773", "createdAt": "2020-03-24T22:00:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -123,7 +124,7 @@ private void updateStateAndBroadcast(State newState) {\n         logger.atInfo().setEventType(\"service-set-state\").addKeyValue(\"currentState\", currentState)\n                 .addKeyValue(\"newState\", newState).log();\n \n-        synchronized (this.state) {\n+        synchronized (State.class) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzI4NTc5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-380728579", "createdAt": "2020-03-24T22:00:53Z", "commit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMDo1M1rOF7EvqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMDo1M1rOF7EvqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODA0MQ==", "bodyText": "nit\n.equals.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397488041", "createdAt": "2020-03-24T22:00:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (eg.getState() == State.NEW) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzI5MTQw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-380729140", "createdAt": "2020-03-24T22:01:59Z", "commit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMTo1OVrOF7Exkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMTo1OVrOF7Exkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODUzMQ==", "bodyText": "We need a way to cancel this: ex if the future that we return is cancelled by the user, this should also be cancelled.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397488531", "createdAt": "2020-03-24T22:01:59Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (eg.getState() == State.NEW) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(Executor.class).execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "originalPosition": 46}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2c21f4b35a24bc38617002a25bf106d51765ccab", "committedDate": "2020-03-24T20:57:06Z", "message": "Fix kernel blocking when merging same config twice\n\n1. Fix condition to check whether kernel merge completed successfully.\n1. Fix ipc test"}, "afterCommit": {"oid": "11c3853be4ae2cd430f41730641f7ef236cb45a0", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/11c3853be4ae2cd430f41730641f7ef236cb45a0", "committedDate": "2020-03-25T00:09:21Z", "message": "Fix kernel blocking when merging same config twice\n\n1. Fix condition to check whether kernel merge completed successfully.\n1. Fix ipc test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODQwMTQ4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-380840148", "createdAt": "2020-03-25T03:37:42Z", "commit": {"oid": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMzozNzo0M1rOF7LGrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMzozNzo0M1rOF7LGrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5MjIzOQ==", "bodyText": "formatting looks off, can you auto-format the whole file please?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397592239", "createdAt": "2020-03-25T03:37:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODQwNTg3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-380840587", "createdAt": "2020-03-25T03:39:31Z", "commit": {"oid": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMzozOTozMlrOF7LIkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMzozOTozMlrOF7LIkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5MjcyMA==", "bodyText": "Not too sure what the behavior is of completing a cancelled future. In the case that it is cancelled, the loop exits and we'll fall through to here and complete it which would normally mean that the merge is done, but that's not the case here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397592720", "createdAt": "2020-03-25T03:39:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+                            removeServices(removedServices);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85"}, "originalPosition": 72}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9b19c3f173135798c0dbc65f14bcd7f75b7ccb85", "committedDate": "2020-03-25T00:12:43Z", "message": "Merge branch 'master' into fixConfigMergeTwice"}, "afterCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d428e6c49462a68e9aba4dbc931361f884c55ce0", "committedDate": "2020-03-25T04:00:20Z", "message": "Fix kernel blocking when merging same config twice\n\n1. Fix condition to check whether kernel merge completed successfully.\n1. Fix ipc test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODUxMjU4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-380851258", "createdAt": "2020-03-25T04:24:51Z", "commit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDoyODoyNVrOF7Lyhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDo0ODoyNVrOF7MCmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzQ2Mw==", "bodyText": "Since mergeMap is asynchronous, does it mean when line613 is executed the mergeMap might not be done yet? Is that not an issue? Do we need to make mergeMap blocking?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397603463", "createdAt": "2020-03-25T04:28:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzg0MQ==", "bodyText": "Why do we need to run context.runOnPublishQueueAndWait() instead of on the current thread? is it because of mergeMap? Let's try to make this code more readable.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397603841", "createdAt": "2020-03-25T04:30:05Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNDY4OA==", "bodyText": "I would log a warn instead.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397604688", "createdAt": "2020-03-25T04:34:08Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNDg0Nw==", "bodyText": "This log line should be after removeServices()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397604847", "createdAt": "2020-03-25T04:35:06Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNjA1NA==", "bodyText": "Do we need to clean up or revert anything before exiting here? Probably also treat different exception differently. Don't need to address in this PR but I would leave a TODO comment in the code so we don't forget.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397606054", "createdAt": "2020-03-25T04:40:59Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzI4MQ==", "bodyText": "I understand this part of code is copy and paste from previous commit, but I think we shouldn't block on get() forever. I don't understand close() return a future instead of a synchronous call. It's not like we can cancel a close.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397607281", "createdAt": "2020-03-25T04:46:47Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ==", "bodyText": "Not sure only logging is sufficient. Not able to remove the topic seems like an error we need to populate up and handle seriously (e.g. rollback).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397607579", "createdAt": "2020-03-25T04:48:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();\n+            } catch (Exception e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Cloud not clean up resources while removing\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b", "committedDate": "2020-03-25T17:43:08Z", "message": "Fix kernel blocking when merging same config twice\n\n1. Fix condition to check whether kernel merge completed successfully.\n1. Fix ipc test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0fd7acf3c5b5166c1acbab88b1a58c83549b6d3f", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0fd7acf3c5b5166c1acbab88b1a58c83549b6d3f", "committedDate": "2020-03-25T04:33:43Z", "message": "Merge branch 'master' into fixConfigMergeTwice"}, "afterCommit": {"oid": "3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b", "committedDate": "2020-03-25T17:43:08Z", "message": "Fix kernel blocking when merging same config twice\n\n1. Fix condition to check whether kernel merge completed successfully.\n1. Fix ipc test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNTM5NzY2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-381539766", "createdAt": "2020-03-25T21:11:43Z", "commit": {"oid": "3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToxMTo0M1rOF7ugHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToxMTo0M1rOF7ugHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3MjE5MQ==", "bodyText": "Use the public static constant for \"services\"", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398172191", "createdAt": "2020-03-25T21:11:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,95 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                // wait until topic listeners finished processing mergeMap changes.\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atWarn(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            removeServices(removedServices);\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                .log(\"All services updated\");\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            //TODO: handle different throwables. Revert changes if applicable.\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNjMxNTg0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-381631584", "createdAt": "2020-03-26T00:37:41Z", "commit": {"oid": "2cf0748d8e91d81cc142c73e6c9812f6bfbc472e"}, "state": "DISMISSED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwMDozNzo0MVrOF7zbOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwMDo0MTo1MFrOF7zf0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1Mjg1Nw==", "bodyText": "Right now maybe add more comments on explain why we need to run on the publish queue. Let's also try to think how we can improve this in the long run.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398252857", "createdAt": "2020-03-26T00:37:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzg0MQ=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1NDAzNQ==", "bodyText": "Then let's remove the try..catch. It doesn't provide any value to wrap all the code in try...catch lol.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398254035", "createdAt": "2020-03-26T00:41:50Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();\n+            } catch (Exception e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Cloud not clean up resources while removing\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb779a746e2b287cf81e73004215266f9683b71b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fb779a746e2b287cf81e73004215266f9683b71b", "committedDate": "2020-03-26T01:38:39Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2cf0748d8e91d81cc142c73e6c9812f6bfbc472e", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2cf0748d8e91d81cc142c73e6c9812f6bfbc472e", "committedDate": "2020-03-25T22:56:58Z", "message": "Address comments"}, "afterCommit": {"oid": "fb779a746e2b287cf81e73004215266f9683b71b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fb779a746e2b287cf81e73004215266f9683b71b", "committedDate": "2020-03-26T01:38:39Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a4de9002202c34d01fb012d3a1fdd743b808208", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9a4de9002202c34d01fb012d3a1fdd743b808208", "committedDate": "2020-03-26T12:38:58Z", "message": "Merge branch 'master' into fixConfigMergeTwice"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTY4MzE4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-381968318", "createdAt": "2020-03-26T12:41:12Z", "commit": {"oid": "9a4de9002202c34d01fb012d3a1fdd743b808208"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMTEyMTI4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#pullrequestreview-382112128", "createdAt": "2020-03-26T15:15:31Z", "commit": {"oid": "9a4de9002202c34d01fb012d3a1fdd743b808208"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2373, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}