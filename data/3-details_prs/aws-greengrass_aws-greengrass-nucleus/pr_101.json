{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1MDcxNTM2", "number": 101, "title": "Config resolver with parameter interpolation", "bodyText": "Issue #, if available:\nhttps://issues.amazon.com/P33690989\nDescription of changes:\nPR for the new config resolution code after refactored interfaces and changed decisions\nA separate PR with cleaned up code and unit tests will be created when ready, this is just to make sure we have a common understanding and we see no red flags\nWhy is this change necessary:\nHow was this change tested:\nunit tests\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-03-07T00:04:50Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101", "merged": true, "mergeCommit": {"oid": "e885deda7f652bba1d8c249cf61bd7fabec096f0"}, "closed": true, "closedAt": "2020-03-12T20:32:09Z", "author": {"login": "shaguptashaikh"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcLJm5kgFqTM3MDY5ODcwNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcNBxsggFqTM3Mzg4MDA2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjk4NzA2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-370698706", "createdAt": "2020-03-07T00:22:33Z", "commit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDoyMjozM1rOFzLFtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDozMDoxMVrOFzLLMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzM4MQ==", "bodyText": "All these gets should take a timeout, and that timeout should probably come from the caller of this deployment task, or something like that.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389203381", "createdAt": "2020-03-07T00:22:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentTask.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.DependencyResolver;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.packagemanager.PackageCache;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+@AllArgsConstructor\n+public class DeploymentTask implements Callable<Void> {\n+    private final DependencyResolver dependencyResolver;\n+    private final PackageCache packageCache;\n+    private final KernelConfigResolver kernelConfigResolver;\n+    private final Kernel kernel;\n+    private final DeploymentDocument document;\n+\n+    @Override\n+    public Void call() throws Exception {\n+        List<PackageIdentifier> desiredPackages = dependencyResolver.resolveDependencies(document);\n+        packageCache.preparePackages(desiredPackages).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzc0OA==", "bodyText": "Seems like since this is the KernelConfigResolver that it should be the bridge between DA and Kernel. In that way, DA should not tell it what packages to remove, but I think that this class itself should determine what packages to remove.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389203748", "createdAt": "2020-03-07T00:24:46Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDA4Nw==", "bodyText": "[nit]\nUse method reference instead of lambda: EvergreenService::getName", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389204087", "createdAt": "2020-03-07T00:26:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Set<PackageParameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Object childLifecycleKey : childLifecycleMap.keySet()) {\n+                interpolate(childLifecycleKey, childLifecycleMap, packageParameters);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Recompute main service dependencies for deployment.\n+     *\n+     * @return main service with updated dependencies\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Set<String> rootPackagesToRemove, DeploymentDocument document) {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(s -> s.getName()).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDQ0Mw==", "bodyText": "Instead of null, why not just return the Optional?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389204443", "createdAt": "2020-03-07T00:28:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Set<PackageParameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Object childLifecycleKey : childLifecycleMap.keySet()) {\n+                interpolate(childLifecycleKey, childLifecycleMap, packageParameters);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Recompute main service dependencies for deployment.\n+     *\n+     * @return main service with updated dependencies\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Set<String> rootPackagesToRemove, DeploymentDocument document) {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(rootPackagesToRemove);\n+        kernelDependencies.addAll(getRootPackagesToAdd(document).stream().map(PackageIdentifier::getName)\n+                .collect(Collectors.toSet()));\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        addConfigForServiceDependencies(mainLifecycleMap, kernelDependencies);\n+\n+        return mainLifecycleMap;\n+    }\n+\n+    void addConfigForServiceDependencies(Map<Object, Object> lifecycle, final Set<String> dependencies) {\n+        lifecycle.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencies));\n+    }\n+\n+    boolean packageExistsInDeployment(DeploymentDocument document, PackageIdentifier packageIdentifier) {\n+        return getMatchingPackageConfigFromDeployment(document, packageIdentifier.getName(),\n+                packageIdentifier.getVersion().toString()) != null;\n+    }\n+\n+    DeploymentPackageConfiguration getMatchingPackageConfigFromDeployment(DeploymentDocument document,\n+                                                                          String packageName, String packageVersion) {\n+        return document.getDeploymentPackageConfigurationList().stream()\n+                .filter(packageConfig -> packageName.equals(packageConfig.getPackageName()) && packageVersion.toString()\n+                        .equals(packageConfig.getResolvedVersion())).findAny().orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDc4NQ==", "bodyText": "I'm not too sure about the pojos we have right now, but this seems to be unnecessarily copying data by making a new PackageIdentifier. Is it possible to just use the existing package POJO that is in the getDeploymentPackageConfigurationList?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389204785", "createdAt": "2020-03-07T00:30:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Set<PackageParameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Object childLifecycleKey : childLifecycleMap.keySet()) {\n+                interpolate(childLifecycleKey, childLifecycleMap, packageParameters);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Recompute main service dependencies for deployment.\n+     *\n+     * @return main service with updated dependencies\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Set<String> rootPackagesToRemove, DeploymentDocument document) {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(rootPackagesToRemove);\n+        kernelDependencies.addAll(getRootPackagesToAdd(document).stream().map(PackageIdentifier::getName)\n+                .collect(Collectors.toSet()));\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        addConfigForServiceDependencies(mainLifecycleMap, kernelDependencies);\n+\n+        return mainLifecycleMap;\n+    }\n+\n+    void addConfigForServiceDependencies(Map<Object, Object> lifecycle, final Set<String> dependencies) {\n+        lifecycle.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencies));\n+    }\n+\n+    boolean packageExistsInDeployment(DeploymentDocument document, PackageIdentifier packageIdentifier) {\n+        return getMatchingPackageConfigFromDeployment(document, packageIdentifier.getName(),\n+                packageIdentifier.getVersion().toString()) != null;\n+    }\n+\n+    DeploymentPackageConfiguration getMatchingPackageConfigFromDeployment(DeploymentDocument document,\n+                                                                          String packageName, String packageVersion) {\n+        return document.getDeploymentPackageConfigurationList().stream()\n+                .filter(packageConfig -> packageName.equals(packageConfig.getPackageName()) && packageVersion.toString()\n+                        .equals(packageConfig.getResolvedVersion())).findAny().orElse(null);\n+    }\n+\n+    Set<PackageParameter> resolveParameterValuesToUse(Package pkg, DeploymentDocument document) {\n+        // If values for parameters were set in deployment they should be used\n+        Set<PackageParameter> resolvedParams = new HashSet<>(getParametersFromDeployment(document, pkg));\n+\n+        // Use defaults for parameters for which no values were set in deployment\n+        resolvedParams.addAll(pkg.getPackageParameters());\n+        return resolvedParams;\n+    }\n+\n+    Set<PackageParameter> getParametersFromDeployment(DeploymentDocument document, Package pkg) {\n+        return getMatchingPackageConfigFromDeployment(document, pkg.getPackageName(), pkg.getVersion().toString())\n+                .getParameters();\n+    }\n+\n+    /*\n+     * Deployment document has a flat list of packages, we need to identify those that are the root\n+     * packages that customer added so that they can be added as the top level dependencies of the main service.\n+     */\n+    Set<PackageIdentifier> getRootPackagesToAdd(DeploymentDocument document) {\n+        Set<PackageIdentifier> rootPackages = document.getDeploymentPackageConfigurationList().stream()\n+                .map(pkg -> new PackageIdentifier(pkg.getPackageName(),\n+                        new Semver(pkg.getResolvedVersion(), Semver.SemverType.NPM))).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 177}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjk3ODY3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-370697867", "createdAt": "2020-03-07T00:18:33Z", "commit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMDoxODozM1rOFzLCmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTowNjozNVrOFzLhsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMjU4NQ==", "bodyText": "How is rootPackagesToRemove derived from? Can it be included in the document?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389202585", "createdAt": "2020-03-07T00:18:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwODY2MQ==", "bodyText": "How do we know it must be a map? Can it be a list?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389208661", "createdAt": "2020-03-07T00:54:10Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Set<PackageParameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwOTE5OQ==", "bodyText": "Ideally I would prefer not to mutate the object passed into a method. Can we change to return the value instead?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389209199", "createdAt": "2020-03-07T00:57:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwOTY4MA==", "bodyText": "Isn't listOfPackagesToDeploy in the deploymentDocument the top level packages to be deploy?  We can modify it to include version information too.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389209680", "createdAt": "2020-03-07T01:00:32Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,\n+                                DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen over\n+        // the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(pkg, document);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, resolvedParams);\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        addConfigForServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        newConfig.put(pkg.getPackageName(), lifecycle);\n+\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey      key of the key value pair in lifecycle map\n+     * @param lifecycle         lifecycle map\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Set<PackageParameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Object childLifecycleKey : childLifecycleMap.keySet()) {\n+                interpolate(childLifecycleKey, childLifecycleMap, packageParameters);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Recompute main service dependencies for deployment.\n+     *\n+     * @return main service with updated dependencies\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Set<String> rootPackagesToRemove, DeploymentDocument document) {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(rootPackagesToRemove);\n+        kernelDependencies.addAll(getRootPackagesToAdd(document).stream().map(PackageIdentifier::getName)\n+                .collect(Collectors.toSet()));\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        addConfigForServiceDependencies(mainLifecycleMap, kernelDependencies);\n+\n+        return mainLifecycleMap;\n+    }\n+\n+    void addConfigForServiceDependencies(Map<Object, Object> lifecycle, final Set<String> dependencies) {\n+        lifecycle.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencies));\n+    }\n+\n+    boolean packageExistsInDeployment(DeploymentDocument document, PackageIdentifier packageIdentifier) {\n+        return getMatchingPackageConfigFromDeployment(document, packageIdentifier.getName(),\n+                packageIdentifier.getVersion().toString()) != null;\n+    }\n+\n+    DeploymentPackageConfiguration getMatchingPackageConfigFromDeployment(DeploymentDocument document,\n+                                                                          String packageName, String packageVersion) {\n+        return document.getDeploymentPackageConfigurationList().stream()\n+                .filter(packageConfig -> packageName.equals(packageConfig.getPackageName()) && packageVersion.toString()\n+                        .equals(packageConfig.getResolvedVersion())).findAny().orElse(null);\n+    }\n+\n+    Set<PackageParameter> resolveParameterValuesToUse(Package pkg, DeploymentDocument document) {\n+        // If values for parameters were set in deployment they should be used\n+        Set<PackageParameter> resolvedParams = new HashSet<>(getParametersFromDeployment(document, pkg));\n+\n+        // Use defaults for parameters for which no values were set in deployment\n+        resolvedParams.addAll(pkg.getPackageParameters());\n+        return resolvedParams;\n+    }\n+\n+    Set<PackageParameter> getParametersFromDeployment(DeploymentDocument document, Package pkg) {\n+        return getMatchingPackageConfigFromDeployment(document, pkg.getPackageName(), pkg.getVersion().toString())\n+                .getParameters();\n+    }\n+\n+    /*\n+     * Deployment document has a flat list of packages, we need to identify those that are the root\n+     * packages that customer added so that they can be added as the top level dependencies of the main service.\n+     */\n+    Set<PackageIdentifier> getRootPackagesToAdd(DeploymentDocument document) {\n+        Set<PackageIdentifier> rootPackages = document.getDeploymentPackageConfigurationList().stream()\n+                .map(pkg -> new PackageIdentifier(pkg.getPackageName(),\n+                        new Semver(pkg.getResolvedVersion(), Semver.SemverType.NPM))).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDc4NQ=="}, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMDU0Ng==", "bodyText": "Same here. Let's not return value through parameter. This can be changed to\nprivate Object generateConfig(PackageIdentifier packageIdentifier, DeploymentDocument document)\n\nIn the caller code line52:\npackageIdentifiers.stream().collect(Collectors.toMap(PackageIdentifier::getName, p -> generateConfig(p, document));", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r389210546", "createdAt": "2020-03-07T01:06:35Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> newConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> processPackage(newConfig, packageIdentifier, document));\n+\n+        newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return newConfig;\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param pkg       package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, PackageIdentifier packageIdentifier,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 66}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3eac70f1a15c52663dbf55c6688b435d6954e458", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3eac70f1a15c52663dbf55c6688b435d6954e458", "committedDate": "2020-03-07T05:20:57Z", "message": "Address comments and clean up"}, "afterCommit": {"oid": "4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f", "committedDate": "2020-03-07T06:34:52Z", "message": "Address comments and clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNjMwMzAy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-371630302", "createdAt": "2020-03-10T01:36:48Z", "commit": {"oid": "4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMTozNjo0OFrOFz-t-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMTo0NzoyOVrOFz-3-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0OTI3NA==", "bodyText": "This assumption may not be true if the job document has multiple versions of a package. It might be better to check with kernel instead.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r390049274", "createdAt": "2020-03-10T01:36:48Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each packaage and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen during\n+        // dependency resolution over the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1MTgzMw==", "bodyText": "We might also want to put the version constraints of each deployment fleet.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r390051833", "createdAt": "2020-03-10T01:47:29Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each packaage and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen during\n+        // dependency resolution over the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return Collections.EMPTY_MAP;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax, then change the following code accordingly\n+\n+        // Generate dependencies\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f"}, "originalPosition": 90}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f", "committedDate": "2020-03-07T06:34:52Z", "message": "Address comments and clean up"}, "afterCommit": {"oid": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a34df402e6143e1f115c0c0af8f0ff667acf6bb2", "committedDate": "2020-03-11T20:54:31Z", "message": "Config resolver with parameter interpolation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMTg4MjU0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-373188254", "createdAt": "2020-03-11T23:16:04Z", "commit": {"oid": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMzoxNjowNFrOF1Mc7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMzoxNjowNFrOF1Mc7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyMjg2Mg==", "bodyText": "Could you use PlatformResolver.resolvePlatform() to get platform-specific lifecycle?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391322862", "createdAt": "2020-03-11T23:16:04Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,179 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     resolved packages to deploy\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMjc4NzU0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-373278754", "createdAt": "2020-03-12T04:57:43Z", "commit": {"oid": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNDo1Nzo0NFrOF1RQcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNToxNjo1MFrOF1RggA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMTU4NA==", "bodyText": "This is a map, can you add information on what the map represents.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391401584", "createdAt": "2020-03-12T04:57:44Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,179 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     resolved packages to deploy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwNTY5Ng==", "bodyText": "To be future proof and consistent we can use Set to represent rootPackagesToRemove.\nYou can simply pull the PackageName from it for now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391405696", "createdAt": "2020-03-12T05:16:50Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,179 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     resolved packages to deploy\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2"}, "originalPosition": 59}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a34df402e6143e1f115c0c0af8f0ff667acf6bb2", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a34df402e6143e1f115c0c0af8f0ff667acf6bb2", "committedDate": "2020-03-11T20:54:31Z", "message": "Config resolver with parameter interpolation"}, "afterCommit": {"oid": "b6c0e1330923f33df76e52f23c89c583b93b2b69", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6c0e1330923f33df76e52f23c89c583b93b2b69", "committedDate": "2020-03-12T18:02:37Z", "message": "Config resolver with parameter interpolation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b6c0e1330923f33df76e52f23c89c583b93b2b69", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6c0e1330923f33df76e52f23c89c583b93b2b69", "committedDate": "2020-03-12T18:02:37Z", "message": "Config resolver with parameter interpolation"}, "afterCommit": {"oid": "748c8bc9567bd0f9ea801cae9076b938ccbd0e9d", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/748c8bc9567bd0f9ea801cae9076b938ccbd0e9d", "committedDate": "2020-03-12T18:14:08Z", "message": "Config resolver with parameter interpolation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "748c8bc9567bd0f9ea801cae9076b938ccbd0e9d", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/748c8bc9567bd0f9ea801cae9076b938ccbd0e9d", "committedDate": "2020-03-12T18:14:08Z", "message": "Config resolver with parameter interpolation"}, "afterCommit": {"oid": "aa72910b4a55e3dae36d31b770fe1b2247614c04", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aa72910b4a55e3dae36d31b770fe1b2247614c04", "committedDate": "2020-03-12T18:32:52Z", "message": "Config resolver with parameter interpolation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODEzNjk2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-373813696", "createdAt": "2020-03-12T18:45:01Z", "commit": {"oid": "aa72910b4a55e3dae36d31b770fe1b2247614c04"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODI4ODQ4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-373828848", "createdAt": "2020-03-12T19:08:16Z", "commit": {"oid": "aa72910b4a55e3dae36d31b770fe1b2247614c04"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzkyNjIy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-373792622", "createdAt": "2020-03-12T18:14:24Z", "commit": {"oid": "b6c0e1330923f33df76e52f23c89c583b93b2b69"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxNDoyNVrOF1p5mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTowODoxOVrOF1rpDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTMzOQ==", "bodyText": "I'm going to mark this as deprecated because job document does not have this information based on the latest changes. When do you need this list?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391805339", "createdAt": "2020-03-12T18:14:25Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPackageConfiguration.java", "diffHunk": "@@ -32,6 +35,6 @@\n     Set<PackageParameter> parameters;\n \n     @JsonProperty(\"Dependencies\")\n-    List<NameVersionPair> listOfDependentPackages;\n+    List<PackageIdentifier> listOfDependencies;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6c0e1330923f33df76e52f23c89c583b93b2b69"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjgyMQ==", "bodyText": "Besides naming changes, do you need this function in parameter resolution?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391806821", "createdAt": "2020-03-12T18:17:01Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/state/ParseAndValidateState.java", "diffHunk": "@@ -69,12 +69,12 @@ public void proceed() throws DeploymentFailureException {\n             PackageMetadata currentPackageMetdata = entry.getValue();\n             if (nameToPackageConfig.containsKey(packageName)) {\n                 DeploymentPackageConfiguration deploymentPackageConfiguration = nameToPackageConfig.get(packageName);\n-                if (deploymentPackageConfiguration.getListOfDependentPackages() != null) {\n-                    for (NameVersionPair dependencyNameVersion : deploymentPackageConfiguration\n-                            .getListOfDependentPackages()) {\n-                        if (nameToPackageMetadata.containsKey(dependencyNameVersion.getPackageName())) {\n+                if (deploymentPackageConfiguration.getListOfDependencies() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "748c8bc9567bd0f9ea801cae9076b938ccbd0e9d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxNDM0MA==", "bodyText": "I'm assuming the \"dependencies\" has platform-specific definitions https://github.com/aws/aws-greengrass-kernel/blob/73a8bec3a4d64c4b1499bded048a6523279dcfaf/src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java#L232-L238\nDoes kernel config resolve the platform as well when merging?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391814340", "createdAt": "2020-03-12T18:30:54Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,182 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     map of package identifiers to version constraints for resolved packages that are\n+     *                             to be deployed\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        // Services need to be under the services namespace in kernel config\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax e.g. isHotPluggable, dependency service state,\n+        // then change the following code accordingly\n+\n+        // Generate dependencies\n+        // TODO : Only platform specific dependencies should be added once deployment document and\n+        // package recipe format supports platform wise dependency specification\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "748c8bc9567bd0f9ea801cae9076b938ccbd0e9d"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyMTkzMg==", "bodyText": "I'm fine with your current implementation, but we might need some more discussions later about how to store this version constraint information.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391821932", "createdAt": "2020-03-12T18:45:04Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n+     * @return a kernel config map\n+     */\n+    public Map<Object, Object> resolve(List<PackageIdentifier> packageIdentifiers, DeploymentDocument document,\n+                                       Set<String> rootPackagesToRemove) {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packageIdentifiers.forEach(packageIdentifier -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each packaage and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, DeploymentDocument document) {\n+        // If package-version does not exist in deployment document, the running version on device was chosen during\n+        // dependency resolution over the one proposed in deployment, we do not need to update this service\n+        if (packageExistsInDeployment(document, packageIdentifier)) {\n+            return Collections.EMPTY_MAP;\n+        }\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax, then change the following code accordingly\n+\n+        // Generate dependencies\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA1MTgzMw=="}, "originalCommit": {"oid": "4187eb8d80c1e0645e8a54b592a84ef3bfa52e7f"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNzE4Nw==", "bodyText": "Just to confirm, parameters are only allowed for \"lifecycle\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391827187", "createdAt": "2020-03-12T18:55:05Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,184 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     map of package identifiers to version constraints for resolved packages that are\n+     *                             to be deployed\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<PackageIdentifier> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        // Services need to be under the services namespace in kernel config\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax e.g. isHotPluggable, dependency service state,\n+        // then change the following code accordingly\n+\n+        // Generate dependencies\n+        // TODO : Only platform specific dependencies should be added once deployment document and\n+        // package recipe format supports platform wise dependency specification\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        resolvedServiceConfig.put(VERSION_CONSTRAINT_CONFIG_KEY, versionConstraint);\n+        return resolvedServiceConfig;\n+    }\n+\n+    /*\n+     * For each lifecycle key-value pair of a package, substitute parameter values.\n+     */\n+    private Object interpolate(Object configValue, Set<PackageParameter> packageParameters) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa72910b4a55e3dae36d31b770fe1b2247614c04"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMDUzNg==", "bodyText": "Maybe I'm underestimating things, why don't we flatten the config to String, run a replaceAll, and reconstruct the config tree?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391830536", "createdAt": "2020-03-12T19:01:26Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,184 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     map of package identifiers to version constraints for resolved packages that are\n+     *                             to be deployed\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<PackageIdentifier> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        // Services need to be under the services namespace in kernel config\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax e.g. isHotPluggable, dependency service state,\n+        // then change the following code accordingly\n+\n+        // Generate dependencies\n+        // TODO : Only platform specific dependencies should be added once deployment document and\n+        // package recipe format supports platform wise dependency specification\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        resolvedServiceConfig.put(VERSION_CONSTRAINT_CONFIG_KEY, versionConstraint);\n+        return resolvedServiceConfig;\n+    }\n+\n+    /*\n+     * For each lifecycle key-value pair of a package, substitute parameter values.\n+     */\n+    private Object interpolate(Object configValue, Set<PackageParameter> packageParameters) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyNzE4Nw=="}, "originalCommit": {"oid": "aa72910b4a55e3dae36d31b770fe1b2247614c04"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMjQxMQ==", "bodyText": "Currently this packageVersion.toString().equals(packageConfig.getResolvedVersion()) is always true, but let's keep the check here just in case any logic changes in dependency resolver.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391832411", "createdAt": "2020-03-12T19:05:20Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,184 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     map of package identifiers to version constraints for resolved packages that are\n+     *                             to be deployed\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<PackageIdentifier> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        // Services need to be under the services namespace in kernel config\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax e.g. isHotPluggable, dependency service state,\n+        // then change the following code accordingly\n+\n+        // Generate dependencies\n+        // TODO : Only platform specific dependencies should be added once deployment document and\n+        // package recipe format supports platform wise dependency specification\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        resolvedServiceConfig.put(VERSION_CONSTRAINT_CONFIG_KEY, versionConstraint);\n+        return resolvedServiceConfig;\n+    }\n+\n+    /*\n+     * For each lifecycle key-value pair of a package, substitute parameter values.\n+     */\n+    private Object interpolate(Object configValue, Set<PackageParameter> packageParameters) {\n+\n+        Object result = configValue;\n+        if (configValue instanceof String) {\n+            String value = (String) configValue;\n+\n+            // Handle package parameters\n+            for (final PackageParameter parameter : packageParameters) {\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()),\n+                        parameter.getValue());\n+            }\n+            result = value;\n+\n+            // TODO : Handle system parameters\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<Object, Object> resolvedChildConfig = new HashMap<>();\n+            for (Map.Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig\n+                        .put(childLifecycle.getKey(), interpolate(childLifecycle.getValue(), packageParameters));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+        // TODO : Do we want to support other config types than map of\n+        // string k,v pairs? e.g. how should lists be handled?\n+        return result;\n     }\n+\n+\n+    /*\n+     * Recompute main service dependencies for deployment.\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Set<PackageIdentifier> rootPackagesToRemove,\n+                                                     DeploymentDocument document) {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(EvergreenService::getName)\n+                        .collect(Collectors.toSet());\n+        kernelDependencies\n+                .removeAll(rootPackagesToRemove.stream().map(PackageIdentifier::getName).collect(Collectors.toSet()));\n+        kernelDependencies.addAll(document.getRootPackages());\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        mainLifecycleMap.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", kernelDependencies));\n+\n+        return mainLifecycleMap;\n+    }\n+\n+    /*\n+     * Get configuration for a package-version combination from deployment document.\n+     */\n+    private Optional<DeploymentPackageConfiguration> getMatchingPackageConfigFromDeployment(DeploymentDocument document,\n+                                                                                            String packageName,\n+                                                                                            String packageVersion) {\n+        return document.getDeploymentPackageConfigurationList().stream()\n+                .filter(packageConfig -> packageName.equals(packageConfig.getPackageName()) && packageVersion.toString()\n+                        .equals(packageConfig.getResolvedVersion())).findAny();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa72910b4a55e3dae36d31b770fe1b2247614c04"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzg3MA==", "bodyText": "Maybe add a TODO in DeploymentTask or somewhere else, that we need to find out this information rootPackagesToRemove.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391833870", "createdAt": "2020-03-12T19:08:19Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.vdurmont.semver4j.Semver;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class KernelConfigResolver {\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Create a kernel config map from a list of package identifiers and deployment document.\n+     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * transform it to a kernel config key-value pair.\n+     *\n+     * @param packageIdentifiers   a list of package identifiers\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwMzc0OA=="}, "originalCommit": {"oid": "48457ace2e8873fcd3ff8cf165876729b97659d7"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODUzOTg5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-373853989", "createdAt": "2020-03-12T19:49:38Z", "commit": {"oid": "aa72910b4a55e3dae36d31b770fe1b2247614c04"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42b0ffe7591f294d8e4d67f9fc893bca872279b6", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/42b0ffe7591f294d8e4d67f9fc893bca872279b6", "committedDate": "2020-03-12T20:19:45Z", "message": "Config resolver with parameter interpolation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa72910b4a55e3dae36d31b770fe1b2247614c04", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aa72910b4a55e3dae36d31b770fe1b2247614c04", "committedDate": "2020-03-12T18:32:52Z", "message": "Config resolver with parameter interpolation"}, "afterCommit": {"oid": "42b0ffe7591f294d8e4d67f9fc893bca872279b6", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/42b0ffe7591f294d8e4d67f9fc893bca872279b6", "committedDate": "2020-03-12T20:19:45Z", "message": "Config resolver with parameter interpolation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODgwMDY0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#pullrequestreview-373880064", "createdAt": "2020-03-12T20:31:16Z", "commit": {"oid": "42b0ffe7591f294d8e4d67f9fc893bca872279b6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDozMToxN1rOF1uVYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDozMToxN1rOF1uVYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3Nzk4NA==", "bodyText": "According to yesterday's discussion, we don't need the versionConstraint since it can be derived from the recipe file for each package. It can also lead to error cases, for example:\nDeployment 1: Group A: pkgA-1.0 -> pkgD-2.0 (constraint: pkgD < 3.0) => resolved constraint: pkgD: < 3.0\nDeployment 2: Group B: pkgB-1.0 -> pkgD-2.0 (constraint: pkgD > 1.0) => resolved constraint: pkgD: >1.0 && < 3.0\nDeployment 3: Group A: pkgA-1.0 -> pkgD-3.0 (constraint: pkgD > 3.0) => constraint conflict!\n\nIn this case Deployment 3 will fail because the constraint brought by it conflicts with the existing constraint on device. However, in this case it shouldn't fail.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/101#discussion_r391877984", "createdAt": "2020-03-12T20:31:17Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -1,31 +1,184 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n package com.aws.iot.evergreen.packagemanager;\n \n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.AllArgsConstructor;\n \n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n+@AllArgsConstructor\n public class KernelConfigResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageCache packageCache;\n \n-    public KernelConfigResolver(PackageCache packageCache) {\n-        this.packageCache = packageCache;\n-    }\n+    private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";\n+    private static final String SERVICE_NAMESPACE_CONFIG_KEY = \"services\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    private final PackageCache packageCache;\n+    private final Kernel kernel;\n \n     /**\n      * Create a kernel config map from a list of package identifiers and deployment document.\n-     * For each package, it first retrieves its recipe, then merge the parameter values into the recipe, and last\n+     * For each package, it first retrieves its recipe, then merges the parameter values into the recipe, and last\n      * transform it to a kernel config key-value pair.\n-     * @param pkgs a map of package identifiers to version constraints\n-     * @param document deployment document\n+     *\n+     * @param packagesToDeploy     map of package identifiers to version constraints for resolved packages that are\n+     *                             to be deployed\n+     * @param document             deployment document\n+     * @param rootPackagesToRemove top level packages that need to be removed as part of current deployment\n      * @return a kernel config map\n      * @throws InterruptedException when the running thread is interrupted\n      */\n-    public Map<Object, Object> resolve(Map<PackageIdentifier, String> pkgs, DeploymentDocument document)\n-            throws InterruptedException {\n-        return new HashMap<>();\n+    public Map<Object, Object> resolve(Map<PackageIdentifier, String> packagesToDeploy, DeploymentDocument document,\n+                                       Set<PackageIdentifier> rootPackagesToRemove) throws InterruptedException {\n+\n+        Map<Object, Object> servicesConfig = new HashMap<>();\n+\n+        packagesToDeploy.forEach((packageIdentifier, versionConstraint) -> servicesConfig\n+                .put(packageIdentifier.getName(), getServiceConfig(packageIdentifier, versionConstraint, document)));\n+\n+        servicesConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(rootPackagesToRemove, document));\n+\n+        // Services need to be under the services namespace in kernel config\n+        return Collections.singletonMap(SERVICE_NAMESPACE_CONFIG_KEY, servicesConfig);\n+    }\n+\n+    /*\n+     * Processe lifecycle section of each package and add it to the config.\n+     */\n+    private Map<Object, Object> getServiceConfig(PackageIdentifier packageIdentifier, String versionConstraint,\n+                                                 DeploymentDocument document) {\n+\n+        Package pkg = packageCache.getRecipe(packageIdentifier);\n+\n+        Map<Object, Object> resolvedServiceConfig = new HashMap<>();\n+\n+        // TODO : Package recipe format is not in alignment with the changed Kernel config syntax,\n+        // which leads to inconsistent naming, e.g. lifecycle per new Kernel config syntax is one of several config\n+        // keys while per current package recipe format it's the entire config for that package\n+        // These incosistencies need to be addressed\n+\n+        // Interpolate parameters\n+        Set<PackageParameter> resolvedParams = resolveParameterValuesToUse(document, pkg);\n+        for (Map.Entry<String, Object> configKVPair : pkg.getLifecycle().entrySet()) {\n+            resolvedServiceConfig.put(configKVPair.getKey(), interpolate(configKVPair.getValue(), resolvedParams));\n+        }\n+\n+        // TODO : Update package recipe format to include all information that service dependencies config\n+        // expects according to the new syntax e.g. isHotPluggable, dependency service state,\n+        // then change the following code accordingly\n+\n+        // Generate dependencies\n+        // TODO : Only platform specific dependencies should be added once deployment document and\n+        // package recipe format supports platform wise dependency specification\n+        Set<String> dependencyServiceNames = pkg.getDependencies().keySet();\n+        resolvedServiceConfig.put(SERVICE_DEPENDENCIES_CONFIG_KEY, String.join(\", \", dependencyServiceNames));\n+\n+        resolvedServiceConfig.put(VERSION_CONFIG_KEY, pkg.getVersion());\n+        resolvedServiceConfig.put(VERSION_CONSTRAINT_CONFIG_KEY, versionConstraint);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42b0ffe7591f294d8e4d67f9fc893bca872279b6"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2314, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}