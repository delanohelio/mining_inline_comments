{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYxOTk2MTYw", "number": 346, "title": "Config store IPC APIs - updates read, subscribe and adds write, validate", "bodyText": "Config store IPC APIs - updates read, subscribe for supporting shared con\u2026fig, adds write and validate\nIssue #, if available:\nhttps://issues.amazon.com/issues/P37992161\nDescription of changes:\nTries to follow API design - https://quip-amazon.com/mbN5ATEk6Db6/IPC-SDK-API-Design\nClient changes - aws-greengrass/aws-greengrass-logging-java#47\n[RESOLVED]Needs open questions to be answered tracked in - https://issues.amazon.com/issues/P38232751 Open questions were answered and the decision is to allow both deployments and service process to update the same set of keys so there will be no separate namespace for deployment managed vs runtime config\n[NOTE] Have some questions after implementing the per key and nested config update subscriptions, added them as comments/TODOs [UPDATE] Questions resolved and TODOs replaced with decided implementation\n[NOTE] Current IPC client has one channel per client/component process. Had to write some not-so-nice workaround in the client aws-greengrass/aws-greengrass-logging-java#47 to make it work with multiple subscriptions per client requirement, but it should help avoid throwaway changes on the server side.\n[NOTE] Update config API also supports a compare and swap mechanism per this recent doc https://quip-amazon.com/p8cHAqa43GRM/Support-compare-and-swap-operation-on-UpdateConfiguration-API\nWhy is this change necessary:\nHow was this change tested:\nExisting and new tests pass\nAny additional information or context required to review the change:\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-08-03T07:18:24Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346", "merged": true, "mergeCommit": {"oid": "ab92b31023f6ed26b8f2be52eb40d5577b238119"}, "closed": true, "closedAt": "2020-08-18T18:23:52Z", "author": {"login": "shaguptashaikh"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7u-D3ABqjM2MjIzNDc1NjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdAKkhvgFqTQ2OTY4MDM4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b78266759811946360e64f07e20d0bf07ad6ab7", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4b78266759811946360e64f07e20d0bf07ad6ab7", "committedDate": "2020-08-03T07:11:39Z", "message": "Config store APIs - updates read, subscribe for supporting shared config, adds write and validate"}, "afterCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "committedDate": "2020-08-04T23:10:14Z", "message": "Remove runtime config handling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODQ5NDA4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-461849408", "createdAt": "2020-08-05T16:53:31Z", "commit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjo1MzozMVrOG8STuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjo1ODozN1rOG8Sgdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NzcwNA==", "bodyText": "update this comment, what is this a map of now?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r465867704", "createdAt": "2020-08-05T16:53:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -40,17 +49,13 @@\n  */\n public class ConfigStoreIPCAgent implements InjectionActions {\n     // Map from connection --> Function to call when service config changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2OTY5NQ==", "bodyText": "I don't think you need the contains check, I'm pretty sure you can just do remove", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r465869695", "createdAt": "2020-08-05T16:56:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -84,22 +100,38 @@ public void postInject() {\n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n+     * @param request request for component update subscription\n      * @param context connection context\n      * @return response code Success if all went well\n      */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n         });\n \n-        return new ConfigStoreGenericResponse(ConfigStoreResponseStatus.Success, null);\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDk2Nw==", "bodyText": "[nit]\ncombine this string", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r465870967", "createdAt": "2020-08-05T16:58:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 200}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyOTc0MDQy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-462974042", "createdAt": "2020-08-07T01:12:57Z", "commit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwMToyNDozNVrOG9JXmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwMjo0Njo1MlrOG9Ko9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2OTgxOQ==", "bodyText": "Are we not taking key (to subscribe to) as an input in the request as desribed in API design doc?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466769819", "createdAt": "2020-08-07T01:24:35Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -84,22 +100,38 @@ public void postInject() {\n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n+     * @param request request for component update subscription\n      * @param context connection context\n      * @return response code Success if all went well\n      */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n+        String componentName =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MTI5OQ==", "bodyText": "To me the name does not seem to fit. Don;t have great suggestions but maybe actionsByContext or methodToInvokeByContext", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466771299", "createdAt": "2020-08-07T01:30:14Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -40,17 +49,13 @@\n  */\n public class ConfigStoreIPCAgent implements InjectionActions {\n     // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n+            new ConcurrentHashMap<>();\n+    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NzIwNA==", "bodyText": "Currently context represents one client and you can receive more than one subscriptions from one client. I think in that case this will not work. We probably need configUpdateListeners to be Map<Context, BiConsumer<String, String>>\nBiConsumer to consume keychanged and serviceName, and send that serviceName to the client. Let me know what you think.\nAlso, it is not implemented yet but I think the meaning of context will change when we use the new IPC, since that will have streamIds. A context object will represent a particular stream for a particular client. So when that happens this code will work. We can see if we can write something that works for both and we do not have to change much with new IPC.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466777204", "createdAt": "2020-08-07T01:53:25Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -84,22 +100,38 @@ public void postInject() {\n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n+     * @param request request for component update subscription\n      * @param context connection context\n      * @return response code Success if all went well\n      */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3OTY2Nw==", "bodyText": "Is the key still called parameters? Or is it now called configuration?\nAlso, just making sure, event for the same service we allow only this part of config to be read?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466779667", "createdAt": "2020-08-07T02:03:04Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -134,27 +166,28 @@ public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n \n     /**\n      * Read specified key from the service's dynamic config.\n-     * @param readRequest read request\n+     *\n+     * @param request request\n      * @param context client context\n      * @return response data\n      */\n-    public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest, ConnectionContext context) {\n-        log.atDebug().kv(\"context\", context).log(\"Config IPC read request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ConfigStoreReadValueResponse.ConfigStoreReadValueResponseBuilder response =\n-                ConfigStoreReadValueResponse.builder();\n+    public GetConfigurationResponse getConfig(GetConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC get config request\");\n+        String serviceName = request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+        Topics serviceTopic = kernel.findServiceTopic(serviceName);\n+        GetConfigurationResponse.GetConfigurationResponseBuilder response = GetConfigurationResponse.builder();\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        Topics configTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);\n-        if (configTopics == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.NoDynamicConfig)\n-                    .errorMessage(\"Service has no dynamic config\").build();\n+        Topics componentConfigurationTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDU4NQ==", "bodyText": "So when the device SDK team provides us the server code, I imagine we will get some POJOS for requests, responses and errors. Let see how we can reduce the changes we need to do when we want to move to using those POJOS. So putting all send error responses into a helper method would help. In that helper we can pass the error type and send the response accordingly and when we move to using SDK POJOS we just need to change that helper method. You can refer to ConfigStore APIs error messages at https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L259", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466780585", "createdAt": "2020-08-07T02:06:44Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -134,27 +166,28 @@ public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n \n     /**\n      * Read specified key from the service's dynamic config.\n-     * @param readRequest read request\n+     *\n+     * @param request request\n      * @param context client context\n      * @return response data\n      */\n-    public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest, ConnectionContext context) {\n-        log.atDebug().kv(\"context\", context).log(\"Config IPC read request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ConfigStoreReadValueResponse.ConfigStoreReadValueResponseBuilder response =\n-                ConfigStoreReadValueResponse.builder();\n+    public GetConfigurationResponse getConfig(GetConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC get config request\");\n+        String serviceName = request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+        Topics serviceTopic = kernel.findServiceTopic(serviceName);\n+        GetConfigurationResponse.GetConfigurationResponseBuilder response = GetConfigurationResponse.builder();\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDg1OA==", "bodyText": "Also, if we need other error messages then we can add to the Smithy model as well.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466780858", "createdAt": "2020-08-07T02:07:50Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -134,27 +166,28 @@ public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n \n     /**\n      * Read specified key from the service's dynamic config.\n-     * @param readRequest read request\n+     *\n+     * @param request request\n      * @param context client context\n      * @return response data\n      */\n-    public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest, ConnectionContext context) {\n-        log.atDebug().kv(\"context\", context).log(\"Config IPC read request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ConfigStoreReadValueResponse.ConfigStoreReadValueResponseBuilder response =\n-                ConfigStoreReadValueResponse.builder();\n+    public GetConfigurationResponse getConfig(GetConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC get config request\");\n+        String serviceName = request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+        Topics serviceTopic = kernel.findServiceTopic(serviceName);\n+        GetConfigurationResponse.GetConfigurationResponseBuilder response = GetConfigurationResponse.builder();\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDU4NQ=="}, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MjcxNg==", "bodyText": "If we do not allow this then we should remove componentName from the request. We can add when we start supporting it. Let me know what is the decision, the API doc says we are. We need to update both Smithy model and doc to reflect the decision.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466782716", "createdAt": "2020-08-07T02:14:44Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4NzY5OA==", "bodyText": "I am thinking about how we can minimize the changes we need to do with new IPC. So putting this creation of application message and sending can be put in helper method (which takes the opcode and others as parameters). This helper can be used by the sendStoreUpdateToListener method as well.\nThis is just something I want to put out there so as you code you can keep it in mind and wherever possible we can attempt to do it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466787698", "createdAt": "2020-08-07T02:34:43Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4OTYxNg==", "bodyText": "Add handle in the method name?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466789616", "createdAt": "2020-08-07T02:42:37Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Handle user service's response to config validation request.\n+     *\n+     * @param request request to report validation status for config\n+     * @param context client context\n+     * @return response data\n+     */\n+    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDUzOQ==", "bodyText": "Most of the APIs for Config store does not send response. You can refer here : https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L76\nEven the Subscribe APIs do not send any initial response. The acknowledgement of the message at protocol level should be taken care by new IPC. So for now you may want to add TODO to remove these sent responses when new IPC is used.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466790539", "createdAt": "2020-08-07T02:46:26Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -70,13 +73,28 @@ public void postInject() {\n             ConfigStoreClientOpCodes opCode = ConfigStoreClientOpCodes.values()[applicationMessage.getOpCode()];\n             ConfigStoreGenericResponse configStoreGenericResponse = new ConfigStoreGenericResponse();\n             switch (opCode) {\n-                case SUBSCRIBE_ALL:\n-                    configStoreGenericResponse = agent.subscribe(context);\n+                case SUBSCRIBE_TO_ALL_CONFIG_UPDATES:\n+                    SubscribeToConfigurationUpdateRequest subscribeToConfigUpdateRequest = CBOR_MAPPER\n+                            .readValue(applicationMessage.getPayload(), SubscribeToConfigurationUpdateRequest.class);\n+                    configStoreGenericResponse = agent.subscribeToConfigUpdate(subscribeToConfigUpdateRequest, context);\n                     break;\n-                case READ_KEY:\n-                    ConfigStoreReadValueRequest readRequest =\n-                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), ConfigStoreReadValueRequest.class);\n-                    configStoreGenericResponse = agent.read(readRequest, context);\n+                case GET_CONFIG:\n+                    GetConfigurationRequest getConfigRequest =\n+                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), GetConfigurationRequest.class);\n+                    configStoreGenericResponse = agent.getConfig(getConfigRequest, context);\n+                    break;\n+                case UPDATE_CONFIG:\n+                    UpdateConfigurationRequest updateConfigRequest =\n+                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), UpdateConfigurationRequest.class);\n+                    configStoreGenericResponse = agent.updateConfig(updateConfigRequest, context);\n+                    break;\n+                case SUBSCRIBE_TO_CONFIG_VALIDATION:\n+                    configStoreGenericResponse = agent.subscribeToConfigValidation(context);\n+                    break;\n+                case REPORT_CONFIG_VALIDITY:\n+                    ReportConfigurationValidityRequest reportConfigValidityRequest = CBOR_MAPPER\n+                            .readValue(applicationMessage.getPayload(), ReportConfigurationValidityRequest.class);\n+                    configStoreGenericResponse = agent.reportConfigValidity(reportConfigValidityRequest, context);\n                     break;\n                 default:\n                     configStoreGenericResponse.setStatus(ConfigStoreResponseStatus.InvalidRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDY0Ng==", "bodyText": "Similar comment about helper for sending errors. This will be treated as ServiceError since this is not a clients mistake.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466790646", "createdAt": "2020-08-07T02:46:52Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Handle user service's response to config validation request.\n+     *\n+     * @param request request to report validation status for config\n+     * @param context client context\n+     * @return response data\n+     */\n+    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,\n+                                                                    ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        ReportConfigurationValidityResponse.ReportConfigurationValidityResponseBuilder response =\n+                ReportConfigurationValidityResponse.builder();\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3"}, "originalPosition": 288}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "committedDate": "2020-08-04T23:10:14Z", "message": "Remove runtime config handling"}, "afterCommit": {"oid": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/81ecc7100d8d18e21d85048a661cf47a0d12726e", "committedDate": "2020-08-07T04:31:29Z", "message": "Enhancements"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/81ecc7100d8d18e21d85048a661cf47a0d12726e", "committedDate": "2020-08-07T04:31:29Z", "message": "Enhancements"}, "afterCommit": {"oid": "dac25eeeea15629ed8f335290415076ea691bc22", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dac25eeeea15629ed8f335290415076ea691bc22", "committedDate": "2020-08-07T04:34:31Z", "message": "Enhancements"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dac25eeeea15629ed8f335290415076ea691bc22", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dac25eeeea15629ed8f335290415076ea691bc22", "committedDate": "2020-08-07T04:34:31Z", "message": "Enhancements"}, "afterCommit": {"oid": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/85c8fa46d71692a43e5f4e3dfcf080bf38694230", "committedDate": "2020-08-07T04:42:58Z", "message": "Enhancements"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/85c8fa46d71692a43e5f4e3dfcf080bf38694230", "committedDate": "2020-08-07T04:42:58Z", "message": "Enhancements"}, "afterCommit": {"oid": "35798fd73576d2dcc4a06ba500c23f7aec2ecc18", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/35798fd73576d2dcc4a06ba500c23f7aec2ecc18", "committedDate": "2020-08-07T04:52:57Z", "message": "Enhancements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNjkyNjUy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-463692652", "createdAt": "2020-08-07T23:55:15Z", "commit": {"oid": "a25849e13367a1d2345b91b308fe457fd4f6e220"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMzo1NToxNVrOG9rqBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOFQwMDowMDo0OVrOG9ruAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTU5MQ==", "bodyText": "should this be in a finally so that it is always removed even if the test fails?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467331591", "createdAt": "2020-08-07T23:55:15Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -222,17 +225,80 @@ void GIVEN_ConfigStoreClient_WHEN_subscribe_THEN_key_sent_when_changed() throws\n             }\n         }, 2);\n \n-        c.subscribe(p.getRight());\n-        custom.createLeafChild(\"abc\").withValue(\"ABC\");\n-        custom.createLeafChild(\"DDF\").withValue(\"ddf\");\n+        c.subscribeToConfigurationUpdate(\"ServiceName\", p.getRight());\n+        configuration.createLeafChild(\"abc\").withValue(\"ABC\");\n+        configuration.createLeafChild(\"DDF\").withValue(\"ddf\");\n \n         try {\n-            p.getLeft().get(1, TimeUnit.SECONDS);\n+            p.getLeft().get(10, TimeUnit.SECONDS);\n         } finally {\n-            custom.remove();\n+            configuration.remove();\n         }\n     }\n \n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validateResultFuture =\n+                new CompletableFuture<>();\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n+                validateResultFuture);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25849e13367a1d2345b91b308fe457fd4f6e220"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTgwNg==", "bodyText": "this assertion won't do anything (except cause the CDL to not be counted down). I'd recommend using: https://github.com/aws/aws-greengrass-kernel/blob/708b5de9daf62f941429a6131523aaae3c448380/src/test/java/com/aws/iot/evergreen/testcommons/testutilities/TestUtils.java#L60", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467331806", "createdAt": "2020-08-07T23:56:25Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -222,17 +225,80 @@ void GIVEN_ConfigStoreClient_WHEN_subscribe_THEN_key_sent_when_changed() throws\n             }\n         }, 2);\n \n-        c.subscribe(p.getRight());\n-        custom.createLeafChild(\"abc\").withValue(\"ABC\");\n-        custom.createLeafChild(\"DDF\").withValue(\"ddf\");\n+        c.subscribeToConfigurationUpdate(\"ServiceName\", p.getRight());\n+        configuration.createLeafChild(\"abc\").withValue(\"ABC\");\n+        configuration.createLeafChild(\"DDF\").withValue(\"ddf\");\n \n         try {\n-            p.getLeft().get(1, TimeUnit.SECONDS);\n+            p.getLeft().get(10, TimeUnit.SECONDS);\n         } finally {\n-            custom.remove();\n+            configuration.remove();\n         }\n     }\n \n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validateResultFuture =\n+                new CompletableFuture<>();\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n+                validateResultFuture);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);\n+    }\n+\n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25849e13367a1d2345b91b308fe457fd4f6e220"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTk3MQ==", "bodyText": "this is changed now due to my recent merge. You'll need to rebase.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467331971", "createdAt": "2020-08-07T23:57:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -62,19 +91,30 @@\n         }\n \n         List<String> nodePath = node.path();\n-        // The path should have at least 5 items: null (root), services, serviceName, custom, <someKey>\n+        // The path should have at least 5 items: null (root), services, serviceName, parameters, <someKey>\n         if (nodePath.size() < 5) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25849e13367a1d2345b91b308fe457fd4f6e220"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMjM5Ng==", "bodyText": "should this be moved into our SDK package?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467332396", "createdAt": "2020-08-07T23:59:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -165,10 +217,179 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n         } else if (node instanceof Topics) {\n             response.value(((Topics) node).toPOJO());\n         } else {\n-            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            response.responseStatus(ConfigStoreResponseStatus.ServiceError).errorMessage(\"Node has an unknown type\");\n             log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n         }\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's configuration.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Handle user service's response to config validation request.\n+     *\n+     * @param request request to report validation status for config\n+     * @param context client context\n+     * @return response data\n+     */\n+    public SendConfigurationValidityReportResponse handleConfigValidityReport(\n+            SendConfigurationValidityReportRequest request, ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n+        SendConfigurationValidityReportResponse.SendConfigurationValidityReportResponseBuilder response =\n+                SendConfigurationValidityReportResponse.builder();\n+        // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n+        //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n+        //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+        if (!configValidationReportFutures.containsKey(context.getServiceName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Validation request either timed out or was never made\").build();\n+        }\n+\n+        CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                configValidationReportFutures.get(context.getServiceName());\n+        if (!reportFuture.isCancelled()) {\n+            reportFuture.complete(\n+                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n+                            .build());\n+        }\n+        configValidationReportFutures.remove(context.getServiceName());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Trigger a validate event to service/component, typically used during deployments.\n+     *\n+     * @param componentName service/component to send validate event to\n+     * @param configuration new component configuration to validate\n+     * @param reportFuture  future to track validation report in response to the event\n+     * @return true if the service has registered a validator, false if not\n+     * @throws UnsupportedOperationException throws when triggering requested validation event is not allowed\n+     */\n+    public boolean validateConfiguration(String componentName, Map<String, Object> configuration,\n+                                         CompletableFuture<ConfigurationValidityReport> reportFuture)\n+            throws UnsupportedOperationException {\n+        // TODO : Consider handling a collection of components to abstract validation for the whole deployment\n+        if (configValidationReportFutures.containsKey(componentName)) {\n+            throw new UnsupportedOperationException(\n+                    \"A validation request to this component is already waiting for response\");\n+        }\n+\n+        for (Map.Entry<ConnectionContext, Consumer<Map<String, Object>>> e : configValidationListeners.entrySet()) {\n+            if (e.getKey().getServiceName().equals(componentName)) {\n+                configValidationReportFutures.put(componentName, reportFuture);\n+                e.getValue().accept(configuration);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Abandon tracking for report of configuration validation event. Can be used by the caller in the case of timeouts\n+     * or other errors.\n+     *\n+     * @param componentName component name to abandon validation for\n+     * @param reportFuture  tracking future for validation report to abandon\n+     * @return true if abandon request was successful\n+     */\n+    public boolean discardValidationReportTracker(String componentName,\n+                                                  CompletableFuture<ConfigurationValidityReport> reportFuture) {\n+        return configValidationReportFutures.remove(componentName, reportFuture);\n+    }\n+\n+    // TODO: If it adds value, add this to the SendConfigurationValidityReportRequest in smithy model\n+    @Builder\n+    @Getter\n+    public static class ConfigurationValidityReport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25849e13367a1d2345b91b308fe457fd4f6e220"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMjYwOA==", "bodyText": "close context in aftereach", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467332608", "createdAt": "2020-08-08T00:00:49Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdateEvent;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class ConfigStoreIPCAgentTest {\n+    private static final String TEST_COMPONENT_A = \"Component_A\";\n+    private static final String TEST_COMPONENT_B = \"Component_B\";\n+    private static final String TEST_CONFIG_KEY_1 = \"temperature\";\n+    private static final String TEST_CONFIG_KEY_2 = \"humidity\";\n+\n+    @Mock\n+    private Kernel kernel;\n+\n+    @Mock\n+    private ExecutorService executor;\n+\n+    @Mock\n+    private ConnectionContext componentAContext;\n+\n+    @Mock\n+    private ConnectionContext componentBContext;\n+\n+    private ConfigStoreIPCAgent agent;\n+\n+    private Configuration configuration;\n+\n+    @BeforeEach\n+    void setup() {\n+        agent = new ConfigStoreIPCAgent(kernel, executor);\n+\n+        configuration = new Configuration(new Context());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25849e13367a1d2345b91b308fe457fd4f6e220"}, "originalPosition": 90}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a25849e13367a1d2345b91b308fe457fd4f6e220", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a25849e13367a1d2345b91b308fe457fd4f6e220", "committedDate": "2020-08-07T23:40:36Z", "message": "Unit and integ tests"}, "afterCommit": {"oid": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0eada4e4c5d2644f516058f34a4f43a9472fbc58", "committedDate": "2020-08-09T03:45:51Z", "message": "Simplified version with per key and nested key subscriptions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzODQxMjc3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-463841277", "createdAt": "2020-08-09T03:56:32Z", "commit": {"oid": "0eada4e4c5d2644f516058f34a4f43a9472fbc58"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwMzo1NjozMlrOG9367w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwMzo1NjozMlrOG9367w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjUyNw==", "bodyText": "I changed this but forgot to remove this comment", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467532527", "createdAt": "2020-08-09T03:56:32Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +52,177 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        // Sends an event immediately after", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eada4e4c5d2644f516058f34a4f43a9472fbc58"}, "originalPosition": 141}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzODQxMTky", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-463841192", "createdAt": "2020-08-09T03:53:48Z", "commit": {"oid": "0eada4e4c5d2644f516058f34a4f43a9472fbc58"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwMzo1Mzo0OFrOG936RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwMzo1Mzo0OFrOG936RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjM1Nw==", "bodyText": "pass in the version too", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467532357", "createdAt": "2020-08-09T03:53:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.aws.iot.evergreen.ipc.common;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ServiceEventHelper {\n+    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    ExecutorService executor;\n+\n+    /**\n+     * Send requested event to requested IPC channel.\n+     *\n+     * @param connectionContext client connection context\n+     * @param serviceEvent event data\n+     * @param destinationCode service destination code to denote the source of the event\n+     * @param opCode op code\n+     */\n+    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n+        try {\n+            ApplicationMessage applicationMessage =\n+                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eada4e4c5d2644f516058f34a4f43a9472fbc58"}, "originalPosition": 41}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0eada4e4c5d2644f516058f34a4f43a9472fbc58", "committedDate": "2020-08-09T03:45:51Z", "message": "Simplified version with per key and nested key subscriptions"}, "afterCommit": {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/21d36db9c58cff65320dc91184a2dab2b057cc32", "committedDate": "2020-08-09T04:04:28Z", "message": "Simplified version with per key and nested key subscriptions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTAzODQ3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-463903847", "createdAt": "2020-08-09T21:14:27Z", "commit": {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMToxNDoyOFrOG9912Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMToxNDoyOFrOG9912Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYyOTUyOQ==", "bodyText": "Nice, this can be used by all ipc components\ndo the server push also with the executor thread? Since this will run by the publish thread, we should avoid doing IO. Also can we return the future so called can handle if the sendEvent failed. The caller might not use it always but is a nice to have", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467629529", "createdAt": "2020-08-09T21:14:28Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.aws.iot.evergreen.ipc.common;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ServiceEventHelper {\n+    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    ExecutorService executor;\n+\n+    /**\n+     * Send requested event to requested IPC channel.\n+     *\n+     * @param connectionContext client connection context\n+     * @param serviceEvent event data\n+     * @param destinationCode service destination code to denote the source of the event\n+     * @param opCode op code\n+     */\n+    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n+        try {\n+            ApplicationMessage applicationMessage =\n+                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)\n+                            .payload(IPCUtil.encode(serviceEvent)).build();\n+            // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+            Future<FrameReader.Message> fut = connectionContext", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTA0MTY3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-463904167", "createdAt": "2020-08-09T21:19:33Z", "commit": {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMToxOTozM1rOG993rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMToxOTozM1rOG993rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYyOTk5Ng==", "bodyText": "This is leaking info about what components are present, from a security stand point we should always return key not found. Same goes for \"Requested component does not have any configuration\". Not sure how relevant this is right now, but changing it now might help in the future", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467629996", "createdAt": "2020-08-09T21:19:33Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +52,176 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTA0ODY5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-463904869", "createdAt": "2020-08-09T21:31:32Z", "commit": {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMTozMTozMlrOG9974g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQyMTozMTozMlrOG9974g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzMTA3NA==", "bodyText": "+1 for string arrays.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467631074", "createdAt": "2020-08-09T21:31:32Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +52,176 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n         }\n \n-        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n-                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath[customConfigIndex + 1]));\n-    };\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+        return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n-     *\n-     * @param context connection context\n-     * @return response code Success if all went well\n-     */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32"}, "originalPosition": 183}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/21d36db9c58cff65320dc91184a2dab2b057cc32", "committedDate": "2020-08-09T04:04:28Z", "message": "Simplified version with per key and nested key subscriptions"}, "afterCommit": {"oid": "06ea9776f2584626db3feffbab6dbb09ff463b69", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/06ea9776f2584626db3feffbab6dbb09ff463b69", "committedDate": "2020-08-10T16:42:05Z", "message": "Address comments add more open questions as TODOs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDMyOTkz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-467032993", "createdAt": "2020-08-13T18:38:16Z", "commit": {"oid": "06ea9776f2584626db3feffbab6dbb09ff463b69"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODozODoxNlrOHAYriA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODozODoxNlrOHAYriA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NjQwOA==", "bodyText": "withNewerValue() will not change the value if the request timestamp is less than the topics last modified timestamp. We should return that information back to the callee rather than report success.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470166408", "createdAt": "2020-08-13T18:38:16Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -170,4 +238,154 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's configuration.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n+        }\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ea9776f2584626db3feffbab6dbb09ff463b69"}, "originalPosition": 365}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06ea9776f2584626db3feffbab6dbb09ff463b69", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/06ea9776f2584626db3feffbab6dbb09ff463b69", "committedDate": "2020-08-10T16:42:05Z", "message": "Address comments add more open questions as TODOs"}, "afterCommit": {"oid": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "committedDate": "2020-08-13T20:46:32Z", "message": "Implemented TODOs for previously open/now resolved questions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "committedDate": "2020-08-13T20:46:32Z", "message": "Implemented TODOs for previously open/now resolved questions"}, "afterCommit": {"oid": "647576c1f224d6603cec83e06225b81e8738162e", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/647576c1f224d6603cec83e06225b81e8738162e", "committedDate": "2020-08-14T02:23:16Z", "message": "Support compare and swap update"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "07262794834f062c3248017e01db996383d8eb63", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/07262794834f062c3248017e01db996383d8eb63", "committedDate": "2020-08-14T05:37:32Z", "message": "Make checkstyle and pmd happy"}, "afterCommit": {"oid": "96005264f317b738b3a10e836112b85cc4ad0a6b", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/96005264f317b738b3a10e836112b85cc4ad0a6b", "committedDate": "2020-08-14T05:41:34Z", "message": "Make checkstyle and pmd happy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODI3NDc2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-467827476", "createdAt": "2020-08-14T19:30:47Z", "commit": {"oid": "4053d8d291511f5087460f3ea17fd05dd88045f2"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxOTozMDo0OFrOHBBBfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxOTo1ODozNlrOHBBuJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgyNzM4OQ==", "bodyText": "Is this something you are using for your testing?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470827389", "createdAt": "2020-08-14T19:30:48Z", "author": {"login": "abanthiy"}, "path": "pom.xml", "diffHunk": "@@ -90,7 +90,7 @@\n         <dependency>\n             <groupId>com.aws.iot</groupId>\n             <artifactId>evergreen-java-sdk</artifactId>\n-            <version>0.0.0-SNAPSHOT</version>\n+            <version>0.0.0-shared_config-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4053d8d291511f5087460f3ea17fd05dd88045f2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzNjg2NQ==", "bodyText": "Initialize to null? as you are doing a null check where it is being called.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470836865", "createdAt": "2020-08-14T19:53:58Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +53,164 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String CONTEXT_LOGGING_KEY = \"context\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n         }\n \n-        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n-                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath[customConfigIndex + 1]));\n-    };\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+        return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n-     *\n-     * @param context connection context\n-     * @return response code Success if all went well\n-     */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n+        Node subscribeTo = configurationTopics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4053d8d291511f5087460f3ea17fd05dd88045f2"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzODgyMA==", "bodyText": "Dead code? If not needed, may remove the check watcher.isPresent() in the calling method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470838820", "createdAt": "2020-08-14T19:58:36Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +53,164 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String CONTEXT_LOGGING_KEY = \"context\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n         }\n \n-        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n-                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath[customConfigIndex + 1]));\n-    };\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+        return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n-     *\n-     * @param context connection context\n-     * @return response code Success if all went well\n-     */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n+        Node subscribeTo = configurationTopics;\n+        if (keyPath != null && !keyPath.isEmpty()) {\n+            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n+        }\n+        return subscribeTo;\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n \n-        return new ConfigStoreGenericResponse(ConfigStoreResponseStatus.Success, null);\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4053d8d291511f5087460f3ea17fd05dd88045f2"}, "originalPosition": 195}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODk3NDc4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-467897478", "createdAt": "2020-08-14T22:02:07Z", "commit": {"oid": "4053d8d291511f5087460f3ea17fd05dd88045f2"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3OTA0MTIz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-467904123", "createdAt": "2020-08-14T22:22:32Z", "commit": {"oid": "4053d8d291511f5087460f3ea17fd05dd88045f2"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a197e2f42f728d7d18772483a5b9069198b6c816", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a197e2f42f728d7d18772483a5b9069198b6c816", "committedDate": "2020-08-14T23:36:42Z", "message": "Config store APIs - updates read, subscribe for supporting shared config, adds write and validate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bf751c899bf489deab8fae35f87a339e2d4ca18", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8bf751c899bf489deab8fae35f87a339e2d4ca18", "committedDate": "2020-08-14T23:36:42Z", "message": "Remove runtime config handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "committedDate": "2020-08-14T23:36:42Z", "message": "Enhancements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "committedDate": "2020-08-14T23:36:42Z", "message": "Unit and integ tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a9ade7d386a806aa6a0b7287151d4c385ab552ab", "committedDate": "2020-08-14T23:36:42Z", "message": "Simplified version with per key and nested key subscriptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "committedDate": "2020-08-14T23:36:42Z", "message": "Address comments add more open questions as TODOs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a80552617929885383367fa73312d0463252df98", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a80552617929885383367fa73312d0463252df98", "committedDate": "2020-08-14T23:36:42Z", "message": "Implemented TODOs for previously open/now resolved questions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fcea893248454e36733ab3403d7b3f9c9f63657", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2fcea893248454e36733ab3403d7b3f9c9f63657", "committedDate": "2020-08-14T23:36:42Z", "message": "Support compare and swap update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "committedDate": "2020-08-14T23:36:42Z", "message": "Make checkstyle and pmd happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af1db22427c77a4b6d617ebd503c6eb878b08f21", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/af1db22427c77a4b6d617ebd503c6eb878b08f21", "committedDate": "2020-08-14T23:36:42Z", "message": "Fix integ test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "151638416620da7204def0d2fc975075be6363d7", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/151638416620da7204def0d2fc975075be6363d7", "committedDate": "2020-08-14T23:36:42Z", "message": "Fix flakiness in subscribe to config update tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4053d8d291511f5087460f3ea17fd05dd88045f2", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4053d8d291511f5087460f3ea17fd05dd88045f2", "committedDate": "2020-08-14T07:34:26Z", "message": "Fix integ test"}, "afterCommit": {"oid": "151638416620da7204def0d2fc975075be6363d7", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/151638416620da7204def0d2fc975075be6363d7", "committedDate": "2020-08-14T23:36:42Z", "message": "Fix flakiness in subscribe to config update tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3OTI1MTA0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-467925104", "createdAt": "2020-08-14T23:52:49Z", "commit": {"oid": "151638416620da7204def0d2fc975075be6363d7"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3OTI3NzY0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-467927764", "createdAt": "2020-08-15T00:07:42Z", "commit": {"oid": "151638416620da7204def0d2fc975075be6363d7"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cc694b3d02b1f6abc2bae044415818f638cc1c6", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9cc694b3d02b1f6abc2bae044415818f638cc1c6", "committedDate": "2020-08-15T00:57:45Z", "message": "Fix another flake in integ test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDgyOTM4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-468082938", "createdAt": "2020-08-16T17:57:20Z", "commit": {"oid": "9cc694b3d02b1f6abc2bae044415818f638cc1c6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02bedd38a3acab477dda371b3d7eb2ae50c68f2e", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/02bedd38a3acab477dda371b3d7eb2ae50c68f2e", "committedDate": "2020-08-18T15:59:00Z", "message": "Merge branch 'master' into shared-config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cf93b4af6ecaf3649e133e46de6918204f297c2", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cf93b4af6ecaf3649e133e46de6918204f297c2", "committedDate": "2020-08-18T17:28:55Z", "message": "Merge branch 'master' into shared-config"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjgwMzg3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#pullrequestreview-469680387", "createdAt": "2020-08-18T17:36:11Z", "commit": {"oid": "3cf93b4af6ecaf3649e133e46de6918204f297c2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2979, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}