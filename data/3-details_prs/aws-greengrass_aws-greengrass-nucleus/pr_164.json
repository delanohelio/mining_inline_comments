{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNDgyOTU3", "number": 164, "title": "Package store happy path", "bodyText": "Issue #, if available:\nDescription of changes:\nImplement package store 'preparePackages' method. Implement one of artifact downloaders which downloads artifacts from greengrass repo. Leave cloud API integration as TODO.\nWhy is this change necessary:\nThe 1st happy path of package store for preparing packages.\nHow was this change tested:\nAdded sufficient unit tests.\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-04-07T20:22:08Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164", "merged": true, "mergeCommit": {"oid": "c6c6c5892cc5dbe7e42e1a9dba6a87355ad06175"}, "closed": true, "closedAt": "2020-04-10T03:21:10Z", "author": {"login": "wikimonkey"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVa3z3gFqTM4OTUxNzA4Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcWIZ_rgFqTM5MTI0Nzg3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTE3MDgz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-389517083", "createdAt": "2020-04-07T21:52:25Z", "commit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMTo1MjoyNVrOGCXghA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjoxNjo1MlrOGCYJDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTQ5Mg==", "bodyText": "How does this work for completing with an error? Does that count as a completion? We really don't want to be get()ing with no timeout since it obviously blocks forever.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405135492", "createdAt": "2020-04-07T21:52:25Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentTask.java", "diffHunk": "@@ -45,11 +46,11 @@ public Void call() throws NonRetryableDeploymentTaskFailureException, RetryableD\n             //  of all groups, when multi group support is added.\n             List<String> rootPackages = new ArrayList<>(document.getRootPackages());\n \n-            List<PackageIdentifier> desiredPackages = dependencyResolver\n-                    .resolveDependencies(document, rootPackages);\n+            List<PackageIdentifier> desiredPackages = dependencyResolver.resolveDependencies(document, rootPackages);\n             // Block this without timeout because a device can be offline and it can take quite a long time\n             // to download a package.\n-            packageStore.preparePackages(desiredPackages).get();\n+            List<CompletableFuture<Boolean>> preparePackageFutures = packageStore.preparePackages(desiredPackages);\n+            CompletableFuture.allOf(preparePackageFutures.toArray(new CompletableFuture[0])).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTYyMg==", "bodyText": "If possible, remove these suppressions as well.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405135622", "createdAt": "2020-04-07T21:52:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,21 +35,34 @@\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjQxMA==", "bodyText": "should this all be encapsulated into findPackageRecipe? Seems that all of these go together.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405136410", "createdAt": "2020-04-07T21:54:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjc1Ng==", "bodyText": "Please rename e to something more meaningful.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405136756", "createdAt": "2020-04-07T21:55:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzExNw==", "bodyText": "Shouldn't this exception be caught in the outside of this lambda? Since you expect that it can be thrown, I think you should rewrap it in one of your package exceptions.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405137117", "createdAt": "2020-04-07T21:56:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzU0Mw==", "bodyText": "This can never return a meaningful error message, right? All it can tell you is that if failed? I don't think that's a very good interface. We want the user to get the error all the way back up in the console when possible.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405137543", "createdAt": "2020-04-07T21:56:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNzY5Nw==", "bodyText": "Prefer Optional instead of returning null.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405137697", "createdAt": "2020-04-07T21:57:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzODY0OA==", "bodyText": "LOCAL_CACHE_PATH needs to be a variable, doesn't it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405138648", "createdAt": "2020-04-07T21:59:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return OBJECT_MAPPER.readValue(recipeContent, Package.class);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private byte[] loadPackageRecipeContent(Path packageRecipe) throws PackageLoadingException {\n+        if (!Files.exists(packageRecipe) || !Files.isRegularFile(packageRecipe)) {\n+            return new byte[0];\n+        }\n+\n+        try {\n+            return Files.readAllBytes(packageRecipe);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private Package downloadPackageRecipe(PackageIdentifier packageIdentifier) throws PackageDownloadException {\n+        logger.atInfo().setEventType(\"downloading-package-recipe\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).log();\n+        //TODO retrieve package recipe from cloud\n+        //load from local now to pretend it working\n+        try {\n+            return findPackageRecipe(LOCAL_CACHE_PATH.resolve(packageIdentifier.getName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzOTE0OA==", "bodyText": "Use Path.toFile()?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405139148", "createdAt": "2020-04-07T22:00:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return OBJECT_MAPPER.readValue(recipeContent, Package.class);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private byte[] loadPackageRecipeContent(Path packageRecipe) throws PackageLoadingException {\n+        if (!Files.exists(packageRecipe) || !Files.isRegularFile(packageRecipe)) {\n+            return new byte[0];\n+        }\n+\n+        try {\n+            return Files.readAllBytes(packageRecipe);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private Package downloadPackageRecipe(PackageIdentifier packageIdentifier) throws PackageDownloadException {\n+        logger.atInfo().setEventType(\"downloading-package-recipe\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).log();\n+        //TODO retrieve package recipe from cloud\n+        //load from local now to pretend it working\n+        try {\n+            return findPackageRecipe(LOCAL_CACHE_PATH.resolve(packageIdentifier.getName())\n+                    .resolve(packageIdentifier.getVersion().getValue()).resolve(\"recipe.yaml\"));\n+        } catch (PackageLoadingException e) {\n+            throw new PackageDownloadException(String.format(\"Failed to download package %s recipe\", packageIdentifier),\n+                    e);\n+        }\n+    }\n+\n+    void savePackageToFile(Package pkg, Path saveToFile) throws PackageLoadingException {\n+        try {\n+            OBJECT_MAPPER.writeValue(new File(saveToFile.toString()), pkg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTQ4MQ==", "bodyText": "This can be greatly simplified.\nFiles.copy(\n      inputStream, \n      saveToPath.resolve(filename),\n      StandardCopyOption.REPLACE_EXISTING);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405141481", "createdAt": "2020-04-07T22:06:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream();\n+                     OutputStream outputStream = Files.newOutputStream(saveToPath.resolve(filename))) {\n+                    int bytesRead;\n+                    byte[] buffer = new byte[BUFFER_SIZE];\n+                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n+                        outputStream.write(buffer, 0, bytesRead);\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjEyOQ==", "bodyText": "extract filename= to a variable and then use .length() on it instead of hardcoding the 10. Also, are we positive we want to read all the way to the end? I believe headers like this may be comma or semicolon separated.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405142129", "createdAt": "2020-04-07T22:07:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream();\n+                     OutputStream outputStream = Files.newOutputStream(saveToPath.resolve(filename))) {\n+                    int bytesRead;\n+                    byte[] buffer = new byte[BUFFER_SIZE];\n+                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n+                        outputStream.write(buffer, 0, bytesRead);\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (httpConn != null) {\n+                httpConn.disconnect();\n+            }\n+        }\n+    }\n+\n+    HttpURLConnection create(URL url) throws IOException {\n+        return (HttpURLConnection) url.openConnection();\n+    }\n+\n+    String getArtifactDownloadURL(String packageArn, String artifactName) {\n+        //TODO retrieve artifact presigned download URL from cloud as redirection\n+        return \"placeholder\";\n+    }\n+\n+    String extractFilename(String preSignedUrl, String contentDisposition) {\n+        if (contentDisposition != null) {\n+            int index = contentDisposition.indexOf(\"filename=\");\n+            if (index > 0) {\n+                return contentDisposition.substring(index + 10, contentDisposition.length() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mjk0MQ==", "bodyText": "This is assuming too much about the format of the URL. Try something like\nx = uri.getPath().split(\"/\");\nlastPath = x[x.length - 1];", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405142941", "createdAt": "2020-04-07T22:09:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream();\n+                     OutputStream outputStream = Files.newOutputStream(saveToPath.resolve(filename))) {\n+                    int bytesRead;\n+                    byte[] buffer = new byte[BUFFER_SIZE];\n+                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n+                        outputStream.write(buffer, 0, bytesRead);\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (httpConn != null) {\n+                httpConn.disconnect();\n+            }\n+        }\n+    }\n+\n+    HttpURLConnection create(URL url) throws IOException {\n+        return (HttpURLConnection) url.openConnection();\n+    }\n+\n+    String getArtifactDownloadURL(String packageArn, String artifactName) {\n+        //TODO retrieve artifact presigned download URL from cloud as redirection\n+        return \"placeholder\";\n+    }\n+\n+    String extractFilename(String preSignedUrl, String contentDisposition) {\n+        if (contentDisposition != null) {\n+            int index = contentDisposition.indexOf(\"filename=\");\n+            if (index > 0) {\n+                return contentDisposition.substring(index + 10, contentDisposition.length() - 1);\n+            }\n+        }\n+        int startIndex = preSignedUrl.lastIndexOf('/') + 1;\n+        int endIndex = preSignedUrl.indexOf('?');\n+        return endIndex == -1 ? preSignedUrl.substring(startIndex) : preSignedUrl.substring(startIndex, endIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk4OQ==", "bodyText": "This can be simplified.\nFiles.walk(pathToBeDeleted)\n      .sorted(Comparator.reverseOrder())\n      .map(Path::toFile)\n      .forEach(File::delete);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405143989", "createdAt": "2020-04-07T22:12:14Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/TestHelper.java", "diffHunk": "@@ -75,4 +78,22 @@ public static String getPackageRecipeFromMockRepository(String testPackageName,\n         String recipeFmt = new String(Files.readAllBytes(path));\n         return String.format(recipeFmt, rootPath.toString());\n     }\n+\n+    public static void cleanDirectory(Path pathToDirectory) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTI4Nw==", "bodyText": "typo: filename", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405145287", "createdAt": "2020-04-07T22:15:22Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloaderTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+class GreengrassRepositoryDownloaderTest {\n+\n+    @Spy\n+    private GreengrassRepositoryDownloader downloader;\n+\n+    @Mock\n+    private HttpURLConnection connection;\n+\n+    @Test\n+    void GIVEN_artifact_url_WHEN_attempt_download_THEN_task_succeed() throws Exception {\n+        doReturn(\"https://www.amazon.com/artifact.txt\").when(downloader)\n+                .getArtifactDownloadURL(anyString(), anyString());\n+        doReturn(connection).when(downloader).create(any());\n+        when(connection.getResponseCode()).thenReturn(HttpURLConnection.HTTP_OK);\n+        Path mockArtifactPath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.0.0\")\n+                .resolve(\"monitor_artifact_100.txt\");\n+        when(connection.getInputStream()).thenReturn(new FileInputStream(mockArtifactPath.toString()));\n+\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+        Path testCache = TestHelper.getPathForLocalTestCache();\n+        Path saveToPath = testCache.resolve(\"CoolService\").resolve(\"1.0.0\");\n+        Files.createDirectories(saveToPath);\n+        downloader.downloadArtifactToPath(pkgId, new URI(\"greengrass:binary\"), saveToPath);\n+\n+        byte[] originalFile = Files.readAllBytes(mockArtifactPath);\n+        byte[] downloadFile = Files.readAllBytes(saveToPath.resolve(\"artifact.txt\"));\n+        assertThat(Arrays.equals(originalFile, downloadFile), is(true));\n+\n+        TestHelper.cleanDirectory(testCache);\n+    }\n+\n+    @Test\n+    void GIVEN_http_connection_error_WHEN_attempt_download_THEN_return_exception() throws Exception {\n+        doReturn(\"https://www.amazon.com/artifact.txt\").when(downloader)\n+                .getArtifactDownloadURL(anyString(), anyString());\n+        doReturn(connection).when(downloader).create(any());\n+        when(connection.getResponseCode()).thenThrow(IOException.class);\n+\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+        assertThrows(IOException.class,\n+                () -> downloader.downloadArtifactToPath(pkgId, new URI(\"greengrass:binary\"), null));\n+    }\n+\n+    @Test\n+    void GIVEN_filename_in_disposition_WHEN_attempt_resolve_filename_THEN_parse_filename() {\n+        String filename = downloader\n+                .extractFilename(\"https://www.amazon.com/artifact.txt\", \"attachment; \" + \"filename=\\\"filename.jpg\\\"\");\n+\n+        assertThat(filename, is(\"filename.jpg\"));\n+    }\n+\n+    @Test\n+    void GIVEN_filename_in_url_WHEN_attempt_resolve_filenmae_THEN_parse_filename() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTg2OQ==", "bodyText": "URL format? greengrass://", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405145869", "createdAt": "2020-04-07T22:16:52Z", "author": {"login": "MikeDombo"}, "path": "src/test/resources/com/aws/iot/evergreen/packagemanager/test_packages/MonitoringService-1.1.0/recipe.yaml", "diffHunk": "@@ -16,7 +16,7 @@ Lifecycle:\n       skipif: onpath git\n       script: brew install git\n Artifacts:\n-  - %s/MonitoringService-1.1.0/monitor_artifact_100.txt\n+  - greengrass:monitor_artifact_100.txt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTgwOTU2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-389580956", "createdAt": "2020-04-08T00:36:23Z", "commit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMDozNjoyM1rOGCbADQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTozMDoxOFrOGCb4SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MjcxNw==", "bodyText": "I'm assuming this is the bad part? Could we put a comment here to indicate about the \"bad\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405192717", "createdAt": "2020-04-08T00:36:23Z", "author": {"login": "leaf94"}, "path": "src/test/resources/com/aws/iot/evergreen/packagemanager/test_packages/MonitoringService-1.1.0/bad_recipe.yaml", "diffHunk": "@@ -0,0 +1,34 @@\n+---\n+RecipeTemplateVersion: '2020-01-25'\n+PackageName: MonitoringService\n+Description: Test recipe for Evergreen packages\n+Publisher: Me\n+Version: '1.0.0'\n+Parameters:\n+  - name: TestParam\n+    value: TestVal\n+    type: String\n+Lifecycle:\n+  all:\n+    install:\n+      skipif: onpath git\n+      script: sudo apt-get install git\n+  debian:\n+    install:\n+      skipif: onpath git\n+      script: sudo apt-get install git\n+  macos:\n+    install:\n+      skipif: onpath git\n+      script: brew install git\n+    run: git status\n+Artifacts:\n+  - %s/MonitoringService-1.0.0/monitor_artifact_100.txt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5MzcwOQ==", "bodyText": "remove +", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405193709", "createdAt": "2020-04-08T00:40:00Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.lang.reflect.Field;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsNull.notNullValue;\n+import static org.hamcrest.core.IsNull.nullValue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private PackageStore packageStore;\n+\n+    private Path testCache;\n+\n+    @Mock\n+    private static ArtifactDownloader artifactDownloader;\n+\n+    @BeforeEach\n+    void beforeEach() throws Exception {\n+        testCache = TestHelper.getPathForLocalTestCache();\n+        packageStore = new PackageStore(testCache, testCache);\n+\n+        Field downloaderField = PackageStore.ArtifactProvider.class.getDeclaredField(\"artifactDownloader\");\n+        downloaderField.setAccessible(true);\n+        for (PackageStore.ArtifactProvider artifactProvider : PackageStore.ArtifactProvider.values()) {\n+            downloaderField.set(artifactProvider, artifactDownloader);\n+        }\n+    }\n+\n+    @AfterEach\n+    void cleanTestCache() throws Exception {\n+        TestHelper.cleanDirectory(testCache);\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_valid_package_recipe_WHEN_attempt_find_package_THEN_package_model_is_returned()\n+            throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"recipe\" + \".yaml\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5NDQzOA==", "bodyText": "I will simplify to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n          \n          \n            \n                void downloadToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405194438", "createdAt": "2020-04-08T00:42:43Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactDownloader.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Path;\n+\n+public interface ArtifactDownloader {\n+\n+    void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5NTYxMA==", "bodyText": "connect might be better than create", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405195610", "createdAt": "2020-04-08T00:47:19Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMTgwNw==", "bodyText": "nit - I know we probably don't have and don't want to have guava lib - so \"Content-Dispsoition\" probably deserve a constant...", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405201807", "createdAt": "2020-04-08T01:10:33Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMzI4MQ==", "bodyText": "What case are we handling here? I'm assuming url with query string? Something like /filename.txt?sessionId=value so that we still extract filename.txt.\nAdd an example in the comment would be very helpful!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405203281", "createdAt": "2020-04-08T01:16:22Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream();\n+                     OutputStream outputStream = Files.newOutputStream(saveToPath.resolve(filename))) {\n+                    int bytesRead;\n+                    byte[] buffer = new byte[BUFFER_SIZE];\n+                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n+                        outputStream.write(buffer, 0, bytesRead);\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (httpConn != null) {\n+                httpConn.disconnect();\n+            }\n+        }\n+    }\n+\n+    HttpURLConnection create(URL url) throws IOException {\n+        return (HttpURLConnection) url.openConnection();\n+    }\n+\n+    String getArtifactDownloadURL(String packageArn, String artifactName) {\n+        //TODO retrieve artifact presigned download URL from cloud as redirection\n+        return \"placeholder\";\n+    }\n+\n+    String extractFilename(String preSignedUrl, String contentDisposition) {\n+        if (contentDisposition != null) {\n+            int index = contentDisposition.indexOf(\"filename=\");\n+            if (index > 0) {\n+                return contentDisposition.substring(index + 10, contentDisposition.length() - 1);\n+            }\n+        }\n+        int startIndex = preSignedUrl.lastIndexOf('/') + 1;\n+        int endIndex = preSignedUrl.indexOf('?');\n+        return endIndex == -1 ? preSignedUrl.substring(startIndex) : preSignedUrl.substring(startIndex, endIndex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mjk0MQ=="}, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwNzExMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n          \n          \n            \n                Package findPackageRecipe(Path recipePath) throws PackageLoadingException {", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405207112", "createdAt": "2020-04-08T01:30:18Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTI0MTEx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-389524111", "createdAt": "2020-04-07T22:06:01Z", "commit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMjowNjowMVrOGCX3yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjo1OTozMVrOGCdTTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTQ0OQ==", "bodyText": "Why do you return a list of futures instead of one future? The caller of this method shouldn't be concerned about which package is prepared or not.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405141449", "createdAt": "2020-04-07T22:06:01Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTgzOQ==", "bodyText": "Instead of taking two paths as input, why not just take one path as the package root path and create recipe and artifact sub directories?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405141839", "createdAt": "2020-04-07T22:06:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,21 +35,34 @@\n import java.util.List;\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n \n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    public PackageStore(@Named(\"RecipeDirectory\") Path recipeDirectory,\n+                        @Named(\"ArtifactDirectory\") Path artifactDirectory) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MjcxMQ==", "bodyText": "I would rather throw a PackageLoadingException if the package does not exist instead of returning null. Here you're forcing the caller to both check the exception and null.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405142711", "createdAt": "2020-04-07T22:09:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzU1MQ==", "bodyText": "This private method seems unnecessary. You merge it back to findPackageRecipe method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405217551", "createdAt": "2020-04-08T02:10:00Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return OBJECT_MAPPER.readValue(recipeContent, Package.class);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private byte[] loadPackageRecipeContent(Path packageRecipe) throws PackageLoadingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyMzAzOA==", "bodyText": "Why break these two lines to two methods?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405223038", "createdAt": "2020-04-08T02:30:21Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNjk5Nw==", "bodyText": "I'm fine with get() blocking as long as DeploymentTask can cancel this when the deployment is being cancelled. My reasoning is, even if deploymentTask put a timeout on the get() call, how would it handle the timeout? fail the deployment? It's undesired because we expect the deployment can be hanging for a long time if the network is off; retry on the timeout? My preference is inside preparePackages() method, we should retry on the download packages.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405226997", "createdAt": "2020-04-08T02:46:16Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentTask.java", "diffHunk": "@@ -45,11 +46,11 @@ public Void call() throws NonRetryableDeploymentTaskFailureException, RetryableD\n             //  of all groups, when multi group support is added.\n             List<String> rootPackages = new ArrayList<>(document.getRootPackages());\n \n-            List<PackageIdentifier> desiredPackages = dependencyResolver\n-                    .resolveDependencies(document, rootPackages);\n+            List<PackageIdentifier> desiredPackages = dependencyResolver.resolveDependencies(document, rootPackages);\n             // Block this without timeout because a device can be offline and it can take quite a long time\n             // to download a package.\n-            packageStore.preparePackages(desiredPackages).get();\n+            List<CompletableFuture<Boolean>> preparePackageFutures = packageStore.preparePackages(desiredPackages);\n+            CompletableFuture.allOf(preparePackageFutures.toArray(new CompletableFuture[0])).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNTQ5Mg=="}, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNzQ0OA==", "bodyText": "I don't think we should handle these exceptions together. This whole try catch block can be better organized. I agree with Michael that we can have findPackageRecipe() encapsulate the logic of reading and downloading package recipes.\nPackage findPackageRecipe() throws PackageRecipeUnavailableException {\n     // find the package on the device;\n     // if not found or encounter exception;\n     //      then download from the cloud and save on device;\n     //      if encounter exception again\n     //      retry or populate the exception up\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405227448", "createdAt": "2020-04-08T02:47:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyNzc1Nw==", "bodyText": "Can you have a stub cloud client instead of just calling \"findPackageRecipe\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405227757", "createdAt": "2020-04-08T02:49:04Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -56,15 +76,144 @@\n      * they don't exist.\n      *\n      * @param pkgs a list of packages.\n-     * @return a future to notify once this is finished.\n+     * @return a list of future to notify packages are prepared or not.\n      */\n-    @SuppressFBWarnings(value = \"NP_NONNULL_PARAM_VIOLATION\", justification = \"Waiting for package cache \"\n-            + \"implementation to be completed\")\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public List<CompletableFuture<Boolean>> preparePackages(List<PackageIdentifier> pkgs) {\n+        return pkgs.stream().map(pkg -> CompletableFuture.supplyAsync(() -> preparePackage(pkg)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean preparePackage(PackageIdentifier packageIdentifier) {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        boolean prepared = true;\n+        try {\n+            Package pkg = findPackageRecipe(recipePath);\n+            if (pkg == null) {\n+                pkg = downloadPackageRecipe(packageIdentifier);\n+                savePackageToFile(pkg, recipePath);\n+            }\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(e -> {\n+                try {\n+                    return new URI(e);\n+                } catch (URISyntaxException ex) {\n+                    String message = String.format(\"artifact URI %s is invalid\", e);\n+                    logger.atError().log(message, ex);\n+                    throw new RuntimeException(message, ex);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            prepared = false;\n+        }\n+        logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                .addKeyValue(\"succeed\", prepared).log();\n+        return prepared;\n+    }\n+\n+    Package findPackageRecipe(Path packageRecipe) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", packageRecipe).log();\n+        byte[] recipeContent = loadPackageRecipeContent(packageRecipe);\n+        if (recipeContent.length == 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return OBJECT_MAPPER.readValue(recipeContent, Package.class);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private byte[] loadPackageRecipeContent(Path packageRecipe) throws PackageLoadingException {\n+        if (!Files.exists(packageRecipe) || !Files.isRegularFile(packageRecipe)) {\n+            return new byte[0];\n+        }\n+\n+        try {\n+            return Files.readAllBytes(packageRecipe);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", packageRecipe), e);\n+        }\n+    }\n+\n+    private Package downloadPackageRecipe(PackageIdentifier packageIdentifier) throws PackageDownloadException {\n+        logger.atInfo().setEventType(\"downloading-package-recipe\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).log();\n+        //TODO retrieve package recipe from cloud\n+        //load from local now to pretend it working", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIyOTI5Mg==", "bodyText": "This seems a code smell to me. Why do we need to use reflection for unit test? How can we refactor the code so that we can properly mock dependencies?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405229292", "createdAt": "2020-04-08T02:55:13Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.lang.reflect.Field;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsNull.notNullValue;\n+import static org.hamcrest.core.IsNull.nullValue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private PackageStore packageStore;\n+\n+    private Path testCache;\n+\n+    @Mock\n+    private static ArtifactDownloader artifactDownloader;\n+\n+    @BeforeEach\n+    void beforeEach() throws Exception {\n+        testCache = TestHelper.getPathForLocalTestCache();\n+        packageStore = new PackageStore(testCache, testCache);\n+\n+        Field downloaderField = PackageStore.ArtifactProvider.class.getDeclaredField(\"artifactDownloader\");\n+        downloaderField.setAccessible(true);\n+        for (PackageStore.ArtifactProvider artifactProvider : PackageStore.ArtifactProvider.values()) {\n+            downloaderField.set(artifactProvider, artifactDownloader);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzMDQxNA==", "bodyText": "Why do we need this? Can't we assume the majority of the respository endpoint is HTTP based? How would the Greengrass repository be different from a docker repository in terms of downloading?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r405230414", "createdAt": "2020-04-08T02:59:31Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -167,4 +314,18 @@ private static Path getPackageVersionStorageRoot(final String packageName, final\n                                                      final Path cacheFolder) {\n         return getPackageStorageRoot(packageName, cacheFolder).resolve(packageVersion);\n     }\n+\n+    enum ArtifactProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 235}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb93f818e9ef12e5bb926e0f8fe1d83929b63c3d", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fb93f818e9ef12e5bb926e0f8fe1d83929b63c3d", "committedDate": "2020-04-09T05:37:15Z", "message": "fix PMD"}, "afterCommit": {"oid": "a395f136bf2047b1bba5efa5ad6a83366a0dda2d", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a395f136bf2047b1bba5efa5ad6a83366a0dda2d", "committedDate": "2020-04-09T18:34:44Z", "message": "resolve merge conflicts"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "963a71a9f17ad1e78cf1e72d96183f564ce036e9", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/963a71a9f17ad1e78cf1e72d96183f564ce036e9", "committedDate": "2020-04-09T20:10:14Z", "message": "supply package store path to context for DI"}, "afterCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5b04c91702627047e23b2b100a2aec7ecba56cd7", "committedDate": "2020-04-09T20:30:55Z", "message": "supply package store path to context for DI"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTI5NjIx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391129621", "createdAt": "2020-04-09T21:01:42Z", "commit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMTowMTo0MlrOGDpRbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToxNzo0M1rOGDpvnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NTExOA==", "bodyText": "nit\nI'd prefer packages", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406475118", "createdAt": "2020-04-09T21:01:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -81,9 +81,11 @@\n     public Path configPath;\n     public Path clitoolPath;\n     public Path workPath;\n+    public Path packageStorePath;\n     public String configPathName = \"~root/config\";\n     public String clitoolPathName = \"~root/bin\";\n     public String workPathName = \"~root/work\";\n+    public String packageStorePathName = \"~root/package\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NTc3NQ==", "bodyText": "Can we get rid of this? Shouldn't this be under the package directory that you setup in the Kernel?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406475775", "createdAt": "2020-04-09T21:03:01Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/GreengrassPackageServiceHelper.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.LocalPackageStoreDeprecated;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class GreengrassPackageServiceHelper {\n+    private static final Path LOCAL_CACHE_PATH =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NjUzOQ==", "bodyText": "unused now? Get rid of it if so.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406476539", "createdAt": "2020-04-09T21:04:35Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NzAxNQ==", "bodyText": "is this constructor only for testing? If so, make it package-private and say in the comment that it is only for testing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406477015", "createdAt": "2020-04-09T21:05:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String GREENGRASS_SCHEME = \"GREENGRASS\";\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n-    private Path packageStorePath = LOCAL_CACHE_PATH;\n \n-    public PackageStore() {\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @Inject\n+    private GreengrassRepositoryDownloader greenGrassArtifactDownloader;\n+\n+    @Inject\n+    private GreengrassPackageServiceHelper greengrassPackageServiceHelper;\n+\n+    // Workaround using InjectionActions since constructor named pattern injection is not supported yet\n+    @Inject\n+    @Named(\"packageStoreDirectory\")\n+    private Path packageStoreDirectory;\n+\n+    /**\n+     * PackageStore constructor.\n+     * @param packageStoreDirectory directory for caching package recipes and artifacts\n+     * @param packageServiceHelper  greengrass package service client helper\n+     * @param artifactDownloader    artifact downloader\n+     */\n+    public PackageStore(Path packageStoreDirectory, GreengrassPackageServiceHelper packageServiceHelper,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NzcwNg==", "bodyText": "Why are we doing this? If we can't create the directories we can't do anything. It needs to quit, but this exception should be handled by the caller so it doesn't take down the whole thread.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406477706", "createdAt": "2020-04-09T21:07:00Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String GREENGRASS_SCHEME = \"GREENGRASS\";\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n-    private Path packageStorePath = LOCAL_CACHE_PATH;\n \n-    public PackageStore() {\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @Inject\n+    private GreengrassRepositoryDownloader greenGrassArtifactDownloader;\n+\n+    @Inject\n+    private GreengrassPackageServiceHelper greengrassPackageServiceHelper;\n+\n+    // Workaround using InjectionActions since constructor named pattern injection is not supported yet\n+    @Inject\n+    @Named(\"packageStoreDirectory\")\n+    private Path packageStoreDirectory;\n+\n+    /**\n+     * PackageStore constructor.\n+     * @param packageStoreDirectory directory for caching package recipes and artifacts\n+     * @param packageServiceHelper  greengrass package service client helper\n+     * @param artifactDownloader    artifact downloader\n+     */\n+    public PackageStore(Path packageStoreDirectory, GreengrassPackageServiceHelper packageServiceHelper,\n+                        GreengrassRepositoryDownloader artifactDownloader) {\n+        initializeSubDirectories(packageStoreDirectory);\n+        this.greengrassPackageServiceHelper = packageServiceHelper;\n+        this.greenGrassArtifactDownloader = artifactDownloader;\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        initializeSubDirectories(packageStoreDirectory);\n     }\n \n-    public PackageStore(Path packageStorePath) {\n-        this.packageStorePath = packageStorePath;\n+    private void initializeSubDirectories(Path packageStoreDirectory) {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTMyNQ==", "bodyText": "This can be a lambda", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406479325", "createdAt": "2020-04-09T21:10:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTkyMg==", "bodyText": "This runs the task in the ForkJoin common pool. Please use our own threadpool from the Context.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406479922", "createdAt": "2020-04-09T21:11:38Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MDI4Mw==", "bodyText": "This is a big code smell to me. Let's be explicit about what we're throwing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406480283", "createdAt": "2020-04-09T21:12:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MTMwNA==", "bodyText": "remove the concatenation since this string is on a single line.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406481304", "createdAt": "2020-04-09T21:14:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().log(message, e);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            throw e;\n+        }\n+    }\n+\n+    private Package findRecipeDownloadIfNotExisted(PackageIdentifier packageIdentifier)\n+            throws PackageDownloadException, PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        Optional<Package> packageOptional = Optional.empty();\n+        try {\n+            packageOptional = findPackageRecipe(recipePath);\n+        } catch (PackageLoadingException e) {\n+            logger.atWarn().log(String.format(\"Failed to load package from %s\", recipePath), e);\n+        }\n+        if (packageOptional.isPresent()) {\n+            return packageOptional.get();\n+        } else {\n+            Package pkg = greengrassPackageServiceHelper.downloadPackageRecipe(packageIdentifier);\n+            savePackageToFile(pkg, recipePath);\n+            return pkg;\n+        }\n+    }\n+\n+    Optional<Package> findPackageRecipe(Path recipePath) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(OBJECT_MAPPER.readValue(recipeContent, Package.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    void savePackageToFile(Package pkg, Path saveToFile) throws PackageLoadingException {\n+        try {\n+            OBJECT_MAPPER.writeValue(saveToFile.toFile(), pkg);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", saveToFile), e);\n+        }\n+    }\n+\n+    private Path resolveRecipePath(String packageName, Semver packageVersion) {\n+        return recipeDirectory.resolve(String.format(\"%s-%s.yaml\", packageName, packageVersion.getValue()));\n+    }\n+\n+    void downloadArtifactsIfNecessary(PackageIdentifier packageIdentifier, List<URI> artifactList)\n+            throws PackageLoadingException, PackageDownloadException {\n+        Path packageArtifactDirectory =\n+                resolveArtifactDirectoryPath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        if (!Files.exists(packageArtifactDirectory) || !Files.isDirectory(packageArtifactDirectory)) {\n+            try {\n+                Files.createDirectories(packageArtifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackageLoadingException(\n+                        String.format(\"Failed to create package artifact cache directory \" + \"%s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4MTkzOA==", "bodyText": "Why aren't these using the variable path?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406481938", "createdAt": "2020-04-09T21:15:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -93,11 +287,9 @@ public Package getRecipe(PackageIdentifier pkg) {\n \n     /**\n      * Get package from cache if it exists.\n-     *\n-     *\n      */\n     List<Semver> getPackageVersionsIfExists(final String packageName) throws UnexpectedPackagingException {\n-        Path srcPkgRoot = getPackageStorageRoot(packageName, packageStorePath);\n+        Path srcPkgRoot = getPackageStorageRoot(packageName, LOCAL_CACHE_PATH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4Mjg0NQ==", "bodyText": "You're manipulating a URL as a string, but Java has builtins to do this for you which will work properly when given a malformed string. Try the solution I gave in my first comment.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406482845", "createdAt": "2020-04-09T21:17:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final int BUFFER_SIZE = 4096;\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadArtifactToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\").addKeyValue(\"packageIdentifier\",\n+                packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = create(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(\"Content-Disposition\");\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream();\n+                     OutputStream outputStream = Files.newOutputStream(saveToPath.resolve(filename))) {\n+                    int bytesRead;\n+                    byte[] buffer = new byte[BUFFER_SIZE];\n+                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n+                        outputStream.write(buffer, 0, bytesRead);\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (httpConn != null) {\n+                httpConn.disconnect();\n+            }\n+        }\n+    }\n+\n+    HttpURLConnection create(URL url) throws IOException {\n+        return (HttpURLConnection) url.openConnection();\n+    }\n+\n+    String getArtifactDownloadURL(String packageArn, String artifactName) {\n+        //TODO retrieve artifact presigned download URL from cloud as redirection\n+        return \"placeholder\";\n+    }\n+\n+    String extractFilename(String preSignedUrl, String contentDisposition) {\n+        if (contentDisposition != null) {\n+            int index = contentDisposition.indexOf(\"filename=\");\n+            if (index > 0) {\n+                return contentDisposition.substring(index + 10, contentDisposition.length() - 1);\n+            }\n+        }\n+        int startIndex = preSignedUrl.lastIndexOf('/') + 1;\n+        int endIndex = preSignedUrl.indexOf('?');\n+        return endIndex == -1 ? preSignedUrl.substring(startIndex) : preSignedUrl.substring(startIndex, endIndex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mjk0MQ=="}, "originalCommit": {"oid": "8fa440347feb757342db7dbcaf4e688fb206387d"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTU4Njc0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391158674", "createdAt": "2020-04-09T21:55:05Z", "commit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMTo1NTowNVrOGDqx5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMTo1NTowNVrOGDqx5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5OTgxNA==", "bodyText": "Maybe add a TODO for dealing with unhappy response code?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406499814", "createdAt": "2020-04-09T21:55:05Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/GreengrassRepositoryDownloader.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+\n+public class GreengrassRepositoryDownloader implements ArtifactDownloader {\n+    private static final Logger logger = LogManager.getLogger(GreengrassRepositoryDownloader.class);\n+    private static final String CONTENT_DISPOSITION = \"Content-Disposition\";\n+\n+    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n+    @Override\n+    public void downloadToPath(PackageIdentifier packageIdentifier, URI artifactUri, Path saveToPath)\n+            throws IOException {\n+        logger.atInfo().setEventType(\"download-artifact-from-greengrass-repo\")\n+                .addKeyValue(\"packageIdentifier\", packageIdentifier).addKeyValue(\"artifactUri\", artifactUri).log();\n+        String preSignedUrl = getArtifactDownloadURL(packageIdentifier.getArn(), artifactUri.getSchemeSpecificPart());\n+        URL url = new URL(preSignedUrl);\n+        HttpURLConnection httpConn = null;\n+        try {\n+            httpConn = connect(url);\n+            int responseCode = httpConn.getResponseCode();\n+\n+            if (responseCode == HttpURLConnection.HTTP_OK) {\n+                String disposition = httpConn.getHeaderField(CONTENT_DISPOSITION);\n+                String filename = extractFilename(preSignedUrl, disposition);\n+\n+                try (InputStream inputStream = httpConn.getInputStream()) {\n+                    Files.copy(inputStream, saveToPath.resolve(filename), StandardCopyOption.REPLACE_EXISTING);\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTYwMDY0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391160064", "createdAt": "2020-04-09T21:58:02Z", "commit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMTo1ODowMlrOGDq2iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMTo1ODowMlrOGDq2iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwMTAwMA==", "bodyText": "Just FYI, I'm creating a new test root folder and I was just initializing the path inside the test. We could consolidate these two later.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406501000", "createdAt": "2020-04-09T21:58:02Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.GreengrassRepositoryDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private Path testCache;\n+\n+    private PackageStore packageStore;\n+\n+    @Mock\n+    private GreengrassRepositoryDownloader artifactDownloader;\n+\n+    @Mock\n+    private GreengrassPackageServiceHelper packageServiceHelper;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        testCache = TestHelper.getPathForLocalTestCache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTYxNDAx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391161401", "createdAt": "2020-04-09T22:00:49Z", "commit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjowMDo0OVrOGDq67g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjowMDo0OVrOGDq67g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwMjEyNg==", "bodyText": "I think this could be removed now with the proper DI?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406502126", "createdAt": "2020-04-09T22:00:49Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/deployment/DeploymentE2ETest.java", "diffHunk": "@@ -221,6 +221,6 @@ private void setupIotResourcesAndInjectIntoKernel() throws IOException {\n \n     private void injectKernelPackageManagementDependencies() {\n         kernel.context.getv(DependencyResolver.class)\n-                .put(new DependencyResolver(new PackageStore(LOCAL_CACHE_PATH), kernel));\n+                .put(new DependencyResolver(new PackageStore(), kernel));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTYyNDI4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391162428", "createdAt": "2020-04-09T22:03:17Z", "commit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTIzNjk1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391123695", "createdAt": "2020-04-09T20:52:08Z", "commit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDo1MjowOVrOGDo-Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToyNjoyM1rOGDp_lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MDE5MA==", "bodyText": "nit: use plural, package -> packages.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406470190", "createdAt": "2020-04-09T20:52:09Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -81,9 +81,11 @@\n     public Path configPath;\n     public Path clitoolPath;\n     public Path workPath;\n+    public Path packageStorePath;\n     public String configPathName = \"~root/config\";\n     public String clitoolPathName = \"~root/bin\";\n     public String workPathName = \"~root/work\";\n+    public String packageStorePathName = \"~root/package\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MDc4NQ==", "bodyText": "I suppose this should be packageStorePath?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406470785", "createdAt": "2020-04-09T20:53:11Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/GreengrassPackageServiceHelper.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.LocalPackageStoreDeprecated;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class GreengrassPackageServiceHelper {\n+    private static final Path LOCAL_CACHE_PATH =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3MjAzMg==", "bodyText": "greenGrassArtifactDownloader -> greengrassArtifactDownloader", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406472032", "createdAt": "2020-04-09T20:55:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String GREENGRASS_SCHEME = \"GREENGRASS\";\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n-    private Path packageStorePath = LOCAL_CACHE_PATH;\n \n-    public PackageStore() {\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @Inject\n+    private GreengrassRepositoryDownloader greenGrassArtifactDownloader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NjAwMQ==", "bodyText": "How would this RuntimeException be handled?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406476001", "createdAt": "2020-04-09T21:03:28Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String GREENGRASS_SCHEME = \"GREENGRASS\";\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n-    private Path packageStorePath = LOCAL_CACHE_PATH;\n \n-    public PackageStore() {\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @Inject\n+    private GreengrassRepositoryDownloader greenGrassArtifactDownloader;\n+\n+    @Inject\n+    private GreengrassPackageServiceHelper greengrassPackageServiceHelper;\n+\n+    // Workaround using InjectionActions since constructor named pattern injection is not supported yet\n+    @Inject\n+    @Named(\"packageStoreDirectory\")\n+    private Path packageStoreDirectory;\n+\n+    /**\n+     * PackageStore constructor.\n+     * @param packageStoreDirectory directory for caching package recipes and artifacts\n+     * @param packageServiceHelper  greengrass package service client helper\n+     * @param artifactDownloader    artifact downloader\n+     */\n+    public PackageStore(Path packageStoreDirectory, GreengrassPackageServiceHelper packageServiceHelper,\n+                        GreengrassRepositoryDownloader artifactDownloader) {\n+        initializeSubDirectories(packageStoreDirectory);\n+        this.greengrassPackageServiceHelper = packageServiceHelper;\n+        this.greenGrassArtifactDownloader = artifactDownloader;\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        initializeSubDirectories(packageStoreDirectory);\n     }\n \n-    public PackageStore(Path packageStorePath) {\n-        this.packageStorePath = packageStorePath;\n+    private void initializeSubDirectories(Path packageStoreDirectory) {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new RuntimeException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NTA1Nw==", "bodyText": "setCause in the log?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406485057", "createdAt": "2020-04-09T21:22:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().log(message, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NTM0NA==", "bodyText": "also setCause", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406485344", "createdAt": "2020-04-09T21:22:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().log(message, e);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NjkzMg==", "bodyText": "Info level is too high, I would set it to Debug.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406486932", "createdAt": "2020-04-09T21:26:23Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +127,143 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        Runnable preparePackageTask = new Runnable() {\n+            @SneakyThrows\n+            @Override\n+            public void run() {\n+                for (PackageIdentifier packageIdentifier :  pkgIds) {\n+                    preparePackage(packageIdentifier);\n+                }\n+            }\n+        };\n+\n+        return CompletableFuture.runAsync(preparePackageTask);\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().log(message, e);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().log(String.format(\"Failed to prepare package %s\", packageIdentifier), e);\n+            throw e;\n+        }\n+    }\n+\n+    private Package findRecipeDownloadIfNotExisted(PackageIdentifier packageIdentifier)\n+            throws PackageDownloadException, PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        Optional<Package> packageOptional = Optional.empty();\n+        try {\n+            packageOptional = findPackageRecipe(recipePath);\n+        } catch (PackageLoadingException e) {\n+            logger.atWarn().log(String.format(\"Failed to load package from %s\", recipePath), e);\n+        }\n+        if (packageOptional.isPresent()) {\n+            return packageOptional.get();\n+        } else {\n+            Package pkg = greengrassPackageServiceHelper.downloadPackageRecipe(packageIdentifier);\n+            savePackageToFile(pkg, recipePath);\n+            return pkg;\n+        }\n+    }\n+\n+    Optional<Package> findPackageRecipe(Path recipePath) throws PackageLoadingException {\n+        logger.atInfo().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 191}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af70bdb47c9bd8bdb21b8d6acf66ea4a8cc48e6a", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/af70bdb47c9bd8bdb21b8d6acf66ea4a8cc48e6a", "committedDate": "2020-04-10T00:46:17Z", "message": "remove unused import"}, "afterCommit": {"oid": "4af1dad8171e3bf82a92f914bfa4b2b213bd5123", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4af1dad8171e3bf82a92f914bfa4b2b213bd5123", "committedDate": "2020-04-10T00:53:36Z", "message": "remove unused import"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMjEyMzk5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391212399", "createdAt": "2020-04-10T00:37:43Z", "commit": {"oid": "5c57b6fe5e8741814b3bb58c7f39b51115a72a11"}, "state": "DISMISSED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMDozNzo0M1rOGDtv4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMDo1NTo0MFrOGDuAjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0ODQ1MQ==", "bodyText": "Only if it's a service. Since PackageStore is not a service, the exception is logged and swallowed.\nSince later you uses Files.createDirectories(), which automatically creates missing directories. I think you can just remove the initializeSubDirectories() method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406548451", "createdAt": "2020-04-10T00:37:43Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -28,28 +39,82 @@\n import java.util.Optional;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n \n /**\n  * TODO Implement public methods.\n  */\n @SuppressWarnings({\"PMD.AvoidPrintStackTrace\", \"PMD.IdenticalCatchBranches\"})\n-public class PackageStore {\n+@NoArgsConstructor // for dependency injection\n+public class PackageStore implements InjectionActions {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n     private static final Path LOCAL_CACHE_PATH =\n             Paths.get(System.getProperty(\"user.dir\")).resolve(\"local_artifact_source\");\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String GREENGRASS_SCHEME = \"GREENGRASS\";\n \n     private static final ObjectMapper OBJECT_MAPPER = SerializerFactory.getRecipeSerializer();\n-    private Path packageStorePath = LOCAL_CACHE_PATH;\n \n-    public PackageStore() {\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @Inject\n+    private GreengrassRepositoryDownloader greenGrassArtifactDownloader;\n+\n+    @Inject\n+    private GreengrassPackageServiceHelper greengrassPackageServiceHelper;\n+\n+    // Workaround using InjectionActions since constructor named pattern injection is not supported yet\n+    @Inject\n+    @Named(\"packageStoreDirectory\")\n+    private Path packageStoreDirectory;\n+\n+    /**\n+     * PackageStore constructor.\n+     * @param packageStoreDirectory directory for caching package recipes and artifacts\n+     * @param packageServiceHelper  greengrass package service client helper\n+     * @param artifactDownloader    artifact downloader\n+     */\n+    public PackageStore(Path packageStoreDirectory, GreengrassPackageServiceHelper packageServiceHelper,\n+                        GreengrassRepositoryDownloader artifactDownloader) {\n+        initializeSubDirectories(packageStoreDirectory);\n+        this.greengrassPackageServiceHelper = packageServiceHelper;\n+        this.greenGrassArtifactDownloader = artifactDownloader;\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        initializeSubDirectories(packageStoreDirectory);\n     }\n \n-    public PackageStore(Path packageStorePath) {\n-        this.packageStorePath = packageStorePath;\n+    private void initializeSubDirectories(Path packageStoreDirectory) {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new RuntimeException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3NjAwMQ=="}, "originalCommit": {"oid": "5b04c91702627047e23b2b100a2aec7ecba56cd7"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0OTMzNA==", "bodyText": "No need to wrap. Just throw URISyntaxException so that the caller of preparePackages() can unwrap the ExecutionException and see what's the cause.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406549334", "createdAt": "2020-04-10T00:41:00Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c57b6fe5e8741814b3bb58c7f39b51115a72a11"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0OTg3Mg==", "bodyText": "saveRecipeToFile or savePackageRecipeToFile is better.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406549872", "createdAt": "2020-04-10T00:43:19Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().setCause(e).log(String.format(\"Failed to prepare package %s\", packageIdentifier));\n+            throw e;\n+        }\n+    }\n+\n+    private Package findRecipeDownloadIfNotExisted(PackageIdentifier packageIdentifier)\n+            throws PackageDownloadException, PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        Optional<Package> packageOptional = Optional.empty();\n+        try {\n+            packageOptional = findPackageRecipe(recipePath);\n+        } catch (PackageLoadingException e) {\n+            logger.atWarn().log(String.format(\"Failed to load package from %s\", recipePath), e);\n+        }\n+        if (packageOptional.isPresent()) {\n+            return packageOptional.get();\n+        } else {\n+            Package pkg = greengrassPackageServiceHelper.downloadPackageRecipe(packageIdentifier);\n+            savePackageToFile(pkg, recipePath);\n+            return pkg;\n+        }\n+    }\n+\n+    Optional<Package> findPackageRecipe(Path recipePath) throws PackageLoadingException {\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(OBJECT_MAPPER.readValue(recipeContent, Package.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    void savePackageToFile(Package pkg, Path saveToFile) throws PackageLoadingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c57b6fe5e8741814b3bb58c7f39b51115a72a11"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MDExNA==", "bodyText": "Log at debug level.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406550114", "createdAt": "2020-04-10T00:44:19Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().setCause(e).log(String.format(\"Failed to prepare package %s\", packageIdentifier));\n+            throw e;\n+        }\n+    }\n+\n+    private Package findRecipeDownloadIfNotExisted(PackageIdentifier packageIdentifier)\n+            throws PackageDownloadException, PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        Optional<Package> packageOptional = Optional.empty();\n+        try {\n+            packageOptional = findPackageRecipe(recipePath);\n+        } catch (PackageLoadingException e) {\n+            logger.atWarn().log(String.format(\"Failed to load package from %s\", recipePath), e);\n+        }\n+        if (packageOptional.isPresent()) {\n+            return packageOptional.get();\n+        } else {\n+            Package pkg = greengrassPackageServiceHelper.downloadPackageRecipe(packageIdentifier);\n+            savePackageToFile(pkg, recipePath);\n+            return pkg;\n+        }\n+    }\n+\n+    Optional<Package> findPackageRecipe(Path recipePath) throws PackageLoadingException {\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(OBJECT_MAPPER.readValue(recipeContent, Package.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    void savePackageToFile(Package pkg, Path saveToFile) throws PackageLoadingException {\n+        try {\n+            OBJECT_MAPPER.writeValue(saveToFile.toFile(), pkg);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", saveToFile), e);\n+        }\n+    }\n+\n+    private Path resolveRecipePath(String packageName, Semver packageVersion) {\n+        return recipeDirectory.resolve(String.format(\"%s-%s.yaml\", packageName, packageVersion.getValue()));\n+    }\n+\n+    void downloadArtifactsIfNecessary(PackageIdentifier packageIdentifier, List<URI> artifactList)\n+            throws PackageLoadingException, PackageDownloadException {\n+        Path packageArtifactDirectory =\n+                resolveArtifactDirectoryPath(packageIdentifier.getName(), packageIdentifier.getVersion());\n+        if (!Files.exists(packageArtifactDirectory) || !Files.isDirectory(packageArtifactDirectory)) {\n+            try {\n+                Files.createDirectories(packageArtifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackageLoadingException(\n+                        String.format(\"Failed to create package artifact cache directory %s\", packageArtifactDirectory),\n+                        e);\n+            }\n+        }\n+\n+        List<URI> artifactsNeedToDownload = determineArtifactsNeedToDownload(packageArtifactDirectory, artifactList);\n+        logger.atInfo().setEventType(\"downloading-package-artifacts\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c57b6fe5e8741814b3bb58c7f39b51115a72a11"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTI5Ng==", "bodyText": "Can you also assert the exception message? There are a number of places throwing PackageLoadingException.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406551296", "createdAt": "2020-04-10T00:49:32Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.GreengrassRepositoryDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private Path testCache;\n+\n+    private PackageStore packageStore;\n+\n+    @Mock\n+    private GreengrassRepositoryDownloader artifactDownloader;\n+\n+    @Mock\n+    private GreengrassPackageServiceHelper packageServiceHelper;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        testCache = TestHelper.getPathForLocalTestCache();\n+        packageStore = new PackageStore(testCache, packageServiceHelper, artifactDownloader,\n+                Executors.newSingleThreadExecutor());\n+    }\n+\n+    @AfterEach\n+    void cleanTestCache() throws Exception {\n+        TestHelper.cleanDirectory(testCache);\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_valid_package_recipe_WHEN_attempt_find_package_THEN_package_model_is_returned()\n+            throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"recipe.yaml\");\n+        Optional<Package> pkg = packageStore.findPackageRecipe(recipePath);\n+        assertThat(pkg.isPresent(), is(true));\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_invalid_package_recipe_WHEN_attempt_find_package_THEN_get_loading_exception() throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"bad_recipe.yaml\");\n+\n+        assertThrows(PackageLoadingException.class, () -> packageStore.findPackageRecipe(recipePath));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c57b6fe5e8741814b3bb58c7f39b51115a72a11"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MjcxNw==", "bodyText": "The test coverage is a bit thin. I would like to see a few more unit tests on preparePackages() method that hits all the branches.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406552717", "createdAt": "2020-04-10T00:55:40Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.GreengrassRepositoryDownloader;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+class PackageStoreTest {\n+\n+    private Path testCache;\n+\n+    private PackageStore packageStore;\n+\n+    @Mock\n+    private GreengrassRepositoryDownloader artifactDownloader;\n+\n+    @Mock\n+    private GreengrassPackageServiceHelper packageServiceHelper;\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        testCache = TestHelper.getPathForLocalTestCache();\n+        packageStore = new PackageStore(testCache, packageServiceHelper, artifactDownloader,\n+                Executors.newSingleThreadExecutor());\n+    }\n+\n+    @AfterEach\n+    void cleanTestCache() throws Exception {\n+        TestHelper.cleanDirectory(testCache);\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_valid_package_recipe_WHEN_attempt_find_package_THEN_package_model_is_returned()\n+            throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"recipe.yaml\");\n+        Optional<Package> pkg = packageStore.findPackageRecipe(recipePath);\n+        assertThat(pkg.isPresent(), is(true));\n+    }\n+\n+    @Test\n+    void GIVEN_path_to_invalid_package_recipe_WHEN_attempt_find_package_THEN_get_loading_exception() throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"bad_recipe.yaml\");\n+\n+        assertThrows(PackageLoadingException.class, () -> packageStore.findPackageRecipe(recipePath));\n+    }\n+\n+    @Test\n+    void GIVEN_invalid_path_to_package_recipe_WHEN_attempt_find_package_THEN_null_is_returned() throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"not_exist_recipe.yaml\");\n+\n+        Optional<Package> pkg = packageStore.findPackageRecipe(recipePath);\n+        assertThat(pkg.isPresent(), is(false));\n+    }\n+\n+    @Test\n+    void GIVEN_package_in_memory_WHEN_attempt_save_package_THEN_successfully_save_to_file() throws Exception {\n+        Path recipePath = TestHelper.getPathForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\")\n+                .resolve(\"recipe.yaml\");\n+        Package pkg = packageStore.findPackageRecipe(recipePath).get();\n+\n+        Path saveToFile =\n+                testCache.resolve(String.format(\"%s-%s.yaml\", TestHelper.MONITORING_SERVICE_PACKAGE_NAME, \"1.1.0\"));\n+        packageStore.savePackageToFile(pkg, saveToFile);\n+\n+        Package savedPackage = packageStore.findPackageRecipe(saveToFile).get();\n+        assertThat(savedPackage, is(pkg));\n+    }\n+\n+    @Test\n+    void GIVEN_artifact_list_empty_WHEN_attempt_download_artifact_THEN_do_nothing() throws Exception {\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+\n+        packageStore.downloadArtifactsIfNecessary(pkgId, Collections.emptyList());\n+\n+        verify(artifactDownloader, never()).downloadToPath(any(), any(), any());\n+    }\n+\n+    @Test\n+    void GIVEN_artifact_list_WHEN_attempt_download_artifact_THEN_invoke_downloader() throws Exception {\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+\n+        packageStore.downloadArtifactsIfNecessary(pkgId,\n+                Arrays.asList(new URI(\"greengrass:binary1\"), new URI(\"greengrass:binary2\")));\n+\n+        ArgumentCaptor<URI> uriArgumentCaptor = ArgumentCaptor.forClass(URI.class);\n+        verify(artifactDownloader, times(2)).downloadToPath(eq(pkgId), uriArgumentCaptor.capture(),\n+                eq(testCache.resolve(\"artifact\").resolve(\"CoolService\").resolve(\"1.0.0\")));\n+        List<URI> uriList = uriArgumentCaptor.getAllValues();\n+        assertThat(uriList.size(), is(2));\n+        assertThat(uriList.get(0).getSchemeSpecificPart(), is(\"binary1\"));\n+        assertThat(uriList.get(1).getSchemeSpecificPart(), is(\"binary2\"));\n+    }\n+\n+\n+    @Test\n+    void GIVEN_artifact_provider_not_supported_WHEN_attempt_download_THEN_throw_package_exception() {\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0.0\"), \"CoolServiceARN\");\n+\n+        assertThrows(PackageLoadingException.class, () -> packageStore\n+                .downloadArtifactsIfNecessary(pkgId, Collections.singletonList(new URI(\"docker:image1\"))));\n+    }\n+\n+    @Test\n+    void GIVEN_artifact_url_no_scheme_WHEN_attempt_download_THEN_throw_package_exception() {\n+        PackageIdentifier pkgId = new PackageIdentifier(\"CoolService\", new Semver(\"1.0\" + \".0\"), \"CoolServiceARN\");\n+\n+        assertThrows(PackageLoadingException.class,\n+                () -> packageStore.downloadArtifactsIfNecessary(pkgId, Collections.singletonList(new URI(\"binary1\"))));\n+    }\n+\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4af1dad8171e3bf82a92f914bfa4b2b213bd5123"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMjIwMTM2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391220136", "createdAt": "2020-04-10T01:11:33Z", "commit": {"oid": "4af1dad8171e3bf82a92f914bfa4b2b213bd5123"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be9f8e15da57b718ad3a48986e7e22d4b2deb58f", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/be9f8e15da57b718ad3a48986e7e22d4b2deb58f", "committedDate": "2020-04-10T01:27:33Z", "message": "package store download with s3 presigned url"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "737b796ec3a24f58dbbe937172c8982f44470e50", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/737b796ec3a24f58dbbe937172c8982f44470e50", "committedDate": "2020-04-10T01:27:33Z", "message": "add unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4662b4588947187c9334d0a62fe9a8f09a6a4a02", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4662b4588947187c9334d0a62fe9a8f09a6a4a02", "committedDate": "2020-04-10T01:27:33Z", "message": "fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0527ae27459f3a7cdfa2fb28dff17ceeef3cb651", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0527ae27459f3a7cdfa2fb28dff17ceeef3cb651", "committedDate": "2020-04-10T01:27:33Z", "message": "handling comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c543f114ee8c6e767c0e86db1a7d42bf31eaaebb", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c543f114ee8c6e767c0e86db1a7d42bf31eaaebb", "committedDate": "2020-04-10T01:27:33Z", "message": "renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6eba791d6cc5864b7f0b247910502503a79e58cb", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6eba791d6cc5864b7f0b247910502503a79e58cb", "committedDate": "2020-04-10T01:27:33Z", "message": "add some comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb673ea16547331544af6486ffc216e18d3a75dc", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cb673ea16547331544af6486ffc216e18d3a75dc", "committedDate": "2020-04-10T01:27:33Z", "message": "simplify the prepare package task to be sequential"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8744e30c0b1ebd116ba5a8a924370e3a79dbfee4", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8744e30c0b1ebd116ba5a8a924370e3a79dbfee4", "committedDate": "2020-04-10T01:27:33Z", "message": "remove import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "783e4f11870096e8bb0adb61f2a7ebf9543ee77a", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/783e4f11870096e8bb0adb61f2a7ebf9543ee77a", "committedDate": "2020-04-10T01:27:34Z", "message": "fix javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9495e61fa1d77cb470553ca239518b9430ee0520", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9495e61fa1d77cb470553ca239518b9430ee0520", "committedDate": "2020-04-10T01:27:34Z", "message": "fix PMD"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c32b8156a971e619d5c269deeb8dfa413ecbc10e", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c32b8156a971e619d5c269deeb8dfa413ecbc10e", "committedDate": "2020-04-10T01:27:34Z", "message": "make integ test pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffd1c214df7a34dff811fe8f944738c8e7e4ee23", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ffd1c214df7a34dff811fe8f944738c8e7e4ee23", "committedDate": "2020-04-10T01:27:34Z", "message": "resolve merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa289bd6dbac8a8cc9a238e44f6a9f989849085e", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fa289bd6dbac8a8cc9a238e44f6a9f989849085e", "committedDate": "2020-04-10T01:27:34Z", "message": "remove package store deprecated constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2278a3f33382b104ab4bc948cb1eda9f1cdcc8a", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c2278a3f33382b104ab4bc948cb1eda9f1cdcc8a", "committedDate": "2020-04-10T01:27:34Z", "message": "fix PMD violation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42ca33cc983e87c8da2b63c444f3375e239cfa72", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/42ca33cc983e87c8da2b63c444f3375e239cfa72", "committedDate": "2020-04-10T01:27:34Z", "message": "supply package store path to context for DI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18e08dc820947516cf7b6cf284d68d338ad8ee7a", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/18e08dc820947516cf7b6cf284d68d338ad8ee7a", "committedDate": "2020-04-10T01:27:34Z", "message": "add TODO"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbc869360590131a98da1dfbc92dc46a7aab89a6", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cbc869360590131a98da1dfbc92dc46a7aab89a6", "committedDate": "2020-04-10T01:27:34Z", "message": "handle comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21d04a2b9b44b1a622d3198407d05fd4413065ad", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/21d04a2b9b44b1a622d3198407d05fd4413065ad", "committedDate": "2020-04-10T01:27:34Z", "message": "clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd0bd69f748c5f0f906c391d17d018772bddda3b", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cd0bd69f748c5f0f906c391d17d018772bddda3b", "committedDate": "2020-04-10T01:27:34Z", "message": "remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1323ea52dfd4555ce205817d0415eb7c42b853f", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b1323ea52dfd4555ce205817d0415eb7c42b853f", "committedDate": "2020-04-10T01:27:34Z", "message": "a few renaming"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4af1dad8171e3bf82a92f914bfa4b2b213bd5123", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4af1dad8171e3bf82a92f914bfa4b2b213bd5123", "committedDate": "2020-04-10T00:53:36Z", "message": "remove unused import"}, "afterCommit": {"oid": "b1323ea52dfd4555ce205817d0415eb7c42b853f", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b1323ea52dfd4555ce205817d0415eb7c42b853f", "committedDate": "2020-04-10T01:27:34Z", "message": "a few renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13af016555afcee5a8836855ed1cb7d2c93877e1", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/13af016555afcee5a8836855ed1cb7d2c93877e1", "committedDate": "2020-04-10T01:32:40Z", "message": "fix PMD"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMjI1OTEy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391225912", "createdAt": "2020-04-10T01:36:07Z", "commit": {"oid": "13af016555afcee5a8836855ed1cb7d2c93877e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMjMxMTU1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391231155", "createdAt": "2020-04-10T01:59:32Z", "commit": {"oid": "13af016555afcee5a8836855ed1cb7d2c93877e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMjQ3ODc0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#pullrequestreview-391247874", "createdAt": "2020-04-10T03:17:11Z", "commit": {"oid": "13af016555afcee5a8836855ed1cb7d2c93877e1"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMzoxNzoxMVrOGDv7dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMzoxNzo1M1rOGDv8Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4NDE4MQ==", "bodyText": "Generally we should not be both logging and throwing within the same catch.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406584181", "createdAt": "2020-04-10T03:17:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13af016555afcee5a8836855ed1cb7d2c93877e1"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4NDMzMQ==", "bodyText": "Same here, to prevent duplicate logging, our standard is to only log when the exception is handled.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/164#discussion_r406584331", "createdAt": "2020-04-10T03:17:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -62,14 +132,138 @@ public PackageStore(Path packageStorePath) {\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if\n      * they don't exist.\n      *\n-     * @param pkgs a list of packages.\n+     * @param pkgIds a list of packages.\n      * @return a future to notify once this is finished.\n      */\n-    public Future<Void> preparePackages(List<PackageIdentifier> pkgs) {\n-        // TODO: to be implemented.\n-        CompletableFuture<Void> completableFuture = new CompletableFuture<>();\n-        completableFuture.complete(null);\n-        return completableFuture;\n+    public Future<Void> preparePackages(List<PackageIdentifier> pkgIds) {\n+        return executorService.submit(() -> {\n+            for (PackageIdentifier packageIdentifier : pkgIds) {\n+                    preparePackage(packageIdentifier);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    private void preparePackage(PackageIdentifier packageIdentifier)\n+            throws PackageLoadingException, PackageDownloadException {\n+        logger.atInfo().setEventType(\"prepare-package-start\").addKeyValue(\"packageIdentifier\", packageIdentifier).log();\n+        try {\n+            Package pkg = findRecipeDownloadIfNotExisted(packageIdentifier);\n+            List<URI> artifactURIList = pkg.getArtifacts().stream().map(artifactStr -> {\n+                try {\n+                    return new URI(artifactStr);\n+                } catch (URISyntaxException e) {\n+                    String message = String.format(\"artifact URI %s is invalid\", artifactStr);\n+                    logger.atError().setCause(e).log(message);\n+                    throw new RuntimeException(message, e);\n+                }\n+            }).collect(Collectors.toList());\n+            downloadArtifactsIfNecessary(packageIdentifier, artifactURIList);\n+            logger.atInfo().setEventType(\"prepare-package-finished\").addKeyValue(\"packageIdentifier\", packageIdentifier)\n+                    .log();\n+        } catch (PackageLoadingException | PackageDownloadException e) {\n+            logger.atError().setCause(e).log(String.format(\"Failed to prepare package %s\", packageIdentifier));\n+            throw e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13af016555afcee5a8836855ed1cb7d2c93877e1"}, "originalPosition": 171}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2426, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}