{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMjYzMzU1", "number": 512, "reviewThreads": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjoxMjo1NVrOEr3kSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTozMTozNFrOEyGHGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NDM0NjM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjoxMjo1NVrOHe37Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjoyMjoyMlrOHe4PzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzNTYwNw==", "bodyText": "I think you extend the wrong parent class. It should be GeneratedAbstractPublishToTopicOperationHandler. GeneratedAbstractPublishToIoTCoreOperationHandler is for MQTTClient.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r502135607", "createdAt": "2020-10-09T02:12:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.DefaultConcurrentHashMap;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ResourceNotFoundError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import lombok.Getter;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+import software.amazon.eventstream.iot.server.ServerStreamEventPublisher;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final Map<String, Set<ServerStreamEventPublisher<IoTCoreMessage>>> listeners =\n+            new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);\n+    private static final Map<String, ServerStreamEventPublisher<IoTCoreMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f7c414503ee454ef945d42d9041ea3f99858e59"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE0MDg3Ng==", "bodyText": "Oops. My bad. Will make the changes.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r502140876", "createdAt": "2020-10-09T02:22:22Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.DefaultConcurrentHashMap;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ResourceNotFoundError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import lombok.Getter;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+import software.amazon.eventstream.iot.server.ServerStreamEventPublisher;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final Map<String, Set<ServerStreamEventPublisher<IoTCoreMessage>>> listeners =\n+            new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);\n+    private static final Map<String, ServerStreamEventPublisher<IoTCoreMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzNTYwNw=="}, "originalCommit": {"oid": "9f7c414503ee454ef945d42d9041ea3f99858e59"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NDM0OTU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjoxMzo0OVrOHe39DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjoxMzo0OVrOHe39DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzNjA3Ng==", "bodyText": "Same here. For internal pubsub, it should extend to GeneratedAbstractSubscribeToTopicOperationHandler and GeneratedAbstractPublishToTopicOperationHandler", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r502136076", "createdAt": "2020-10-09T02:13:49Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.DefaultConcurrentHashMap;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ResourceNotFoundError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import lombok.Getter;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+import software.amazon.eventstream.iot.server.ServerStreamEventPublisher;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final Map<String, Set<ServerStreamEventPublisher<IoTCoreMessage>>> listeners =\n+            new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);\n+    private static final Map<String, ServerStreamEventPublisher<IoTCoreMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest publishRequest) {\n+            if (!listeners.containsKey(publishRequest.getTopicName())) {\n+                // Still technically successful, just no one was subscribed\n+                return new PublishToIoTCoreResponse();\n+            }\n+            Set<ServerStreamEventPublisher<IoTCoreMessage>> contexts = listeners.get(publishRequest.getTopicName());\n+\n+            executor.execute(() -> contexts.forEach(c -> {\n+                log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Sending publish event {} to {}\", publishRequest);\n+                MQTTMessage mqttMessage = new MQTTMessage();\n+                mqttMessage.setPayload(publishRequest.getPayload());\n+                mqttMessage.setTopicName(publishRequest.getTopicName());\n+                IoTCoreMessage ioTCoreMessage = new IoTCoreMessage();\n+                ioTCoreMessage.setMessage(mqttMessage);\n+                c.sendStreamEvent(ioTCoreMessage);\n+            }));\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+            // NA\n+        }\n+    }\n+\n+    static class UnsubscribeFromIoTCoreOperationHandler", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f7c414503ee454ef945d42d9041ea3f99858e59"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA5OTc2OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo1MTozNFrOHlXTxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo1MTozNFrOHlXTxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MTI1Mw==", "bodyText": "log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r508941253", "createdAt": "2020-10-21T01:51:34Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -362,4 +373,120 @@ public void onStreamClosed() {\n         lifecycleIPCEventStreamAgent.sendPostComponentUpdateEvent(new PostComponentUpdateEvent());\n         assertTrue(cdl.await(TIMEOUT_FOR_LIFECYCLE_SECONDS, TimeUnit.SECONDS));\n     }\n+\n+    @Test\n+    void GIVEN_PubSubEventStreamClient_WHEN_subscribe_and_unsubscribe_THEN_publishes_only_once() throws Exception {\n+        String topicName = \"topicName\";\n+        SubscribeToTopicRequest subscribeToTopicRequest = new SubscribeToTopicRequest();\n+        subscribeToTopicRequest.setTopic(topicName);\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        AtomicInteger atomicInteger = new AtomicInteger();\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+            greengrassCoreIPCClient.subscribeToTopic(subscribeToTopicRequest,\n+                    Optional.of(new StreamResponseHandler<SubscriptionResponseMessage>() {\n+                @Override\n+                public void onStreamEvent(SubscriptionResponseMessage message) {\n+                    assertNotNull(message.getBinaryMessage());\n+                    assertNull(message.getJsonMessage());\n+                    assertEquals(\"ABCDEFG\", new String(message.getBinaryMessage().getMessage()));\n+                    atomicInteger.incrementAndGet();\n+                    cdl.countDown();\n+                }\n+\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODEwMDc4OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo1MjowOFrOHlXUYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo1MjowOFrOHlXUYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MTQxMQ==", "bodyText": "log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r508941411", "createdAt": "2020-10-21T01:52:08Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -362,4 +373,120 @@ public void onStreamClosed() {\n         lifecycleIPCEventStreamAgent.sendPostComponentUpdateEvent(new PostComponentUpdateEvent());\n         assertTrue(cdl.await(TIMEOUT_FOR_LIFECYCLE_SECONDS, TimeUnit.SECONDS));\n     }\n+\n+    @Test\n+    void GIVEN_PubSubEventStreamClient_WHEN_subscribe_and_unsubscribe_THEN_publishes_only_once() throws Exception {\n+        String topicName = \"topicName\";\n+        SubscribeToTopicRequest subscribeToTopicRequest = new SubscribeToTopicRequest();\n+        subscribeToTopicRequest.setTopic(topicName);\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        AtomicInteger atomicInteger = new AtomicInteger();\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+            greengrassCoreIPCClient.subscribeToTopic(subscribeToTopicRequest,\n+                    Optional.of(new StreamResponseHandler<SubscriptionResponseMessage>() {\n+                @Override\n+                public void onStreamEvent(SubscriptionResponseMessage message) {\n+                    assertNotNull(message.getBinaryMessage());\n+                    assertNull(message.getJsonMessage());\n+                    assertEquals(\"ABCDEFG\", new String(message.getBinaryMessage().getMessage()));\n+                    atomicInteger.incrementAndGet();\n+                    cdl.countDown();\n+                }\n+\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;\n+                }\n+\n+                @Override\n+                public void onStreamClosed() {\n+\n+                }\n+            }));\n+            CountDownLatch subscriptionLatch = new CountDownLatch(1);\n+            CountDownLatch unsubscriptionLatch = new CountDownLatch(1);\n+            Slf4jLogAdapter.addGlobalListener(m -> {\n+                if (m.getMessage().contains(\"Subscribing to topic\")) {\n+                    subscriptionLatch.countDown();\n+                }\n+                if (m.getMessage().contains(\"Unsubscribing from topic\")) {\n+                    unsubscriptionLatch.countDown();\n+                }\n+            });\n+            assertTrue(subscriptionLatch.await(10, TimeUnit.SECONDS));\n+\n+            PublishToTopicRequest publishToTopicRequest = new PublishToTopicRequest();\n+            publishToTopicRequest.setTopic(topicName);\n+            PublishMessage publishMessage = new PublishMessage();\n+            BinaryMessage binaryMessage = new BinaryMessage();\n+            binaryMessage.setMessage(\"ABCDEFG\".getBytes());\n+            publishMessage.setBinaryMessage(binaryMessage);\n+            publishToTopicRequest.setPublishMessage(publishMessage);\n+            greengrassCoreIPCClient.publishToTopic(publishToTopicRequest, Optional.empty()).getResponse().get(10, TimeUnit.SECONDS);\n+            assertTrue(cdl.await(20, TimeUnit.SECONDS));\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_PubSubEventStreamClient_WHEN_subscribe_to_another_source_THEN_does_not_publish()\n+            throws Exception {\n+        String topicName = \"topicName\";\n+        String sourceName = \"sourceName\";\n+        SubscribeToTopicRequest subscribeToTopicRequest = new SubscribeToTopicRequest();\n+        subscribeToTopicRequest.setTopic(topicName);\n+        subscribeToTopicRequest.setSource(sourceName);\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        AtomicInteger atomicInteger = new AtomicInteger();\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+            greengrassCoreIPCClient.subscribeToTopic(subscribeToTopicRequest,\n+                    Optional.of(new StreamResponseHandler<SubscriptionResponseMessage>() {\n+                @Override\n+                public void onStreamEvent(SubscriptionResponseMessage message) {\n+                    assertNotNull(message.getBinaryMessage());\n+                    assertNull(message.getJsonMessage());\n+                    assertEquals(\"ABCDEFG\", new String(message.getBinaryMessage().getMessage()));\n+                    atomicInteger.incrementAndGet();\n+                    cdl.countDown();\n+                }\n+\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODEwNTAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo1NDozNFrOHlXW4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1MTozMlrOHmKaVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MjA0OQ==", "bodyText": "This should be using the old implementation so that everything can talk together. Old ipc, new ipc, and lambda (lambda uses the old IPC API, but within the JVM, not the network)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r508942049", "createdAt": "2020-10-21T01:54:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0NzgyOA==", "bodyText": "Didn't quite understand, Are you saying that all the code in PubSubIPCEventStreamAgent should live in PubSubIPCAgent?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r508947828", "createdAt": "2020-10-21T02:16:16Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MjA0OQ=="}, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0OTM5Mw==", "bodyText": "It could work, but no. I'm saying that it should use that code. You've setup a parallel world of different pubsub. So now we have 2 pubsubs. We should have 1 pubsub with 2 APIs", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r508949393", "createdAt": "2020-10-21T02:22:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MjA0OQ=="}, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyNzEzMQ==", "bodyText": "https://github.com/aws/aws-greengrass-nucleus/blob/master/src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCAgent.java#L60\nhttps://github.com/aws/aws-greengrass-nucleus/blob/master/src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCAgent.java#L102\nhttps://github.com/aws/aws-greengrass-nucleus/blob/master/src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCAgent.java#L130\nThese three methods need to be copied over here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509727131", "createdAt": "2020-10-21T21:45:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MjA0OQ=="}, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3ODUxNg==", "bodyText": "I had copied over two of them. Will copy over the last one as well.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509778516", "createdAt": "2020-10-21T22:51:32Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MjA0OQ=="}, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Mjk4OTU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTo1Nzo0MVrOHmH0Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowNDozN1rOHmKynw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczNjAxMA==", "bodyText": "Why do we care about source? This is new to me.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509736010", "createdAt": "2020-10-21T21:57:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MzA1Mw==", "bodyText": "The source was included in the smithy model. So I thought we need to handle that as well -> https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/b279b53dc49d0d0bd13df3d3cf4253f77a3e4dd9/--/model/main.smithy#L296", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509773053", "createdAt": "2020-10-21T22:44:23Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczNjAxMA=="}, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NDczNQ==", "bodyText": "The whole concept of pubsub is that the publisher and subscriber don't need to know each other. I think the source was probably added for some backward compatibility reason but it can be safely removed now @abanthiy . I don't see any use case for it at this point.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509784735", "createdAt": "2020-10-21T23:04:37Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczNjAxMA=="}, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzAwMTYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowMDoxOVrOHmH8Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1MjozMFrOHmKdQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczODA1NQ==", "bodyText": "Again. Why do we check the source of the publish message? What's the use case?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509738055", "createdAt": "2020-10-21T22:00:19Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }\n+    }\n+\n+\n+    class PublishToTopicOperationHandler extends GeneratedAbstractPublishToTopicOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToTopicResponse handleRequest(PublishToTopicRequest publishRequest) {\n+            if (!allSourcesListeners.containsKey(publishRequest.getTopic())\n+                    && !particularSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                // Still technically successful, just no one was subscribed\n+                return new PublishToTopicResponse();\n+            }\n+\n+            executor.execute(() -> {\n+                Set<Object> contexts = new HashSet<>();\n+                if (allSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                    contexts.addAll(allSourcesListeners.get(publishRequest.getTopic()));\n+                }\n+\n+                if (particularSourcesListeners.containsKey(publishRequest.getTopic())\n+                        && particularSourcesListeners.get(publishRequest.getTopic()).containsKey(serviceName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTI2Ng==", "bodyText": "I thought the idea was that if only one source updates the topic, the subscriber needs to be notified.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509779266", "createdAt": "2020-10-21T22:52:30Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }\n+    }\n+\n+\n+    class PublishToTopicOperationHandler extends GeneratedAbstractPublishToTopicOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToTopicResponse handleRequest(PublishToTopicRequest publishRequest) {\n+            if (!allSourcesListeners.containsKey(publishRequest.getTopic())\n+                    && !particularSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                // Still technically successful, just no one was subscribed\n+                return new PublishToTopicResponse();\n+            }\n+\n+            executor.execute(() -> {\n+                Set<Object> contexts = new HashSet<>();\n+                if (allSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                    contexts.addAll(allSourcesListeners.get(publishRequest.getTopic()));\n+                }\n+\n+                if (particularSourcesListeners.containsKey(publishRequest.getTopic())\n+                        && particularSourcesListeners.get(publishRequest.getTopic()).containsKey(serviceName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczODA1NQ=="}, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzAxMDA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowMTo1N1rOHmIBpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowMTo1N1rOHmIBpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczOTQyOQ==", "bodyText": "log something before just dropping the message on the floor?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509739429", "createdAt": "2020-10-21T22:01:57Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }\n+    }\n+\n+\n+    class PublishToTopicOperationHandler extends GeneratedAbstractPublishToTopicOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToTopicResponse handleRequest(PublishToTopicRequest publishRequest) {\n+            if (!allSourcesListeners.containsKey(publishRequest.getTopic())\n+                    && !particularSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                // Still technically successful, just no one was subscribed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzAxOTIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowNDoyMFrOHmIHtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjowNDoyMFrOHmIHtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MDk4Mg==", "bodyText": "These can be extracted out from the foreach loop.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509740982", "createdAt": "2020-10-21T22:04:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }\n+    }\n+\n+\n+    class PublishToTopicOperationHandler extends GeneratedAbstractPublishToTopicOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToTopicResponse handleRequest(PublishToTopicRequest publishRequest) {\n+            if (!allSourcesListeners.containsKey(publishRequest.getTopic())\n+                    && !particularSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                // Still technically successful, just no one was subscribed\n+                return new PublishToTopicResponse();\n+            }\n+\n+            executor.execute(() -> {\n+                Set<Object> contexts = new HashSet<>();\n+                if (allSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                    contexts.addAll(allSourcesListeners.get(publishRequest.getTopic()));\n+                }\n+\n+                if (particularSourcesListeners.containsKey(publishRequest.getTopic())\n+                        && particularSourcesListeners.get(publishRequest.getTopic()).containsKey(serviceName)) {\n+                    contexts.addAll(particularSourcesListeners.get(publishRequest.getTopic()).get(serviceName));\n+                }\n+                contexts.forEach(context -> {\n+                    log.atDebug().kv(SERVICE_NAME, serviceName)\n+                            .log(\"Sending publish event {}\", publishRequest);\n+                    SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+                    publishRequest.getPublishMessage().selfDesignateSetUnionMember();\n+                    if (publishRequest.getPublishMessage().getJsonMessage() != null) {\n+                        message.setJsonMessage(publishRequest.getPublishMessage().getJsonMessage());\n+                    }\n+                    if (publishRequest.getPublishMessage().getBinaryMessage() != null) {\n+                        message.setBinaryMessage(publishRequest.getPublishMessage().getBinaryMessage());\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzA0MjM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxMDozMlrOHmIXRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxMDozMlrOHmIXRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NDk2NA==", "bodyText": "How does this even work? For handling subscribe request, you put the service name into the serviceToPublisherMap  but then no one is reading from the map. For handling publish request, the subscribers are read from allSourcesListeners and particularSourcesListeners. How these two are connected together? I'm lost here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509744964", "createdAt": "2020-10-21T22:10:32Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }\n+    }\n+\n+\n+    class PublishToTopicOperationHandler extends GeneratedAbstractPublishToTopicOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToTopicResponse handleRequest(PublishToTopicRequest publishRequest) {\n+            if (!allSourcesListeners.containsKey(publishRequest.getTopic())\n+                    && !particularSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                // Still technically successful, just no one was subscribed\n+                return new PublishToTopicResponse();\n+            }\n+\n+            executor.execute(() -> {\n+                Set<Object> contexts = new HashSet<>();\n+                if (allSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                    contexts.addAll(allSourcesListeners.get(publishRequest.getTopic()));\n+                }\n+\n+                if (particularSourcesListeners.containsKey(publishRequest.getTopic())\n+                        && particularSourcesListeners.get(publishRequest.getTopic()).containsKey(serviceName)) {\n+                    contexts.addAll(particularSourcesListeners.get(publishRequest.getTopic()).get(serviceName));\n+                }\n+                contexts.forEach(context -> {\n+                    log.atDebug().kv(SERVICE_NAME, serviceName)\n+                            .log(\"Sending publish event {}\", publishRequest);\n+                    SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+                    publishRequest.getPublishMessage().selfDesignateSetUnionMember();\n+                    if (publishRequest.getPublishMessage().getJsonMessage() != null) {\n+                        message.setJsonMessage(publishRequest.getPublishMessage().getJsonMessage());\n+                    }\n+                    if (publishRequest.getPublishMessage().getBinaryMessage() != null) {\n+                        message.setBinaryMessage(publishRequest.getPublishMessage().getBinaryMessage());\n+                    }\n+                    if (context instanceof StreamEventPublisher) {\n+                        ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message);\n+                    } else if (context instanceof Consumer) {\n+                        ((Consumer<SubscriptionResponseMessage>) context).accept(message);\n+                    }\n+                });\n+            });\n+            return new PublishToTopicResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+            // NA\n+        }\n+    }\n+\n+    class SubscribeToTopicOperationHandler extends GeneratedAbstractSubscribeToTopicOperationHandler {\n+        @Getter\n+        private final String serviceName;\n+        private String subscribeTopic;\n+        private String subscribeToSource;\n+\n+        protected SubscribeToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribeTopic) && allSourcesListeners.containsKey(subscribeTopic)) {\n+                if (allSourcesListeners.get(subscribeTopic).remove(this)) {\n+                    log.atDebug().kv(SERVICE_NAME, serviceName)\n+                            .log(\"Client disconnected, removing subscription {}\", subscribeTopic);\n+                }\n+                if (allSourcesListeners.get(subscribeTopic).isEmpty()) {\n+                    allSourcesListeners.remove(subscribeTopic);\n+                }\n+            } else if (!Utils.isEmpty(subscribeTopic) && !Utils.isEmpty(subscribeToSource)\n+                    && particularSourcesListeners.containsKey(subscribeTopic)) {\n+                if (particularSourcesListeners.get(subscribeTopic).get(subscribeToSource).remove(this)) {\n+                    log.atDebug().kv(SERVICE_NAME, serviceName)\n+                            .log(\"Client disconnected, removing subscription {} for source\",\n+                                    subscribeTopic, subscribeToSource);\n+                }\n+                if (particularSourcesListeners.get(subscribeTopic).get(subscribeToSource).isEmpty()) {\n+                    particularSourcesListeners.remove(subscribeTopic);\n+                }\n+                if (particularSourcesListeners.get(subscribeTopic).isEmpty()) {\n+                    particularSourcesListeners.remove(subscribeTopic);\n+                }\n+            }\n+\n+        }\n+\n+        @Override\n+        public SubscribeToTopicResponse handleRequest(SubscribeToTopicRequest subscribeRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODM1MTE0OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCPubSubTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMzoyODoxMVrOHm67xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMzozMToxN1rOHm6-iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU3MzUwOA==", "bodyText": "these operations should be taken from the SDK like MQTT is doing. so it would be aws.greengrass#publish", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r510573508", "createdAt": "2020-10-23T03:28:11Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -54,9 +77,44 @@\n     private static IPCClient client;\n     public static Permission TES_DEFAULT_POLICY =\n             Permission.builder().principal(\"*\").operation(\"getCredentials\").resource(null).build();\n+    private static final String newACl =\n+            \"{  \\n\" +\n+            \"   \\\"aws.greengrass.ipc.pubsub\\\":[\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"policyId10\\\":{\\n\" +\n+            \"            \\\"policyDescription\\\":\\\"access to pubsub topics for ServiceName\\\",\\n\" +\n+            \"            \\\"operations\\\":[\\n\" +\n+            \"              \\\"*\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"resources\\\":[\\n\" +\n+            \"              \\\"*\\\"\\n\" +\n+            \"            ]\\n\" +\n+            \"          }\\n\" +\n+            \"        }\\n\" +\n+            \"    ]\\n\" +\n+            \"}\";\n+\n+    private static final String oldACl =\n+            \"{  \\n\" +\n+            \"   \\\"aws.greengrass.ipc.pubsub\\\":[\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"policyId4\\\":{\\n\" +\n+            \"            \\\"policyDescription\\\":\\\"access to pubsub topics for ServiceName\\\",\\n\" +\n+            \"            \\\"operations\\\":[\\n\" +\n+            \"              \\\"publish\\\"\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU3NDIxOQ==", "bodyText": "I see that you have done that change, my mistake then.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r510574219", "createdAt": "2020-10-23T03:31:17Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -54,9 +77,44 @@\n     private static IPCClient client;\n     public static Permission TES_DEFAULT_POLICY =\n             Permission.builder().principal(\"*\").operation(\"getCredentials\").resource(null).build();\n+    private static final String newACl =\n+            \"{  \\n\" +\n+            \"   \\\"aws.greengrass.ipc.pubsub\\\":[\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"policyId10\\\":{\\n\" +\n+            \"            \\\"policyDescription\\\":\\\"access to pubsub topics for ServiceName\\\",\\n\" +\n+            \"            \\\"operations\\\":[\\n\" +\n+            \"              \\\"*\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"resources\\\":[\\n\" +\n+            \"              \\\"*\\\"\\n\" +\n+            \"            ]\\n\" +\n+            \"          }\\n\" +\n+            \"        }\\n\" +\n+            \"    ]\\n\" +\n+            \"}\";\n+\n+    private static final String oldACl =\n+            \"{  \\n\" +\n+            \"   \\\"aws.greengrass.ipc.pubsub\\\":[\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"policyId4\\\":{\\n\" +\n+            \"            \\\"policyDescription\\\":\\\"access to pubsub topics for ServiceName\\\",\\n\" +\n+            \"            \\\"operations\\\":[\\n\" +\n+            \"              \\\"publish\\\"\\n\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU3MzUwOA=="}, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTA5NTEyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjozODo0M1rOHnVYVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjozODo0M1rOHnVYVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNjgwNw==", "bodyText": "remove allSources prefix.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511006807", "createdAt": "2020-10-23T16:38:43Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTExNTgzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo0NDoyNFrOHnVkuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo0NDoyNFrOHnVkuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwOTk3Ng==", "bodyText": "This signature still requires lambdaManager to import the data model. Why not just change it to:\npublic void publish(String topic, String serviceName, byte[] payload) {\n    handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(payload));\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511009976", "createdAt": "2020-10-23T16:44:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", topic);\n+        if (allSourcesListeners.containsKey(topic)) {\n+            allSourcesListeners.get(topic).remove(cb);\n+        }\n+        if (allSourcesListeners.get(topic).isEmpty()) {\n+            allSourcesListeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param jsonMessage   JSON message to publish.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic,\n+                                          Optional<Map<String, Object>> jsonMessage,\n+                                          Optional<byte[]> binaryMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTEyMzcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo0NjozM1rOHnVpdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo0NjozM1rOHnVpdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMTE4OQ==", "bodyText": "Don't use empty string. It doesn't help debugging. Let the client pass in a service name.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511011189", "createdAt": "2020-10-23T16:46:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", topic);\n+        if (allSourcesListeners.containsKey(topic)) {\n+            allSourcesListeners.get(topic).remove(cb);\n+        }\n+        if (allSourcesListeners.get(topic).isEmpty()) {\n+            allSourcesListeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param jsonMessage   JSON message to publish.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic,\n+                                          Optional<Map<String, Object>> jsonMessage,\n+                                          Optional<byte[]> binaryMessage) {\n+        return handlePublishToTopicRequest(topic, \"\", jsonMessage, binaryMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTE0MjQ5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1MjoxNFrOHnV07Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1MjoxNFrOHnV07Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNDEyNQ==", "bodyText": "Why asynchronous?  Why put asynchronous here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511014125", "createdAt": "2020-10-23T16:52:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", topic);\n+        if (allSourcesListeners.containsKey(topic)) {\n+            allSourcesListeners.get(topic).remove(cb);\n+        }\n+        if (allSourcesListeners.get(topic).isEmpty()) {\n+            allSourcesListeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param jsonMessage   JSON message to publish.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic,\n+                                          Optional<Map<String, Object>> jsonMessage,\n+                                          Optional<byte[]> binaryMessage) {\n+        return handlePublishToTopicRequest(topic, \"\", jsonMessage, binaryMessage);\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        if (!allSourcesListeners.containsKey(topic)) {\n+            log.atDebug().log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+\n+        executor.execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTE1NTU0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1NjoxNFrOHnV9Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1NjoxNFrOHnV9Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNjIwMw==", "bodyText": "What if one of the callbacks blocks? Now the rest will also be blocked. The callback needs to run in a thread pool. And ideally for the same callback, all the messages should be running on the same thread so that we have a guarantee of order.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511016203", "createdAt": "2020-10-23T16:56:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", topic);\n+        if (allSourcesListeners.containsKey(topic)) {\n+            allSourcesListeners.get(topic).remove(cb);\n+        }\n+        if (allSourcesListeners.get(topic).isEmpty()) {\n+            allSourcesListeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param jsonMessage   JSON message to publish.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic,\n+                                          Optional<Map<String, Object>> jsonMessage,\n+                                          Optional<byte[]> binaryMessage) {\n+        return handlePublishToTopicRequest(topic, \"\", jsonMessage, binaryMessage);\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        if (!allSourcesListeners.containsKey(topic)) {\n+            log.atDebug().log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+\n+        executor.execute(() -> {\n+            Set<Object> contexts = new HashSet<>();\n+            if (allSourcesListeners.containsKey(topic)) {\n+                contexts.addAll(allSourcesListeners.get(topic));\n+            }\n+\n+            SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+            if (jsonMessage.isPresent()) {\n+                JsonMessage message1 = new JsonMessage();\n+                message1.setMessage(jsonMessage.get());\n+                message.setJsonMessage(message1);\n+            }\n+            if (binaryMessage.isPresent()) {\n+                BinaryMessage binaryMessage1 = new BinaryMessage();\n+                binaryMessage1.setMessage(binaryMessage.get());\n+                message.setBinaryMessage(binaryMessage1);\n+            }\n+\n+            contexts.forEach(context -> {\n+                log.atDebug().kv(SERVICE_NAME, serviceName)\n+                        .log(\"Sending publish event for topic {}\", topic);\n+                if (context instanceof StreamEventPublisher) {\n+                    ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message);\n+                } else if (context instanceof Consumer) {\n+                    ((Consumer<SubscriptionResponseMessage>) context).accept(message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTE3NjQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzowMjozM1rOHnWKMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxODoyNzoyOVrOHnY4xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxOTU2OA==", "bodyText": "Can we keep the same signature as\npublic void subscribe(PubSubSubscribeRequest subscribeRequest, Consumer<MessagePublishedEvent> cb)\n\nand handle the translation in this class?\nThe reason is this will keep the lambda manager simpler (one less dependency).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511019568", "createdAt": "2020-10-23T17:02:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMzA2MA==", "bodyText": "Also update this to have client pass in the service name.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511023060", "createdAt": "2020-10-23T17:09:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxOTU2OA=="}, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2NDI2MA==", "bodyText": "Will update the signature to be\npublic void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName)\nAnd will add a new MessagePublishedEvent in the kernel since we will eventually be removing all IPC models from the SDK.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511064260", "createdAt": "2020-10-23T18:27:29Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxOTU2OA=="}, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTE3OTg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzowMzozNVrOHnWMUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzowMzozNVrOHnWMUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMDExMg==", "bodyText": "Same here. keep the same signature as\npublic void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<MessagePublishedEvent> cb)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511020112", "createdAt": "2020-10-23T17:03:35Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE2MjU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTozOTo0MlrOHnfKzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTozOTo0MlrOHnfKzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NzE4Mw==", "bodyText": "use computeIfPresent to be threadsafe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511167183", "createdAt": "2020-10-23T21:39:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE2Mjc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTozOTo0OFrOHnfK6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTozOTo0OFrOHnfK6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NzIwOQ==", "bodyText": "same", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511167209", "createdAt": "2020-10-23T21:39:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }\n+        if (listeners.get(topic).isEmpty()) {\n+            listeners.remove(topic);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE3MjI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NDowOFrOHnfQyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NDowOFrOHnfQyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODcxMw==", "bodyText": "compute if present", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511168713", "createdAt": "2020-10-23T21:44:08Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }\n+        if (listeners.get(topic).isEmpty()) {\n+            listeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param serviceName   name of the service publishing the message.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        if (!listeners.containsKey(topic)) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+\n+        Set<Object> contexts = new HashSet<>();\n+        if (listeners.containsKey(topic)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjE5NzUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/MessagePublishedEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1NTozM1rOHnffww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1NTozM1rOHnffww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MjU0Nw==", "bodyText": "It's a weird name. Just call it PublishEvent?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511172547", "createdAt": "2020-10-23T21:55:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/MessagePublishedEvent.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class MessagePublishedEvent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjIwMDYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1NzowM1rOHnfhmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1NzowM1rOHnfhmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MzAxNg==", "bodyText": "Adjust order.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511173016", "createdAt": "2020-10-23T21:57:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }\n+        if (listeners.get(topic).isEmpty()) {\n+            listeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param serviceName   name of the service publishing the message.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjI2NTQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjozMTozMlrOHngHfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjozMTozMlrOHngHfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE4MjcxOQ==", "bodyText": "Why is the publishedEvent only getting the binary payload? Is it correct?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511182719", "createdAt": "2020-10-23T22:31:32Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }\n+        if (listeners.get(topic).isEmpty()) {\n+            listeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param serviceName   name of the service publishing the message.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        if (!listeners.containsKey(topic)) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+\n+        Set<Object> contexts = new HashSet<>();\n+        if (listeners.containsKey(topic)) {\n+            contexts.addAll(listeners.get(topic));\n+        }\n+\n+        SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+        MessagePublishedEvent publishedEvent = MessagePublishedEvent.builder().topic(topic).build();\n+        if (jsonMessage.isPresent()) {\n+            JsonMessage message1 = new JsonMessage();\n+            message1.setMessage(jsonMessage.get());\n+            message.setJsonMessage(message1);\n+        }\n+        if (binaryMessage.isPresent()) {\n+            BinaryMessage binaryMessage1 = new BinaryMessage();\n+            binaryMessage1.setMessage(binaryMessage.get());\n+            message.setBinaryMessage(binaryMessage1);\n+            publishedEvent.setPayload(binaryMessage.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjI3NTg2OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgentTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjozNzowNlrOHngNWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjozNzowNlrOHngNWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE4NDIxOQ==", "bodyText": "Can you add a few more test cases? e.g.\n\nThe payload is json type\nThe payload is binary type\nWhen multiple messages are published, the subscribers receives the messages in the order that they're published.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511184219", "createdAt": "2020-10-23T22:37:06Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class PubSubIPCEventStreamAgentTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjcyMjYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMjoxMzowNFrOHnkq_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMjoxMzowNFrOHnkq_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI1NzM0Mw==", "bodyText": "in this case using get and then checking for null makes more sense than compute I think, sorry if I commented the other way before.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511257343", "createdAt": "2020-10-24T02:13:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = new HashSet<>();\n+        listeners.computeIfPresent(topic, (s, objects) -> {\n+            contexts.addAll(listeners.get(topic));\n+            return objects;\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjcyNjA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMjoxNDo0MVrOHnktiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMDowOToyNlrOHn0Eeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI1Nzk5Mg==", "bodyText": "I think we may want to just fire and forget.\n@fengwa-aws what do you say?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511257992", "createdAt": "2020-10-24T02:14:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = new HashSet<>();\n+        listeners.computeIfPresent(topic, (s, objects) -> {\n+            contexts.addAll(listeners.get(topic));\n+            return objects;\n+        });\n+        if (contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        synchronized (listeners.get(topic)) {\n+\n+            SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+            PublishEvent publishedEvent = PublishEvent.builder().topic(topic).build();\n+            if (jsonMessage.isPresent()) {\n+                JsonMessage message1 = new JsonMessage();\n+                message1.setMessage(jsonMessage.get());\n+                message.setJsonMessage(message1);\n+                try {\n+                    publishedEvent.setPayload(SERIALIZER.writeValueAsBytes(jsonMessage.get()));\n+                } catch (JsonProcessingException e) {\n+                    log.atError().cause(e).kv(SERVICE_NAME, serviceName)\n+                            .log(\"Unable to serialize JSON message.\");\n+                }\n+            }\n+            if (binaryMessage.isPresent()) {\n+                BinaryMessage binaryMessage1 = new BinaryMessage();\n+                binaryMessage1.setMessage(binaryMessage.get());\n+                message.setBinaryMessage(binaryMessage1);\n+                publishedEvent.setPayload(binaryMessage.get());\n+            }\n+\n+            List<Future<?>> futures = new ArrayList<>();\n+            contexts.forEach(context -> {\n+                log.atDebug().kv(SERVICE_NAME, serviceName)\n+                        .log(\"Sending publish event for topic {}\", topic);\n+                if (context instanceof StreamEventPublisher) {\n+                    Future<?> submit = executor.submit(() -> {\n+                        ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message);\n+                    });\n+                    futures.add(submit);\n+                } else if (context instanceof Consumer) {\n+                    Future<?> submit = executor.submit(() -> {\n+                        ((Consumer<PublishEvent>) context).accept(publishedEvent);\n+                    });\n+                    futures.add(submit);\n+                }\n+            });\n+            futures.forEach(future -> {\n+                try {\n+                    future.get();\n+                } catch (InterruptedException | ExecutionException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwOTYyNg==", "bodyText": "I think it's beneficial for the customers if we can guarantee the messages are delivered to the subscriber in the order they're published.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511509626", "createdAt": "2020-10-24T20:09:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = new HashSet<>();\n+        listeners.computeIfPresent(topic, (s, objects) -> {\n+            contexts.addAll(listeners.get(topic));\n+            return objects;\n+        });\n+        if (contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        synchronized (listeners.get(topic)) {\n+\n+            SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+            PublishEvent publishedEvent = PublishEvent.builder().topic(topic).build();\n+            if (jsonMessage.isPresent()) {\n+                JsonMessage message1 = new JsonMessage();\n+                message1.setMessage(jsonMessage.get());\n+                message.setJsonMessage(message1);\n+                try {\n+                    publishedEvent.setPayload(SERIALIZER.writeValueAsBytes(jsonMessage.get()));\n+                } catch (JsonProcessingException e) {\n+                    log.atError().cause(e).kv(SERVICE_NAME, serviceName)\n+                            .log(\"Unable to serialize JSON message.\");\n+                }\n+            }\n+            if (binaryMessage.isPresent()) {\n+                BinaryMessage binaryMessage1 = new BinaryMessage();\n+                binaryMessage1.setMessage(binaryMessage.get());\n+                message.setBinaryMessage(binaryMessage1);\n+                publishedEvent.setPayload(binaryMessage.get());\n+            }\n+\n+            List<Future<?>> futures = new ArrayList<>();\n+            contexts.forEach(context -> {\n+                log.atDebug().kv(SERVICE_NAME, serviceName)\n+                        .log(\"Sending publish event for topic {}\", topic);\n+                if (context instanceof StreamEventPublisher) {\n+                    Future<?> submit = executor.submit(() -> {\n+                        ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message);\n+                    });\n+                    futures.add(submit);\n+                } else if (context instanceof Consumer) {\n+                    Future<?> submit = executor.submit(() -> {\n+                        ((Consumer<PublishEvent>) context).accept(publishedEvent);\n+                    });\n+                    futures.add(submit);\n+                }\n+            });\n+            futures.forEach(future -> {\n+                try {\n+                    future.get();\n+                } catch (InterruptedException | ExecutionException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI1Nzk5Mg=="}, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDI5MDE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxODo1ODoxNFrOHnzq0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxODo1ODoxNFrOHnzq0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwMzA1Ng==", "bodyText": "nit: Handle the subscription request from internal plugin services.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511503056", "createdAt": "2020-10-24T18:58:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDM0Mzc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMDowNjo0OVrOHn0Dxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQwMDowMTowOFrOHn9urg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwOTQ0Nw==", "bodyText": "The synchronization shouldn't occur on the topic. Instead it should be on the subscriber. What needs to happen here is to make sure the subscriber handles the messages in a sequential order. Take a look at this SO post (https://stackoverflow.com/questions/2153663/controlling-task-execution-order-with-executorservice) for some inspiration.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511509447", "createdAt": "2020-10-24T20:06:49Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = new HashSet<>();\n+        listeners.computeIfPresent(topic, (s, objects) -> {\n+            contexts.addAll(listeners.get(topic));\n+            return objects;\n+        });\n+        if (contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        synchronized (listeners.get(topic)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY2Nzg4Ng==", "bodyText": "I have added a new Executors.newSingleThreadExecutor which guarantees order.\nTasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. I think that should suffice.\n\nEdit:\nAdded a new OrderedExecutorService which should address this comment.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511667886", "createdAt": "2020-10-26T00:01:08Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = new HashSet<>();\n+        listeners.computeIfPresent(topic, (s, objects) -> {\n+            contexts.addAll(listeners.get(topic));\n+            return objects;\n+        });\n+        if (contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        synchronized (listeners.get(topic)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwOTQ0Nw=="}, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODM2Mjg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjowNToxNlrOHoW2Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjowNToxNlrOHoW2Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3OTM3MQ==", "bodyText": "You can use injection to make this ordered executor", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512079371", "createdAt": "2020-10-26T16:05:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.OrderedExecutorService;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    private final OrderedExecutorService orderedExecutorService;\n+    private final AuthorizationHandler authorizationHandler;\n+\n+    @Inject\n+    PubSubIPCEventStreamAgent(AuthorizationHandler authorizationHandler, ExecutorService executor) {\n+        this.authorizationHandler = authorizationHandler;\n+        orderedExecutorService = new OrderedExecutorService(executor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "183f99d38881fe1de31941226c2fb120914f1dfd"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODM2OTM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjowNjo0NVrOHoW6Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjowNjo0NVrOHoW6Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MDQyMg==", "bodyText": "add @Inject", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512080422", "createdAt": "2020-10-26T16:06:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "183f99d38881fe1de31941226c2fb120914f1dfd"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODM5NzQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoxMjo0NFrOHoXLAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDoxOToxMVrOHogzWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NDczNw==", "bodyText": "not sure that the sync is needed since you're using concurrent hashmap, as long as you use that correctly this shouldn't be needed. But that's ok I guess", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512084737", "createdAt": "2020-10-26T16:12:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        boolean isFirst = false;\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            if (dependencyQueue == null) {\n+                dependencyQueue = new LinkedBlockingDeque<>();\n+                keyedOrderedTasks.put(key, dependencyQueue);\n+                isFirst = true;\n+            }\n+\n+            orderedTask = wrap(task, dependencyQueue, key);\n+            if (!isFirst) {\n+                dependencyQueue.add(orderedTask);\n+            }\n+        }\n+\n+        // execute method can block, call it outside synchronize block\n+        if (isFirst) {\n+            executor.execute(orderedTask);\n+        }\n+    }\n+\n+    private Runnable wrap(Runnable task, BlockingQueue<Runnable> dependencyQueue, Object key) {\n+        return new OrderedTask(task, dependencyQueue, key);\n+    }\n+\n+    class OrderedTask implements Runnable {\n+        private final BlockingQueue<Runnable> nextOrderedTasksQueue;\n+        private final Runnable task;\n+        private final Object key;\n+\n+        public OrderedTask(Runnable task, BlockingQueue<Runnable> nextOrderedTasksQueue, Object key) {\n+            this.task = task;\n+            this.nextOrderedTasksQueue = nextOrderedTasksQueue;\n+            this.key = key;\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        @Override\n+        public void run() {\n+            try {\n+                task.run();\n+            } catch (Throwable e) {\n+                log.atError().cause(e).log(\"Error executing ordered task for key: {}\", this.key);\n+            } finally {\n+                AtomicReference<Runnable> nextTask = new AtomicReference<>();\n+                synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI0MjUyMA==", "bodyText": "Agree with Michael. Not sure if we need synchronized block here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512242520", "createdAt": "2020-10-26T20:19:11Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        boolean isFirst = false;\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            if (dependencyQueue == null) {\n+                dependencyQueue = new LinkedBlockingDeque<>();\n+                keyedOrderedTasks.put(key, dependencyQueue);\n+                isFirst = true;\n+            }\n+\n+            orderedTask = wrap(task, dependencyQueue, key);\n+            if (!isFirst) {\n+                dependencyQueue.add(orderedTask);\n+            }\n+        }\n+\n+        // execute method can block, call it outside synchronize block\n+        if (isFirst) {\n+            executor.execute(orderedTask);\n+        }\n+    }\n+\n+    private Runnable wrap(Runnable task, BlockingQueue<Runnable> dependencyQueue, Object key) {\n+        return new OrderedTask(task, dependencyQueue, key);\n+    }\n+\n+    class OrderedTask implements Runnable {\n+        private final BlockingQueue<Runnable> nextOrderedTasksQueue;\n+        private final Runnable task;\n+        private final Object key;\n+\n+        public OrderedTask(Runnable task, BlockingQueue<Runnable> nextOrderedTasksQueue, Object key) {\n+            this.task = task;\n+            this.nextOrderedTasksQueue = nextOrderedTasksQueue;\n+            this.key = key;\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        @Override\n+        public void run() {\n+            try {\n+                task.run();\n+            } catch (Throwable e) {\n+                log.atError().cause(e).log(\"Error executing ordered task for key: {}\", this.key);\n+            } finally {\n+                AtomicReference<Runnable> nextTask = new AtomicReference<>();\n+                synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NDczNw=="}, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODU4NTIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjo1MTo0NFrOHoZAsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjo1MTo0NFrOHoZAsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjExNDg2Nw==", "bodyText": "not needed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512114867", "createdAt": "2020-10-26T16:51:44Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        boolean isFirst = false;\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            if (dependencyQueue == null) {\n+                dependencyQueue = new LinkedBlockingDeque<>();\n+                keyedOrderedTasks.put(key, dependencyQueue);\n+                isFirst = true;\n+            }\n+\n+            orderedTask = wrap(task, dependencyQueue, key);\n+            if (!isFirst) {\n+                dependencyQueue.add(orderedTask);\n+            }\n+        }\n+\n+        // execute method can block, call it outside synchronize block\n+        if (isFirst) {\n+            executor.execute(orderedTask);\n+        }\n+    }\n+\n+    private Runnable wrap(Runnable task, BlockingQueue<Runnable> dependencyQueue, Object key) {\n+        return new OrderedTask(task, dependencyQueue, key);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODU5MzMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjo1Mjo1NlrOHoZGUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjo1Mjo1NlrOHoZGUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjExNjMwNw==", "bodyText": "use computeIfAbsent", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512116307", "createdAt": "2020-10-26T16:52:56Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        boolean isFirst = false;\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            if (dependencyQueue == null) {\n+                dependencyQueue = new LinkedBlockingDeque<>();\n+                keyedOrderedTasks.put(key, dependencyQueue);\n+                isFirst = true;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODY0MjcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzowMjo1MFrOHoZlJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo0OTo0NVrOHodwzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNDE5Ng==", "bodyText": "Unit tests for this class are missing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512124196", "createdAt": "2020-10-26T17:02:50Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE0NjU1Mg==", "bodyText": "There are unit tests for this in the PubSubIPCEventStreamAgentTest do I still need to add separate unit tests for this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512146552", "createdAt": "2020-10-26T17:35:48Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNDE5Ng=="}, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5MjcxNg==", "bodyText": "Yes. We should have unit tests in this class and move those cases in PubSubIPCEventStreamAgentTest to here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512192716", "createdAt": "2020-10-26T18:49:45Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNDE5Ng=="}, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODY0ODI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzowNDoxMlrOHoZomg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzowNDoxMlrOHoZomg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNTA4Mg==", "bodyText": "replace nextOrderedTasksQueue with runnables?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512125082", "createdAt": "2020-10-26T17:04:12Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        boolean isFirst = false;\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            if (dependencyQueue == null) {\n+                dependencyQueue = new LinkedBlockingDeque<>();\n+                keyedOrderedTasks.put(key, dependencyQueue);\n+                isFirst = true;\n+            }\n+\n+            orderedTask = wrap(task, dependencyQueue, key);\n+            if (!isFirst) {\n+                dependencyQueue.add(orderedTask);\n+            }\n+        }\n+\n+        // execute method can block, call it outside synchronize block\n+        if (isFirst) {\n+            executor.execute(orderedTask);\n+        }\n+    }\n+\n+    private Runnable wrap(Runnable task, BlockingQueue<Runnable> dependencyQueue, Object key) {\n+        return new OrderedTask(task, dependencyQueue, key);\n+    }\n+\n+    class OrderedTask implements Runnable {\n+        private final BlockingQueue<Runnable> nextOrderedTasksQueue;\n+        private final Runnable task;\n+        private final Object key;\n+\n+        public OrderedTask(Runnable task, BlockingQueue<Runnable> nextOrderedTasksQueue, Object key) {\n+            this.task = task;\n+            this.nextOrderedTasksQueue = nextOrderedTasksQueue;\n+            this.key = key;\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        @Override\n+        public void run() {\n+            try {\n+                task.run();\n+            } catch (Throwable e) {\n+                log.atError().cause(e).log(\"Error executing ordered task for key: {}\", this.key);\n+            } finally {\n+                AtomicReference<Runnable> nextTask = new AtomicReference<>();\n+                synchronized (keyedOrderedTasks) {\n+                    keyedOrderedTasks.computeIfPresent(key, (o, runnables) -> {\n+                        if (runnables.isEmpty()) {\n+                            return null;\n+                        }\n+                        nextTask.set(nextOrderedTasksQueue.poll());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODY2MDI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzowNzowMlrOHoZv-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzozNToxOVrOHoa7Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNjk3MQ==", "bodyText": "Should the key of the orderedTasks be topic?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512126971", "createdAt": "2020-10-26T17:07:02Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.OrderedExecutorService;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    private final OrderedExecutorService orderedExecutorService;\n+    private final AuthorizationHandler authorizationHandler;\n+\n+    @Inject\n+    PubSubIPCEventStreamAgent(AuthorizationHandler authorizationHandler, ExecutorService executor) {\n+        this.authorizationHandler = authorizationHandler;\n+        orderedExecutorService = new OrderedExecutorService(executor);\n+    }\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from internal plugin services.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic for internal plugin services.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = listeners.get(topic);\n+        if (contexts == null || contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+        PublishEvent publishedEvent = PublishEvent.builder().topic(topic).build();\n+        if (jsonMessage.isPresent()) {\n+            JsonMessage message1 = new JsonMessage();\n+            message1.setMessage(jsonMessage.get());\n+            message.setJsonMessage(message1);\n+            try {\n+                publishedEvent.setPayload(SERIALIZER.writeValueAsBytes(jsonMessage.get()));\n+            } catch (JsonProcessingException e) {\n+                log.atError().cause(e).kv(SERVICE_NAME, serviceName)\n+                        .log(\"Unable to serialize JSON message.\");\n+            }\n+        }\n+        if (binaryMessage.isPresent()) {\n+            BinaryMessage binaryMessage1 = new BinaryMessage();\n+            binaryMessage1.setMessage(binaryMessage.get());\n+            message.setBinaryMessage(binaryMessage1);\n+            publishedEvent.setPayload(binaryMessage.get());\n+        }\n+\n+        contexts.forEach(context -> {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"Sending publish event for topic {}\", topic);\n+            if (context instanceof StreamEventPublisher) {\n+                orderedExecutorService.execute(() ->\n+                        ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message),\n+                        topic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE0NjIzOA==", "bodyText": "Updated the key to be the publisher/consumer.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512146238", "createdAt": "2020-10-26T17:35:19Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.OrderedExecutorService;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    private final OrderedExecutorService orderedExecutorService;\n+    private final AuthorizationHandler authorizationHandler;\n+\n+    @Inject\n+    PubSubIPCEventStreamAgent(AuthorizationHandler authorizationHandler, ExecutorService executor) {\n+        this.authorizationHandler = authorizationHandler;\n+        orderedExecutorService = new OrderedExecutorService(executor);\n+    }\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from internal plugin services.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic for internal plugin services.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = listeners.get(topic);\n+        if (contexts == null || contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+        PublishEvent publishedEvent = PublishEvent.builder().topic(topic).build();\n+        if (jsonMessage.isPresent()) {\n+            JsonMessage message1 = new JsonMessage();\n+            message1.setMessage(jsonMessage.get());\n+            message.setJsonMessage(message1);\n+            try {\n+                publishedEvent.setPayload(SERIALIZER.writeValueAsBytes(jsonMessage.get()));\n+            } catch (JsonProcessingException e) {\n+                log.atError().cause(e).kv(SERVICE_NAME, serviceName)\n+                        .log(\"Unable to serialize JSON message.\");\n+            }\n+        }\n+        if (binaryMessage.isPresent()) {\n+            BinaryMessage binaryMessage1 = new BinaryMessage();\n+            binaryMessage1.setMessage(binaryMessage.get());\n+            message.setBinaryMessage(binaryMessage1);\n+            publishedEvent.setPayload(binaryMessage.get());\n+        }\n+\n+        contexts.forEach(context -> {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"Sending publish event for topic {}\", topic);\n+            if (context instanceof StreamEventPublisher) {\n+                orderedExecutorService.execute(() ->\n+                        ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message),\n+                        topic);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNjk3MQ=="}, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTEzOTAzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowNzoxNVrOHoeYUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMToyMDoyNlrOHoi0kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMjgzNQ==", "bodyText": "you shouldn't need to synchronize on it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512202835", "createdAt": "2020-10-26T19:07:15Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNzAwOQ==", "bodyText": "I thought we might have to since there are other places where this object needs to be properly synchronized. If the last task is currently executing and we get another task for the same key, by the time the compute finishes, (where there was a key on line 58) the compute on line 97 might happen and then this task might never get executed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512207009", "createdAt": "2020-10-26T19:14:48Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMjgzNQ=="}, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI0NDQ1MQ==", "bodyText": "Compute isn't async, that's the whole point, is that it will lock internally as needed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512244451", "createdAt": "2020-10-26T20:22:50Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMjgzNQ=="}, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI0NzY5Mw==", "bodyText": "That should be already handled by ConcurrentMap.\nConcurrentMap (https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html):\n As with other concurrent collections, actions in a thread prior to placing an object into a ConcurrentMap as a key or value happen-before actions subsequent to the access or removal of that object from the ConcurrentMap in another thread", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512247693", "createdAt": "2020-10-26T20:29:00Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMjgzNQ=="}, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI0ODM5Mg==", "bodyText": "Right. I know. But lines 63-67 also need to be synchronized along with the compute on line 97. cause we are possibly removing the key from the keyedOrderedTasks", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512248392", "createdAt": "2020-10-26T20:30:09Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMjgzNQ=="}, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1MTc1NQ==", "bodyText": "Use the return value from the compute instead of calling get later, that will be safe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512251755", "createdAt": "2020-10-26T20:36:09Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMjgzNQ=="}, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NTYwMg==", "bodyText": "Tried to make it all run in a compute as well as syncing on just the runnables. But that was causing the unit test to be flaky. Just made the Map into a normal HashMap since we don't need concurrent hash map.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512275602", "createdAt": "2020-10-26T21:20:26Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMjgzNQ=="}, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTE0Mjk0OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/util/OrderedExecutorServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowODoyOFrOHoea3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowODoyOFrOHoea3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMzQ4Ng==", "bodyText": "this doesn't verify anything because it is in a separate thread, so throwing won't fail the test", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512203486", "createdAt": "2020-10-26T19:08:28Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/util/OrderedExecutorServiceTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class OrderedExecutorServiceTest {\n+    private static OrderedExecutorService orderedExecutorService;\n+\n+    @BeforeAll\n+    static void startUp() {\n+        orderedExecutorService = new OrderedExecutorService(Executors.newCachedThreadPool());\n+    }\n+\n+    @Test\n+    void GIVEN_multiple_keys_and_tasks_WHEN_esecute_THEN_executes_in_proper_order_for_each_key()\n+            throws InterruptedException {\n+        String key = UUID.randomUUID().toString();\n+        String key2 = UUID.randomUUID().toString();\n+\n+        Queue<String> queue = new LinkedList<>();\n+        List<Runnable> tasks = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            String randomString = UUID.randomUUID().toString();\n+            queue.add(randomString);\n+            tasks.add(createRunnable(randomString, queue));\n+        }\n+        Queue<String> queue2 = new LinkedList<>();\n+        List<Runnable> tasks2 = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            String randomString = UUID.randomUUID().toString();\n+            queue2.add(randomString);\n+            tasks2.add(createRunnable(randomString, queue2));\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            orderedExecutorService.execute(tasks.get(i), key);\n+            orderedExecutorService.execute(tasks2.get(i), key2);\n+        }\n+        while (!orderedExecutorService.getKeyedOrderedTasks().isEmpty()) {\n+            TimeUnit.SECONDS.sleep(1);\n+        }\n+    }\n+\n+    private Runnable createRunnable(final String randomStringToCheck, final Queue<String> queue){\n+        return () -> {\n+            String firstRandomVarFromQueue = queue.poll();\n+            assertEquals(randomStringToCheck, firstRandomVarFromQueue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTQ1NTg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDozNjo0NFrOHohYyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDozNjo0NFrOHohYyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1MjEwNw==", "bodyText": "why not inside the compute? execute shouldn't be blocking", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512252107", "createdAt": "2020-10-26T20:36:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            keyedOrderedTasks.computeIfAbsent(key, o -> {\n+                isFirst.set(true);\n+                return new LinkedBlockingDeque<>();\n+            });\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            orderedTask = new OrderedTask(task, dependencyQueue, key);\n+            if (!isFirst.get()) {\n+                dependencyQueue.add(orderedTask);\n+            }\n+        }\n+\n+        // execute method can block, call it outside synchronize block\n+        if (isFirst.get()) {\n+            executor.execute(orderedTask);\n+        }\n+    }\n+\n+    class OrderedTask implements Runnable {\n+        private final BlockingQueue<Runnable> runnables;\n+        private final Runnable task;\n+        private final Object key;\n+\n+        public OrderedTask(Runnable task, BlockingQueue<Runnable> runnables, Object key) {\n+            this.task = task;\n+            this.runnables = runnables;\n+            this.key = key;\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        @Override\n+        public void run() {\n+            try {\n+                task.run();\n+            } catch (Throwable e) {\n+                log.atError().cause(e).log(\"Error executing ordered task for key: {}\", this.key);\n+            } finally {\n+                AtomicReference<Runnable> nextTask = new AtomicReference<>();\n+                synchronized (keyedOrderedTasks) {\n+                    keyedOrderedTasks.computeIfPresent(key, (o, runnables) -> {\n+                        if (runnables.isEmpty()) {\n+                            return null;\n+                        }\n+                        nextTask.set(this.runnables.poll());\n+                        return runnables;\n+                    });\n+                }\n+                if (nextTask.get() != null) {\n+                    executor.execute(nextTask.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTYyMDE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMToyNDoxMFrOHoi8JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMToyNDoxMFrOHoi8JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NzU0MQ==", "bodyText": "don't call get. just use the return from the compute", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512277541", "createdAt": "2020-10-26T21:24:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new HashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            keyedOrderedTasks.computeIfAbsent(key, o -> {\n+                isFirst.set(true);\n+                return new LinkedBlockingDeque<>();\n+            });\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41fdea8658d6b903b6cc06a9377104d9bfd6a4ec"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwOTY0Mzc2OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/util/OrderedExecutorServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTozMTozNFrOHojKqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTozMTozNFrOHojKqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTI1Ng==", "bodyText": "use executor.shutdown() and then assertTrue(executor.awaitTermination(1, TimeUnit.Seconds))", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512281256", "createdAt": "2020-10-26T21:31:34Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/util/OrderedExecutorServiceTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class OrderedExecutorServiceTest {\n+    private static OrderedExecutorService orderedExecutorService;\n+    private volatile static Throwable lastThrownException = null;\n+\n+    @BeforeAll\n+    static void startUp() {\n+        orderedExecutorService = new OrderedExecutorService(Executors.newCachedThreadPool());\n+    }\n+\n+    @Test\n+    void GIVEN_multiple_keys_and_tasks_WHEN_esecute_THEN_executes_in_proper_order_for_each_key()\n+            throws InterruptedException {\n+        String key = UUID.randomUUID().toString();\n+        String key2 = UUID.randomUUID().toString();\n+\n+        Queue<String> queue = new LinkedList<>();\n+        List<Runnable> tasks = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            String randomString = UUID.randomUUID().toString();\n+            queue.add(randomString);\n+            tasks.add(createRunnable(randomString, queue));\n+        }\n+        Queue<String> queue2 = new LinkedList<>();\n+        List<Runnable> tasks2 = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            String randomString = UUID.randomUUID().toString();\n+            queue2.add(randomString);\n+            tasks2.add(createRunnable(randomString, queue2));\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            orderedExecutorService.execute(tasks.get(i), key);\n+            orderedExecutorService.execute(tasks2.get(i), key2);\n+        }\n+        while (!orderedExecutorService.getKeyedOrderedTasks().isEmpty()) {\n+            TimeUnit.SECONDS.sleep(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bacee5b2fd3f54911e6feda2314287b9f03c6f8"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 635, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}