{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExNjkyNjQ4", "number": 577, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOTo0MDoyOVrOEy-Nbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoyMTowOVrOEy_F7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODgzNTAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOTo0MDoyOVrOHp6iqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoxOTo0MVrOHp74Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxMjgxMA==", "bodyText": "More specific exception we can use?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/577#discussion_r513712810", "createdAt": "2020-10-28T19:40:29Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -87,65 +87,71 @@\n         this.config = config;\n     }\n \n+    @SuppressWarnings(\"PMD.AvoidCatchingGenericException\")\n     @Override\n     public void startup() {\n-        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n-            greengrassCoreIPCService.setOperationHandler(operation,\n+        try {\n+            greengrassCoreIPCService.getAllOperations().forEach(operation ->\n+                    greengrassCoreIPCService.setOperationHandler(operation,\n                     (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n-                            .getOperationModelContext(operation), context));\n-        });\n-        greengrassCoreIPCService.setAuthenticationHandler(\n-                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(bytes));\n-        greengrassCoreIPCService.setAuthorizationHandler(\n-                authenticationData -> ipcAuthorizationHandler(authenticationData));\n-\n-        socketOptions = new SocketOptions();\n-        socketOptions.connectTimeoutMs = 3000;\n-        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n-        socketOptions.type = SocketOptions.SocketType.STREAM;\n-        eventLoopGroup = new EventLoopGroup(1);\n-        ipcServerSocketAbsolutePath = kernel.getNucleusPaths().rootPath()\n-                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n-\n-        if (Files.exists(Paths.get(ipcServerSocketAbsolutePath))) {\n-            try {\n-                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n-                Files.delete(Paths.get(ipcServerSocketAbsolutePath));\n-            } catch (IOException e) {\n-                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+                            .getOperationModelContext(operation), context)));\n+            greengrassCoreIPCService.setAuthenticationHandler((List<Header> headers, byte[] bytes) ->\n+                    ipcAuthenticationHandler(bytes));\n+            greengrassCoreIPCService.setAuthorizationHandler(authenticationData ->\n+                    ipcAuthorizationHandler(authenticationData));\n+\n+            socketOptions = new SocketOptions();\n+            socketOptions.connectTimeoutMs = 3000;\n+            socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+            socketOptions.type = SocketOptions.SocketType.STREAM;\n+            eventLoopGroup = new EventLoopGroup(1);\n+            ipcServerSocketAbsolutePath =\n+                    kernel.getNucleusPaths().rootPath().resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+\n+            if (Files.exists(Paths.get(ipcServerSocketAbsolutePath))) {\n+                try {\n+                    logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                    Files.delete(Paths.get(ipcServerSocketAbsolutePath));\n+                } catch (IOException e) {\n+                    logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+                }\n             }\n-        }\n \n-        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n-        kernelUri.withValue(ipcServerSocketAbsolutePath);\n-        Topic kernelRelativeUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE,\n-                NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n-        kernelRelativeUri.withValue(ipcServerSocketAbsolutePath);\n+            Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+            kernelUri.withValue(ipcServerSocketAbsolutePath);\n+            Topic kernelRelativeUri =\n+                    config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n+            kernelRelativeUri.withValue(ipcServerSocketAbsolutePath);\n \n-        boolean symLinkCreated = false;\n+            boolean symLinkCreated = false;\n \n-        try {\n-            // Usually we do not want to write outside of kernel root. Because of socket path length limitations we\n-            // will create a symlink only if needed\n-            if (ipcServerSocketAbsolutePath.length() > UDS_SOCKET_PATH_MAX_LEN) {\n-                Files.createSymbolicLink(Paths.get(NUCLEUS_ROOT_PATH_SYMLINK), kernel.getNucleusPaths().rootPath());\n-                kernelRelativeUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE,\n-                        NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n-                kernelRelativeUri.withValue(IPC_SERVER_DOMAIN_SOCKET_RELATIVE_FILENAME);\n-                symLinkCreated = true;\n+            try {\n+                // Usually we do not want to write outside of kernel root. Because of socket path length limitations we\n+                // will create a symlink only if needed\n+                if (ipcServerSocketAbsolutePath.length() > UDS_SOCKET_PATH_MAX_LEN) {\n+                    Files.createSymbolicLink(Paths.get(NUCLEUS_ROOT_PATH_SYMLINK), kernel.getNucleusPaths().rootPath());\n+                    kernelRelativeUri = config.getRoot()\n+                            .lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n+                    kernelRelativeUri.withValue(IPC_SERVER_DOMAIN_SOCKET_RELATIVE_FILENAME);\n+                    symLinkCreated = true;\n+                }\n+\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Cannot setup symlinks for the ipc server socket path\");\n             }\n \n-        } catch (IOException e) {\n-            logger.atError().setCause(e).log(\"Cannot setup symlinks for the ipc server socket path\");\n+            // For domain sockets:\n+            // 1. Port number is ignored. IpcServer does not accept a null value so we are using a default value.\n+            // 2. The hostname parameter expects the socket filepath\n+            ipcServer = new IpcServer(eventLoopGroup, socketOptions, null,\n+                    symLinkCreated ? IPC_SERVER_DOMAIN_SOCKET_FILENAME_SYMLINK : ipcServerSocketAbsolutePath,\n+                    DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+            ipcServer.runServer();\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c33872a6b43d71b81fd002d1865e3d1885b34039"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxNjY0NQ==", "bodyText": "I don't want to be specific, since it could be anything and I want to be sure that we always close the ELG no matter what.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/577#discussion_r513716645", "createdAt": "2020-10-28T19:47:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -87,65 +87,71 @@\n         this.config = config;\n     }\n \n+    @SuppressWarnings(\"PMD.AvoidCatchingGenericException\")\n     @Override\n     public void startup() {\n-        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n-            greengrassCoreIPCService.setOperationHandler(operation,\n+        try {\n+            greengrassCoreIPCService.getAllOperations().forEach(operation ->\n+                    greengrassCoreIPCService.setOperationHandler(operation,\n                     (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n-                            .getOperationModelContext(operation), context));\n-        });\n-        greengrassCoreIPCService.setAuthenticationHandler(\n-                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(bytes));\n-        greengrassCoreIPCService.setAuthorizationHandler(\n-                authenticationData -> ipcAuthorizationHandler(authenticationData));\n-\n-        socketOptions = new SocketOptions();\n-        socketOptions.connectTimeoutMs = 3000;\n-        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n-        socketOptions.type = SocketOptions.SocketType.STREAM;\n-        eventLoopGroup = new EventLoopGroup(1);\n-        ipcServerSocketAbsolutePath = kernel.getNucleusPaths().rootPath()\n-                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n-\n-        if (Files.exists(Paths.get(ipcServerSocketAbsolutePath))) {\n-            try {\n-                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n-                Files.delete(Paths.get(ipcServerSocketAbsolutePath));\n-            } catch (IOException e) {\n-                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+                            .getOperationModelContext(operation), context)));\n+            greengrassCoreIPCService.setAuthenticationHandler((List<Header> headers, byte[] bytes) ->\n+                    ipcAuthenticationHandler(bytes));\n+            greengrassCoreIPCService.setAuthorizationHandler(authenticationData ->\n+                    ipcAuthorizationHandler(authenticationData));\n+\n+            socketOptions = new SocketOptions();\n+            socketOptions.connectTimeoutMs = 3000;\n+            socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+            socketOptions.type = SocketOptions.SocketType.STREAM;\n+            eventLoopGroup = new EventLoopGroup(1);\n+            ipcServerSocketAbsolutePath =\n+                    kernel.getNucleusPaths().rootPath().resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+\n+            if (Files.exists(Paths.get(ipcServerSocketAbsolutePath))) {\n+                try {\n+                    logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                    Files.delete(Paths.get(ipcServerSocketAbsolutePath));\n+                } catch (IOException e) {\n+                    logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+                }\n             }\n-        }\n \n-        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n-        kernelUri.withValue(ipcServerSocketAbsolutePath);\n-        Topic kernelRelativeUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE,\n-                NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n-        kernelRelativeUri.withValue(ipcServerSocketAbsolutePath);\n+            Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+            kernelUri.withValue(ipcServerSocketAbsolutePath);\n+            Topic kernelRelativeUri =\n+                    config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n+            kernelRelativeUri.withValue(ipcServerSocketAbsolutePath);\n \n-        boolean symLinkCreated = false;\n+            boolean symLinkCreated = false;\n \n-        try {\n-            // Usually we do not want to write outside of kernel root. Because of socket path length limitations we\n-            // will create a symlink only if needed\n-            if (ipcServerSocketAbsolutePath.length() > UDS_SOCKET_PATH_MAX_LEN) {\n-                Files.createSymbolicLink(Paths.get(NUCLEUS_ROOT_PATH_SYMLINK), kernel.getNucleusPaths().rootPath());\n-                kernelRelativeUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE,\n-                        NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n-                kernelRelativeUri.withValue(IPC_SERVER_DOMAIN_SOCKET_RELATIVE_FILENAME);\n-                symLinkCreated = true;\n+            try {\n+                // Usually we do not want to write outside of kernel root. Because of socket path length limitations we\n+                // will create a symlink only if needed\n+                if (ipcServerSocketAbsolutePath.length() > UDS_SOCKET_PATH_MAX_LEN) {\n+                    Files.createSymbolicLink(Paths.get(NUCLEUS_ROOT_PATH_SYMLINK), kernel.getNucleusPaths().rootPath());\n+                    kernelRelativeUri = config.getRoot()\n+                            .lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n+                    kernelRelativeUri.withValue(IPC_SERVER_DOMAIN_SOCKET_RELATIVE_FILENAME);\n+                    symLinkCreated = true;\n+                }\n+\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Cannot setup symlinks for the ipc server socket path\");\n             }\n \n-        } catch (IOException e) {\n-            logger.atError().setCause(e).log(\"Cannot setup symlinks for the ipc server socket path\");\n+            // For domain sockets:\n+            // 1. Port number is ignored. IpcServer does not accept a null value so we are using a default value.\n+            // 2. The hostname parameter expects the socket filepath\n+            ipcServer = new IpcServer(eventLoopGroup, socketOptions, null,\n+                    symLinkCreated ? IPC_SERVER_DOMAIN_SOCKET_FILENAME_SYMLINK : ipcServerSocketAbsolutePath,\n+                    DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+            ipcServer.runServer();\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxMjgxMA=="}, "originalCommit": {"oid": "c33872a6b43d71b81fd002d1865e3d1885b34039"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMzQyMg==", "bodyText": "Why not just catch Throwable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/577#discussion_r513733422", "createdAt": "2020-10-28T20:17:22Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -87,65 +87,71 @@\n         this.config = config;\n     }\n \n+    @SuppressWarnings(\"PMD.AvoidCatchingGenericException\")\n     @Override\n     public void startup() {\n-        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n-            greengrassCoreIPCService.setOperationHandler(operation,\n+        try {\n+            greengrassCoreIPCService.getAllOperations().forEach(operation ->\n+                    greengrassCoreIPCService.setOperationHandler(operation,\n                     (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n-                            .getOperationModelContext(operation), context));\n-        });\n-        greengrassCoreIPCService.setAuthenticationHandler(\n-                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(bytes));\n-        greengrassCoreIPCService.setAuthorizationHandler(\n-                authenticationData -> ipcAuthorizationHandler(authenticationData));\n-\n-        socketOptions = new SocketOptions();\n-        socketOptions.connectTimeoutMs = 3000;\n-        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n-        socketOptions.type = SocketOptions.SocketType.STREAM;\n-        eventLoopGroup = new EventLoopGroup(1);\n-        ipcServerSocketAbsolutePath = kernel.getNucleusPaths().rootPath()\n-                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n-\n-        if (Files.exists(Paths.get(ipcServerSocketAbsolutePath))) {\n-            try {\n-                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n-                Files.delete(Paths.get(ipcServerSocketAbsolutePath));\n-            } catch (IOException e) {\n-                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+                            .getOperationModelContext(operation), context)));\n+            greengrassCoreIPCService.setAuthenticationHandler((List<Header> headers, byte[] bytes) ->\n+                    ipcAuthenticationHandler(bytes));\n+            greengrassCoreIPCService.setAuthorizationHandler(authenticationData ->\n+                    ipcAuthorizationHandler(authenticationData));\n+\n+            socketOptions = new SocketOptions();\n+            socketOptions.connectTimeoutMs = 3000;\n+            socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+            socketOptions.type = SocketOptions.SocketType.STREAM;\n+            eventLoopGroup = new EventLoopGroup(1);\n+            ipcServerSocketAbsolutePath =\n+                    kernel.getNucleusPaths().rootPath().resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+\n+            if (Files.exists(Paths.get(ipcServerSocketAbsolutePath))) {\n+                try {\n+                    logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                    Files.delete(Paths.get(ipcServerSocketAbsolutePath));\n+                } catch (IOException e) {\n+                    logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+                }\n             }\n-        }\n \n-        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n-        kernelUri.withValue(ipcServerSocketAbsolutePath);\n-        Topic kernelRelativeUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE,\n-                NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n-        kernelRelativeUri.withValue(ipcServerSocketAbsolutePath);\n+            Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+            kernelUri.withValue(ipcServerSocketAbsolutePath);\n+            Topic kernelRelativeUri =\n+                    config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n+            kernelRelativeUri.withValue(ipcServerSocketAbsolutePath);\n \n-        boolean symLinkCreated = false;\n+            boolean symLinkCreated = false;\n \n-        try {\n-            // Usually we do not want to write outside of kernel root. Because of socket path length limitations we\n-            // will create a symlink only if needed\n-            if (ipcServerSocketAbsolutePath.length() > UDS_SOCKET_PATH_MAX_LEN) {\n-                Files.createSymbolicLink(Paths.get(NUCLEUS_ROOT_PATH_SYMLINK), kernel.getNucleusPaths().rootPath());\n-                kernelRelativeUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE,\n-                        NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n-                kernelRelativeUri.withValue(IPC_SERVER_DOMAIN_SOCKET_RELATIVE_FILENAME);\n-                symLinkCreated = true;\n+            try {\n+                // Usually we do not want to write outside of kernel root. Because of socket path length limitations we\n+                // will create a symlink only if needed\n+                if (ipcServerSocketAbsolutePath.length() > UDS_SOCKET_PATH_MAX_LEN) {\n+                    Files.createSymbolicLink(Paths.get(NUCLEUS_ROOT_PATH_SYMLINK), kernel.getNucleusPaths().rootPath());\n+                    kernelRelativeUri = config.getRoot()\n+                            .lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n+                    kernelRelativeUri.withValue(IPC_SERVER_DOMAIN_SOCKET_RELATIVE_FILENAME);\n+                    symLinkCreated = true;\n+                }\n+\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Cannot setup symlinks for the ipc server socket path\");\n             }\n \n-        } catch (IOException e) {\n-            logger.atError().setCause(e).log(\"Cannot setup symlinks for the ipc server socket path\");\n+            // For domain sockets:\n+            // 1. Port number is ignored. IpcServer does not accept a null value so we are using a default value.\n+            // 2. The hostname parameter expects the socket filepath\n+            ipcServer = new IpcServer(eventLoopGroup, socketOptions, null,\n+                    symLinkCreated ? IPC_SERVER_DOMAIN_SOCKET_FILENAME_SYMLINK : ipcServerSocketAbsolutePath,\n+                    DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+            ipcServer.runServer();\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxMjgxMA=="}, "originalCommit": {"oid": "c33872a6b43d71b81fd002d1865e3d1885b34039"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczNDY3MQ==", "bodyText": "I can't rethrow throwable without declaring it. RuntimeException should be fine", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/577#discussion_r513734671", "createdAt": "2020-10-28T20:19:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -87,65 +87,71 @@\n         this.config = config;\n     }\n \n+    @SuppressWarnings(\"PMD.AvoidCatchingGenericException\")\n     @Override\n     public void startup() {\n-        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n-            greengrassCoreIPCService.setOperationHandler(operation,\n+        try {\n+            greengrassCoreIPCService.getAllOperations().forEach(operation ->\n+                    greengrassCoreIPCService.setOperationHandler(operation,\n                     (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n-                            .getOperationModelContext(operation), context));\n-        });\n-        greengrassCoreIPCService.setAuthenticationHandler(\n-                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(bytes));\n-        greengrassCoreIPCService.setAuthorizationHandler(\n-                authenticationData -> ipcAuthorizationHandler(authenticationData));\n-\n-        socketOptions = new SocketOptions();\n-        socketOptions.connectTimeoutMs = 3000;\n-        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n-        socketOptions.type = SocketOptions.SocketType.STREAM;\n-        eventLoopGroup = new EventLoopGroup(1);\n-        ipcServerSocketAbsolutePath = kernel.getNucleusPaths().rootPath()\n-                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n-\n-        if (Files.exists(Paths.get(ipcServerSocketAbsolutePath))) {\n-            try {\n-                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n-                Files.delete(Paths.get(ipcServerSocketAbsolutePath));\n-            } catch (IOException e) {\n-                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+                            .getOperationModelContext(operation), context)));\n+            greengrassCoreIPCService.setAuthenticationHandler((List<Header> headers, byte[] bytes) ->\n+                    ipcAuthenticationHandler(bytes));\n+            greengrassCoreIPCService.setAuthorizationHandler(authenticationData ->\n+                    ipcAuthorizationHandler(authenticationData));\n+\n+            socketOptions = new SocketOptions();\n+            socketOptions.connectTimeoutMs = 3000;\n+            socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+            socketOptions.type = SocketOptions.SocketType.STREAM;\n+            eventLoopGroup = new EventLoopGroup(1);\n+            ipcServerSocketAbsolutePath =\n+                    kernel.getNucleusPaths().rootPath().resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+\n+            if (Files.exists(Paths.get(ipcServerSocketAbsolutePath))) {\n+                try {\n+                    logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                    Files.delete(Paths.get(ipcServerSocketAbsolutePath));\n+                } catch (IOException e) {\n+                    logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+                }\n             }\n-        }\n \n-        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n-        kernelUri.withValue(ipcServerSocketAbsolutePath);\n-        Topic kernelRelativeUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE,\n-                NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n-        kernelRelativeUri.withValue(ipcServerSocketAbsolutePath);\n+            Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+            kernelUri.withValue(ipcServerSocketAbsolutePath);\n+            Topic kernelRelativeUri =\n+                    config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n+            kernelRelativeUri.withValue(ipcServerSocketAbsolutePath);\n \n-        boolean symLinkCreated = false;\n+            boolean symLinkCreated = false;\n \n-        try {\n-            // Usually we do not want to write outside of kernel root. Because of socket path length limitations we\n-            // will create a symlink only if needed\n-            if (ipcServerSocketAbsolutePath.length() > UDS_SOCKET_PATH_MAX_LEN) {\n-                Files.createSymbolicLink(Paths.get(NUCLEUS_ROOT_PATH_SYMLINK), kernel.getNucleusPaths().rootPath());\n-                kernelRelativeUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE,\n-                        NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n-                kernelRelativeUri.withValue(IPC_SERVER_DOMAIN_SOCKET_RELATIVE_FILENAME);\n-                symLinkCreated = true;\n+            try {\n+                // Usually we do not want to write outside of kernel root. Because of socket path length limitations we\n+                // will create a symlink only if needed\n+                if (ipcServerSocketAbsolutePath.length() > UDS_SOCKET_PATH_MAX_LEN) {\n+                    Files.createSymbolicLink(Paths.get(NUCLEUS_ROOT_PATH_SYMLINK), kernel.getNucleusPaths().rootPath());\n+                    kernelRelativeUri = config.getRoot()\n+                            .lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH_FOR_COMPONENT);\n+                    kernelRelativeUri.withValue(IPC_SERVER_DOMAIN_SOCKET_RELATIVE_FILENAME);\n+                    symLinkCreated = true;\n+                }\n+\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Cannot setup symlinks for the ipc server socket path\");\n             }\n \n-        } catch (IOException e) {\n-            logger.atError().setCause(e).log(\"Cannot setup symlinks for the ipc server socket path\");\n+            // For domain sockets:\n+            // 1. Port number is ignored. IpcServer does not accept a null value so we are using a default value.\n+            // 2. The hostname parameter expects the socket filepath\n+            ipcServer = new IpcServer(eventLoopGroup, socketOptions, null,\n+                    symLinkCreated ? IPC_SERVER_DOMAIN_SOCKET_FILENAME_SYMLINK : ipcServerSocketAbsolutePath,\n+                    DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+            ipcServer.runServer();\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcxMjgxMA=="}, "originalCommit": {"oid": "c33872a6b43d71b81fd002d1865e3d1885b34039"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODg4NDUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/iot/IotConnectionManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOTo1NDoyMVrOHp7BOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOTo1NToxMVrOHp7DLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyMDYzNQ==", "bodyText": "Shouldn't the order of closure be reverse?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/577#discussion_r513720635", "createdAt": "2020-10-28T19:54:21Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/iot/IotConnectionManager.java", "diffHunk": "@@ -49,11 +49,21 @@\n      * @param deviceConfiguration Device configuration helper getting cert and keys for mTLS\n      */\n     @Inject\n+    @SuppressWarnings(\"PMD.AvoidCatchingGenericException\")\n     public IotConnectionManager(final DeviceConfiguration deviceConfiguration) {\n         eventLoopGroup = new EventLoopGroup(1);\n         resolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-        this.connManager = initConnectionManager(deviceConfiguration);\n+        try {\n+            this.connManager = initConnectionManager(deviceConfiguration);\n+        } catch (RuntimeException e) {\n+            // If we couldn't initialize the connection manager, then make sure to shutdown\n+            // everything which was started up\n+            eventLoopGroup.close();\n+            resolver.close();\n+            clientBootstrap.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "282f3f261d010c9af63cc903a067d3fa2b53b2b8"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyMTEzNQ==", "bodyText": "Updated", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/577#discussion_r513721135", "createdAt": "2020-10-28T19:55:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/iot/IotConnectionManager.java", "diffHunk": "@@ -49,11 +49,21 @@\n      * @param deviceConfiguration Device configuration helper getting cert and keys for mTLS\n      */\n     @Inject\n+    @SuppressWarnings(\"PMD.AvoidCatchingGenericException\")\n     public IotConnectionManager(final DeviceConfiguration deviceConfiguration) {\n         eventLoopGroup = new EventLoopGroup(1);\n         resolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-        this.connManager = initConnectionManager(deviceConfiguration);\n+        try {\n+            this.connManager = initConnectionManager(deviceConfiguration);\n+        } catch (RuntimeException e) {\n+            // If we couldn't initialize the connection manager, then make sure to shutdown\n+            // everything which was started up\n+            eventLoopGroup.close();\n+            resolver.close();\n+            clientBootstrap.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzcyMDYzNQ=="}, "originalCommit": {"oid": "282f3f261d010c9af63cc903a067d3fa2b53b2b8"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODk3OTY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/iot/IotConnectionManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoyMTowOVrOHp77OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMDoyNDo0M1rOHp8CgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczNTQ4MA==", "bodyText": "try-with-resources on these three Autocloseable objects will cleanly close everything", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/577#discussion_r513735480", "createdAt": "2020-10-28T20:21:09Z", "author": {"login": "DavidOgunsAWS"}, "path": "src/main/java/com/aws/greengrass/iot/IotConnectionManager.java", "diffHunk": "@@ -49,11 +49,21 @@\n      * @param deviceConfiguration Device configuration helper getting cert and keys for mTLS\n      */\n     @Inject\n+    @SuppressWarnings(\"PMD.AvoidCatchingGenericException\")\n     public IotConnectionManager(final DeviceConfiguration deviceConfiguration) {\n         eventLoopGroup = new EventLoopGroup(1);\n         resolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-        this.connManager = initConnectionManager(deviceConfiguration);\n+        try {\n+            this.connManager = initConnectionManager(deviceConfiguration);\n+        } catch (RuntimeException e) {\n+            // If we couldn't initialize the connection manager, then make sure to shutdown\n+            // everything which was started up\n+            clientBootstrap.close();\n+            resolver.close();\n+            eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e207aad7db6891778c419da492f6a93e5d7dcd58"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczNzM0NQ==", "bodyText": "We can't do that because they need to stay open for the life of this object. We can't just close them in the constructor.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/577#discussion_r513737345", "createdAt": "2020-10-28T20:24:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/iot/IotConnectionManager.java", "diffHunk": "@@ -49,11 +49,21 @@\n      * @param deviceConfiguration Device configuration helper getting cert and keys for mTLS\n      */\n     @Inject\n+    @SuppressWarnings(\"PMD.AvoidCatchingGenericException\")\n     public IotConnectionManager(final DeviceConfiguration deviceConfiguration) {\n         eventLoopGroup = new EventLoopGroup(1);\n         resolver = new HostResolver(eventLoopGroup);\n         clientBootstrap = new ClientBootstrap(eventLoopGroup, resolver);\n-        this.connManager = initConnectionManager(deviceConfiguration);\n+        try {\n+            this.connManager = initConnectionManager(deviceConfiguration);\n+        } catch (RuntimeException e) {\n+            // If we couldn't initialize the connection manager, then make sure to shutdown\n+            // everything which was started up\n+            clientBootstrap.close();\n+            resolver.close();\n+            eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczNTQ4MA=="}, "originalCommit": {"oid": "e207aad7db6891778c419da492f6a93e5d7dcd58"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 402, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}