{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMTg0NDY3", "number": 222, "title": "Config store IPC server-side", "bodyText": "Issue #, if available:\nDescription of changes:\nServer-side implementation for the ConfigStore IPC (aws-greengrass/aws-greengrass-logging-java#35).\nThis PR implements the server with 1 operation: subscribe. Upon subscription the initial state is immediately sent to the client and then any subsequent changes are also sent. A service can only subscribe to its own custom config.\nWhy is this change necessary:\nHow was this change tested:\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-05-04T21:05:17Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222", "merged": true, "mergeCommit": {"oid": "993a6c8e8e928b9379c47e30dadcf0156f68e5ce"}, "closed": true, "closedAt": "2020-05-07T02:08:51Z", "author": {"login": "MikeDombo"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceGEGRgBqjMzMDE3MTcwMzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcezBbsAH2gAyNDEzMTg0NDY3OjNhYzBiNGZiYzk0ZWZkZmMyYjgxYTI0ZDdhN2Q2ODZlZWM5ZDMxODU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ae075fa40150803293f2bcd927bbdc147b5a5a3", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1ae075fa40150803293f2bcd927bbdc147b5a5a3", "committedDate": "2020-05-04T21:03:13Z", "message": "Config store IPC"}, "afterCommit": {"oid": "840107cdf5df20f77156ddb995445d2fbae3e062", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/840107cdf5df20f77156ddb995445d2fbae3e062", "committedDate": "2020-05-04T21:07:35Z", "message": "Config store IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "840107cdf5df20f77156ddb995445d2fbae3e062", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/840107cdf5df20f77156ddb995445d2fbae3e062", "committedDate": "2020-05-04T21:07:35Z", "message": "Config store IPC"}, "afterCommit": {"oid": "a8aa6c95835d363cce4d94f152256a9051538edc", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a8aa6c95835d363cce4d94f152256a9051538edc", "committedDate": "2020-05-04T21:44:27Z", "message": "Config store IPC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MzY1NzAz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-405365703", "createdAt": "2020-05-04T21:36:11Z", "commit": {"oid": "840107cdf5df20f77156ddb995445d2fbae3e062"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTozNjoxMVrOGQTHzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMjowODoxM1rOGQUARA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MzY5NQ==", "bodyText": "Are we sending the entire custom config to listeners on every change?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419743695", "createdAt": "2020-05-04T21:36:11Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigValueChangedEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> listeners = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "840107cdf5df20f77156ddb995445d2fbae3e062"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0NDkxMQ==", "bodyText": "I'd prefer this under EvergreenService class's static method", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419744911", "createdAt": "2020-05-04T21:38:48Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Node.java", "diffHunk": "@@ -153,6 +157,35 @@ public boolean childOf(String n) {\n         return n.equals(name) || parent != null && parent.childOf(n);\n     }\n \n+    /**\n+     * Get path of parents.\n+     *\n+     * @return list of strings with index 0 being the current node's name\n+     */\n+    public List<String> path() {\n+        ArrayList<String> parents = new ArrayList<>();\n+        parents.add(name);\n+\n+        if (parent != null) {\n+            parents.addAll(parent.path());\n+        }\n+        return parents;\n+    }\n+\n+    /**\n+     * Find the service that this node belongs to (or null if it is not under a service).\n+     *\n+     * @return service name or null\n+     */\n+    public String findService() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "840107cdf5df20f77156ddb995445d2fbae3e062"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MzU4Mw==", "bodyText": "If we are always completing the future before returning, what's the point of using Future?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419753583", "createdAt": "2020-05-04T21:57:25Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.aws.iot.evergreen.ipc.modules;\n+\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader.Message;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreClientOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+//TODO: see if this needs to be a GGService\n+@ImplementsService(name = \"configstoreipc\", autostart = true)\n+public class ConfigStoreIPCService extends EvergreenService {\n+    private static final ObjectMapper CBOR_MAPPER = new CBORMapper();\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent agent;\n+\n+    public ConfigStoreIPCService(Topics c) {\n+        super(c);\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.CONFIG_STORE;\n+        super.postInject();\n+        try {\n+            router.registerServiceCallback(destination.getValue(), this::handleMessage);\n+            logger.atInfo().setEventType(\"ipc-register-request-handler\").addKeyValue(\"destination\", destination.name())\n+                    .log();\n+        } catch (IPCException e) {\n+            logger.atError().setEventType(\"ipc-register-request-handler-error\").setCause(e)\n+                    .addKeyValue(\"destination\", destination.name())\n+                    .log(\"Failed to register service callback to destination\");\n+        }\n+    }\n+\n+    /**\n+     * Handle all requests from the client.\n+     *\n+     * @param message the incoming request\n+     * @param context caller request context\n+     * @return future containing our response\n+     */\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+    public Future<Message> handleMessage(Message message, ConnectionContext context) {\n+        CompletableFuture<Message> fut = new CompletableFuture<>();\n+\n+        ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n+        try {\n+            //TODO: add version compatibility check\n+            ConfigStoreClientOpCodes opCode = ConfigStoreClientOpCodes.values()[applicationMessage.getOpCode()];\n+            ConfigStoreGenericResponse configStoreGenericResponse = new ConfigStoreGenericResponse();\n+            if (ConfigStoreClientOpCodes.SUBSCRIBE_ALL.equals(opCode)) {\n+                configStoreGenericResponse = agent.subscribe(context);\n+            } else {\n+                configStoreGenericResponse.setStatus(ConfigStoreResponseStatus.InvalidRequest);\n+                configStoreGenericResponse.setErrorMessage(\"Unknown request type \" + opCode.toString());\n+            }\n+\n+            ApplicationMessage responseMessage = ApplicationMessage.builder().version(applicationMessage.getVersion())\n+                    .payload(CBOR_MAPPER.writeValueAsBytes(configStoreGenericResponse)).build();\n+            fut.complete(new Message(responseMessage.toByteArray()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8aa6c95835d363cce4d94f152256a9051538edc"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1ODE0OA==", "bodyText": "can this be in AfterEach?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419758148", "createdAt": "2020-05-04T22:08:13Z", "author": {"login": "ShirleyZheng92"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -186,4 +198,53 @@ void lifecycleTest(ExtensionContext context) throws Exception {\n         ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n         client.disconnect();\n     }\n+\n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_THEN_initial_state_sent(ExtensionContext context) throws Exception {\n+        KernelIPCClientConfig config = KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.findServiceTopic(\"ServiceName\").findLeafChild(SERVICE_UNIQUE_ID_KEY).getOnce())\n+                .build();\n+        IPCClient client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<Map<String, Object>>> p = TestUtils.asyncAssertOnConsumer((a) -> {\n+            assertThat(a, anEmptyMap());\n+        });\n+\n+        c.subscribe(p.getRight());\n+        p.getLeft().get(500, TimeUnit.MILLISECONDS);\n+        client.disconnect();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8aa6c95835d363cce4d94f152256a9051538edc"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1Mzg1NTQx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-405385541", "createdAt": "2020-05-04T22:14:23Z", "commit": {"oid": "a8aa6c95835d363cce4d94f152256a9051538edc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMjoxNDoyM1rOGQUKWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMjoxNDoyM1rOGQUKWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2MDcyOA==", "bodyText": "NIT: can you add comment on this function?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419760728", "createdAt": "2020-05-04T22:14:23Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/testcommons/testutilities/TestUtils.java", "diffHunk": "@@ -35,12 +36,21 @@ private TestUtils() {\n     }\n \n     public static <A> Pair<CompletableFuture<Void>, Consumer<A>> asyncAssertOnConsumer(Consumer<A> c) {\n+        return asyncAssertOnConsumer(c, 1);\n+    }\n+\n+    public static <A> Pair<CompletableFuture<Void>, Consumer<A>> asyncAssertOnConsumer(Consumer<A> c, int numCalls) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8aa6c95835d363cce4d94f152256a9051538edc"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDE3MzIx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-405417321", "createdAt": "2020-05-04T23:36:09Z", "commit": {"oid": "a8aa6c95835d363cce4d94f152256a9051538edc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzozNjowOVrOGQV5kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzozNjowOVrOGQV5kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4OTIwMQ==", "bodyText": "Nit- Should this have State in the name?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r419789201", "createdAt": "2020-05-04T23:36:09Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigValueChangedEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = node.findService();\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+        // Ensure that the node which changed was part of the custom config\n+        if (node.path().lastIndexOf(EvergreenService.CUSTOM_CONFIG_NAMESPACE) < 0) {\n+            return;\n+        }\n+\n+        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n+                .map(Map.Entry::getValue).forEach(c -> c.accept(\n+                kernel.findServiceTopic(serviceName).createInteriorChild(EvergreenService.CUSTOM_CONFIG_NAMESPACE)\n+                        .toPOJO()));\n+    };\n+\n+    @Override\n+    public void postInject() {\n+        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> listeners.remove(context));\n+            return sendStateUpdateToListener(context);\n+        });\n+\n+        // Immediately send the current state\n+        listeners.get(context).accept(kernel.findServiceTopic(context.getServiceName())\n+                .createInteriorChild(EvergreenService.CUSTOM_CONFIG_NAMESPACE).toPOJO());\n+\n+        return ConfigStoreGenericResponse.builder().status(ConfigStoreResponseStatus.Success).build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendStateUpdateToListener(ConnectionContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8aa6c95835d363cce4d94f152256a9051538edc"}, "originalPosition": 92}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9de4a7e7575fed5b5fd8455753a0d8bd368ef624", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9de4a7e7575fed5b5fd8455753a0d8bd368ef624", "committedDate": "2020-05-05T19:04:31Z", "message": "Config store IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a8aa6c95835d363cce4d94f152256a9051538edc", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a8aa6c95835d363cce4d94f152256a9051538edc", "committedDate": "2020-05-04T21:44:27Z", "message": "Config store IPC"}, "afterCommit": {"oid": "26715fc2eab5da4762eba0cfe5a3876b97fe299d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/26715fc2eab5da4762eba0cfe5a3876b97fe299d", "committedDate": "2020-05-05T22:58:50Z", "message": "Add read() for Config IPC and update subscribe"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "26715fc2eab5da4762eba0cfe5a3876b97fe299d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/26715fc2eab5da4762eba0cfe5a3876b97fe299d", "committedDate": "2020-05-05T22:58:50Z", "message": "Add read() for Config IPC and update subscribe"}, "afterCommit": {"oid": "7ca54f3651f8da32c546e2ecca7738136c64f58e", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7ca54f3651f8da32c546e2ecca7738136c64f58e", "committedDate": "2020-05-05T23:05:02Z", "message": "Add read() for Config IPC and update subscribe"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7ca54f3651f8da32c546e2ecca7738136c64f58e", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7ca54f3651f8da32c546e2ecca7738136c64f58e", "committedDate": "2020-05-05T23:05:02Z", "message": "Add read() for Config IPC and update subscribe"}, "afterCommit": {"oid": "5391dd6d8b43e9f17e89711663471314bfa3f346", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5391dd6d8b43e9f17e89711663471314bfa3f346", "committedDate": "2020-05-05T23:16:47Z", "message": "Add read() for Config IPC and update subscribe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "committedDate": "2020-05-05T23:26:55Z", "message": "Add read() for Config IPC and update subscribe"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5391dd6d8b43e9f17e89711663471314bfa3f346", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5391dd6d8b43e9f17e89711663471314bfa3f346", "committedDate": "2020-05-05T23:16:47Z", "message": "Add read() for Config IPC and update subscribe"}, "afterCommit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ac9f547c918f3dd6942a1bdcd5c33f77893e94e6", "committedDate": "2020-05-05T23:26:55Z", "message": "Add read() for Config IPC and update subscribe"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NzgxMTMx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-406781131", "createdAt": "2020-05-06T16:24:43Z", "commit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Nzg4MjI2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-406788226", "createdAt": "2020-05-06T16:33:11Z", "commit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjozMzoxMlrOGRbe7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjozMzoxMlrOGRbe7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyOTI2Mw==", "bodyText": "Is this a temporary change?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r420929263", "createdAt": "2020-05-06T16:33:12Z", "author": {"login": "shaguptashaikh"}, "path": "pom.xml", "diffHunk": "@@ -83,7 +83,7 @@\n         <dependency>\n             <groupId>com.aws.iot</groupId>\n             <artifactId>evergreen-java-sdk</artifactId>\n-            <version>0.0.0-SNAPSHOT</version>\n+            <version>0.0.0-configstore-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Nzk5NTcz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-406799573", "createdAt": "2020-05-06T16:47:20Z", "commit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0NzoyMFrOGRcDZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0NzoyMFrOGRcDZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODU5Ng==", "bodyText": "I've was thinking about where the 'other' type of service runtime config should live, i.e. the one that service reads and writes like a datastore and doesn't change / rollback on deployments. If it lives under the custom namespace then once we introduce removal of config keys in merge, it might get wiped out on deployments because merge might think it was something that existed before but not anymore. It is only somewhat related to this change because depending on where that config lives i.e. under custom key or under a separate key, we will need to adjust this code a little bit too. That is not the scope of this PR though. this code is doing what its supposed to at the moment, but lets discuss the point above soon if it makes sense", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r420938596", "createdAt": "2020-05-06T16:47:20Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigKeyChangedEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.CUSTOM_CONFIG_NAMESPACE;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = Kernel.findServiceForNode(node);\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+\n+        List<String> nodePath = node.path();\n+        // Ensure that the node which changed was part of the custom config\n+        int customConfigIndex = nodePath.lastIndexOf(CUSTOM_CONFIG_NAMESPACE);\n+        // Compare < 1 because we want to capture only changes under the \"custom\" key and not the \"custom\" key itself\n+        if (customConfigIndex < 1) {\n+            return;\n+        }\n+        // Ensure the path is <service_name>.custom.<other stuff>\n+        // path is reversed, so we check serviceNameIndex - 1 == customConfigIndex\n+        int serviceNameIndex = nodePath.lastIndexOf(serviceName);\n+        if (serviceNameIndex < 0 || (serviceNameIndex - 1) != customConfigIndex) {\n+            return;\n+        }\n+\n+        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n+                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath.get(customConfigIndex - 1)));\n+    };\n+\n+    @Override\n+    public void postInject() {\n+        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> listeners.remove(context));\n+            return sendStoreUpdateToListener(context);\n+        });\n+\n+        return new ConfigStoreGenericResponse(ConfigStoreResponseStatus.Success, null);\n+    }\n+\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context) {\n+        return (changedKey) -> {\n+            ConfigKeyChangedEvent valueChangedEvent = ConfigKeyChangedEvent.builder().changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Read specified key from the service's dynamic config.\n+     * @param readRequest read request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC read request\");\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        ConfigStoreReadValueResponse.ConfigStoreReadValueResponseBuilder response =\n+                ConfigStoreReadValueResponse.builder();\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        Topics configTopics = serviceTopic.findInteriorChild(CUSTOM_CONFIG_NAMESPACE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2ODY3OTg4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-406867988", "createdAt": "2020-05-06T18:14:01Z", "commit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoxNDowMVrOGRfc-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoxNDowMVrOGRfc-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5NDI5Nw==", "bodyText": "NIT: getting path can be a one-time computation", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r420994297", "createdAt": "2020-05-06T18:14:01Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Node.java", "diffHunk": "@@ -153,6 +155,21 @@ public boolean childOf(String n) {\n         return n.equals(name) || parent != null && parent.childOf(n);\n     }\n \n+    /**\n+     * Get path of parents.\n+     *\n+     * @return list of strings with index 0 being the current node's name\n+     */\n+    public List<String> path() {\n+        ArrayList<String> parents = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2ODc0OTg5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-406874989", "createdAt": "2020-05-06T18:23:41Z", "commit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoyMzo0MlrOGRfzkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoyMzo0MlrOGRfzkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMDA4Mg==", "bodyText": "If using lastIndexOf(),  then customer can't have 'custom' keyword in their custom config . Currently our 'custom' keyword is located as 'services.\n<serviceName>.custom' , IMO it's safe to just check\nif ( !'custom'.equals(nodePath[2])) {\nreturn\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421000082", "createdAt": "2020-05-06T18:23:42Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigKeyChangedEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.CUSTOM_CONFIG_NAMESPACE;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = Kernel.findServiceForNode(node);\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+\n+        List<String> nodePath = node.path();\n+        // Ensure that the node which changed was part of the custom config\n+        int customConfigIndex = nodePath.lastIndexOf(CUSTOM_CONFIG_NAMESPACE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2ODc4Mjgx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-406878281", "createdAt": "2020-05-06T18:28:13Z", "commit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODoyODoxM1rOGRf91A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODozMDo1N1rOGRgEdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMjcwOA==", "bodyText": "In current implementation, when a field is removed, this listener will be invoked with (whatHappened.childRemoved, node) parameter, where node is the value before removal . This may cause unintentional behavior here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421002708", "createdAt": "2020-05-06T18:28:13Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigKeyChangedEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.CUSTOM_CONFIG_NAMESPACE;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNDQwNQ==", "bodyText": "If the existing config is custom.foo.bar.zoo and changed to custom.foo.bar.zoo2 , then listener will get the changed key of 'foo' instead of 'foo.bar' ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#discussion_r421004405", "createdAt": "2020-05-06T18:30:57Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.ChildChanged;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigKeyChangedEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreReadValueResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.CUSTOM_CONFIG_NAMESPACE;\n+\n+/**\n+ * Class to handle business logic for all ConfigStore requests over IPC.\n+ */\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = Kernel.findServiceForNode(node);\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+\n+        List<String> nodePath = node.path();\n+        // Ensure that the node which changed was part of the custom config\n+        int customConfigIndex = nodePath.lastIndexOf(CUSTOM_CONFIG_NAMESPACE);\n+        // Compare < 1 because we want to capture only changes under the \"custom\" key and not the \"custom\" key itself\n+        if (customConfigIndex < 1) {\n+            return;\n+        }\n+        // Ensure the path is <service_name>.custom.<other stuff>\n+        // path is reversed, so we check serviceNameIndex - 1 == customConfigIndex\n+        int serviceNameIndex = nodePath.lastIndexOf(serviceName);\n+        if (serviceNameIndex < 0 || (serviceNameIndex - 1) != customConfigIndex) {\n+            return;\n+        }\n+\n+        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n+                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath.get(customConfigIndex - 1)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac9f547c918f3dd6942a1bdcd5c33f77893e94e6"}, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fd611ef2e143a74881dd4e24f41e68149b89f99", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8fd611ef2e143a74881dd4e24f41e68149b89f99", "committedDate": "2020-05-06T19:35:59Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2OTg4MzAy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-406988302", "createdAt": "2020-05-06T21:08:24Z", "commit": {"oid": "8fd611ef2e143a74881dd4e24f41e68149b89f99"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MDkzMTU2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/222#pullrequestreview-407093156", "createdAt": "2020-05-07T01:29:30Z", "commit": {"oid": "8fd611ef2e143a74881dd4e24f41e68149b89f99"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ac0b4fbc94efdfc2b81a24d7a7d686eec9d3185", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3ac0b4fbc94efdfc2b81a24d7a7d686eec9d3185", "committedDate": "2020-05-07T01:30:32Z", "message": "Merge branch 'master' into configstore"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2171, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}