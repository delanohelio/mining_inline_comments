{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MTAwNjc5", "number": 399, "title": "Refactored authorization to take in a parameterized JSON ACL", "bodyText": "Description of changes:\nChanged the AuthorizationHandler and AuthorizationPolicyParser to take in a JSON of ACL values instead of a YAML, in order to pass these in as easily updatable parameters during deployments.\nWhy is this change necessary:\nWe would like ACLs to be dynamically updatable via deployments, instead of needing to restart the kernel for these changes to take effect.\nHow was this change tested:\nUpdated unit and integration tests to match.\nAlso ran the following test command on a local POC to verify that the ACL does indeed update as expected:\ngreengrass-cli component update --merge helloworldpubsub=1.0.0 --param helloworldpubsub.accessControl='{\"aws.greengrass.ipc.pubsub\":[{\"policyId1\":{\"policyDescription\":\"access to pubsub topics\",\"operations\":[\"*\"],\"resources\":[\"test/topic\"]}}]}'`\n\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-08-28T05:32:42Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399", "merged": true, "mergeCommit": {"oid": "e3f2ce18fc2779b7031dfaddb911e0b2af9ed609"}, "closed": true, "closedAt": "2020-09-02T20:59:24Z", "author": {"login": "avipinku"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdDY7pmgFqTQ3NzkyNjU1NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFCanIAFqTQ4MTI5MzkzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTI2NTU1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-477926555", "createdAt": "2020-08-28T18:01:53Z", "commit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowMTo1M1rOHJPvzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowMTo1M1rOHJPvzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NzIzMA==", "bodyText": "I am not sure what would happen if the ACL parameter key itself is removed, like when author deploys a new recipe and removes the parameter config altogether and then deploys. That case is skipped here, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479457230", "createdAt": "2020-08-28T18:01:53Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -72,12 +73,14 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                 false);\n \n         //Subscribe to future auth config updates\n+        //This will bubble up the entire \"accessControl\" topic containing the entire ACL JSON\n         this.kernel.getConfig().getRoot().subscribe(\n                 (why, newv) -> {\n                     if (newv == null) {\n                         return;\n                     }\n-                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                    if (!newv.childOf(PARAMETERS_CONFIG_KEY)\n+                            || !newv.getName().equals(ACCESS_CONTROL_NAMESPACE_TOPIC)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTI4NDkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-477928491", "createdAt": "2020-08-28T18:05:10Z", "commit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowNToxMFrOHJP1cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowNToxMFrOHJP1cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1ODY3NQ==", "bodyText": "Is it a common pattern to pass logger as part of method? Isnt it usually class member?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479458675", "createdAt": "2020-08-28T18:05:10Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -88,11 +91,13 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                     }\n                     Topic updatedTopic = (Topic) newv;\n                     String componentName = findServiceForNode(updatedTopic);\n-                    //If there is a change in a node, reload that one component's ACL\n-                    List<AuthorizationPolicy> updatedComponentPolicies = policyParser\n-                            .parseAuthorizationPolicyList(componentName, updatedTopic, logger);\n-                    this.loadAuthorizationPolicies(updatedTopic.getName(), updatedComponentPolicies, true);\n-\n+                    Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = policyParser\n+                           .parseAllPoliciesForComponent(updatedTopic, componentName, logger);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTMxMzMw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-477931330", "createdAt": "2020-08-28T18:09:58Z", "commit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowOTo1OFrOHJP9-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowOTo1OFrOHJP9-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MDg1Nw==", "bodyText": "This is not a warn, and as auth we dont care about it really. lets make it info, same for below.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479460857", "createdAt": "2020-08-28T18:09:58Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTMzNTgw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-477933580", "createdAt": "2020-08-28T18:13:46Z", "commit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoxMzo0NlrOHJQExg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoxMzo0NlrOHJQExg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjU5OA==", "bodyText": "You dont need to do getOnce(), coerce does that. right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479462598", "createdAt": "2020-08-28T18:13:46Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atWarn(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName, logger);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+                    //If multiple components have policies for the same policy type\n+                    if (masterAuthorizationPolicyMap.containsKey(policyType)) {\n+                        masterAuthorizationPolicyMap.get(policyTypeList.getKey()).addAll(policyList);\n+                    } else {\n+                        masterAuthorizationPolicyMap.put(policyType, policyList);\n+                    }\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                               String componentName, Logger logger) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic.getOnce());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTM1NzUy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-477935752", "createdAt": "2020-08-28T18:17:27Z", "commit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoxNzoyN1rOHJQLkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoxNzoyN1rOHJQLkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2NDMzOA==", "bodyText": "Being empty is not invalid, that should not be warn.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479464338", "createdAt": "2020-08-28T18:17:27Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atWarn(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName, logger);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+                    //If multiple components have policies for the same policy type\n+                    if (masterAuthorizationPolicyMap.containsKey(policyType)) {\n+                        masterAuthorizationPolicyMap.get(policyTypeList.getKey()).addAll(policyList);\n+                    } else {\n+                        masterAuthorizationPolicyMap.put(policyType, policyList);\n+                    }\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                               String componentName, Logger logger) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic.getOnce());\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {\n+\n+            String policyType = Coerce.toString(accessControlType.getKey());\n+            Object accessControlTopicObject = accessControlType.getValue();\n+\n+            if (!(accessControlTopicObject instanceof List)\n+                    || Utils.isEmpty((List) accessControlTopicObject)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTMzMTc0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-477933174", "createdAt": "2020-08-28T18:13:03Z", "commit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoxMzowM1rOHJQDig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoxMzowM1rOHJQDig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjI4Mg==", "bodyText": "Have you tested if \"parameters\" or \"accessControl\" node is removed? Will that fall into this if statement?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479462282", "createdAt": "2020-08-28T18:13:03Z", "author": {"login": "youtuyy"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -72,12 +73,14 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                 false);\n \n         //Subscribe to future auth config updates\n+        //This will bubble up the entire \"accessControl\" topic containing the entire ACL JSON\n         this.kernel.getConfig().getRoot().subscribe(\n                 (why, newv) -> {\n                     if (newv == null) {\n                         return;\n                     }\n-                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                    if (!newv.childOf(PARAMETERS_CONFIG_KEY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDA0NTQ1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-478004545", "createdAt": "2020-08-28T20:22:44Z", "commit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMDoyMjo0NFrOHJTcVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMDoyMjo0NFrOHJTcVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzc4MQ==", "bodyText": "why?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479517781", "createdAt": "2020-08-28T20:22:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDA0OTEw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-478004910", "createdAt": "2020-08-28T20:23:31Z", "commit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMDoyMzozMVrOHJTdcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMDoyMzozMVrOHJTdcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxODA2NA==", "bodyText": "put this in a try-finally, and remove the listener in the finally", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479518064", "createdAt": "2020-08-28T20:23:31Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -158,8 +176,15 @@ public void GIVEN_invalid_pubsub_yaml_file_with_invalid_fields_WHEN_auth_parsing\n             assertNotNull(inputStream);\n             config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n \n-            //TODO: this no longer throws an exception; we need to parse the log to check the behavior\n+            logReceived = new CountDownLatch(1);\n+            logListener = m -> {\n+                if (\"load-authorization-config-unknown-policy-key\".equals(m.getEventType())) {\n+                    logReceived.countDown();\n+                }\n+            };\n+            Slf4jLogAdapter.addGlobalListener(logListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 75}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e635263b98f8b7855d95b8bb685b8e5cf28379f3", "committedDate": "2020-08-28T04:14:19Z", "message": "Refactored authorization to take in a parameterized JSON ACL"}, "afterCommit": {"oid": "645f32f6407553d6b0b8c875d0c6c76d7c77aa8a", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/645f32f6407553d6b0b8c875d0c6c76d7c77aa8a", "committedDate": "2020-08-29T00:44:11Z", "message": "Responded to feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "645f32f6407553d6b0b8c875d0c6c76d7c77aa8a", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/645f32f6407553d6b0b8c875d0c6c76d7c77aa8a", "committedDate": "2020-08-29T00:44:11Z", "message": "Responded to feedback"}, "afterCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "committedDate": "2020-08-29T00:57:13Z", "message": "Responded to feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODE2NjEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-478816613", "createdAt": "2020-08-31T17:47:14Z", "commit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0NzoxNFrOHKCc4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0OTo1M1rOHKCiZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA==", "bodyText": "why are we logging the exception? It should probably only be returned to the user, maybe with a warning or info as well.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480287968", "createdAt": "2020-08-31T17:47:14Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODA5MQ==", "bodyText": "this won't do anything; you've already ignored it on L157.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480288091", "createdAt": "2020-08-31T17:47:31Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODE0MA==", "bodyText": "same", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480288140", "createdAt": "2020-08-31T17:47:37Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8)));\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_parameters_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        if (parameters != null) {\n+            parameters.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4OTM4MA==", "bodyText": "this isn't possible", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480289380", "createdAt": "2020-08-31T17:49:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,35 +24,145 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atInfo(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 73}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7", "committedDate": "2020-08-29T00:57:13Z", "message": "Responded to feedback"}, "afterCommit": {"oid": "ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4", "committedDate": "2020-08-31T20:18:32Z", "message": "Minor cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMDQ5ODI1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-480049825", "createdAt": "2020-09-01T19:24:57Z", "commit": {"oid": "ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxOToyNDo1N1rOHLFDCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxOToyNDo1N1rOHLFDCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3OTA4Mg==", "bodyText": "Let's also remove \"unsubscribe\" while you are here. We can remove it from the list of operations we add to auth handler.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481379082", "createdAt": "2020-09-01T19:24:57Z", "author": {"login": "prateek-y"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/ipc/pubsub_unauthorized_publish.yaml", "diffHunk": "@@ -24,14 +24,7 @@ services:\n           powershell -command sleep 100\n         posix:\n           sleep 100\n-    accessControl:\n-      aws.greengrass.ipc.pubsub:\n-        - policyId1:\n-            policyDescription: \"access to pubsub topics\"\n-            operations:\n-              - \"subscribe\"\n-              - \"unsubscribe\"\n-            resources:\n-              - \"/topic/1/#\"\n-              - \"/longer/topic/example/\"\n-              - \"*\"\n+    parameters:\n+      accessControl:\n+        '{\"aws.greengrass.ipc.pubsub\":[{\"policyId1\":{\"policyDescription\":\"access to pubsub topics\",\"operations\":[\"subscribe\",\"unsubscribe\"],\"resources\":[\"/topic/1/#\",\"/longer/topic/example/\",\"*\"]}}]}'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4", "committedDate": "2020-08-31T20:18:32Z", "message": "Minor cleanup"}, "afterCommit": {"oid": "d253092d449a841b242526f9537068ddcca48547", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d253092d449a841b242526f9537068ddcca48547", "committedDate": "2020-09-01T21:54:22Z", "message": "Responded to feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5afa632b4a4e62aa996ad547f12da1456a1af733", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5afa632b4a4e62aa996ad547f12da1456a1af733", "committedDate": "2020-09-01T22:07:43Z", "message": "Removed pub/sub support for unsubscribe operation"}, "afterCommit": {"oid": "7765270bfa21f1fb5ee1e92f92d3e86749d6fd2e", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7765270bfa21f1fb5ee1e92f92d3e86749d6fd2e", "committedDate": "2020-09-01T22:09:16Z", "message": "Removed pub/sub support for unsubscribe operation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "de7f1788b8682d04c2802e70b4b168c0997b1ba9", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/de7f1788b8682d04c2802e70b4b168c0997b1ba9", "committedDate": "2020-09-01T22:34:18Z", "message": "Integration test fix"}, "afterCommit": {"oid": "b9ee6ffbbd6d4a5de952e547d5bced5cc237bb7b", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b9ee6ffbbd6d4a5de952e547d5bced5cc237bb7b", "committedDate": "2020-09-01T22:49:49Z", "message": "Integration test fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "committedDate": "2020-09-02T02:02:36Z", "message": "Refactored authorization to take in a parameterized JSON ACL"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9ee6ffbbd6d4a5de952e547d5bced5cc237bb7b", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b9ee6ffbbd6d4a5de952e547d5bced5cc237bb7b", "committedDate": "2020-09-01T22:49:49Z", "message": "Integration test fix"}, "afterCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3db175983ddf858190d4bf5c9bf55ee97cc04e5d", "committedDate": "2020-09-02T02:02:36Z", "message": "Refactored authorization to take in a parameterized JSON ACL"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNTAzNjQx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-480503641", "createdAt": "2020-09-02T05:56:52Z", "commit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNTo1Njo1M1rOHLbxJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowODoyMlrOHLceew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA==", "bodyText": "can we get rid of the sleep? Random sleeps are incredibly suspect", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481751334", "createdAt": "2020-09-02T05:56:53Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -119,13 +111,72 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n \n         //Reload the kernel with the correct authorization policy\n         kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n-        Thread.sleep(500);\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTgwNA==", "bodyText": "Since you changed it, you should be able to remove the ignore now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481751804", "createdAt": "2020-09-02T05:57:20Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzUyNg==", "bodyText": "do not log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481753526", "createdAt": "2020-09-02T05:58:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzY1NQ==", "bodyText": "do not log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481753655", "createdAt": "2020-09-02T05:59:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NDQwNg==", "bodyText": "use Kernel.findServiceForNode instead of getting the name like that. Just in case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481754406", "createdAt": "2020-09-02T05:59:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NTIzMA==", "bodyText": "simplify to serviceConfig.find(PARAMETERS_CONFIG_KEY, ACCESS_CONTROL_NAMESPACE_TOPIC) which will return null if either is null", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481755230", "createdAt": "2020-09-02T06:00:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NzEyNA==", "bodyText": "Provide the generics: Map.Entry<String, Object>", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481757124", "createdAt": "2020-09-02T06:02:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+\n+                    //If multiple components have policies for the same policy type\n+                    masterAuthorizationPolicyMap.computeIfAbsent(policyType, k -> new ArrayList<>()).addAll(policyList);\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    private Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                                String componentName) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic);\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1Nzg3OQ==", "bodyText": "you don't need to coerce to string, it is already a string. This will be fixed if you use the generic as I suggest above.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481757879", "createdAt": "2020-09-02T06:03:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+\n+                    //If multiple components have policies for the same policy type\n+                    masterAuthorizationPolicyMap.computeIfAbsent(policyType, k -> new ArrayList<>()).addAll(policyList);\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    private Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                                String componentName) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic);\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {\n+\n+            String policyType = Coerce.toString(accessControlType.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1OTA4NQ==", "bodyText": "don't bother with the cause, we know what causes authz exceptions. You can just log the exception message. (e.getmessage()I mean)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481759085", "createdAt": "2020-09-02T06:04:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -126,21 +127,30 @@ public void postInject() {\n             ApplicationMessage responseMessage = ApplicationMessage.builder().version(applicationMessage.getVersion())\n                     .payload(CBOR_MAPPER.writeValueAsBytes(pubSubGenericResponse)).build();\n             fut.complete(new Message(responseMessage.toByteArray()));\n+        } catch (AuthorizationException e) {\n+            logger.atWarn().setEventType(\"pubsub-authorization-error\").setCause(e).log(\"Unauthorized request\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MDQwNQ==", "bodyText": "try (InputStream inputStream = getClass().getResourceAsStream(filename)) { ... }", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481760405", "createdAt": "2020-09-02T06:05:46Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MTkzNQ==", "bodyText": "not needed. You already do this with @Mock", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481761935", "createdAt": "2020-09-02T06:07:23Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);\n+        Topics allServices = mock(Topics.class);\n+        it = mock(Iterator.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ==", "bodyText": "You have both real and mocked configs?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481762939", "createdAt": "2020-09-02T06:08:22Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 91}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a06f01904d48b500c11f08874c81c16a941088e", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0a06f01904d48b500c11f08874c81c16a941088e", "committedDate": "2020-09-02T17:59:12Z", "message": "Cleaned up according to feedback"}, "afterCommit": {"oid": "b04ba917f0dd346057454e07dc06fe95ff4f3856", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b04ba917f0dd346057454e07dc06fe95ff4f3856", "committedDate": "2020-09-02T19:17:38Z", "message": "Cleaned up according to feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb841218b544be7d0d65ce0e6a9479742039d5dc", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eb841218b544be7d0d65ce0e6a9479742039d5dc", "committedDate": "2020-09-02T19:53:01Z", "message": "Responded to feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b04ba917f0dd346057454e07dc06fe95ff4f3856", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b04ba917f0dd346057454e07dc06fe95ff4f3856", "committedDate": "2020-09-02T19:17:38Z", "message": "Cleaned up according to feedback"}, "afterCommit": {"oid": "eb841218b544be7d0d65ce0e6a9479742039d5dc", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eb841218b544be7d0d65ce0e6a9479742039d5dc", "committedDate": "2020-09-02T19:53:01Z", "message": "Responded to feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjg4NjU0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-481288654", "createdAt": "2020-09-02T20:48:59Z", "commit": {"oid": "eb841218b544be7d0d65ce0e6a9479742039d5dc"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo0ODo1OVrOHMGMUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo0ODo1OVrOHMGMUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ0NjQxNg==", "bodyText": "technically, the nullcheck is included here, so you can remove L59", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482446416", "createdAt": "2020-09-02T20:48:59Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,165 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb841218b544be7d0d65ce0e6a9479742039d5dc"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjkzOTM1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#pullrequestreview-481293935", "createdAt": "2020-09-02T20:55:44Z", "commit": {"oid": "eb841218b544be7d0d65ce0e6a9479742039d5dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3227, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}