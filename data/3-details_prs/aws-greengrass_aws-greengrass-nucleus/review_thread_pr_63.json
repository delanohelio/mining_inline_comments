{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1NTY5OTc3", "number": 63, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMjo0NjozMVrODgCdeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMjowNjowNlrODgg3Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0OTIxMzM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMjo0NjozMVrOFqFvEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMjo0NjozMVrOFqFvEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY3ODQ4MQ==", "bodyText": "Why not move Set to a field 'onDisconnectTasks' in ConnectionContext object?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/63#discussion_r379678481", "createdAt": "2020-02-14T22:46:31Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "diffHunk": "@@ -34,8 +34,7 @@\n \n     private final Map<Integer, IPCCallback> destinationCallbackMap = new ConcurrentHashMap<>();\n     private final Map<ConnectionContext, Channel> clientToChannelMap = new ConcurrentHashMap<>();\n-    private final Map<ConnectionContext, List<Consumer<ConnectionContext>>> clientToDisconnectorsMap =\n-            new ConcurrentHashMap<>();\n+    private final Map<ConnectionContext, Set<Runnable>> clientToDisconnectorsMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0c46a9b0e08c286da959bf5dbb4a168c2c7c2cf"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDE5NDUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMjowNjowNlrOFqwkKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMjowNjowNlrOFqwkKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4MDIwMg==", "bodyText": "NIT: You can add context.onDisconnect(clientToChannelMap.onDisconnect(context));", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/63#discussion_r380380202", "createdAt": "2020-02-17T22:06:06Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "diffHunk": "@@ -68,79 +63,59 @@ public IPCCallback getCallbackForDestination(int destination) {\n     }\n \n     /**\n-     * Tries to get a connection handle from a context. The connection handle can be used to send\n-     * requests to the client and then wait for a response.\n+     * Send a message to a connection's destination and get a future for the response message.\n      *\n-     * @param connectionContext  The request context of the client that you want the handle to.\n-     * @param disconnectCallback Function to be called when the client disconnects. Use for cleaning up\n-     *                           extra listeners.\n-     * @return\n+     * @param connection  connection to send the message to\n+     * @param destination destination within the context to target\n+     * @param msg         message to be send\n+     * @return future containing response message or exception\n      */\n-    @Nullable\n-    public ConnectionHandle getConnectionHandle(ConnectionContext connectionContext,\n-                                                Consumer<ConnectionContext> disconnectCallback) {\n-        Channel channel = clientToChannelMap.get(connectionContext);\n+    public Future<FrameReader.Message> sendAndReceive(ConnectionContext connection, int destination,\n+                                                      FrameReader.Message msg) {\n+        CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+\n+        Channel channel = clientToChannelMap.get(connection);\n         if (channel == null) {\n-            return null;\n+            fut.completeExceptionally(new IPCException(\"Channel not found for given connection context\"));\n+            return fut;\n         }\n \n-        clientToDisconnectorsMap.compute(connectionContext, (key, value) -> {\n-            if (value == null) {\n-                value = new ArrayList<>();\n-            }\n-            value.add(disconnectCallback);\n-            return value;\n-        });\n-\n-        return (destination, message) -> {\n-            FrameReader.MessageFrame requestFrame =\n-                    new FrameReader.MessageFrame(destination, message, FrameReader.FrameType.REQUEST);\n+        FrameReader.MessageFrame requestFrame =\n+                new FrameReader.MessageFrame(destination, msg, FrameReader.FrameType.REQUEST);\n+        requestIdToCallbackMap.put(new ClientAndRequestId(requestFrame.requestId, connection), fut);\n \n-            CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n-            requestIdToCallbackMap\n-                    .put(new ClientAndRequestId(requestFrame.requestId, connectionContext), fut);\n-\n-            channel.writeAndFlush(requestFrame);\n-\n-            return fut;\n-        };\n+        channel.writeAndFlush(requestFrame);\n+        return fut;\n     }\n \n     /**\n-     * Only called by MessageRouter, do not call in any other place.\n      * Called when a client disconnects from the server.\n      *\n      * @param context client which disconnected's context\n      */\n-    public void clientDisconnected(ConnectionContext context) {\n+    void clientDisconnected(ConnectionContext context) {\n         clientToChannelMap.remove(context);\n-        List<Consumer<ConnectionContext>> disconnectors = clientToDisconnectorsMap.remove(context);\n-        if (disconnectors != null) {\n-            disconnectors.forEach(d -> d.accept(context));\n-        }\n     }\n \n     /**\n-     * Only called by MessageRouter, do not call in any other place.\n      * Called when a client first authenticates successfully.\n      *\n      * @param context the context for the client that just connected\n      * @param channel the channel to talk to the client\n      */\n-    public void clientConnected(ConnectionContext context, Channel channel) {\n+    void clientConnected(ConnectionContext context, Channel channel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67d8099357664a2848948c17f4ef51287b1a9e67"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 89, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}