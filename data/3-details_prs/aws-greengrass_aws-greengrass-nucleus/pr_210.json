{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MDc0MDY3", "number": 210, "title": "Encapsulate recipe CRUD in PackageStore", "bodyText": "Issue #, if available:\nDescription of changes:\nPart 2 of #201\n\n\nAdding new PackageStore with CRUD, file name and folder handling logic, including:\n\ncreatePackageRecipe\nfindPackageRecipe\ngetPackageRecipe\ngetPackageMetadata\nlistAvailablePackageMetadata\nresolveArtifactDirectoryPath\nand other additional methods.\n\n\n\nRe-wrote the unit test to always start with a new and clean package store by creating a temp folder. It pre loads files from its test resource folder if it needs to mock some recipe/artifact.\nIt doesn't use or assume any static folder directly as package store. The package store folder is deleted after each test.\n\n\nAs the first iteration, it has some basic exception handling structure. More refinement is added as TODO for now.\n\n\nWhy is this change necessary:\nAbout the test, before we were using either working directory or some test resource folder as package store directly. Tests not only assume the folder structure, but also may mutate files/folders during the test. Tests were also not independent because of a shared and mutable folder.\nHow was this change tested:\nmvn clean verify\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-04-23T17:41:55Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210", "merged": true, "mergeCommit": {"oid": "867743475b8892150dd04bd99f8109c22c11d1e7"}, "closed": true, "closedAt": "2020-04-27T20:09:00Z", "author": {"login": "leaf94"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcagI8vgH2gAyNDA4MDc0MDY3OmY2YjY0MTA3ZDAwNjQ5MGMxMjliOGQ4ZGY5ZDg4ZWM3NzQwYjRkZjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcb01ONAFqTQwMTI3ODQzMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f6b64107d006490c129b8d8df9d88ec7740b4df3", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f6b64107d006490c129b8d8df9d88ec7740b4df3", "committedDate": "2020-04-23T17:14:51Z", "message": "Implement PackageStore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa96f07584959ae6429866b5b27b6c2c179578af", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fa96f07584959ae6429866b5b27b6c2c179578af", "committedDate": "2020-04-23T17:25:32Z", "message": "Implement PackageStore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3baa86269b0ee9fcddcb13839c27738ace8ee2bf", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3baa86269b0ee9fcddcb13839c27738ace8ee2bf", "committedDate": "2020-04-23T17:32:46Z", "message": "Implement PackageStore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/091066d97955d68b49c8cf7334958eda6fae157e", "committedDate": "2020-04-23T17:43:34Z", "message": "small typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MzM0NDk1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#pullrequestreview-399334495", "createdAt": "2020-04-23T17:45:41Z", "commit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzo0NTo0MlrOGK0dNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxODowOToyMlrOGK1cJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5ODM4OA==", "bodyText": "rename: savePackageRecipe. I'd expect that create would return me a PackageRecipe.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r413998388", "createdAt": "2020-04-23T17:45:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void createPackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAwNjYwNg==", "bodyText": "we have .yaml in many places throughout the codebase, can we extract that out to a shared const please?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414006606", "createdAt": "2020-04-23T17:57:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void createPackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     */\n+    List<PackageMetadata> listAvailablePackageMetadata(final String packageName, Requirement requirement)\n+            throws PackagingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        Arrays.sort(recipeFiles);\n+\n+        List<PackageMetadata> packageMetadataList = new ArrayList<>();\n+\n+        for (File recipeFile : recipeFiles) {\n+            String recipePackageName = parsePackageNameFromFileName(recipeFile.getName());\n+            // Only check the recipes for the package that we're looking for\n+            if (!recipePackageName.equalsIgnoreCase(packageName)) {\n+                continue;\n+            }\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+            if (requirement.isSatisfiedBy(version)) {\n+                packageMetadataList.add(getPackageMetadata(new PackageIdentifier(packageName, version)));\n+            }\n+        }\n+\n+        return packageMetadataList;\n+    }\n+\n+\n+    /**\n+     * Resolve the artifact directory path for a target package id.\n+     *\n+     * @param packageIdentifier packageIdentifier\n+     * @return the artifact directory path for target package.\n+     */\n+    Path resolveArtifactDirectoryPath(PackageIdentifier packageIdentifier) {\n+        return artifactDirectory.resolve(packageIdentifier.getName())\n+                .resolve(packageIdentifier.getVersion().getValue());\n+    }\n+\n+    private Path resolveRecipePath(String packageName, Semver packageVersion) {\n+        return recipeDirectory.resolve(String.format(RECIPE_FILE_NAME_FORMAT, packageName, packageVersion.getValue()));\n+    }\n+\n+    private static String parsePackageNameFromFileName(String filename) {\n+        // TODO validate filename\n+\n+        // MonitoringService-1.0.0.yaml\n+        String suffix = \".yaml\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxMzgxOA==", "bodyText": "nit\nblank line at end.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414013818", "createdAt": "2020-04-23T18:08:23Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.collection.IsIterableWithSize.iterableWithSize;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsEqual.equalTo;\n+import static org.hamcrest.io.FileMatchers.anExistingDirectory;\n+import static org.hamcrest.io.FileMatchers.anExistingFile;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Every test in PackageStoreTest start with a new and clean package store by creating a temp folder. It pre loads\n+ * files from its test resource folder if it needs to mock some recipe/artifact. It doesn't and shouldn't use or assume\n+ * any static folder directly as package store. The package store folder is deleted after each test.\n+ */\n+@ExtendWith({EGExtension.class})\n+class PackageStoreTest {\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private static final String MONITORING_SERVICE_PKG_NAME = \"MonitoringService\";\n+    private static final Semver MONITORING_SERVICE_PKG_VERSION = new Semver(\"1.0.0\", Semver.SemverType.NPM);\n+    private static final PackageIdentifier MONITORING_SERVICE_PKG_ID =\n+            new PackageIdentifier(MONITORING_SERVICE_PKG_NAME, MONITORING_SERVICE_PKG_VERSION);\n+\n+\n+    private static final Path RECIPE_RESOURCE_PATH = Paths.get(PackageStoreTest.class.getResource(\"recipe\").getPath());\n+\n+    private PackageStore packageStore;\n+\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @TempDir\n+    Path packageStoreRootPath;\n+\n+    @BeforeEach\n+    void beforeEach() throws PackagingException {\n+        packageStore = new PackageStore(packageStoreRootPath.toAbsolutePath());\n+        recipeDirectory = packageStoreRootPath.resolve(\"recipe\");\n+        artifactDirectory = packageStoreRootPath.resolve(\"artifact\");\n+    }\n+\n+    @Test\n+    void WHEN_PackageStore_is_initialized_THEN_recipe_and_artifact_folders_created() {\n+        assertThat(recipeDirectory.toFile(), anExistingDirectory());\n+        assertThat(artifactDirectory.toFile(), anExistingDirectory());\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_not_exists_when_createPackageRecipe_THEN_recipe_file_created()\n+            throws IOException, PackageLoadingException {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+        PackageRecipe recipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+\n+\n+        File expectedRecipeFile = recipeDirectory.resolve(fileName).toFile();\n+        assertThat(expectedRecipeFile, not(anExistingFile()));\n+\n+        // WHEN\n+        packageStore.createPackageRecipe(recipe);\n+\n+        // THEN\n+        assertThat(expectedRecipeFile, anExistingFile());\n+        String fileContent = new String(Files.readAllBytes(expectedRecipeFile.toPath()));\n+        assertThat(fileContent, is(equalTo(RECIPE_SERIALIZER.writeValueAsString(recipe))));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_findPackageRecipe_THEN_return_it() throws Exception {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        // WHEN\n+        Optional<PackageRecipe> optionalPackageRecipe = packageStore.findPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertTrue(optionalPackageRecipe.isPresent());\n+\n+        PackageRecipe expectedRecipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+        assertThat(optionalPackageRecipe.get(), equalTo(expectedRecipe));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_does_not_exist_WHEN_findPackageRecipe_THEN_empty_is_returned() throws Exception {\n+        // WHEN\n+        Optional<PackageRecipe> optionalPackageRecipe = packageStore.findPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertFalse(optionalPackageRecipe.isPresent());\n+    }\n+\n+    @Test\n+    void GIVEN_an_invalid_recipe_exists_WHEN_findPackageRecipe_THEN_loading_exception_is_thrown() throws Exception {\n+        // GIVEN\n+        String fileName = \"InvalidRecipe-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        // THEN\n+        assertThrows(PackageLoadingException.class,\n+                () -> packageStore.findPackageRecipe(new PackageIdentifier(\"InvalidRecipe\", new Semver(\"1.0.0\"))));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_getPackageRecipe_THEN_return_it() throws Exception {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        PackageRecipe packageRecipe = packageStore.getPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        PackageRecipe expectedRecipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+        assertThat(packageRecipe, equalTo(expectedRecipe));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_does_not_exist_WHEN_getPackageRecipe_THEN_loading_exception_is_thrown() throws Exception {\n+        assertThrows(PackageLoadingException.class, () -> packageStore.getPackageRecipe(MONITORING_SERVICE_PKG_ID));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_getPackageMetadata_then_return_it() throws PackagingException, IOException {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        PackageMetadata packageMetadata = packageStore.getPackageMetadata(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertThat(packageMetadata.getPackageIdentifier(), is(MONITORING_SERVICE_PKG_ID));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(MONITORING_SERVICE_PKG_VERSION)));\n+    }\n+\n+    @Test\n+    void GIVEN_pre_loaded_package_versions_WHEN_listAvailablePackageMetadata_THEN_return_satisfiedVersion()\n+            throws IOException, PackagingException {\n+        // GIVEN\n+        preloadRecipeFileFromTestResource(\"MonitoringService-1.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-1.1.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-2.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-3.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"Log-1.0.0.yaml\");\n+\n+        // WHEN\n+        Requirement requirement = Requirement.buildNPM(\">=1.0.0 <2.0.0\");\n+        List<PackageMetadata> packageMetadataList =\n+                packageStore.listAvailablePackageMetadata(MONITORING_SERVICE_PKG_NAME, requirement);\n+\n+        // THEN\n+        // expected return: MonitoringService 1.0.0 and 1.1.0\n+        assertThat(packageMetadataList, iterableWithSize(2));\n+\n+        // 1.0.0\n+        PackageMetadata packageMetadata = packageMetadataList.get(0);\n+        assertThat(packageMetadata.getPackageIdentifier().getName(), is(MONITORING_SERVICE_PKG_NAME));\n+        assertThat(packageMetadata.getPackageIdentifier().getVersion(), is(new Semver(\"1.0.0\")));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(new Semver(\"1.0.0\"))));\n+\n+        // 1.1.0\n+        packageMetadata = packageMetadataList.get(1);\n+        assertThat(packageMetadata.getPackageIdentifier().getName(), is(MONITORING_SERVICE_PKG_NAME));\n+        assertThat(packageMetadata.getPackageIdentifier().getVersion(), is(new Semver(\"1.1.0\")));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(new Semver(\"1.1.0\"))));\n+    }\n+\n+    private void preloadRecipeFileFromTestResource(String fileName) throws IOException {\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        Path destinationRecipe = recipeDirectory.resolve(fileName);\n+\n+        Files.copy(sourceRecipe, destinationRecipe);\n+    }\n+\n+    @Test\n+    void resolveArtifactDirectoryPath() {\n+        Path artifactPath = packageStore.resolveArtifactDirectoryPath(MONITORING_SERVICE_PKG_ID);\n+\n+        Path expectedArtifactPath = artifactDirectory.resolve(MONITORING_SERVICE_PKG_ID.getName())\n+                .resolve(MONITORING_SERVICE_PKG_ID.getVersion().getValue());\n+        assertThat(artifactPath.toAbsolutePath(), is(equalTo(expectedArtifactPath)));\n+\n+    }\n+\n+    private static Map<String, String> getExpectedDependencies(Semver version) {\n+        return new HashMap<String, String>() {{\n+            put(\"Log\", version.toString());\n+            put(\"Cool-Database\", version.toString());\n+        }};\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxNDUwMA==", "bodyText": "test for create when it already exists?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414014500", "createdAt": "2020-04-23T18:09:22Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/PackageStoreTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.collection.IsIterableWithSize.iterableWithSize;\n+import static org.hamcrest.core.Is.is;\n+import static org.hamcrest.core.IsEqual.equalTo;\n+import static org.hamcrest.io.FileMatchers.anExistingDirectory;\n+import static org.hamcrest.io.FileMatchers.anExistingFile;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * Every test in PackageStoreTest start with a new and clean package store by creating a temp folder. It pre loads\n+ * files from its test resource folder if it needs to mock some recipe/artifact. It doesn't and shouldn't use or assume\n+ * any static folder directly as package store. The package store folder is deleted after each test.\n+ */\n+@ExtendWith({EGExtension.class})\n+class PackageStoreTest {\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private static final String MONITORING_SERVICE_PKG_NAME = \"MonitoringService\";\n+    private static final Semver MONITORING_SERVICE_PKG_VERSION = new Semver(\"1.0.0\", Semver.SemverType.NPM);\n+    private static final PackageIdentifier MONITORING_SERVICE_PKG_ID =\n+            new PackageIdentifier(MONITORING_SERVICE_PKG_NAME, MONITORING_SERVICE_PKG_VERSION);\n+\n+\n+    private static final Path RECIPE_RESOURCE_PATH = Paths.get(PackageStoreTest.class.getResource(\"recipe\").getPath());\n+\n+    private PackageStore packageStore;\n+\n+    private Path recipeDirectory;\n+\n+    private Path artifactDirectory;\n+\n+    @TempDir\n+    Path packageStoreRootPath;\n+\n+    @BeforeEach\n+    void beforeEach() throws PackagingException {\n+        packageStore = new PackageStore(packageStoreRootPath.toAbsolutePath());\n+        recipeDirectory = packageStoreRootPath.resolve(\"recipe\");\n+        artifactDirectory = packageStoreRootPath.resolve(\"artifact\");\n+    }\n+\n+    @Test\n+    void WHEN_PackageStore_is_initialized_THEN_recipe_and_artifact_folders_created() {\n+        assertThat(recipeDirectory.toFile(), anExistingDirectory());\n+        assertThat(artifactDirectory.toFile(), anExistingDirectory());\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_not_exists_when_createPackageRecipe_THEN_recipe_file_created()\n+            throws IOException, PackageLoadingException {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+        PackageRecipe recipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+\n+\n+        File expectedRecipeFile = recipeDirectory.resolve(fileName).toFile();\n+        assertThat(expectedRecipeFile, not(anExistingFile()));\n+\n+        // WHEN\n+        packageStore.createPackageRecipe(recipe);\n+\n+        // THEN\n+        assertThat(expectedRecipeFile, anExistingFile());\n+        String fileContent = new String(Files.readAllBytes(expectedRecipeFile.toPath()));\n+        assertThat(fileContent, is(equalTo(RECIPE_SERIALIZER.writeValueAsString(recipe))));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_findPackageRecipe_THEN_return_it() throws Exception {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        // WHEN\n+        Optional<PackageRecipe> optionalPackageRecipe = packageStore.findPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertTrue(optionalPackageRecipe.isPresent());\n+\n+        PackageRecipe expectedRecipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+        assertThat(optionalPackageRecipe.get(), equalTo(expectedRecipe));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_does_not_exist_WHEN_findPackageRecipe_THEN_empty_is_returned() throws Exception {\n+        // WHEN\n+        Optional<PackageRecipe> optionalPackageRecipe = packageStore.findPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertFalse(optionalPackageRecipe.isPresent());\n+    }\n+\n+    @Test\n+    void GIVEN_an_invalid_recipe_exists_WHEN_findPackageRecipe_THEN_loading_exception_is_thrown() throws Exception {\n+        // GIVEN\n+        String fileName = \"InvalidRecipe-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        // THEN\n+        assertThrows(PackageLoadingException.class,\n+                () -> packageStore.findPackageRecipe(new PackageIdentifier(\"InvalidRecipe\", new Semver(\"1.0.0\"))));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_getPackageRecipe_THEN_return_it() throws Exception {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        PackageRecipe packageRecipe = packageStore.getPackageRecipe(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        PackageRecipe expectedRecipe =\n+                RECIPE_SERIALIZER.readValue(new String(Files.readAllBytes(sourceRecipe)), PackageRecipe.class);\n+        assertThat(packageRecipe, equalTo(expectedRecipe));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_does_not_exist_WHEN_getPackageRecipe_THEN_loading_exception_is_thrown() throws Exception {\n+        assertThrows(PackageLoadingException.class, () -> packageStore.getPackageRecipe(MONITORING_SERVICE_PKG_ID));\n+    }\n+\n+    @Test\n+    void GIVEN_a_recipe_exists_WHEN_getPackageMetadata_then_return_it() throws PackagingException, IOException {\n+        // GIVEN\n+        String fileName = \"MonitoringService-1.0.0.yaml\";\n+\n+        preloadRecipeFileFromTestResource(fileName);\n+\n+        // WHEN\n+        PackageMetadata packageMetadata = packageStore.getPackageMetadata(MONITORING_SERVICE_PKG_ID);\n+\n+        // THEN\n+        assertThat(packageMetadata.getPackageIdentifier(), is(MONITORING_SERVICE_PKG_ID));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(MONITORING_SERVICE_PKG_VERSION)));\n+    }\n+\n+    @Test\n+    void GIVEN_pre_loaded_package_versions_WHEN_listAvailablePackageMetadata_THEN_return_satisfiedVersion()\n+            throws IOException, PackagingException {\n+        // GIVEN\n+        preloadRecipeFileFromTestResource(\"MonitoringService-1.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-1.1.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-2.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"MonitoringService-3.0.0.yaml\");\n+        preloadRecipeFileFromTestResource(\"Log-1.0.0.yaml\");\n+\n+        // WHEN\n+        Requirement requirement = Requirement.buildNPM(\">=1.0.0 <2.0.0\");\n+        List<PackageMetadata> packageMetadataList =\n+                packageStore.listAvailablePackageMetadata(MONITORING_SERVICE_PKG_NAME, requirement);\n+\n+        // THEN\n+        // expected return: MonitoringService 1.0.0 and 1.1.0\n+        assertThat(packageMetadataList, iterableWithSize(2));\n+\n+        // 1.0.0\n+        PackageMetadata packageMetadata = packageMetadataList.get(0);\n+        assertThat(packageMetadata.getPackageIdentifier().getName(), is(MONITORING_SERVICE_PKG_NAME));\n+        assertThat(packageMetadata.getPackageIdentifier().getVersion(), is(new Semver(\"1.0.0\")));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(new Semver(\"1.0.0\"))));\n+\n+        // 1.1.0\n+        packageMetadata = packageMetadataList.get(1);\n+        assertThat(packageMetadata.getPackageIdentifier().getName(), is(MONITORING_SERVICE_PKG_NAME));\n+        assertThat(packageMetadata.getPackageIdentifier().getVersion(), is(new Semver(\"1.1.0\")));\n+        assertThat(packageMetadata.getDependencies(), is(getExpectedDependencies(new Semver(\"1.1.0\"))));\n+    }\n+\n+    private void preloadRecipeFileFromTestResource(String fileName) throws IOException {\n+        Path sourceRecipe = RECIPE_RESOURCE_PATH.resolve(fileName);\n+\n+        Path destinationRecipe = recipeDirectory.resolve(fileName);\n+\n+        Files.copy(sourceRecipe, destinationRecipe);\n+    }\n+\n+    @Test\n+    void resolveArtifactDirectoryPath() {\n+        Path artifactPath = packageStore.resolveArtifactDirectoryPath(MONITORING_SERVICE_PKG_ID);\n+\n+        Path expectedArtifactPath = artifactDirectory.resolve(MONITORING_SERVICE_PKG_ID.getName())\n+                .resolve(MONITORING_SERVICE_PKG_ID.getVersion().getValue());\n+        assertThat(artifactPath.toAbsolutePath(), is(equalTo(expectedArtifactPath)));\n+\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e"}, "originalPosition": 229}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69fadd6379276c19dc05aaa9a29b82e67916f1e0", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/69fadd6379276c19dc05aaa9a29b82e67916f1e0", "committedDate": "2020-04-23T20:14:50Z", "message": "rename to save"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDM5MDkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#pullrequestreview-399439091", "createdAt": "2020-04-23T20:10:13Z", "commit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDoxMDoxM1rOGK6F2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMDo0MTo0OFrOGK7Psg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MDcxMg==", "bodyText": "or storePackageRecipe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414090712", "createdAt": "2020-04-23T20:10:13Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void createPackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5ODM4OA=="}, "originalCommit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5Mzc5NQ==", "bodyText": "Why not reuse the pkgId?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414093795", "createdAt": "2020-04-23T20:15:24Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void createPackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NDQxOA==", "bodyText": "you mean version constraints?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414094418", "createdAt": "2020-04-23T20:16:22Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void createPackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "091066d97955d68b49c8cf7334958eda6fae157e"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwODY4Mw==", "bodyText": "Where do we need this method? This seems to be a high computation method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414108683", "createdAt": "2020-04-23T20:40:16Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     */\n+    List<PackageMetadata> listAvailablePackageMetadata(final String packageName, Requirement requirement)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fadd6379276c19dc05aaa9a29b82e67916f1e0"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwOTYxOA==", "bodyText": "Null check for packageRecipe?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414109618", "createdAt": "2020-04-23T20:41:48Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(PackageRecipe packageRecipe) throws PackageLoadingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69fadd6379276c19dc05aaa9a29b82e67916f1e0"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4500144066c67a1df724d10f538b4b2a2153d2d", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e4500144066c67a1df724d10f538b4b2a2153d2d", "committedDate": "2020-04-23T22:52:09Z", "message": "Merge branch 'master' into package_store_new"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf80c657f73b52c7498c84626684b05f4ea924fe", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bf80c657f73b52c7498c84626684b05f4ea924fe", "committedDate": "2020-04-24T01:12:22Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NTgxMzcw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#pullrequestreview-399581370", "createdAt": "2020-04-24T01:24:59Z", "commit": {"oid": "bf80c657f73b52c7498c84626684b05f4ea924fe"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "476d379a99fc59ea7292f925bbb43bd0893c00e5", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/476d379a99fc59ea7292f925bbb43bd0893c00e5", "committedDate": "2020-04-24T17:00:59Z", "message": "Merge branch 'master' into package_store_new"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db01f686abbd30babbc2eff03828e3a4f9c891bd", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/db01f686abbd30babbc2eff03828e3a4f9c891bd", "committedDate": "2020-04-24T17:27:53Z", "message": "Merge branch 'master' into package_store_new"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTMzMTIx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#pullrequestreview-400133121", "createdAt": "2020-04-24T17:20:53Z", "commit": {"oid": "476d379a99fc59ea7292f925bbb43bd0893c00e5"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzoyMDo1M1rOGLhlqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzozMzozNVrOGLiElQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczNzgzNA==", "bodyText": "nit: use plural?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414737834", "createdAt": "2020-04-24T17:20:53Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "476d379a99fc59ea7292f925bbb43bd0893c00e5"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczOTc5Ng==", "bodyText": "Why is it called PackageLoadingException? It has nothing to do with \"load package\". Maybe have a generic PackageIOException?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414739796", "createdAt": "2020-04-24T17:23:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") @NonNull Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(@NonNull PackageRecipe packageRecipe) throws PackageLoadingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "476d379a99fc59ea7292f925bbb43bd0893c00e5"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0MDgyNQ==", "bodyText": "Why need both getPackageRecipe and findPackageRecipe?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414740825", "createdAt": "2020-04-24T17:25:34Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") @NonNull Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(@NonNull PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "476d379a99fc59ea7292f925bbb43bd0893c00e5"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NDcwOA==", "bodyText": "Why sort?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414744708", "createdAt": "2020-04-24T17:31:44Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") @NonNull Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(@NonNull PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(@NonNull PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     */\n+    List<PackageMetadata> listAvailablePackageMetadata(@NonNull String packageName, @NonNull Requirement requirement)\n+            throws PackagingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        Arrays.sort(recipeFiles);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db01f686abbd30babbc2eff03828e3a4f9c891bd"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NTc0OQ==", "bodyText": "This method does a o(n) lookup, do we have to have this method? The other way is to organize the recipe files as\nrecipes/Foo/1.0.recipe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r414745749", "createdAt": "2020-04-24T17:33:35Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipe\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifact\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";\n+\n+    private static final ObjectMapper RECIPE_SERIALIZER = SerializerFactory.getRecipeSerializer();\n+\n+    private final Path recipeDirectory;\n+\n+    private final Path artifactDirectory;\n+\n+    /**\n+     * Constructor. It will initialize both recipe and artifact directory.\n+     *\n+     * @param packageStoreDirectory the root path for package store.\n+     * @throws PackagingException if fails to create recipe or artifact directory.\n+     */\n+    @Inject\n+    public PackageStore(@Named(\"packageStoreDirectory\") @NonNull Path packageStoreDirectory) throws PackagingException {\n+        this.recipeDirectory = packageStoreDirectory.resolve(RECIPE_DIRECTORY);\n+        if (!Files.exists(recipeDirectory)) {\n+            try {\n+                Files.createDirectories(recipeDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create recipe directory %s\", recipeDirectory), e);\n+            }\n+        }\n+        this.artifactDirectory = packageStoreDirectory.resolve(ARTIFACT_DIRECTORY);\n+        if (!Files.exists(artifactDirectory)) {\n+            try {\n+                Files.createDirectories(artifactDirectory);\n+            } catch (IOException e) {\n+                throw new PackagingException(String.format(\"Failed to create artifact directory %s\", artifactDirectory),\n+                        e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates or updates a package recipe in the package store on the disk.\n+     *\n+     * @param packageRecipe package recipe to be create.\n+     * @throws PackageLoadingException if fails to write the package recipe to disk.\n+     */\n+    void savePackageRecipe(@NonNull PackageRecipe packageRecipe) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(packageRecipe.getPackageName(), packageRecipe.getVersion());\n+\n+        try {\n+            RECIPE_SERIALIZER.writeValue(recipePath.toFile(), packageRecipe);\n+        } catch (IOException e) {\n+            // TODO refine exception\n+            throw new PackageLoadingException(String.format(\"Failed to save package recipe to %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Find the target package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return Optional of package recipe; empty if not found.\n+     * @throws PackageLoadingException if fails to parse the recipe file.\n+     */\n+    Optional<PackageRecipe> findPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+\n+        logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n+\n+        if (!Files.exists(recipePath) || !Files.isRegularFile(recipePath)) {\n+            return Optional.empty();\n+        }\n+\n+        byte[] recipeContent;\n+        try {\n+            recipeContent = Files.readAllBytes(recipePath);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to load package recipe at %s\", recipePath), e);\n+        }\n+\n+        try {\n+            return Optional.of(RECIPE_SERIALIZER.readValue(recipeContent, PackageRecipe.class));\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(String.format(\"Failed to parse package recipe at %s\", recipePath), e);\n+        }\n+    }\n+\n+    /**\n+     * Get the package recipe from package store on the disk.\n+     *\n+     * @param pkgId package identifier\n+     * @return retrieved package recipe.\n+     * @throws PackageLoadingException if fails to find the target package recipe or fails to parse the recipe file.\n+     */\n+    PackageRecipe getPackageRecipe(@NonNull PackageIdentifier pkgId) throws PackageLoadingException {\n+        Optional<PackageRecipe> optionalPackage = findPackageRecipe(pkgId);\n+\n+        if (!optionalPackage.isPresent()) {\n+            // TODO refine exception and logs\n+            throw new PackageLoadingException(\n+                    String.format(\"The recipe for package: '%s' doesn't exist in the local package store.\", pkgId));\n+        }\n+\n+        return optionalPackage.get();\n+    }\n+\n+    /**\n+     * Get package metadata for given package name and version.\n+     *\n+     * @param pkgId package id\n+     * @return PackageMetadata; non-null\n+     * @throws PackagingException if fails to find or parse the recipe\n+     */\n+    PackageMetadata getPackageMetadata(@NonNull PackageIdentifier pkgId) throws PackagingException {\n+        PackageRecipe retrievedPackageRecipe = getPackageRecipe(pkgId);\n+\n+        return new PackageMetadata(\n+                new PackageIdentifier(retrievedPackageRecipe.getPackageName(), retrievedPackageRecipe.getVersion()),\n+                retrievedPackageRecipe.getDependencies());\n+    }\n+\n+    /**\n+     * list PackageMetadata for available packages that satisfies the requirement.\n+     *\n+     * @param packageName the target package\n+     * @param requirement version requirement\n+     * @return a list of PackageMetadata that satisfies the requirement.\n+     * @throws UnexpectedPackagingException if fails to parse version directory to Semver\n+     */\n+    List<PackageMetadata> listAvailablePackageMetadata(@NonNull String packageName, @NonNull Requirement requirement)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db01f686abbd30babbc2eff03828e3a4f9c891bd"}, "originalPosition": 162}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "008832328b2daad2885d054dd0a4c0c896b0ba9e", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/008832328b2daad2885d054dd0a4c0c896b0ba9e", "committedDate": "2020-04-24T18:36:24Z", "message": "Merge branch 'master' into package_store_new"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4afb3340e06e1820025c67bb6fd1c236e5807b85", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4afb3340e06e1820025c67bb6fd1c236e5807b85", "committedDate": "2020-04-24T22:45:39Z", "message": "Merge branch 'master' into package_store_new"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59ee87c30d4ad373a3625df8ea8e6cb6ba21bb6f", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/59ee87c30d4ad373a3625df8ea8e6cb6ba21bb6f", "committedDate": "2020-04-24T22:46:03Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b6f1d2614ea4427f5def264c1cc22d1f3fe6ba7", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1b6f1d2614ea4427f5def264c1cc22d1f3fe6ba7", "committedDate": "2020-04-27T18:54:37Z", "message": "Small fix for DeploymentCloudServiceIntegTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaa0cded7046a1864e65008788cc46e95c85d5b2", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aaa0cded7046a1864e65008788cc46e95c85d5b2", "committedDate": "2020-04-27T19:21:17Z", "message": "Small fix for DeploymentCloudServiceIntegTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjU3NjM5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#pullrequestreview-401257639", "createdAt": "2020-04-27T19:24:30Z", "commit": {"oid": "aaa0cded7046a1864e65008788cc46e95c85d5b2"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOToyNDozMFrOGMz5pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOToyNDozMFrOGMz5pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4NjQzOA==", "bodyText": "nit\nuse your const for .yaml.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#discussion_r416086438", "createdAt": "2020-04-27T19:24:30Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageStore.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.constants.FileSuffix;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageLoadingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.aws.iot.evergreen.util.SerializerFactory;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+public class PackageStore {\n+    private static final Logger logger = LogManager.getLogger(PackageStore.class);\n+    private static final String RECIPE_DIRECTORY = \"recipes\";\n+    private static final String ARTIFACT_DIRECTORY = \"artifacts\";\n+    private static final String RECIPE_FILE_NAME_FORMAT = \"%s-%s.yaml\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaa0cded7046a1864e65008788cc46e95c85d5b2"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjc4NDMx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/210#pullrequestreview-401278431", "createdAt": "2020-04-27T19:55:14Z", "commit": {"oid": "aaa0cded7046a1864e65008788cc46e95c85d5b2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2157, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}