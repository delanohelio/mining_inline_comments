{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4NzEyODIw", "number": 503, "title": "Device gets the default value from the recipe, gets update/patch request from deployment doc and perform interpolation", "bodyText": "Issue #, if available:\nDescription of changes:\n\nImplement the whole configuration update flow.\nImplement the interpolation with new configuration.\n\nThe major changes are in KernelConfigResolver.\nI recommend you look at the DeploymentTaskIntegrationTest test cases to get the idea what the behavior looks like,\nand then look at the code.\nNote we've covered A LOT OF edge cases including empty list, string, map, and null.\nSee READMEs for more details.\nWhy is this change necessary:\nHow was this change tested:\nAny additional information or context required to review the change:\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-10-06T17:25:27Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503", "merged": true, "mergeCommit": {"oid": "d326148fc75706fc9e2731ca8d6f79664e495da7"}, "closed": true, "closedAt": "2020-10-12T03:09:39Z", "author": {"login": "leaf94"}, "timelineItems": {"totalCount": 73, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMj4rtgH2gAyNDk4NzEyODIwOjI3M2U0NDgwNGFhOTQ3YWJiM2U0YjcxNTJjNTlkODM4MzgyZDUxNTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdRrEGwgFqTUwNjI2NTQyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "273e44804aa947abb3e4b7152c59d838382d5154", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/273e44804aa947abb3e4b7152c59d838382d5154", "committedDate": "2020-09-26T05:52:55Z", "message": "default value works"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6c865937dbfe1b5e2c85a558c1e2c844d99e573", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6c865937dbfe1b5e2c85a558c1e2c844d99e573", "committedDate": "2020-09-28T06:33:01Z", "message": "insert doesn't really work with json node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aff7b39bed911b337448bf5a777f657249902761", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aff7b39bed911b337448bf5a777f657249902761", "committedDate": "2020-10-01T21:46:18Z", "message": "working for demo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9e7810fd68d84f88d4b8763a75865e64ec63fa3", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c9e7810fd68d84f88d4b8763a75865e64ec63fa3", "committedDate": "2020-10-01T21:46:29Z", "message": "working for demo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "707cee3775e2e77992cc8247c2862a19f7cb4190", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/707cee3775e2e77992cc8247c2862a19f7cb4190", "committedDate": "2020-10-02T23:11:27Z", "message": "done"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c39333af919b5a68125b444649f1b3e06814904a", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c39333af919b5a68125b444649f1b3e06814904a", "committedDate": "2020-10-03T00:05:48Z", "message": "functionality all work. code cleaned. Nest step is to write integ test. Finally add unit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fe6e1a8c7f88b7d93e2e3d08fefc362a21a2a6c", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8fe6e1a8c7f88b7d93e2e3d08fefc362a21a2a6c", "committedDate": "2020-10-06T17:24:50Z", "message": "Integ test working"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMjU3NzYx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-503257761", "createdAt": "2020-10-06T18:42:19Z", "commit": {"oid": "8fe6e1a8c7f88b7d93e2e3d08fefc362a21a2a6c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODo0MjoxOVrOHdVOgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODo0MjoxOVrOHdVOgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxODUzMA==", "bodyText": "Heads up: Packages is a deprecated term. It will be replaced by Components before re:Invent so be ready with a plan to change it over.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500518530", "createdAt": "2020-10-06T18:42:19Z", "author": {"login": "ravenway"}, "path": "src/integrationtests/resources/com/aws/greengrass/integrationtests/deployment/ComponentConfigTest_DeployDocument_1.json", "diffHunk": "@@ -0,0 +1,18 @@\n+{\n+  \"DeploymentId\": \"arn:aws:us-east-1:greengrass:configuration:thinggroup/group1:1\",\n+  \"RootPackages\": [\n+    \"ComponentConfigurationTestService\"\n+  ],\n+  \"Packages\": [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe6e1a8c7f88b7d93e2e3d08fefc362a21a2a6c"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2434fa663d86653505a7c04e0a6e1a0e7374454e", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2434fa663d86653505a7c04e0a6e1a0e7374454e", "committedDate": "2020-10-06T18:46:24Z", "message": "merged"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec5a6f9726a003beb11bcab754395f7fd49e9df0", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ec5a6f9726a003beb11bcab754395f7fd49e9df0", "committedDate": "2020-10-06T20:25:39Z", "message": "merged working again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df4add2b6309e4f87a9d1b3d5286d66ea6caf326", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/df4add2b6309e4f87a9d1b3d5286d66ea6caf326", "committedDate": "2020-10-06T21:05:44Z", "message": "Added list testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cad1771433ccb823bb45965bc43e5c57f91846f2", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cad1771433ccb823bb45965bc43e5c57f91846f2", "committedDate": "2020-10-06T21:23:13Z", "message": "add comments for FCS"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMzcyMzIx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-503372321", "createdAt": "2020-10-06T21:28:13Z", "commit": {"oid": "cad1771433ccb823bb45965bc43e5c57f91846f2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMToyODoxM1rOHdamSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMToyODoxM1rOHdamSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNjUzOQ==", "bodyText": "Will this be deprecated? If so could you add @deprecated annotation?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500606539", "createdAt": "2020-10-06T21:28:13Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/deployment/model/DeploymentPackageConfiguration.java", "diffHunk": "@@ -40,4 +38,25 @@\n \n     @JsonProperty(\"Configuration\")\n     private Map<String, Object> configuration = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cad1771433ccb823bb45965bc43e5c57f91846f2"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afa0b685f8e82278710848bb6dc135f87ef32269", "committedDate": "2020-10-06T22:34:58Z", "message": "service configuration could be null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cd62cc6a7b07715955a6961ff2e7b5499f88100", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1cd62cc6a7b07715955a6961ff2e7b5499f88100", "committedDate": "2020-10-07T01:13:12Z", "message": "half"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDk0NDY0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-503494464", "createdAt": "2020-10-07T03:07:50Z", "commit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMzowNzo1MFrOHdhBZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMzoxNzo1OFrOHdhLEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMTc4Mw==", "bodyText": "Note: this can potentially merge a null value. Not sure if that's desired", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500711783", "createdAt": "2020-10-07T03:07:50Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,41 +198,161 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    private Map<String, Object> resolveConfigurationToApply(ConfigurationUpdateOperation configurationUpdateOperation,\n+                                                            ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.lookupTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                                         .map(ComponentConfiguration::getDefaultConfiguration)\n+                                         .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // deal with no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig != null) {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            } else {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            }\n+        }\n+\n+        // deal with update\n+        return applyUpdateToCurrentConfig(currentRunningConfig, configurationUpdateOperation, defaultConfig);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map applyUpdateToCurrentConfig(Map<String, Object> currentRunningConfig,\n+                                           ConfigurationUpdateOperation configurationUpdateOperation,\n+                                           JsonNode defaultConfiguration) {\n+\n+        // initialize to empty map if null because we will use this map as the base.\n+        if (currentRunningConfig == null) {\n+            currentRunningConfig = new HashMap<>();\n+        }\n+\n+        // perform RESET first\n+        currentRunningConfig =\n+                reset(currentRunningConfig, defaultConfiguration, configurationUpdateOperation.getPathsToReset());\n+\n+        // perform MERGE secondly\n+        deepMerge(currentRunningConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return currentRunningConfig;\n+\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map reset(Map original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            JsonNode targetNode = defaultValue.at(jsonPointer);\n+\n+            if ((targetNode.isMissingNode())) {\n+                // missing default value -> remove the entry completely\n+                // note: remove, rather than setting to null.\n+                ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.getMatchingProperty());\n+\n+            } else {\n+                // target is container node, or a value node, including null node -> replace the entry\n+                ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.getMatchingProperty(), targetNode);\n+            }\n+        }\n+\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Map deepMerge(@Nonnull Map original, Map newMap) {\n+        if (newMap == null || newMap.isEmpty()) {\n+            return original;\n+        }\n+\n+        for (Object key : newMap.keySet()) {\n+            if (newMap.get(key) instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                Map originalChild = (Map) original.get(key);\n+                Map newChild = (Map) newMap.get(key);\n+                original.put(key, deepMerge(originalChild, newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides.\n+                // This branch also handles the list with entire replacement.\n+                // Note: There is no support for list append or insert at index operations.\n+                original.put(key, newMap.get(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMjIwNg==", "bodyText": "What happens here if originalChild is null? What's supposed to happen?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500712206", "createdAt": "2020-10-07T03:09:39Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,41 +198,161 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    private Map<String, Object> resolveConfigurationToApply(ConfigurationUpdateOperation configurationUpdateOperation,\n+                                                            ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.lookupTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                                         .map(ComponentConfiguration::getDefaultConfiguration)\n+                                         .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // deal with no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig != null) {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            } else {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            }\n+        }\n+\n+        // deal with update\n+        return applyUpdateToCurrentConfig(currentRunningConfig, configurationUpdateOperation, defaultConfig);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map applyUpdateToCurrentConfig(Map<String, Object> currentRunningConfig,\n+                                           ConfigurationUpdateOperation configurationUpdateOperation,\n+                                           JsonNode defaultConfiguration) {\n+\n+        // initialize to empty map if null because we will use this map as the base.\n+        if (currentRunningConfig == null) {\n+            currentRunningConfig = new HashMap<>();\n+        }\n+\n+        // perform RESET first\n+        currentRunningConfig =\n+                reset(currentRunningConfig, defaultConfiguration, configurationUpdateOperation.getPathsToReset());\n+\n+        // perform MERGE secondly\n+        deepMerge(currentRunningConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return currentRunningConfig;\n+\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map reset(Map original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            JsonNode targetNode = defaultValue.at(jsonPointer);\n+\n+            if ((targetNode.isMissingNode())) {\n+                // missing default value -> remove the entry completely\n+                // note: remove, rather than setting to null.\n+                ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.getMatchingProperty());\n+\n+            } else {\n+                // target is container node, or a value node, including null node -> replace the entry\n+                ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.getMatchingProperty(), targetNode);\n+            }\n+        }\n+\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Map deepMerge(@Nonnull Map original, Map newMap) {\n+        if (newMap == null || newMap.isEmpty()) {\n+            return original;\n+        }\n+\n+        for (Object key : newMap.keySet()) {\n+            if (newMap.get(key) instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                Map originalChild = (Map) original.get(key);\n+                Map newChild = (Map) newMap.get(key);\n+                original.put(key, deepMerge(originalChild, newChild));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxNDI1Nw==", "bodyText": "should the last } also be escaped for good measure? Also, can this be more strict? It'll basically match anything. It's actually less restrictive than other matchers in this file so I'm concerned about the config resolving to broken state.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500714257", "createdAt": "2020-10-07T03:17:58Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -55,12 +62,21 @@\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n     private static final Pattern SAME_INTERPOLATION_REGEX =\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n+\n+    // pattern matches {group1:group2}. Note char in both group can't be }, but can be special char like / and .\n+    private static final Pattern SAME_COMPONENT_INTERPOLATION_REGEX = Pattern.compile(\"\\\\{([^}]+):([^}]+)}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afb2aea893f215ec7fc841dd342720ae53f1a242", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afb2aea893f215ec7fc841dd342720ae53f1a242", "committedDate": "2020-10-07T05:49:59Z", "message": "add unit tests for configuration update operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd57935cba930e198bb38cc4893aa517da620778", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fd57935cba930e198bb38cc4893aa517da620778", "committedDate": "2020-10-07T06:17:57Z", "message": "new working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8335cfef5e78fe054c7f3d9c119a665dfe6d4e6", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d8335cfef5e78fe054c7f3d9c119a665dfe6d4e6", "committedDate": "2020-10-07T06:18:18Z", "message": "Merge branch 'nested_config' of github.com:aws/aws-greengrass-kernel into nested_config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e458ac8f58ff9cd0e4645d3c404f8fa23604c9f1", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e458ac8f58ff9cd0e4645d3c404f8fa23604c9f1", "committedDate": "2020-10-07T06:47:56Z", "message": "done"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b4156a5121ba490a9b9295a73bedef5f208a5e6", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4b4156a5121ba490a9b9295a73bedef5f208a5e6", "committedDate": "2020-10-07T18:22:24Z", "message": "fix deepcopy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33742eed032dc667f367a746a72ca369364b237d", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33742eed032dc667f367a746a72ca369364b237d", "committedDate": "2020-10-07T21:15:23Z", "message": "add system namespace handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac43895389e93bdeaad34c522d36dcbc74506f7a", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ac43895389e93bdeaad34c522d36dcbc74506f7a", "committedDate": "2020-10-07T21:47:30Z", "message": "fixed cross system"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ec7d828be447b2cf0ecbbc6e8b038b0efb825f5", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9ec7d828be447b2cf0ecbbc6e8b038b0efb825f5", "committedDate": "2020-10-07T22:43:57Z", "message": "clean up code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86ea20a2aed88b0273bc93b021099b29d1066399", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/86ea20a2aed88b0273bc93b021099b29d1066399", "committedDate": "2020-10-07T22:48:19Z", "message": "clean up code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b5f7f65886a61ef760f44df023e7a074b53e618", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b5f7f65886a61ef760f44df023e7a074b53e618", "committedDate": "2020-10-07T22:55:36Z", "message": "system cross"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74c64109e2ce2fb00e4d47b9f5b29f744ad039d5", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/74c64109e2ce2fb00e4d47b9f5b29f744ad039d5", "committedDate": "2020-10-07T22:55:49Z", "message": "add cross component reference test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11a8f57c7c126ef5a46a10a15dacf292d56b4abf", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/11a8f57c7c126ef5a46a10a15dacf292d56b4abf", "committedDate": "2020-10-07T23:19:05Z", "message": "cleanup message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acea077b897322e2f49a742c589ae84d6e3caf6b", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/acea077b897322e2f49a742c589ae84d6e3caf6b", "committedDate": "2020-10-08T00:50:10Z", "message": "all works"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63e2fa9361604539320db0bef58a9ddad9636e57", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/63e2fa9361604539320db0bef58a9ddad9636e57", "committedDate": "2020-10-08T00:50:18Z", "message": "Merge branch 'nested_config' of github.com:aws/aws-greengrass-kernel into nested_config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5a8b20326ac0c5275f7e9368969c8211d7b4e19", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a5a8b20326ac0c5275f7e9368969c8211d7b4e19", "committedDate": "2020-10-08T00:51:49Z", "message": "all works"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33d28253249406553c7bb95cc85d7ddc6f5119ea", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33d28253249406553c7bb95cc85d7ddc6f5119ea", "committedDate": "2020-10-08T01:01:09Z", "message": "original tests passed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fed87f9ff89414e470353ed61945959bbdb9f79", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1fed87f9ff89414e470353ed61945959bbdb9f79", "committedDate": "2020-10-08T03:13:17Z", "message": "mvn verify works locally"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9166f8d1028d32599e4c9316c1288e5e2fa5109a", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9166f8d1028d32599e4c9316c1288e5e2fa5109a", "committedDate": "2020-10-08T06:12:19Z", "message": "Updated README"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "387705bb0f01dc6f9228751583e3e1a9efdb6484", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/387705bb0f01dc6f9228751583e3e1a9efdb6484", "committedDate": "2020-10-08T06:14:41Z", "message": "Updated README"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e14e1a2ce4c7acb1638bccd68ab741a2353326b6", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e14e1a2ce4c7acb1638bccd68ab741a2353326b6", "committedDate": "2020-10-08T06:15:35Z", "message": "Updated README"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00cf23d461bd2fd9921362141dd1a9741491c3db", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/00cf23d461bd2fd9921362141dd1a9741491c3db", "committedDate": "2020-10-08T07:20:08Z", "message": "Update recipe reference"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "771ff9e505fbfaa4d6ed5a46acd1f022b62bcd83", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/771ff9e505fbfaa4d6ed5a46acd1f022b62bcd83", "committedDate": "2020-10-08T07:22:22Z", "message": "Update recipe reference"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/23ae406261e032cdce920523cdd9fb54c0015276", "committedDate": "2020-10-08T07:25:00Z", "message": "shirley's comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NzQ1Mjk5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-504745299", "createdAt": "2020-10-08T12:49:09Z", "commit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMjo0OTowOVrOHec6sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoxMDoyMFrOHedw5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5MzEwNQ==", "bodyText": "What's the use-case for allowing this? Scenario: my component's configuration as a default value on a key, and someone sets this key to null. As a consumer of the key, will I retrieve the default value or null? In other words: is null treated differently than \"unset\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501693105", "createdAt": "2020-10-08T12:49:09Z", "author": {"login": "philcali"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,\n+regardless of the order they are given in the JSON Object.\n+\n+#### 2.3.1 RESET\n+RESET takes a list of String.\n+Each string is a JSON Pointer: https://tools.ietf.org/html/rfc6901.\n+\n+1. If a default value doesn't exist at this JSON pointer location, then the key/value pair will be removed entirely. \n+1. If a default value exists at this JSON pointer location, then the value of configuration will be reset to the default value.\n+\n+##### RESET doesn't support using index for an Array/List!!\n+Although JSON pointer supports use indexes to locate an element in an Array/List, **we don't support use\n+JSON pointer to reset an element in an Array/List for re:Invent 2020**. The reason is that resetting an element of an array\n+might cause removal for an index, elements shifting in the array, and other indeterministic results. \n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+##### RESET the entire configuration\n+Empty String is JSON pointer's way to refer to the whole document. So you could simply do\n+\n+```json\n+{\n+  \"RESET\":  [\"\"]\n+}\n+```\n+\n+Note that if the empty string appears in the list of `RESET`, then the rest of pointers in the list will be ignored, and the configuration\n+will just be reset to the default configuration entirely.\n+\n+\n+##### What happens if I reset to a default value and my default value is null or empty?\n+In general, Greengrass V2 will reset to the default value as is, instead of dropping null or empty values, including:\n+\n+1. Default value has an empty List. ex. `{\"emptyListKey\": []}`. An empty list will be reset with JSON pointer: `/emptyListKey`.\n+1. Default value has an empty Map/Object. `{\"emptyMapKey\": {}}`. An empty map will be reset with JSON pointer: `/emptyMapKey`.\n+1. Default value has an empty String. `{\"emptyStringKey\": \"\"\"}`. An empty String will be reset with JSON pointer: `/emptyStringKey`.\n+1. Default value has a null. `{\"defaultIsNullKey\":null}`. A null will be reset with JSON pointer: `/defaultIsNullKey`.\n+\n+#### 2.3.2 MERGE\n+`MERGE` takes an object, representing new configuration that should be merging in.\n+\n+The given object is merged to the existing configuration object level by level. \n+\n+At every level,\n+1. if a key already exists, then the value will be overridden by the value that is merging in.\n+2. If a key doesn't exist, then key-value pair that is merging in will be added. Note a key that is not existed in the default value,\n+could also be added.\n+\n+##### MERGE doesn't support Array/List append or insertion at index operations!!\n+Similar to removal, list append and insertion index require handling addtional complexity of array index changing, elements\n+shifting, and other indeterministic results.\n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+However, it's still possible to override the entire list.\n+If you really need to make updates at the element level, think about using a map instead, by giving each element an unique key.\n+\n+##### Can I merge in a new key-value pair, which was not part of the default configuration?\n+YES. We are providing the flexibility to do so, so that new configurations could be added during deployments.\n+\n+##### Can I merge empty values?\n+YES. You can merge empty String, List, or Object/Map.\n+\n+##### Can I merge `null` as a value for a key?\n+YES. When reading the merged configuration, you will be able to find the key with value as `null`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwNTM4Ng==", "bodyText": "Understanding that mutation and validation are distinct problems, without schema validation, this is a scary thing to allow. A component's recipe is a static, and therefore structural changes can impact the component's lifecycle in non-obvious ways (ie: changing a complex object into a primitive, or vice-versa). Until proper schema validation exists, I wonder if it makes sense to validate that the mutated object is structurally similar to the default configuration object.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501705386", "createdAt": "2020-10-08T13:07:56Z", "author": {"login": "philcali"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,\n+regardless of the order they are given in the JSON Object.\n+\n+#### 2.3.1 RESET\n+RESET takes a list of String.\n+Each string is a JSON Pointer: https://tools.ietf.org/html/rfc6901.\n+\n+1. If a default value doesn't exist at this JSON pointer location, then the key/value pair will be removed entirely. \n+1. If a default value exists at this JSON pointer location, then the value of configuration will be reset to the default value.\n+\n+##### RESET doesn't support using index for an Array/List!!\n+Although JSON pointer supports use indexes to locate an element in an Array/List, **we don't support use\n+JSON pointer to reset an element in an Array/List for re:Invent 2020**. The reason is that resetting an element of an array\n+might cause removal for an index, elements shifting in the array, and other indeterministic results. \n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+##### RESET the entire configuration\n+Empty String is JSON pointer's way to refer to the whole document. So you could simply do\n+\n+```json\n+{\n+  \"RESET\":  [\"\"]\n+}\n+```\n+\n+Note that if the empty string appears in the list of `RESET`, then the rest of pointers in the list will be ignored, and the configuration\n+will just be reset to the default configuration entirely.\n+\n+\n+##### What happens if I reset to a default value and my default value is null or empty?\n+In general, Greengrass V2 will reset to the default value as is, instead of dropping null or empty values, including:\n+\n+1. Default value has an empty List. ex. `{\"emptyListKey\": []}`. An empty list will be reset with JSON pointer: `/emptyListKey`.\n+1. Default value has an empty Map/Object. `{\"emptyMapKey\": {}}`. An empty map will be reset with JSON pointer: `/emptyMapKey`.\n+1. Default value has an empty String. `{\"emptyStringKey\": \"\"\"}`. An empty String will be reset with JSON pointer: `/emptyStringKey`.\n+1. Default value has a null. `{\"defaultIsNullKey\":null}`. A null will be reset with JSON pointer: `/defaultIsNullKey`.\n+\n+#### 2.3.2 MERGE\n+`MERGE` takes an object, representing new configuration that should be merging in.\n+\n+The given object is merged to the existing configuration object level by level. \n+\n+At every level,\n+1. if a key already exists, then the value will be overridden by the value that is merging in.\n+2. If a key doesn't exist, then key-value pair that is merging in will be added. Note a key that is not existed in the default value,\n+could also be added.\n+\n+##### MERGE doesn't support Array/List append or insertion at index operations!!\n+Similar to removal, list append and insertion index require handling addtional complexity of array index changing, elements\n+shifting, and other indeterministic results.\n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+However, it's still possible to override the entire list.\n+If you really need to make updates at the element level, think about using a map instead, by giving each element an unique key.\n+\n+##### Can I merge in a new key-value pair, which was not part of the default configuration?\n+YES. We are providing the flexibility to do so, so that new configurations could be added during deployments.\n+\n+##### Can I merge empty values?\n+YES. You can merge empty String, List, or Object/Map.\n+\n+##### Can I merge `null` as a value for a key?\n+YES. When reading the merged configuration, you will be able to find the key with value as `null`.\n+\n+##### Can I merge in a new value whose type is different from original value's type for the same key?\n+YES. The new value will be merged in and overrides the old value.\n+This allows you to potentially change the configuration object's structure. See the following example:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwNjk4Mg==", "bodyText": "If I'm allowed to MERGE the args field to a single level key, how will these default values be applied?\nDiscussed offline: it's how it works, but it would fail interpolation on the component service lifecycle, thus failing the deployment.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501706982", "createdAt": "2020-10-08T13:10:20Z", "author": {"login": "philcali"}, "path": "RECIPE_REFERENCE.md", "diffHunk": "@@ -18,31 +18,36 @@ ComponentVersion: 1.0.0\n ComponentDescription: hello world from greengrass!\n ComponentPublisher: Amazon\n ComponentType: aws.greengrass.generic\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    args:\n+      windowsArg: Hello Windows\n+      linuxArg: Hello Linux", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e8037676ac1b2ce0d71bad899758e4250c0bfbc6", "committedDate": "2020-10-08T23:03:45Z", "message": "Merge branch 'master' into nested_config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2d1d567f6eb864d3edda94721411214e9b6a9c4", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f2d1d567f6eb864d3edda94721411214e9b6a9c4", "committedDate": "2020-10-08T23:04:21Z", "message": "half"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efea322745479890aa65a448072859f421019c14", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/efea322745479890aa65a448072859f421019c14", "committedDate": "2020-10-08T23:25:42Z", "message": "fix merging issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MjU1NTAz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-505255503", "createdAt": "2020-10-09T00:04:07Z", "commit": {"oid": "efea322745479890aa65a448072859f421019c14"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4608bb6a09e09790daee49ac5303dd98c2c70cbf", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4608bb6a09e09790daee49ac5303dd98c2c70cbf", "committedDate": "2020-10-09T00:56:26Z", "message": "Merge branch 'master' into nested_config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5046c3ccfbc98ceb3d353bed35dcbcc1499185b", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a5046c3ccfbc98ceb3d353bed35dcbcc1499185b", "committedDate": "2020-10-09T01:05:16Z", "message": "fix merge issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MDU0MDQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-505054046", "createdAt": "2020-10-08T18:26:23Z", "commit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoyNjoyM1rOHerMAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzoxOToxNVrOHe0A6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyNjkxMw==", "bodyText": "I thought we're not supporting path in re:Invent?\nWhat is exactly a path? Does it include the leafKey?\nCan you also add a real example below?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501926913", "createdAt": "2020-10-08T18:26:23Z", "author": {"login": "fengwang666"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzMzk2OQ==", "bodyText": "Then let's remove the YAML sample? This readme will be public, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501933969", "createdAt": "2020-10-08T18:38:05Z", "author": {"login": "fengwang666"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzODYxOA==", "bodyText": "Can I have more than one REST and MERGE?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501938618", "createdAt": "2020-10-08T18:46:22Z", "author": {"login": "fengwang666"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk0NTcyMQ==", "bodyText": "Both double parenthesis and single parenthesis are used. Can we consolidate to use one of them?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501945721", "createdAt": "2020-10-08T18:58:31Z", "author": {"login": "fengwang666"}, "path": "RECIPE_REFERENCE.md", "diffHunk": "@@ -18,31 +18,36 @@ ComponentVersion: 1.0.0\n ComponentDescription: hello world from greengrass!\n ComponentPublisher: Amazon\n ComponentType: aws.greengrass.generic\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    args:\n+      windowsArg: Hello Windows\n+      linuxArg: Hello Linux\n+\n+ComponentDependencies:\n+  variant.Python3:\n+    VersionRequirement: ^3.5\n+    DependencyType: SOFT\n+\n Manifests:\n   - Platform:\n       os: windows\n       architecture: x86_64\n     Lifecycle:\n       Run:\n-        python3 {{artifacts:path}}/hello_windows_server.py\n+        python3 {{artifacts:path}}/hello_windows_server.py {configuration:/args/windowsArg}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mjc3OQ==", "bodyText": "Configurations or configurations?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502042779", "createdAt": "2020-10-08T22:16:31Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -40,12 +46,15 @@\n \n import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n import static com.aws.greengrass.lifecyclemanager.Kernel.SERVICE_TYPE_TOPIC_KEY;\n \n public class KernelConfigResolver {\n     private static final Logger LOGGER = LogManager.getLogger(KernelConfigResolver.class);\n     public static final String VERSION_CONFIG_KEY = \"version\";\n     public static final String PARAMETERS_CONFIG_KEY = \"parameters\";\n+    public static final String CONFIGURATIONS_CONFIG_KEY = \"Configurations\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mzk5OQ==", "bodyText": "Make this a static variable.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502043999", "createdAt": "2020-10-08T22:19:50Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -55,42 +64,68 @@\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n     private static final Pattern SAME_INTERPOLATION_REGEX =\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n+\n+    // pattern matches {group1:group2}. ex. {configuration:/singleLevelKey}\n+    // Group 1 could only be word or dot (.). It is for the namespace such as \"artifacts\" and \"configuration\".\n+    // Group 2 is the key. For namespace \"configuration\", it needs to support arbitrary JSON pointer.\n+    // so it can take any character but not be ':' or '}', because these breaks the interpolation placeholder format.\n+    private static final Pattern SAME_COMPONENT_INTERPOLATION_REGEX = Pattern.compile(\"\\\\{([.\\\\w]+):([^:}]+)}\");\n+\n+\n+    // pattern matches {group1:group2:group3}.\n+    // ex. {aws.iot.aws.iot.gg.test.integ.ComponentConfigTestService:configuration:/singleLevelKey}\n+    // Group 1 could only be word or dot (.). It is for the component name.\n+    // Group 1 could only be word or dot (.). It is for the namespace such as \"artifacts\" and \"configuration\".\n+    // Group 2 is the key. For namespace \"configuration\", it needs to support arbitrary JSON pointer.\n+    // so it can take any character but not be ':' or '}', because these breaks the interpolation placeholder format.\n+    private static final Pattern CROSS_COMPONENT_INTERPOLATION_REGEX =\n+            Pattern.compile(\"\\\\{([.\\\\w]+):([.\\\\w]+):([^:}]+)}\");\n+\n     static final String PARAM_NAMESPACE = \"params\";\n+    static final String CONFIGURATION_NAMESPACE = \"configuration\";\n     static final String PARAM_VALUE_SUFFIX = \".value\";\n     static final String PATH_KEY = \"path\";\n     static final String DECOMPRESSED_PATH_KEY = \"decompressedPath\";\n \n     private static final String NO_RECIPE_ERROR_FORMAT = \"Failed to find component recipe for {}\";\n \n+    // https://tools.ietf.org/html/rfc6901#section-5\n+    private static final String JSON_POINTER_WHOLE_DOC = \"\";\n+\n     // Map from Namespace -> Key -> Function which returns the replacement value\n     private final Map<String, Map<String, CrashableFunction<ComponentIdentifier, String, PackageLoadingException>>>\n             systemParameters = new HashMap<>();\n \n     private final ComponentStore componentStore;\n     private final Kernel kernel;\n \n+    private final ObjectMapper mapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTQ5NQ==", "bodyText": "nit: update the comment", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502045495", "createdAt": "2020-10-08T22:23:39Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -125,30 +178,31 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n      * Processes lifecycle section of each package and add it to the config.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTYyNg==", "bodyText": "packagesToDeploy -> componentsToDeploy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502045626", "createdAt": "2020-10-08T22:24:05Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -125,30 +178,31 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n      * Processes lifecycle section of each package and add it to the config.\n      */\n     private Map<String, Object> getServiceConfig(ComponentIdentifier componentIdentifier, DeploymentDocument document,\n-                                                 List<ComponentIdentifier> packagesToDeploy,\n-                                                 Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>>\n-                                                         parameterAndDependencyCache)\n+            List<ComponentIdentifier> packagesToDeploy,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NzA2Mg==", "bodyText": "Pull reset and deepMerge into a separate class. They are independent from kernel config and can be tested more thoroughly using unit tests. This KernelConfigResolver is getting too big.\nAlso I would make the method signature more consistent:\nJsonNode reset(JsonNode original, JsonNode defaultValue, List<String> paths)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502047062", "createdAt": "2020-10-08T22:27:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1NTE4MQ==", "bodyText": "Why allow nullable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502055181", "createdAt": "2020-10-08T22:50:06Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1Njc3MQ==", "bodyText": "You'll end up having a lot of copies if the nesting is deep. I would be fine just mutating the map. Since the user of this method is only us, it's safe as long as the caller knows this is a mutating method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502056771", "createdAt": "2020-10-08T22:54:45Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2MDkwOQ==", "bodyText": "Is this supposed to replace the intepolate on line567 or they're separate? Can you rename it a bit differently? such as interpolateNew.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502060909", "createdAt": "2020-10-08T23:01:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2ODI3Mg==", "bodyText": "namespace can be null so reverse the comparison order to avoid NPE.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502068272", "createdAt": "2020-10-08T23:14:00Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -163,29 +217,375 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3MTUzMA==", "bodyText": "Is this desirable? If the client is expecting the configuration value is a string, but the node the path points to is an object, apparently something is wrong.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502071530", "createdAt": "2020-10-08T23:19:15Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -163,29 +217,375 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(componentIdentifier.getName(), key,\n+                                                             resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String configReplacement = lookupSystemConfig(componentIdentifier, namespace, key);\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError()\n+                        .kv(\"interpolation placeholder\", matcher.group())\n+                        .kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+        }\n+\n+        // Handle cross-component interpolation. ex. {aws.iot.gg.component1:configuration:/singleLevelKey}\n+        matcher = CROSS_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String targetComponent = matcher.group(1);\n+            String namespace = matcher.group(2);\n+            String key = matcher.group(3);\n+\n+            // only interpolate if target component is a direct dependency\n+            if (!dependencies.contains(targetComponent)) {\n+                LOGGER.atError()\n+                        .kv(\"interpolation text\", matcher.group())\n+                        .kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component it's not a direct dependency.\");\n+                continue;\n+            }\n+\n+            if (!resolvedKernelServiceConfig.containsKey(targetComponent)) {\n+                LOGGER.atError()\n+                        .kv(\"interpolation text\", matcher.group())\n+                        .kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component is not in resolved kernel services.\"\n+                                     + \" This indicates the dependency resolution is broken.\");\n+                continue;\n+            }\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(targetComponent, key, resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String version =\n+                        (String) ((Map) resolvedKernelServiceConfig.get(targetComponent)).get(VERSION_CONFIG_KEY);\n+\n+                String configReplacement =\n+                        lookupSystemConfig(new ComponentIdentifier(targetComponent, new Semver(version)), namespace,\n+                                           key);\n+\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError()\n+                        .kv(\"interpolation placeholder\", matcher.group())\n+                        .kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+\n+        }\n+\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Find the configuration value for a component.\n+     *\n+     * @param componentName               component name\n+     * @param path                        path to the value\n+     * @param resolvedKernelServiceConfig resolved kernel service config to search from\n+     * @return configuration value for the path; empty if not found.\n+     */\n+    private Optional<String> lookupConfigurationValueForComponent(String componentName, String path,\n+            Map<String, Object> resolvedKernelServiceConfig) {\n+\n+        Map componentResolvedConfig;\n+\n+        if (resolvedKernelServiceConfig.containsKey(componentName) && ((Map) resolvedKernelServiceConfig.get(\n+                componentName)).containsKey(CONFIGURATIONS_CONFIG_KEY)) {\n+            componentResolvedConfig =\n+                    (Map) ((Map) resolvedKernelServiceConfig.get(componentName)).get(CONFIGURATIONS_CONFIG_KEY);\n+        } else {\n+            return Optional.empty();\n+        }\n+\n+        JsonNode targetNode = mapper.convertValue(componentResolvedConfig, JsonNode.class).at(path);\n+\n+        if (targetNode.isValueNode()) {\n+            return Optional.of(targetNode.asText());\n+        }\n+\n+        if (targetNode.isMissingNode()) {\n+            LOGGER.atError()\n+                    .addKeyValue(\"Path\", path)\n+                    .log(\"Failed to interpolate configuration due to missing value node at given path\");\n+            return Optional.empty();\n+        }\n+\n+        if (targetNode.isContainerNode()) {\n+            // return a serialized string for container node\n+            return Optional.of(targetNode.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6"}, "originalPosition": 523}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ceb9891abdc158deedc2d54907d1496e5c91e70", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9ceb9891abdc158deedc2d54907d1496e5c91e70", "committedDate": "2020-10-09T01:53:05Z", "message": "github CI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a400c8707e11f214042e82105c8e0a0f47c89adc", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a400c8707e11f214042e82105c8e0a0f47c89adc", "committedDate": "2020-10-09T06:51:22Z", "message": "merge shirley's change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "651240c4274990434cf6debccd91c0217b225339", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/651240c4274990434cf6debccd91c0217b225339", "committedDate": "2020-10-09T07:02:08Z", "message": "merge shirley's change fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28ece1751b9518489666cf5f7f076bef8a457e8e", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/28ece1751b9518489666cf5f7f076bef8a457e8e", "committedDate": "2020-10-09T17:09:45Z", "message": "Fix for windows; address Feng's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f791177cb5f6f99846290c7b5534e6503cb60b4", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7f791177cb5f6f99846290c7b5534e6503cb60b4", "committedDate": "2020-10-09T17:31:02Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c0a8f6465038084ecb686867d21a7188e3cecd1", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4c0a8f6465038084ecb686867d21a7188e3cecd1", "committedDate": "2020-10-09T18:53:40Z", "message": "test integration test on windows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1ddbd8eb7d4f046d8b120fac782d1b6832cd625", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f1ddbd8eb7d4f046d8b120fac782d1b6832cd625", "committedDate": "2020-10-09T19:02:09Z", "message": "test integration test on windows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0497273d12b912507f1f1dc2ed0132197c74c5f", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f0497273d12b912507f1f1dc2ed0132197c74c5f", "committedDate": "2020-10-09T20:38:31Z", "message": "trial 3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60f0300cdcc135434f584eac6c501b5b362accc5", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/60f0300cdcc135434f584eac6c501b5b362accc5", "committedDate": "2020-10-09T20:39:50Z", "message": "trial 3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4b7155df6ea4e3dab0a00b70888971efc343411", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d4b7155df6ea4e3dab0a00b70888971efc343411", "committedDate": "2020-10-09T20:41:33Z", "message": "trial 3.1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50ba3dfd9271dcde96bfb72e8db0f05a6f7b4c5f", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/50ba3dfd9271dcde96bfb72e8db0f05a6f7b4c5f", "committedDate": "2020-10-09T22:29:25Z", "message": "single test for windows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e9bcde9fc75f7404957220c0d37d3a002330259c", "committedDate": "2020-10-09T22:35:45Z", "message": "update readme"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d9cfb7ac5d32457d7c49a0e468a23b38a8fa4b9", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6d9cfb7ac5d32457d7c49a0e468a23b38a8fa4b9", "committedDate": "2020-10-09T22:39:33Z", "message": "single test for windows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4942f0e7c31d4b290bfe1cc47826c98cb0f18128", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4942f0e7c31d4b290bfe1cc47826c98cb0f18128", "committedDate": "2020-10-09T22:48:54Z", "message": "single test for windows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1f1331a07d3421dff9b6247d472ac4e328794da", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e1f1331a07d3421dff9b6247d472ac4e328794da", "committedDate": "2020-10-09T22:59:14Z", "message": "single test for windows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c323ff96415c387552f213fc7180db1e4fa7b240", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c323ff96415c387552f213fc7180db1e4fa7b240", "committedDate": "2020-10-09T23:21:23Z", "message": "fix flaky test for windows"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MDE4Nzg0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-506018784", "createdAt": "2020-10-09T22:30:10Z", "commit": {"oid": "d4b7155df6ea4e3dab0a00b70888971efc343411"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMjozMDoxMFrOHfaBwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzoyMjoyNlrOHfa_Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY5NDMzNw==", "bodyText": "Is this temporary?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502694337", "createdAt": "2020-10-09T22:30:10Z", "author": {"login": "ShirleyZheng92"}, "path": "pom.xml", "diffHunk": "@@ -105,7 +105,7 @@\n         <dependency>\n             <groupId>com.aws.iot</groupId>\n             <artifactId>component-common</artifactId>\n-            <version>0.0.0-SNAPSHOT</version>\n+            <version>0.0.0-config-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4b7155df6ea4e3dab0a00b70888971efc343411"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwMjk5Mg==", "bodyText": "Isn't array treated as object?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502702992", "createdAt": "2020-10-09T22:50:16Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNDI5Mw==", "bodyText": "'parent' or 'target' ? Also why it can't be a container node?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502704293", "createdAt": "2020-10-09T22:55:19Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head()))\n+                            .replace(jsonPointer.last().getMatchingProperty(), targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMDAzOQ==", "bodyText": "You already interpolate config at L166. Why need to interpolate here before configs are resolved? Will this cause new service use old config from dependencies?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502710039", "createdAt": "2020-10-09T23:22:26Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -104,51 +135,80 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n      * retrieves its recipe, then merges the parameter values into the recipe, and last transform it to a kernel config\n      * key-value pair.\n      *\n-     * @param packagesToDeploy package identifiers for resolved packages that are to be deployed\n-     * @param document         deployment document\n-     * @param rootPackages     root level packages\n+     * @param componentsToDeploy package identifiers for resolved packages of complete dependency graph across groups\n+     * @param document           deployment document\n+     * @param rootPackages       root level packages\n      * @return a kernel config map\n      * @throws PackageLoadingException if any service package was unable to be loaded\n-     * @throws IOException for directory issues\n+     * @throws IOException             for directory issues\n      */\n-    public Map<String, Object> resolve(List<ComponentIdentifier> packagesToDeploy, DeploymentDocument document,\n-                                       List<String> rootPackages) throws PackageLoadingException, IOException {\n+\n+    public Map<String, Object> resolve(List<ComponentIdentifier> componentsToDeploy, DeploymentDocument document,\n+            List<String> rootPackages) throws PackageLoadingException, IOException {\n         Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>> parameterAndDependencyCache =\n                 new ConcurrentHashMap<>();\n         Map<String, Object> servicesConfig = new HashMap<>();\n-        for (ComponentIdentifier packageToDeploy : packagesToDeploy) {\n-            servicesConfig.put(packageToDeploy.getName(),\n-                    getServiceConfig(packageToDeploy, document, packagesToDeploy, parameterAndDependencyCache));\n+\n+        // resolve configuration\n+        for (ComponentIdentifier componentToDeploy : componentsToDeploy) {\n+            servicesConfig.put(componentToDeploy.getName(),\n+                               getServiceConfig(componentToDeploy, document, componentsToDeploy,\n+                                                parameterAndDependencyCache));\n         }\n+\n+        // Interpolate configurations\n+        for (ComponentIdentifier resolvedComponentsToDeploy : componentsToDeploy) {\n+            ComponentRecipe componentRecipe = componentStore.getPackageRecipe(resolvedComponentsToDeploy);\n+\n+            Object existingLifecycle = ((Map) servicesConfig.get(resolvedComponentsToDeploy.getName()))\n+                    .get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+\n+            Object interpolatedLifecycle = interpolate(existingLifecycle, resolvedComponentsToDeploy,\n+                                                       componentRecipe.getDependencies().keySet(), servicesConfig);\n+\n+            ((Map) servicesConfig.get(resolvedComponentsToDeploy.getName()))\n+                    .put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, interpolatedLifecycle);\n+        }\n+\n         servicesConfig.put(kernel.getMain().getName(), getMainConfig(rootPackages));\n \n         // Services need to be under the services namespace in kernel config\n         return Collections.singletonMap(SERVICES_NAMESPACE_TOPIC, servicesConfig);\n     }\n \n-    /*\n-     * Processes lifecycle section of each package and add it to the config.\n+    /**\n+     * Build the kernel config for a service/component by processing deployment document.\n+     *\n+     * @param componentIdentifier         target component id\n+     * @param document                    deployment doc for the current deployment\n+     * @param componentsToDeploy          the entire list of components that would be deployed to the device cross\n+     *                                    groups\n+     * @param parameterAndDependencyCache cache for processing parameter and dependency\n+     * @return a built map representing the kernel config under \"services\" key for a particular component\n+     * @throws PackageLoadingException if any service package was unable to be loaded\n+     * @throws IOException             for directory issues\n      */\n     private Map<String, Object> getServiceConfig(ComponentIdentifier componentIdentifier, DeploymentDocument document,\n-                                                 List<ComponentIdentifier> packagesToDeploy,\n-                                                 Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>>\n-                                                         parameterAndDependencyCache)\n+            List<ComponentIdentifier> componentsToDeploy,\n+            Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>> parameterAndDependencyCache)\n             throws PackageLoadingException, IOException {\n+\n         ComponentRecipe componentRecipe = componentStore.getPackageRecipe(componentIdentifier);\n \n         Set<ComponentParameter> resolvedParams = resolveParameterValuesToUse(document, componentRecipe);\n         parameterAndDependencyCache\n                 .put(componentIdentifier, new Pair<>(resolvedParams, componentRecipe.getDependencies().keySet()));\n \n+\n         Map<String, Object> resolvedServiceConfig = new HashMap<>();\n \n         // Interpolate parameters\n-        resolvedServiceConfig.put(GreengrassService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                interpolate(componentRecipe.getLifecycle(), componentIdentifier, packagesToDeploy, document,\n-                        parameterAndDependencyCache));\n+        resolvedServiceConfig.put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                                  interpolate(componentRecipe.getLifecycle(), componentIdentifier, componentsToDeploy,\n+                                              document, parameterAndDependencyCache));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c"}, "originalPosition": 221}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fb3654d9c7d3aed0fe577ad304614e5dab4a6a3", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5fb3654d9c7d3aed0fe577ad304614e5dab4a6a3", "committedDate": "2020-10-09T23:29:56Z", "message": "put back maven"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92a8e9ed03654f2ab6b5fbef6b08e7ae62177511", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/92a8e9ed03654f2ab6b5fbef6b08e7ae62177511", "committedDate": "2020-10-09T23:30:47Z", "message": "Merge branch 'master' into nested_config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea5e3390db3eb816a0e41cc26cc040b23e29d05b", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ea5e3390db3eb816a0e41cc26cc040b23e29d05b", "committedDate": "2020-10-09T23:31:15Z", "message": "Merge branch 'nested_config' of github.com:aws/aws-greengrass-kernel into nested_config"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MDM3Njk3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-506037697", "createdAt": "2020-10-09T23:36:27Z", "commit": {"oid": "ea5e3390db3eb816a0e41cc26cc040b23e29d05b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzozNjoyN1rOHfbKIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzozNjoyN1rOHfbKIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjg2Ng==", "bodyText": "add @deprecated", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502712866", "createdAt": "2020-10-09T23:36:27Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head()))\n+                            .replace(jsonPointer.last().getMatchingProperty(), targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return MAPPER.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws IOException for directory issues\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws IOException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws IOException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (CONFIGURATION_NAMESPACE.equals(namespace)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(componentIdentifier.getName(), key,\n+                                                             resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String configReplacement = lookupSystemConfig(componentIdentifier, namespace, key);\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError().kv(\"interpolation placeholder\", matcher.group()).kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+        }\n+\n+        // Handle cross-component interpolation. ex. {aws.iot.gg.component1:configuration:/singleLevelKey}\n+        matcher = CROSS_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String targetComponent = matcher.group(1);\n+            String namespace = matcher.group(2);\n+            String key = matcher.group(3);\n+\n+            // only interpolate if target component is a direct dependency\n+            if (!dependencies.contains(targetComponent)) {\n+                LOGGER.atError().kv(\"interpolation text\", matcher.group()).kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component it's not a direct dependency.\");\n+                continue;\n+            }\n+\n+            if (!resolvedKernelServiceConfig.containsKey(targetComponent)) {\n+                LOGGER.atError().kv(\"interpolation text\", matcher.group()).kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component is not in resolved kernel services.\"\n+                                     + \" This indicates the dependency resolution is broken.\");\n+                continue;\n+            }\n+\n+            if (CONFIGURATION_NAMESPACE.equals(namespace)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(targetComponent, key, resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String version =\n+                        (String) ((Map) resolvedKernelServiceConfig.get(targetComponent)).get(VERSION_CONFIG_KEY);\n+\n+                String configReplacement =\n+                        lookupSystemConfig(new ComponentIdentifier(targetComponent, new Semver(version)), namespace,\n+                                           key);\n+\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError().kv(\"interpolation placeholder\", matcher.group()).kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+\n+        }\n+\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Find the configuration value for a component.\n+     *\n+     * @param componentName               component name\n+     * @param path                        path to the value\n+     * @param resolvedKernelServiceConfig resolved kernel service config to search from\n+     * @return configuration value for the path; empty if not found.\n+     */\n+    private Optional<String> lookupConfigurationValueForComponent(String componentName, String path,\n+            Map<String, Object> resolvedKernelServiceConfig) {\n+\n+        Map componentResolvedConfig;\n+\n+        if (resolvedKernelServiceConfig.containsKey(componentName) && ((Map) resolvedKernelServiceConfig\n+                .get(componentName)).containsKey(CONFIGURATION_CONFIG_KEY)) {\n+            componentResolvedConfig =\n+                    (Map) ((Map) resolvedKernelServiceConfig.get(componentName)).get(CONFIGURATION_CONFIG_KEY);\n+        } else {\n+            return Optional.empty();\n+        }\n+\n+        JsonNode targetNode = MAPPER.convertValue(componentResolvedConfig, JsonNode.class).at(path);\n+\n+        if (targetNode.isValueNode()) {\n+            return Optional.of(targetNode.asText());\n+        }\n+\n+        if (targetNode.isMissingNode()) {\n+            LOGGER.atError().addKeyValue(\"Path\", path)\n+                    .log(\"Failed to interpolate configuration due to missing value node at given path\");\n+            return Optional.empty();\n+        }\n+\n+        if (targetNode.isContainerNode()) {\n+            // return a serialized string for container node\n+            return Optional.of(targetNode.toString());\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Nullable\n+    private String lookupSystemConfig(ComponentIdentifier component, String namespace, String key) throws IOException {\n+        // Handle system-wide configuration\n+        Map<String, CrashableFunction<ComponentIdentifier, String, IOException>> systemParams =\n+                systemParameters.getOrDefault(namespace, Collections.emptyMap());\n+        if (systemParams.containsKey(key)) {\n+            return systemParams.get(key).apply(component);\n+        }\n+        return null;\n+    }\n+\n+    /***************** end of new configuration code path. *******************/\n+\n     /*\n      * For each lifecycle key-value pair of a package, substitute parameter values.\n      */\n+    @SuppressWarnings(\"checkstyle:OverloadMethodsDeclarationOrder\")\n     private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea5e3390db3eb816a0e41cc26cc040b23e29d05b"}, "originalPosition": 581}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09cb4bcf58b86c7284e9ef028ae2bc2b69b716f7", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/09cb4bcf58b86c7284e9ef028ae2bc2b69b716f7", "committedDate": "2020-10-10T00:09:33Z", "message": "test if new platform common works"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8204a102a9c2d25dc8c10467fff409589e9f2e10", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8204a102a9c2d25dc8c10467fff409589e9f2e10", "committedDate": "2020-10-10T00:27:42Z", "message": "final test before switching back common to mainline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ceac7ca9042f520d468c000ccfd6a920932332d7", "author": {"user": {"login": "leaf94", "name": "Ethan Huang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ceac7ca9042f520d468c000ccfd6a920932332d7", "committedDate": "2020-10-10T02:02:50Z", "message": "change common back to mainline. READY TO BE MERGED"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTk5MDUw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-506199050", "createdAt": "2020-10-11T17:14:30Z", "commit": {"oid": "ceac7ca9042f520d468c000ccfd6a920932332d7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjY1NDI3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#pullrequestreview-506265427", "createdAt": "2020-10-12T03:04:21Z", "commit": {"oid": "ceac7ca9042f520d468c000ccfd6a920932332d7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3084, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}