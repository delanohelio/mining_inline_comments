{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NjM5MTg1", "number": 495, "title": "Using new IPC Server library", "bodyText": "Issue #, if available:\nInitial attempt at integrating with new IPC server library\nDescription of changes:\n\nThe generated code from Smithy (software.amazon.awssdk.aws.greengrass) is currently copied in kernel code. This will eventually be consumed via new IPC SDK (DO NOT REVIEW files in generated.software.* package )\nThe server code from SDK team (software.amazon.awssdk.eventstreamrpc) is currently copied in kernel code. This may or may not be available as a public maven dependency.(DO NOT REVIEW files in software.amazon.awssdk.eventstreamrpc package )\nAdded a dependency on aws-crt version 1.0.0-SNAPSHOT. This is not publicly available. I have uploaded the crt jar to our S3 repo and I am consuming it from there. Right now I have uploaded for linux thats why disabling windows build in this PR\nCurrently both old IPC APIs and new IPC APIs exist so some tests are still using the old IPC. Only after CRT issue is resolved, I will be able to successfully migrate them all.\n\nWhy is this change necessary:\nHow was this change tested:\nHave verified in unit tests that the lifecycle APIs and CLI APIs work with new IPC server. Integration tests for lifecycle are written but failing due to CRT issue. I did not updated the integration tests for CLI since we have PR out to modify the CLI auth. Once that merges and CRT issue gets resolved I will updated those.\nAny additional information or context required to review the change:\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-10-02T02:07:14Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495", "merged": true, "mergeCommit": {"oid": "73233f509b6845eb7fd8ba93fb8f1cf78916143d"}, "closed": true, "closedAt": "2020-10-22T05:47:08Z", "author": {"login": "abanthiy"}, "timelineItems": {"totalCount": 69, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOcQ7AABqjM4MzIwOTY4MTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdU6NsHAFqTUxNDM0OTgxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb8e32eca5c8a76e361576980fc429e36a6100f4", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fb8e32eca5c8a76e361576980fc429e36a6100f4", "committedDate": "2020-10-02T01:59:28Z", "message": "Using new IPC Server library"}, "afterCommit": {"oid": "8230ba0ee8f170be884279d373ec2554761d53b7", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8230ba0ee8f170be884279d373ec2554761d53b7", "committedDate": "2020-10-02T02:07:50Z", "message": "Using new IPC Server library"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8230ba0ee8f170be884279d373ec2554761d53b7", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8230ba0ee8f170be884279d373ec2554761d53b7", "committedDate": "2020-10-02T02:07:50Z", "message": "Using new IPC Server library"}, "afterCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8989fc7439ae6bf5c867e4ef20d0e05db4028981", "committedDate": "2020-10-02T02:17:26Z", "message": "Using new IPC Server library"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODI2ODEx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-500826811", "createdAt": "2020-10-02T02:20:47Z", "commit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMjoyMDo0OFrOHbfvXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMjoyMDo0OFrOHbfvXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5MzYzMQ==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem: While wrapping the caught exception into a custom one, information about the caught exception is being lost, including information about the stack trace of the exception.\nFix: If the caught exception object does not contain sensitive information, consider passing it as the \"rootCause\" or inner exception parameter to the constructor of the new exception before throwing the new exception. (Note that not all exception constructors support inner exceptions. Use a wrapper exception that supports inner exceptions.)\nLearn more\nSimilar issue at line numbers 113.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r498593631", "createdAt": "2020-10-02T02:20:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDQ0MjUy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-501444252", "createdAt": "2020-10-02T20:59:27Z", "commit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDo1OTo1N1rOHb7eKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowMzozOFrOHb7jug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0Nzk3Nw==", "bodyText": "use Kernel.locate instead of context.get for GreengrassServices.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499047977", "createdAt": "2020-10-02T20:59:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ComponentUpdatePolicyEvents;\n+import generated.software.amazon.awssdk.iot.greengrass.model.DeferComponentUpdateRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.DeferComponentUpdateResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PostComponentUpdateEvent;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PreComponentUpdateEvent;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UpdateStateRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UpdateStateResponse;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+import software.amazon.eventstream.iot.server.ServerStreamEventPublisher;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    private final ConcurrentHashMap<String, Set<ServerStreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            Optional<GreengrassService> service = Optional.ofNullable(kernel.getContext().get(GreengrassService.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0ODY2NA==", "bodyText": "can we still set operations after the startup? Like when CLI is a plugin will it be able to register itself after start?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499048664", "createdAt": "2020-10-02T21:01:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0ODgzOQ==", "bodyText": "wait for ELG to close.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499048839", "createdAt": "2020-10-02T21:02:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (StringUtils.isEmpty(authToken)) {\n+            String errorMessage = \"Received empty auth token to authenticate IPC client\";\n+            logger.atError().log(errorMessage);\n+            throw new RuntimeException(errorMessage);\n+        }\n+        AuthenticationData authenticationData;\n+        try {\n+            final String serviceName = authenticationHandler.doAuthentication(authToken);\n+            authenticationData = new AuthenticationData() {\n+                @Override\n+                public String getIdentityLabel() {\n+                    return serviceName;\n+                }\n+            };\n+        } catch (UnauthenticatedException e) {\n+            throw new RuntimeException(\"Unrecognized client connecting to GGC over IPC\");\n+        }\n+        return authenticationData;\n+    }\n+\n+    @Override\n+    public void close() {\n+        ipcServer.stopServer();\n+        socketOptions.close();\n+        eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0ODk0Mw==", "bodyText": "should we use more than 1 thread?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499048943", "createdAt": "2020-10-02T21:02:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTA4Nw==", "bodyText": "LOCALHOST", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499049087", "createdAt": "2020-10-02T21:02:54Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTIwNg==", "bodyText": "use our own utils. Utils.isEmpty", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499049206", "createdAt": "2020-10-02T21:03:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (StringUtils.isEmpty(authToken)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTQwMg==", "bodyText": "why are we rethrowing as unchecked?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499049402", "createdAt": "2020-10-02T21:03:38Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNDQ4MDAw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-501448000", "createdAt": "2020-10-02T21:06:36Z", "commit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowNjozNlrOHb7oWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowNjozNlrOHb7oWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MDU4NQ==", "bodyText": "can we setup their log to write to our own slf4j logger?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499050585", "createdAt": "2020-10-02T21:06:36Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/ipc/IPCEventStreamServiceTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.Log;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.AuthenticationHandler;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.AuthorizationHandler;\n+\n+import java.io.IOException;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class IPCEventStreamServiceTest {\n+    private IPCEventStreamService ipcEventStreamService;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    //    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    protected static ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    static {\n+        Log.initLoggingToFile(Log.LogLevel.Trace, \"crt.log\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 35}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1c465fd16fe89345fc744e96da15aa03044da4e4", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1c465fd16fe89345fc744e96da15aa03044da4e4", "committedDate": "2020-10-06T06:50:14Z", "message": "Making lifecycle APIs work"}, "afterCommit": {"oid": "dd23fb622acdc7d31e9c61ad4c70dd06d5f107cc", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dd23fb622acdc7d31e9c61ad4c70dd06d5f107cc", "committedDate": "2020-10-06T07:03:13Z", "message": "Making lifecycle APIs work"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd23fb622acdc7d31e9c61ad4c70dd06d5f107cc", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dd23fb622acdc7d31e9c61ad4c70dd06d5f107cc", "committedDate": "2020-10-06T07:03:13Z", "message": "Making lifecycle APIs work"}, "afterCommit": {"oid": "08514475cb16f79714ead10249abd3c019d0ae24", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/08514475cb16f79714ead10249abd3c019d0ae24", "committedDate": "2020-10-06T21:04:00Z", "message": "Making lifecycle APIs work"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "748b2a66e44c2d9248e0984a7fd256dc13a5a4e4", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/748b2a66e44c2d9248e0984a7fd256dc13a5a4e4", "committedDate": "2020-10-08T08:14:25Z", "message": "Adding unit tests for IPCService, LifecycleService and LifecycleAgent"}, "afterCommit": {"oid": "ab342252ecd78bca2cc921f1e360fb791898a7b4", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab342252ecd78bca2cc921f1e360fb791898a7b4", "committedDate": "2020-10-13T01:25:21Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab342252ecd78bca2cc921f1e360fb791898a7b4", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab342252ecd78bca2cc921f1e360fb791898a7b4", "committedDate": "2020-10-13T01:25:21Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}, "afterCommit": {"oid": "f1f9ab2e307d3a75fb14e4dc6911337dc42c8772", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f1f9ab2e307d3a75fb14e4dc6911337dc42c8772", "committedDate": "2020-10-13T08:11:22Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1f9ab2e307d3a75fb14e4dc6911337dc42c8772", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f1f9ab2e307d3a75fb14e4dc6911337dc42c8772", "committedDate": "2020-10-13T08:11:22Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}, "afterCommit": {"oid": "e864c581a102ae59b5da1f86e1a12c5ccabfb8cf", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e864c581a102ae59b5da1f86e1a12c5ccabfb8cf", "committedDate": "2020-10-13T08:13:02Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e864c581a102ae59b5da1f86e1a12c5ccabfb8cf", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e864c581a102ae59b5da1f86e1a12c5ccabfb8cf", "committedDate": "2020-10-13T08:13:02Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}, "afterCommit": {"oid": "100cdd6ecfd491ff17c1b2b01f68cd2d624a8260", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/100cdd6ecfd491ff17c1b2b01f68cd2d624a8260", "committedDate": "2020-10-13T17:37:40Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "100cdd6ecfd491ff17c1b2b01f68cd2d624a8260", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/100cdd6ecfd491ff17c1b2b01f68cd2d624a8260", "committedDate": "2020-10-13T17:37:40Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}, "afterCommit": {"oid": "9fcd63afcf364253168a29d99fe55eb10389a305", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9fcd63afcf364253168a29d99fe55eb10389a305", "committedDate": "2020-10-13T19:36:32Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3OTExMjQy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-507911242", "createdAt": "2020-10-14T00:11:43Z", "commit": {"oid": "9fcd63afcf364253168a29d99fe55eb10389a305"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMDoxMTo0M1rOHg9uCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMDoxMTo0M1rOHg9uCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMyNzY5MQ==", "bodyText": "What's 0 here? A Timeout? Will 0 mean no timeout?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r504327691", "createdAt": "2020-10-14T00:11:43Z", "author": {"login": "philcali"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -54,26 +75,39 @@\n import static org.hamcrest.Matchers.is;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n \n @ExtendWith(GGExtension.class)\n class IPCServicesTest {\n \n-    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 2;\n+    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 20;\n+    private static int TIMEOUT_FOR_LIFECYCLE_SECONDS = 20;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n \n     @TempDir\n     static Path tempRootDir;\n \n     private static Kernel kernel;\n+    private static ClientConnection clientConnection;\n     private IPCClient client;\n \n     @BeforeAll\n-    static void beforeAll() throws InterruptedException {\n+    static void beforeAll() throws InterruptedException, IOException, ExecutionException {\n         System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n         kernel = prepareKernelFromConfigFile(\"ipc.yaml\", IPCServicesTest.class, TEST_SERVICE_NAME);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        clientConnection = IPCTestUtils.connectClientForEventStreamIpc(authToken, kernel);\n     }\n \n     @AfterAll\n     static void afterAll() throws InterruptedException {\n+        if (clientConnection != null) {\n+            clientConnection.closeConnection(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd63afcf364253168a29d99fe55eb10389a305"}, "originalPosition": 103}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fcd63afcf364253168a29d99fe55eb10389a305", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9fcd63afcf364253168a29d99fe55eb10389a305", "committedDate": "2020-10-13T19:36:32Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}, "afterCommit": {"oid": "d4b046ce26fc3d541cc088b545b1fcb31b94d0af", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d4b046ce26fc3d541cc088b545b1fcb31b94d0af", "committedDate": "2020-10-14T01:12:59Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f20de9e1a21436dcf753aead8019b205b17707ab", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f20de9e1a21436dcf753aead8019b205b17707ab", "committedDate": "2020-10-15T17:42:14Z", "message": "Removing windows from build"}, "afterCommit": {"oid": "f5f9c36033c2e9349dca71783093b95bdae32ee7", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f5f9c36033c2e9349dca71783093b95bdae32ee7", "committedDate": "2020-10-15T17:43:07Z", "message": "Removing windows from build"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTYxMzA3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-512161307", "createdAt": "2020-10-19T21:09:23Z", "commit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTowOToyM1rOHkhv4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTozNDo1NlrOHkihKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2MzcxMw==", "bodyText": "Low priority obviously, but builders or setters with builder pattern would be nice", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508063713", "createdAt": "2020-10-19T21:09:23Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -80,10 +88,18 @@\n class DeploymentConfigMergingTest extends BaseITCase {\n     private Kernel kernel;\n     private DeploymentConfigMerger deploymentConfigMerger;\n+    private static SocketOptions socketOptions;\n+\n+    @BeforeAll\n+    void initialize() {\n+        socketOptions = new SocketOptions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2Njk2MQ==", "bodyText": "should log this or something so that it can fail the test if some error occurs.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508066961", "createdAt": "2020-10-19T21:15:42Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -461,32 +485,48 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n-        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n-        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n-\n         AtomicInteger deferCount = new AtomicInteger(0);\n         AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n         CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n-        lifecycle.subscribeToComponentUpdate((event) -> {\n-\n-            if (event instanceof PreComponentUpdateEvent) {\n-                preComponentUpdateCount.getAndIncrement();\n-                //defer update the first time\n-                //no response the second time causes the kernel to move forward after default wait time\n-                if (deferCount.get() < 1) {\n-                    try {\n-                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n-                        deferCount.getAndIncrement();\n-                    } catch (LifecycleIPCException e) {\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"nondisruptable\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        final EventStreamRPCConnection clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions,\n+                authToken,\n+                kernel);\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToComponentUpdatesRequest subscribeToComponentUpdatesRequest = new SubscribeToComponentUpdatesRequest();\n+        greengrassCoreIPCClient.subscribeToComponentUpdates(subscribeToComponentUpdatesRequest,\n+                Optional.of(new StreamResponseHandler<ComponentUpdatePolicyEvents>() {\n+                    @Override\n+                    public void onStreamEvent(ComponentUpdatePolicyEvents streamEvent) {\n+                        if (streamEvent.getPreUpdateEvent() != null) {\n+                            preComponentUpdateCount.getAndIncrement();\n+                            if (deferCount.get() < 1) {\n+                                DeferComponentUpdateRequest deferComponentUpdateRequest = new DeferComponentUpdateRequest();\n+                                deferComponentUpdateRequest.setRecheckAfterMs(Duration.ofSeconds(5).toMillis());\n+                                deferComponentUpdateRequest.setMessage(\"Test\");\n+                                greengrassCoreIPCClient.deferComponentUpdate(deferComponentUpdateRequest,\n+                                        Optional.empty());\n+                                deferCount.getAndIncrement();\n+                            } if (streamEvent.getPostUpdateEvent() != null) {\n+                                postComponentUpdateRecieved.countDown();\n+                                clientConnection.disconnect();\n+                            }\n+                        }\n+                    }\n+\n+                    @Override\n+                    public boolean onStreamError(Throwable error) {\n+                        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2NzQ1OQ==", "bodyText": "extract to method? This is showing up a lot", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508067459", "createdAt": "2020-10-19T21:16:34Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -58,22 +80,39 @@\n @ExtendWith(GGExtension.class)\n class IPCServicesTest {\n \n-    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 2;\n+    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 20;\n+    private static int TIMEOUT_FOR_LIFECYCLE_SECONDS = 20;\n \n     @TempDir\n     static Path tempRootDir;\n \n     private static Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n     private IPCClient client;\n+    private static SocketOptions socketOptions;\n \n     @BeforeAll\n-    static void beforeAll() throws InterruptedException {\n+    static void beforeAll() throws InterruptedException, IOException, ExecutionException {\n         System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n         kernel = prepareKernelFromConfigFile(\"ipc.yaml\", IPCServicesTest.class, TEST_SERVICE_NAME);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2ODc2NQ==", "bodyText": "no getOnce when using Coerce", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508068765", "createdAt": "2020-10-19T21:19:13Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                        .find(VERSION_CONFIG_KEY).getOnce()));\n+            }\n+            if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                componentDetails\n+                        .setConfiguration(service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+            }\n+            GetComponentDetailsResponse response = new GetComponentDetailsResponse();\n+            response.setComponentDetails(componentDetails);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateGetComponentDetailsRequest(GetComponentDetailsRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class ListComponentsHandler extends GeneratedAbstractListComponentsOperationHandler {\n+\n+        public ListComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListComponentsResponse handleRequest(ListComponentsRequest request) {\n+            Collection<GreengrassService> services = kernel.orderedDependencies();\n+            List<ComponentDetails> listOfComponents =\n+                    services.stream().filter(service -> !service.getName().equals(kernel.getMain().getName()))\n+                            .map(service -> {\n+                                ComponentDetails componentDetails = new ComponentDetails();\n+                                componentDetails.setComponentName(service.getName());\n+                                componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+                                if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                                    componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                                                    .find(VERSION_CONFIG_KEY).getOnce()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2OTcyMg==", "bodyText": "This isn't logging. Use .log(\"text\")", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508069722", "createdAt": "2020-10-19T21:21:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,258 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo(\"Stream closed for subscribeToComponentUpdate\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MTk0MA==", "bodyText": "why doesn't the SDK deserialize this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508071940", "createdAt": "2020-10-19T21:25:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String KERNEL_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_KERNEL_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MjEwMw==", "bodyText": "also wait for the elg to shutdown, like 2 seconds", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508072103", "createdAt": "2020-10-19T21:26:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String KERNEL_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_KERNEL_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().setCause(e).log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (Utils.isEmpty(authToken)) {\n+            String errorMessage = \"Received empty auth token to authenticate IPC client\";\n+            logger.atError().log(errorMessage);\n+            throw new RuntimeException(errorMessage);\n+        }\n+        AuthenticationData authenticationData;\n+        try {\n+            final String serviceName = authenticationHandler.doAuthentication(authToken);\n+            authenticationData = new AuthenticationData() {\n+                @Override\n+                public String getIdentityLabel() {\n+                    return serviceName;\n+                }\n+            };\n+        } catch (UnauthenticatedException e) {\n+            throw new RuntimeException(\"Unrecognized client connecting to GGC over IPC\");\n+        }\n+        return authenticationData;\n+    }\n+\n+    @Override\n+    public void close() {\n+        // TODO: Future does not complete, wait on them when fixed.\n+        if (ipcServer != null) {\n+            ipcServer.stopServer();\n+        }\n+        if (eventLoopGroup != null) {\n+            eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3NTQ5NQ==", "bodyText": "why is this differetn?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508075495", "createdAt": "2020-10-19T21:33:07Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/testcommons/testutilities/SpawnedProcessProtector.java", "diffHunk": "@@ -33,6 +33,17 @@ public void afterEach(ExtensionContext context) throws Exception {\n             System.err.println(\n                     \"Child PID not cleaned after test case \" + context.getDisplayName() + \". Child PIDs: \" + String\n                             .join(\", \", childPids));\n+            for (String pid : childPids) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3NjMyOA==", "bodyText": "gg extension", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508076328", "createdAt": "2020-10-19T21:34:56Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/ipc/IPCEventStreamServiceTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.ClientConnection;\n+import software.amazon.awssdk.crt.eventstream.ClientConnectionHandler;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.eventstream.MessageType;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthorizationHandler;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.ipc.IPCEventStreamService.DEFAULT_PORT_NUMBER;\n+import static com.aws.greengrass.ipc.IPCEventStreamService.IPC_SERVER_DOMAIN_SOCKET_FILENAME;\n+import static com.aws.greengrass.ipc.IPCEventStreamService.KERNEL_DOMAIN_SOCKET_FILEPATH;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4a916125224bb8671a8c3ac0bf69aee35994f835", "committedDate": "2020-10-19T19:34:30Z", "message": "Updating the event stream rpc server, client and model to latest. Also updating the Greengrass IPC model to latest generated code"}, "afterCommit": {"oid": "32a04ac56397bf0c3aeccafe40a2c9cfb09d5837", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/32a04ac56397bf0c3aeccafe40a2c9cfb09d5837", "committedDate": "2020-10-19T22:46:51Z", "message": "Updating the event stream rpc server, client and model to latest. Also updating the Greengrass IPC model to latest generated code"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5f03199e2200b84e8333351159304fefc11987b6", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5f03199e2200b84e8333351159304fefc11987b6", "committedDate": "2020-10-20T01:49:42Z", "message": "Addressing review comments"}, "afterCommit": {"oid": "c2493cd5a9c63dc4b8540073171ddfd78ee39950", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c2493cd5a9c63dc4b8540073171ddfd78ee39950", "committedDate": "2020-10-20T01:52:32Z", "message": "Addressing review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c2493cd5a9c63dc4b8540073171ddfd78ee39950", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c2493cd5a9c63dc4b8540073171ddfd78ee39950", "committedDate": "2020-10-20T01:52:32Z", "message": "Addressing review comments"}, "afterCommit": {"oid": "928b18a4b89be35f02b7fba9e86677fb015d40c9", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/928b18a4b89be35f02b7fba9e86677fb015d40c9", "committedDate": "2020-10-20T02:05:08Z", "message": "Addressing review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "928b18a4b89be35f02b7fba9e86677fb015d40c9", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/928b18a4b89be35f02b7fba9e86677fb015d40c9", "committedDate": "2020-10-20T02:05:08Z", "message": "Addressing review comments"}, "afterCommit": {"oid": "8f03b585b6e3e45e86bf5fd3df69c9711ce1427c", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8f03b585b6e3e45e86bf5fd3df69c9711ce1427c", "committedDate": "2020-10-20T08:18:38Z", "message": "Addressing review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f03b585b6e3e45e86bf5fd3df69c9711ce1427c", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8f03b585b6e3e45e86bf5fd3df69c9711ce1427c", "committedDate": "2020-10-20T08:18:38Z", "message": "Addressing review comments"}, "afterCommit": {"oid": "353f9ac7f027094b65332da6159504cafa729875", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/353f9ac7f027094b65332da6159504cafa729875", "committedDate": "2020-10-20T08:19:41Z", "message": "Addressing review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aed6946205fe1188d1c24265c514dd574bfbd92d", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/aed6946205fe1188d1c24265c514dd574bfbd92d", "committedDate": "2020-10-20T20:15:00Z", "message": "Fixing some bugs in tests"}, "afterCommit": {"oid": "d0c5d671852cef208ebc0bca689e40c0b601a319", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d0c5d671852cef208ebc0bca689e40c0b601a319", "committedDate": "2020-10-20T20:48:15Z", "message": "Fixing some bugs in tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90d644afdb93b08b8bc35b4ce2b1505fc051ed10", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/90d644afdb93b08b8bc35b4ce2b1505fc051ed10", "committedDate": "2020-10-21T00:20:11Z", "message": "Fixing IPCServicesTest"}, "afterCommit": {"oid": "8450fcccd7094212caf90e2d20bdb481dd744ecc", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8450fcccd7094212caf90e2d20bdb481dd744ecc", "committedDate": "2020-10-21T00:25:01Z", "message": "Fixing IPCServicesTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjQwODc1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-513240875", "createdAt": "2020-10-21T01:17:02Z", "commit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxNzowMlrOHlWv6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxNzowMlrOHlWv6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjA3Mw==", "bodyText": "can we bump this back up?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508932073", "createdAt": "2020-10-21T01:17:02Z", "author": {"login": "MikeDombo"}, "path": "pom.xml", "diffHunk": "@@ -35,7 +36,7 @@\n         <dependency>\n             <groupId>org.mockito</groupId>\n             <artifactId>mockito-junit-jupiter</artifactId>\n-            <version>3.5.13</version>\n+            <version>3.5.6</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjQxMTAx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-513241101", "createdAt": "2020-10-21T01:17:44Z", "commit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxNzo0NFrOHlWwwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozODoyN1rOHlXGDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjI5MA==", "bodyText": "clean shouldn't be needed because github actions uses a fresh workspace every time.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508932290", "createdAt": "2020-10-21T01:17:44Z", "author": {"login": "MikeDombo"}, "path": ".github/workflows/maven.yml", "diffHunk": "@@ -30,7 +30,7 @@ jobs:\n         shell: cmd\n         if: matrix.os == 'Windows'\n       - name: Build with Maven\n-        run: mvn -ntp -U verify\n+        run: mvn -ntp -U clean verify", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjM5Nw==", "bodyText": "this should be extracted to a common util", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508932397", "createdAt": "2020-10-21T01:18:14Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -461,32 +485,49 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n-        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n-        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n-\n         AtomicInteger deferCount = new AtomicInteger(0);\n         AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n         CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n-        lifecycle.subscribeToComponentUpdate((event) -> {\n-\n-            if (event instanceof PreComponentUpdateEvent) {\n-                preComponentUpdateCount.getAndIncrement();\n-                //defer update the first time\n-                //no response the second time causes the kernel to move forward after default wait time\n-                if (deferCount.get() < 1) {\n-                    try {\n-                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n-                        deferCount.getAndIncrement();\n-                    } catch (LifecycleIPCException e) {\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"nondisruptable\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMzM4Mw==", "bodyText": "log?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508933383", "createdAt": "2020-10-21T01:22:17Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -869,25 +881,41 @@ void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_roll\n \n     @Test\n     @Order(8)\n+    @SuppressWarnings(\"PMD.CloseResource\")\n     void GIVEN_deployment_in_progress_WHEN_deployment_task_is_cancelled_THEN_stop_processing() throws Exception {\n         Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n                 DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n                 System.currentTimeMillis());\n         resultFuture.get(30, TimeUnit.SECONDS);\n \n-        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"NonDisruptableService\", kernel);\n-        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n-        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n-\n-        lifecycle.subscribeToComponentUpdate((event) -> {\n-            if (event instanceof PreComponentUpdateEvent) {\n-                try {\n-                    lifecycle.deferComponentUpdate(\"NonDisruptableService\", TimeUnit.SECONDS.toMillis(60));\n-                    ipcClient.disconnect();\n-                } catch (LifecycleIPCException e) {\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"NonDisruptableService\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        final EventStreamRPCConnection clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions,\n+                authToken, kernel);\n+        SubscribeToComponentUpdatesRequest subscribeToComponentUpdatesRequest = new SubscribeToComponentUpdatesRequest();\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        greengrassCoreIPCClient.subscribeToComponentUpdates(subscribeToComponentUpdatesRequest, Optional.of(new StreamResponseHandler<ComponentUpdatePolicyEvents>() {\n+            @Override\n+            public void onStreamEvent(ComponentUpdatePolicyEvents streamEvent) {\n+                if (streamEvent.getPreUpdateEvent() != null ) {\n+                    DeferComponentUpdateRequest deferComponentUpdateRequest = new DeferComponentUpdateRequest();\n+                    deferComponentUpdateRequest.setRecheckAfterMs(Duration.ofSeconds(60).toMillis());\n+                    deferComponentUpdateRequest.setMessage(\"Test\");\n+                    greengrassCoreIPCClient.deferComponentUpdate(deferComponentUpdateRequest, Optional.empty());\n                 }\n             }\n-        });\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMzgyMQ==", "bodyText": "no getOnce when using coerce", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508933821", "createdAt": "2020-10-21T01:23:54Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNDAwNg==", "bodyText": "why suppress the warning, why not just make this a static class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508934006", "createdAt": "2020-10-21T01:24:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                        .find(VERSION_CONFIG_KEY).getOnce()));\n+            }\n+            if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                componentDetails\n+                        .setConfiguration(service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+            }\n+            GetComponentDetailsResponse response = new GetComponentDetailsResponse();\n+            response.setComponentDetails(componentDetails);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateGetComponentDetailsRequest(GetComponentDetailsRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class ListComponentsHandler extends GeneratedAbstractListComponentsOperationHandler {\n+\n+        public ListComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListComponentsResponse handleRequest(ListComponentsRequest request) {\n+            Collection<GreengrassService> services = kernel.orderedDependencies();\n+            List<ComponentDetails> listOfComponents =\n+                    services.stream().filter(service -> !service.getName().equals(kernel.getMain().getName()))\n+                            .map(service -> {\n+                                ComponentDetails componentDetails = new ComponentDetails();\n+                                componentDetails.setComponentName(service.getName());\n+                                componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+                                if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                                    componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                                                    .find(VERSION_CONFIG_KEY)));\n+                                }\n+                                if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                                    componentDetails.setConfiguration(service.getServiceConfig()\n+                                            .findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+                                }\n+                                return componentDetails;\n+                            }).collect(Collectors.toList());\n+            ListComponentsResponse response = new ListComponentsResponse();\n+            response.setComponents(listOfComponents);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class RestartComponentsHandler extends GeneratedAbstractRestartComponentOperationHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNDE5Mw==", "bodyText": "this is out of date from mainline. I have a new way of handling recipes", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508934193", "createdAt": "2020-10-21T01:25:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                        .find(VERSION_CONFIG_KEY).getOnce()));\n+            }\n+            if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                componentDetails\n+                        .setConfiguration(service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+            }\n+            GetComponentDetailsResponse response = new GetComponentDetailsResponse();\n+            response.setComponentDetails(componentDetails);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateGetComponentDetailsRequest(GetComponentDetailsRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class ListComponentsHandler extends GeneratedAbstractListComponentsOperationHandler {\n+\n+        public ListComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListComponentsResponse handleRequest(ListComponentsRequest request) {\n+            Collection<GreengrassService> services = kernel.orderedDependencies();\n+            List<ComponentDetails> listOfComponents =\n+                    services.stream().filter(service -> !service.getName().equals(kernel.getMain().getName()))\n+                            .map(service -> {\n+                                ComponentDetails componentDetails = new ComponentDetails();\n+                                componentDetails.setComponentName(service.getName());\n+                                componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+                                if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                                    componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                                                    .find(VERSION_CONFIG_KEY)));\n+                                }\n+                                if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                                    componentDetails.setConfiguration(service.getServiceConfig()\n+                                            .findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+                                }\n+                                return componentDetails;\n+                            }).collect(Collectors.toList());\n+            ListComponentsResponse response = new ListComponentsResponse();\n+            response.setComponents(listOfComponents);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class RestartComponentsHandler extends GeneratedAbstractRestartComponentOperationHandler {\n+\n+        public RestartComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public RestartComponentResponse handleRequest(RestartComponentRequest request) {\n+            validateRestartComponentRequest(request);\n+            String componentName = request.getComponentName();\n+            try {\n+                GreengrassService service = kernel.locate(componentName);\n+                // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+                // Success of this request means restart was triggered successfully\n+                service.requestRestart();\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            RestartComponentResponse response =  new RestartComponentResponse();\n+            response.setRestartStatus(RequestStatus.SUCCEEDED);\n+            return  response;\n+        }\n+\n+        private void validateRestartComponentRequest(RestartComponentRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class StopComponentHandler extends GeneratedAbstractStopComponentOperationHandler {\n+\n+        public StopComponentHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public StopComponentResponse handleRequest(StopComponentRequest request) {\n+            validateStopComponentRequest(request);\n+            String componentName = request.getComponentName();\n+            try {\n+                GreengrassService service = kernel.locate(componentName);\n+                // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+                // Success of this request means stop was triggered successfully\n+                service.requestStop();\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            StopComponentResponse response = new StopComponentResponse();\n+            response.setStopStatus(RequestStatus.SUCCEEDED);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateStopComponentRequest(StopComponentRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    class UpdateRecipesAndArtifactsHandler extends GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler {\n+\n+        public UpdateRecipesAndArtifactsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateRecipesAndArtifactsResponse handleRequest(UpdateRecipesAndArtifactsRequest request) {\n+            validateUpdateRecipesAndArtifactsRequest(request);\n+            Path kernelPackageStorePath = kernel.getNucleusPaths().componentStorePath();\n+            if (!Utils.isEmpty(request.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+                Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(ComponentStore.RECIPE_DIRECTORY);\n+                try {\n+                    if (recipeDirectoryPath.equals(kernelPackageStorePath)) {\n+                        logger.atWarn().log(\"Requested recipe directory path is same as kernel recipe \"\n+                                + \"directory path. Nothing to do\");\n+                    } else {\n+                        Utils.copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNDY2Nw==", "bodyText": "formatting", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508934667", "createdAt": "2020-10-21T01:27:03Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                        .find(VERSION_CONFIG_KEY).getOnce()));\n+            }\n+            if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                componentDetails\n+                        .setConfiguration(service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+            }\n+            GetComponentDetailsResponse response = new GetComponentDetailsResponse();\n+            response.setComponentDetails(componentDetails);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateGetComponentDetailsRequest(GetComponentDetailsRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class ListComponentsHandler extends GeneratedAbstractListComponentsOperationHandler {\n+\n+        public ListComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListComponentsResponse handleRequest(ListComponentsRequest request) {\n+            Collection<GreengrassService> services = kernel.orderedDependencies();\n+            List<ComponentDetails> listOfComponents =\n+                    services.stream().filter(service -> !service.getName().equals(kernel.getMain().getName()))\n+                            .map(service -> {\n+                                ComponentDetails componentDetails = new ComponentDetails();\n+                                componentDetails.setComponentName(service.getName());\n+                                componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+                                if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                                    componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                                                    .find(VERSION_CONFIG_KEY)));\n+                                }\n+                                if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                                    componentDetails.setConfiguration(service.getServiceConfig()\n+                                            .findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+                                }\n+                                return componentDetails;\n+                            }).collect(Collectors.toList());\n+            ListComponentsResponse response = new ListComponentsResponse();\n+            response.setComponents(listOfComponents);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class RestartComponentsHandler extends GeneratedAbstractRestartComponentOperationHandler {\n+\n+        public RestartComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public RestartComponentResponse handleRequest(RestartComponentRequest request) {\n+            validateRestartComponentRequest(request);\n+            String componentName = request.getComponentName();\n+            try {\n+                GreengrassService service = kernel.locate(componentName);\n+                // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+                // Success of this request means restart was triggered successfully\n+                service.requestRestart();\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            RestartComponentResponse response =  new RestartComponentResponse();\n+            response.setRestartStatus(RequestStatus.SUCCEEDED);\n+            return  response;\n+        }\n+\n+        private void validateRestartComponentRequest(RestartComponentRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class StopComponentHandler extends GeneratedAbstractStopComponentOperationHandler {\n+\n+        public StopComponentHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public StopComponentResponse handleRequest(StopComponentRequest request) {\n+            validateStopComponentRequest(request);\n+            String componentName = request.getComponentName();\n+            try {\n+                GreengrassService service = kernel.locate(componentName);\n+                // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+                // Success of this request means stop was triggered successfully\n+                service.requestStop();\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            StopComponentResponse response = new StopComponentResponse();\n+            response.setStopStatus(RequestStatus.SUCCEEDED);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateStopComponentRequest(StopComponentRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    class UpdateRecipesAndArtifactsHandler extends GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler {\n+\n+        public UpdateRecipesAndArtifactsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateRecipesAndArtifactsResponse handleRequest(UpdateRecipesAndArtifactsRequest request) {\n+            validateUpdateRecipesAndArtifactsRequest(request);\n+            Path kernelPackageStorePath = kernel.getNucleusPaths().componentStorePath();\n+            if (!Utils.isEmpty(request.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+                Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(ComponentStore.RECIPE_DIRECTORY);\n+                try {\n+                    if (recipeDirectoryPath.equals(kernelPackageStorePath)) {\n+                        logger.atWarn().log(\"Requested recipe directory path is same as kernel recipe \"\n+                                + \"directory path. Nothing to do\");\n+                    } else {\n+                        Utils.copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath,\n+                                StandardCopyOption.REPLACE_EXISTING);\n+                    }\n+                } catch (IOException e) {\n+                    logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                            .log(\"Caught exception while updating the recipes\");\n+                    throw new InvalidRecipeDirectoryPathError(e.getMessage());\n+                }\n+            }\n+            if (!Utils.isEmpty(request.getArtifactsDirectoryPath())) {\n+                Path artifactsDirectoryPath = Paths.get(request.getArtifactsDirectoryPath());\n+                Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(ComponentStore.ARTIFACT_DIRECTORY);\n+                try {\n+                    if (artifactsDirectoryPath.equals(kernelArtifactsDirectoryPath)) {\n+                        logger.atWarn().log(\"Requested artifacts directory path is same as kernel artifacts \"\n+                                + \"directory path. Nothing to do\");\n+                    } else {\n+                        Utils.copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath,\n+                                StandardCopyOption.REPLACE_EXISTING);\n+                    }\n+                } catch (IOException e) {\n+                    logger.atError().setCause(e).kv(\"Artifact Directory path\", artifactsDirectoryPath)\n+                            .log(\"Caught exception while updating the recipes\");\n+                    throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+                }\n+            }\n+            return new UpdateRecipesAndArtifactsResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateUpdateRecipesAndArtifactsRequest(UpdateRecipesAndArtifactsRequest request) {\n+            String recipeDirectoryPath = request.getRecipeDirectoryPath();\n+            String artifactsDirectoryPath = request.getArtifactsDirectoryPath();\n+            if (StringUtils.isEmpty(recipeDirectoryPath) && StringUtils.isEmpty(artifactsDirectoryPath)) {\n+                throw new InvalidArgumentsError(\"Need to provide at least one of the directory paths to update\");\n+            }\n+        }\n+    }\n+\n+    class CreateLocalDeploymentHandler extends GeneratedAbstractCreateLocalDeploymentOperationHandler {\n+\n+        private final Topics cliServiceConfig;\n+\n+        public CreateLocalDeploymentHandler(OperationContinuationHandlerContext context, Topics cliServiceConfig) {\n+            super(context);\n+            this.cliServiceConfig = cliServiceConfig;\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public CreateLocalDeploymentResponse handleRequest(CreateLocalDeploymentRequest request) {\n+            //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with\n+            // new recipes set using the updateRecipesAndArtifacts API.\n+            String deploymentId = UUID.randomUUID().toString();\n+\n+            LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                    .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                    .componentsToRemove(request.getRootComponentsToRemove())\n+                    .requestTimestamp(System.currentTimeMillis())\n+                    .groupName(request.getGroupName() == null || request.getGroupName().isEmpty() ? DEFAULT_GROUP_NAME\n+                            : request.getGroupName())\n+                    .componentNameToConfig(request.getComponentToConfiguration()).build();\n+            String deploymentDocument;\n+            try {\n+                deploymentDocument = OBJECT_MAPPER.writeValueAsString(localOverrideRequest);\n+            } catch (JsonProcessingException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while parsing local deployment request\");\n+                throw new ServiceError(e.getMessage());\n+            }\n+            Deployment deployment = new Deployment(deploymentDocument, Deployment.DeploymentType.LOCAL, deploymentId);\n+            if (deploymentQueue == null) {\n+                logger.atError().log(\"Deployments queue not initialized\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+            } else {\n+                // save the deployment status as queued\n+                LocalDeploymentDetails localDeploymentDetails = new LocalDeploymentDetails();\n+                localDeploymentDetails.setDeploymentId(deploymentId);\n+                localDeploymentDetails.setDeploymentType(Deployment.DeploymentType.LOCAL);\n+                localDeploymentDetails.setStatus(DeploymentStatus.QUEUED);\n+                persistLocalDeployment(cliServiceConfig, localDeploymentDetails.convertToMapOfObject());\n+                if (deploymentQueue.offer(deployment)) {\n+                    logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                    CreateLocalDeploymentResponse createLocalDeploymentResponse = new CreateLocalDeploymentResponse();\n+                    createLocalDeploymentResponse.setDeploymentId(deploymentId);\n+                    return createLocalDeploymentResponse;\n+                } else {\n+                    logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                            .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                    throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+            //NA\n+        }\n+    }\n+\n+    class GetLocalDeploymentStatusHandler extends GeneratedAbstractGetLocalDeploymentStatusOperationHandler {\n+\n+        private final Topics cliServiceConfig;\n+\n+        public GetLocalDeploymentStatusHandler(OperationContinuationHandlerContext context, Topics cliServiceConfig) {\n+            super(context);\n+            this.cliServiceConfig = cliServiceConfig;\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public GetLocalDeploymentStatusResponse handleRequest(GetLocalDeploymentStatusRequest request) {\n+            validateGetLocalDeploymentStatusRequest(request);\n+            Topics localDeployments = cliServiceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+            if (localDeployments == null || localDeployments.findTopics(request.getDeploymentId()) == null) {\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Cannot find deployment\");\n+                rnf.setResourceType(LOCAL_DEPLOYMENT_RESOURCE);\n+                rnf.setResourceName(request.getDeploymentId());\n+                throw rnf;\n+            } else {\n+                Topics deployment = localDeployments.findTopics(request.getDeploymentId());\n+                DeploymentStatus status =\n+                        deploymentStatusFromString(Coerce.toString(deployment.find(DEPLOYMENT_STATUS_KEY_NAME)));\n+                GetLocalDeploymentStatusResponse response = new GetLocalDeploymentStatusResponse();\n+                LocalDeployment localDeployment = new LocalDeployment();\n+                localDeployment.setDeploymentId(request.getDeploymentId());\n+                localDeployment.setStatus(status);\n+                response.setDeployment(localDeployment);\n+                return response;\n+            }\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        private void validateGetLocalDeploymentStatusRequest(GetLocalDeploymentStatusRequest request) {\n+            try {\n+                UUID.fromString(request.getDeploymentId());\n+            } catch (IllegalArgumentException e) {\n+                throw new InvalidArgumentsError(\"Invalid deploymentId format received. DeploymentId is a UUID\");\n+            }\n+        }\n+    }\n+\n+    class ListLocalDeploymentsHandler extends GeneratedAbstractListLocalDeploymentsOperationHandler {\n+\n+        private final Topics cliServiceConfig;\n+\n+        public ListLocalDeploymentsHandler(OperationContinuationHandlerContext context, Topics cliServiceConfig) {\n+            super(context);\n+            this.cliServiceConfig = cliServiceConfig;\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListLocalDeploymentsResponse handleRequest(ListLocalDeploymentsRequest request) {\n+            List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+            Topics localDeployments = cliServiceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+            localDeployments.forEach(topic -> {\n+                Topics topics = (Topics) topic;\n+                LocalDeployment localDeployment = new LocalDeployment();\n+                localDeployment.setDeploymentId(topics.getName());\n+                localDeployment.setStatus(deploymentStatusFromString(Coerce.toString(\n+                        topics.find(DEPLOYMENT_STATUS_KEY_NAME))));\n+                persistedDeployments.add(localDeployment);\n+            });\n+            ListLocalDeploymentsResponse response = new ListLocalDeploymentsResponse();\n+            response.setLocalDeployments(persistedDeployments);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    private void validateComponentName(String componentName) {\n+        if (Utils.isEmpty(componentName)) {\n+            throw new InvalidArgumentsError(\"Component name cannot be empty\");\n+        }\n+    }\n+\n+    private DeploymentStatus deploymentStatusFromString(String status) {\n+        for (DeploymentStatus ds: DeploymentStatus.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 561}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNTAwNQ==", "bodyText": "I'm a bit worried about all these changes. I'm sure you thought it through, but most of the interface is in the \"service\" and not the agent. It should be possible to mostly change the service and then the agent logic could remain mostly the same", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508935005", "createdAt": "2020-10-21T01:28:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNTU3Mw==", "bodyText": "Timeout is fine, just log it. I added the same for mqtt and iot connection helper.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508935573", "createdAt": "2020-10-21T01:30:30Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String KERNEL_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_KERNEL_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().setCause(e).log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (Utils.isEmpty(authToken)) {\n+            String errorMessage = \"Received empty auth token to authenticate IPC client\";\n+            logger.atError().log(errorMessage);\n+            throw new RuntimeException(errorMessage);\n+        }\n+        AuthenticationData authenticationData;\n+        try {\n+            final String serviceName = authenticationHandler.doAuthentication(authToken);\n+            authenticationData = new AuthenticationData() {\n+                @Override\n+                public String getIdentityLabel() {\n+                    return serviceName;\n+                }\n+            };\n+        } catch (UnauthenticatedException e) {\n+            throw new RuntimeException(\"Unrecognized client connecting to GGC over IPC\");\n+        }\n+        return authenticationData;\n+    }\n+\n+    @Override\n+    public void close() {\n+        // TODO: Future does not complete, wait on them when fixed.\n+        if (ipcServer != null) {\n+            ipcServer.stopServer();\n+        }\n+        if (eventLoopGroup != null) {\n+            eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MjEwMw=="}, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzMzOA==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937338", "createdAt": "2020-10-21T01:37:03Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzM3NQ==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937375", "createdAt": "2020-10-21T01:37:11Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzU4NA==", "bodyText": "use assert throws. It returns the exception so you can validate the message", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937584", "createdAt": "2020-10-21T01:37:55Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(mockMainService.getName()).thenReturn(\"main\");\n+        when(kernel.getMain()).thenReturn(mockMainService);\n+        when(kernel.orderedDependencies()).thenReturn(Arrays.asList(mockTestService, mockMainService));\n+        ListComponentsResponse response =\n+                cliEventStreamAgent.getListComponentsHandler(mockContext).handleRequest(request);\n+        assertEquals(1, response.getComponents().size());\n+        ComponentDetails componentDetails = response.getComponents().get(0);\n+        assertEquals(TEST_SERVICE, componentDetails.getComponentName());\n+        assertEquals(mockParameterConfig, componentDetails.getConfiguration());\n+        assertEquals(\"1.0.0\", componentDetails.getVersion());\n+    }\n+\n+    @Test\n+    public void testRestartComponent_emptyComponentName() {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_restart() throws ServiceLoadException {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest);\n+        verify(mockTestService).requestRestart();\n+    }\n+\n+    @Test\n+    public void testStopComponent_emptyComponentName() {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_restart() throws ServiceLoadException {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest);\n+        verify(mockTestService).requestStop();\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_empty_paths() {\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_invalid_paths(ExtensionContext context) {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        request.setArtifactsDirectoryPath(\"/InvalidPath\");\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        assertThrows(InvalidArtifactsDirectoryPathError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_successful_update(ExtensionContext context) throws IOException {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        Path mockArtifactsDirectoryPath = Files.createTempDirectory(\"mockArtifactsDirectoryPath\");\n+        request.setArtifactsDirectoryPath(mockArtifactsDirectoryPath.toString());\n+        Path mockRecipesDirectoryPath = Files.createTempDirectory(\"mockRecipesDirectoryPath\");\n+        request.setRecipeDirectoryPath(mockRecipesDirectoryPath.toString());\n+        Path componentPath = Files.createDirectories(mockRecipesDirectoryPath.resolve(\"SampleComponent-1.0.0\"));\n+        Files.createFile(componentPath.resolve(\"sampleRecipe.xml\"));\n+        Files.createFile(mockArtifactsDirectoryPath.resolve(\"artifact.zip\"));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY));\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request);\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY)\n+                .resolve(\"SampleComponent-1.0.0\").resolve(\"sampleRecipe.xml\")));\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY).resolve(\"artifact.zip\")));\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_deployments_Q_not_initialized() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+       try {\n+            cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzY3NQ==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937675", "createdAt": "2020-10-21T01:38:14Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(mockMainService.getName()).thenReturn(\"main\");\n+        when(kernel.getMain()).thenReturn(mockMainService);\n+        when(kernel.orderedDependencies()).thenReturn(Arrays.asList(mockTestService, mockMainService));\n+        ListComponentsResponse response =\n+                cliEventStreamAgent.getListComponentsHandler(mockContext).handleRequest(request);\n+        assertEquals(1, response.getComponents().size());\n+        ComponentDetails componentDetails = response.getComponents().get(0);\n+        assertEquals(TEST_SERVICE, componentDetails.getComponentName());\n+        assertEquals(mockParameterConfig, componentDetails.getConfiguration());\n+        assertEquals(\"1.0.0\", componentDetails.getVersion());\n+    }\n+\n+    @Test\n+    public void testRestartComponent_emptyComponentName() {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_restart() throws ServiceLoadException {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest);\n+        verify(mockTestService).requestRestart();\n+    }\n+\n+    @Test\n+    public void testStopComponent_emptyComponentName() {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_restart() throws ServiceLoadException {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest);\n+        verify(mockTestService).requestStop();\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_empty_paths() {\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_invalid_paths(ExtensionContext context) {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        request.setArtifactsDirectoryPath(\"/InvalidPath\");\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        assertThrows(InvalidArtifactsDirectoryPathError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_successful_update(ExtensionContext context) throws IOException {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        Path mockArtifactsDirectoryPath = Files.createTempDirectory(\"mockArtifactsDirectoryPath\");\n+        request.setArtifactsDirectoryPath(mockArtifactsDirectoryPath.toString());\n+        Path mockRecipesDirectoryPath = Files.createTempDirectory(\"mockRecipesDirectoryPath\");\n+        request.setRecipeDirectoryPath(mockRecipesDirectoryPath.toString());\n+        Path componentPath = Files.createDirectories(mockRecipesDirectoryPath.resolve(\"SampleComponent-1.0.0\"));\n+        Files.createFile(componentPath.resolve(\"sampleRecipe.xml\"));\n+        Files.createFile(mockArtifactsDirectoryPath.resolve(\"artifact.zip\"));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY));\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request);\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY)\n+                .resolve(\"SampleComponent-1.0.0\").resolve(\"sampleRecipe.xml\")));\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY).resolve(\"artifact.zip\")));\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_deployments_Q_not_initialized() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+       try {\n+            cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        } catch (ServiceError e) {\n+           assertEquals(DEPLOYMENTS_QUEUE_NOT_INITIALIZED, e.getMessage());\n+           return;\n+       }\n+       fail();\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_successfull() throws JsonProcessingException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Topics localDeployments = mock(Topics.class);\n+        Topics localDeploymentDetailsTopics = mock(Topics.class);\n+        when(localDeployments.lookupTopics(any())).thenReturn(localDeploymentDetailsTopics);\n+        when(mockCliConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(deploymentQueue.offer(any())).thenReturn(true);\n+        cliEventStreamAgent.setDeploymentQueue(deploymentQueue);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+        request.setGroupName(MOCK_GROUP);\n+        request.setRootComponentVersionsToAdd(ImmutableMap.of(TEST_SERVICE, \"1.0.0\"));\n+        request.setRootComponentsToRemove(Arrays.asList(\"SomeService\"));\n+        Map<String, Map<String, Object>> componentToConfig = new HashMap<>();\n+        componentToConfig.put(TEST_SERVICE, ImmutableMap.of(\"param1\", \"value1\"));\n+        request.setComponentToConfiguration(componentToConfig);\n+        cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        ArgumentCaptor<Deployment> deploymentCaptor = ArgumentCaptor.forClass(Deployment.class);\n+        verify(deploymentQueue).offer(deploymentCaptor.capture());\n+        String deploymentDoc = deploymentCaptor.getValue().getDeploymentDocument();\n+        LocalOverrideRequest localOverrideRequest = OBJECT_MAPPER.readValue(deploymentDoc, LocalOverrideRequest.class);\n+        assertEquals(MOCK_GROUP, localOverrideRequest.getGroupName());\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsKey(TEST_SERVICE));\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsValue(\"1.0.0\"));\n+        assertTrue(localOverrideRequest.getComponentsToRemove().contains(\"SomeService\"));\n+        assertNotNull(localOverrideRequest.getComponentNameToConfig().get(TEST_SERVICE));\n+        assertEquals(\"value1\", localOverrideRequest.getComponentNameToConfig()\n+                .get(TEST_SERVICE).get(\"param1\"));\n+\n+\n+        verify(localDeployments).lookupTopics(localOverrideRequest.getRequestId());\n+        ArgumentCaptor<Map> deploymentDetailsCaptor = ArgumentCaptor.forClass(Map.class);\n+        verify(localDeploymentDetailsTopics).replaceAndWait(deploymentDetailsCaptor.capture());\n+        CLIEventStreamAgent.LocalDeploymentDetails localDeploymentDetails =\n+                OBJECT_MAPPER.convertValue((Map<String, Object>)deploymentDetailsCaptor.getValue(),\n+                CLIEventStreamAgent.LocalDeploymentDetails.class);\n+        assertEquals(Deployment.DeploymentType.LOCAL, localDeploymentDetails.getDeploymentType());\n+        assertEquals(DeploymentStatus.QUEUED, localDeploymentDetails.getStatus());\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_invalidDeploymentId() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(\"InvalidId\");\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+            mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_deploymentId_not_exist() {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        String deploymentId = UUID.randomUUID().toString();\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(null);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testGetLocalDeploymentStatus_successful() throws IOException {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 349}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzcxMQ==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937711", "createdAt": "2020-10-21T01:38:21Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(mockMainService.getName()).thenReturn(\"main\");\n+        when(kernel.getMain()).thenReturn(mockMainService);\n+        when(kernel.orderedDependencies()).thenReturn(Arrays.asList(mockTestService, mockMainService));\n+        ListComponentsResponse response =\n+                cliEventStreamAgent.getListComponentsHandler(mockContext).handleRequest(request);\n+        assertEquals(1, response.getComponents().size());\n+        ComponentDetails componentDetails = response.getComponents().get(0);\n+        assertEquals(TEST_SERVICE, componentDetails.getComponentName());\n+        assertEquals(mockParameterConfig, componentDetails.getConfiguration());\n+        assertEquals(\"1.0.0\", componentDetails.getVersion());\n+    }\n+\n+    @Test\n+    public void testRestartComponent_emptyComponentName() {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_restart() throws ServiceLoadException {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest);\n+        verify(mockTestService).requestRestart();\n+    }\n+\n+    @Test\n+    public void testStopComponent_emptyComponentName() {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_restart() throws ServiceLoadException {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest);\n+        verify(mockTestService).requestStop();\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_empty_paths() {\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_invalid_paths(ExtensionContext context) {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        request.setArtifactsDirectoryPath(\"/InvalidPath\");\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        assertThrows(InvalidArtifactsDirectoryPathError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_successful_update(ExtensionContext context) throws IOException {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        Path mockArtifactsDirectoryPath = Files.createTempDirectory(\"mockArtifactsDirectoryPath\");\n+        request.setArtifactsDirectoryPath(mockArtifactsDirectoryPath.toString());\n+        Path mockRecipesDirectoryPath = Files.createTempDirectory(\"mockRecipesDirectoryPath\");\n+        request.setRecipeDirectoryPath(mockRecipesDirectoryPath.toString());\n+        Path componentPath = Files.createDirectories(mockRecipesDirectoryPath.resolve(\"SampleComponent-1.0.0\"));\n+        Files.createFile(componentPath.resolve(\"sampleRecipe.xml\"));\n+        Files.createFile(mockArtifactsDirectoryPath.resolve(\"artifact.zip\"));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY));\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request);\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY)\n+                .resolve(\"SampleComponent-1.0.0\").resolve(\"sampleRecipe.xml\")));\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY).resolve(\"artifact.zip\")));\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_deployments_Q_not_initialized() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+       try {\n+            cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        } catch (ServiceError e) {\n+           assertEquals(DEPLOYMENTS_QUEUE_NOT_INITIALIZED, e.getMessage());\n+           return;\n+       }\n+       fail();\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_successfull() throws JsonProcessingException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Topics localDeployments = mock(Topics.class);\n+        Topics localDeploymentDetailsTopics = mock(Topics.class);\n+        when(localDeployments.lookupTopics(any())).thenReturn(localDeploymentDetailsTopics);\n+        when(mockCliConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(deploymentQueue.offer(any())).thenReturn(true);\n+        cliEventStreamAgent.setDeploymentQueue(deploymentQueue);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+        request.setGroupName(MOCK_GROUP);\n+        request.setRootComponentVersionsToAdd(ImmutableMap.of(TEST_SERVICE, \"1.0.0\"));\n+        request.setRootComponentsToRemove(Arrays.asList(\"SomeService\"));\n+        Map<String, Map<String, Object>> componentToConfig = new HashMap<>();\n+        componentToConfig.put(TEST_SERVICE, ImmutableMap.of(\"param1\", \"value1\"));\n+        request.setComponentToConfiguration(componentToConfig);\n+        cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        ArgumentCaptor<Deployment> deploymentCaptor = ArgumentCaptor.forClass(Deployment.class);\n+        verify(deploymentQueue).offer(deploymentCaptor.capture());\n+        String deploymentDoc = deploymentCaptor.getValue().getDeploymentDocument();\n+        LocalOverrideRequest localOverrideRequest = OBJECT_MAPPER.readValue(deploymentDoc, LocalOverrideRequest.class);\n+        assertEquals(MOCK_GROUP, localOverrideRequest.getGroupName());\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsKey(TEST_SERVICE));\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsValue(\"1.0.0\"));\n+        assertTrue(localOverrideRequest.getComponentsToRemove().contains(\"SomeService\"));\n+        assertNotNull(localOverrideRequest.getComponentNameToConfig().get(TEST_SERVICE));\n+        assertEquals(\"value1\", localOverrideRequest.getComponentNameToConfig()\n+                .get(TEST_SERVICE).get(\"param1\"));\n+\n+\n+        verify(localDeployments).lookupTopics(localOverrideRequest.getRequestId());\n+        ArgumentCaptor<Map> deploymentDetailsCaptor = ArgumentCaptor.forClass(Map.class);\n+        verify(localDeploymentDetailsTopics).replaceAndWait(deploymentDetailsCaptor.capture());\n+        CLIEventStreamAgent.LocalDeploymentDetails localDeploymentDetails =\n+                OBJECT_MAPPER.convertValue((Map<String, Object>)deploymentDetailsCaptor.getValue(),\n+                CLIEventStreamAgent.LocalDeploymentDetails.class);\n+        assertEquals(Deployment.DeploymentType.LOCAL, localDeploymentDetails.getDeploymentType());\n+        assertEquals(DeploymentStatus.QUEUED, localDeploymentDetails.getStatus());\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_invalidDeploymentId() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(\"InvalidId\");\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+            mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_deploymentId_not_exist() {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        String deploymentId = UUID.randomUUID().toString();\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(null);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testGetLocalDeploymentStatus_successful() throws IOException {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();\n+        String deploymentId = UUID.randomUUID().toString();\n+        Topics mockLocalDeployment = Topics.of(context, deploymentId, null);\n+        mockLocalDeployment.lookup(DEPLOYMENT_STATUS_KEY_NAME).withValue(DeploymentStatus.IN_PROGRESS.toString());\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(mockLocalDeployment);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        GetLocalDeploymentStatusResponse response = cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request);\n+        assertEquals(deploymentId, response.getDeployment().getDeploymentId());\n+        assertEquals(DeploymentStatus.IN_PROGRESS, response.getDeployment().getStatus());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testListLocalDeployment_no_local_deployments() throws IOException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzc0MQ==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937741", "createdAt": "2020-10-21T01:38:27Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(mockMainService.getName()).thenReturn(\"main\");\n+        when(kernel.getMain()).thenReturn(mockMainService);\n+        when(kernel.orderedDependencies()).thenReturn(Arrays.asList(mockTestService, mockMainService));\n+        ListComponentsResponse response =\n+                cliEventStreamAgent.getListComponentsHandler(mockContext).handleRequest(request);\n+        assertEquals(1, response.getComponents().size());\n+        ComponentDetails componentDetails = response.getComponents().get(0);\n+        assertEquals(TEST_SERVICE, componentDetails.getComponentName());\n+        assertEquals(mockParameterConfig, componentDetails.getConfiguration());\n+        assertEquals(\"1.0.0\", componentDetails.getVersion());\n+    }\n+\n+    @Test\n+    public void testRestartComponent_emptyComponentName() {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_restart() throws ServiceLoadException {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest);\n+        verify(mockTestService).requestRestart();\n+    }\n+\n+    @Test\n+    public void testStopComponent_emptyComponentName() {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_restart() throws ServiceLoadException {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest);\n+        verify(mockTestService).requestStop();\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_empty_paths() {\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_invalid_paths(ExtensionContext context) {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        request.setArtifactsDirectoryPath(\"/InvalidPath\");\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        assertThrows(InvalidArtifactsDirectoryPathError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_successful_update(ExtensionContext context) throws IOException {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        Path mockArtifactsDirectoryPath = Files.createTempDirectory(\"mockArtifactsDirectoryPath\");\n+        request.setArtifactsDirectoryPath(mockArtifactsDirectoryPath.toString());\n+        Path mockRecipesDirectoryPath = Files.createTempDirectory(\"mockRecipesDirectoryPath\");\n+        request.setRecipeDirectoryPath(mockRecipesDirectoryPath.toString());\n+        Path componentPath = Files.createDirectories(mockRecipesDirectoryPath.resolve(\"SampleComponent-1.0.0\"));\n+        Files.createFile(componentPath.resolve(\"sampleRecipe.xml\"));\n+        Files.createFile(mockArtifactsDirectoryPath.resolve(\"artifact.zip\"));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY));\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request);\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY)\n+                .resolve(\"SampleComponent-1.0.0\").resolve(\"sampleRecipe.xml\")));\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY).resolve(\"artifact.zip\")));\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_deployments_Q_not_initialized() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+       try {\n+            cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        } catch (ServiceError e) {\n+           assertEquals(DEPLOYMENTS_QUEUE_NOT_INITIALIZED, e.getMessage());\n+           return;\n+       }\n+       fail();\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_successfull() throws JsonProcessingException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Topics localDeployments = mock(Topics.class);\n+        Topics localDeploymentDetailsTopics = mock(Topics.class);\n+        when(localDeployments.lookupTopics(any())).thenReturn(localDeploymentDetailsTopics);\n+        when(mockCliConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(deploymentQueue.offer(any())).thenReturn(true);\n+        cliEventStreamAgent.setDeploymentQueue(deploymentQueue);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+        request.setGroupName(MOCK_GROUP);\n+        request.setRootComponentVersionsToAdd(ImmutableMap.of(TEST_SERVICE, \"1.0.0\"));\n+        request.setRootComponentsToRemove(Arrays.asList(\"SomeService\"));\n+        Map<String, Map<String, Object>> componentToConfig = new HashMap<>();\n+        componentToConfig.put(TEST_SERVICE, ImmutableMap.of(\"param1\", \"value1\"));\n+        request.setComponentToConfiguration(componentToConfig);\n+        cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        ArgumentCaptor<Deployment> deploymentCaptor = ArgumentCaptor.forClass(Deployment.class);\n+        verify(deploymentQueue).offer(deploymentCaptor.capture());\n+        String deploymentDoc = deploymentCaptor.getValue().getDeploymentDocument();\n+        LocalOverrideRequest localOverrideRequest = OBJECT_MAPPER.readValue(deploymentDoc, LocalOverrideRequest.class);\n+        assertEquals(MOCK_GROUP, localOverrideRequest.getGroupName());\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsKey(TEST_SERVICE));\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsValue(\"1.0.0\"));\n+        assertTrue(localOverrideRequest.getComponentsToRemove().contains(\"SomeService\"));\n+        assertNotNull(localOverrideRequest.getComponentNameToConfig().get(TEST_SERVICE));\n+        assertEquals(\"value1\", localOverrideRequest.getComponentNameToConfig()\n+                .get(TEST_SERVICE).get(\"param1\"));\n+\n+\n+        verify(localDeployments).lookupTopics(localOverrideRequest.getRequestId());\n+        ArgumentCaptor<Map> deploymentDetailsCaptor = ArgumentCaptor.forClass(Map.class);\n+        verify(localDeploymentDetailsTopics).replaceAndWait(deploymentDetailsCaptor.capture());\n+        CLIEventStreamAgent.LocalDeploymentDetails localDeploymentDetails =\n+                OBJECT_MAPPER.convertValue((Map<String, Object>)deploymentDetailsCaptor.getValue(),\n+                CLIEventStreamAgent.LocalDeploymentDetails.class);\n+        assertEquals(Deployment.DeploymentType.LOCAL, localDeploymentDetails.getDeploymentType());\n+        assertEquals(DeploymentStatus.QUEUED, localDeploymentDetails.getStatus());\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_invalidDeploymentId() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(\"InvalidId\");\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+            mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_deploymentId_not_exist() {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        String deploymentId = UUID.randomUUID().toString();\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(null);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testGetLocalDeploymentStatus_successful() throws IOException {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();\n+        String deploymentId = UUID.randomUUID().toString();\n+        Topics mockLocalDeployment = Topics.of(context, deploymentId, null);\n+        mockLocalDeployment.lookup(DEPLOYMENT_STATUS_KEY_NAME).withValue(DeploymentStatus.IN_PROGRESS.toString());\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(mockLocalDeployment);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        GetLocalDeploymentStatusResponse response = cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request);\n+        assertEquals(deploymentId, response.getDeployment().getDeploymentId());\n+        assertEquals(DeploymentStatus.IN_PROGRESS, response.getDeployment().getStatus());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testListLocalDeployment_no_local_deployments() throws IOException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();\n+        Topics localDeployments = Topics.of(context, \"localDeployments\", null);\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        ListLocalDeploymentsRequest request = new ListLocalDeploymentsRequest();\n+        ListLocalDeploymentsResponse response = cliEventStreamAgent.getListLocalDeploymentsHandler(mockContext,\n+                mockCliConfig).handleRequest(request);\n+        assertEquals(0, response.getLocalDeployments().size());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testListLocalDeployment_successful() throws IOException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 382}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61d701076b967f2e9b7955251dbfab83a81dfff0", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/61d701076b967f2e9b7955251dbfab83a81dfff0", "committedDate": "2020-10-21T19:43:37Z", "message": "Updated to generated code from latest smithy model"}, "afterCommit": {"oid": "906f5ec756873898c7c5f18f8f7006017a86e257", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/906f5ec756873898c7c5f18f8f7006017a86e257", "committedDate": "2020-10-21T19:54:32Z", "message": "Updated to generated code from latest smithy model"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzOTA3MzE5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-513907319", "createdAt": "2020-10-21T16:32:40Z", "commit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozMjo0MFrOHl1UKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo1Njo1M1rOHmFBbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMjg3Mg==", "bodyText": "hmmm...why are they excluded?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509432872", "createdAt": "2020-10-21T16:32:40Z", "author": {"login": "fengwang666"}, "path": "codestyle/findbugs-exclude.xml", "diffHunk": "@@ -17,4 +17,12 @@\n             <Bug pattern=\"EI_EXPOSE_REP2\"/>\n         </Or>\n     </Match>\n+    <Match>\n+        <Or>\n+            <Package name=\"software.amazon.awssdk.aws.greengrass\"/>\n+            <Package name=\"software.amazon.awssdk.aws.greengrass.model\"/>\n+            <Package name=\"software.amazon.awssdk.eventstreamrpc\"/>\n+            <Package name=\"software.amazon.awssdk.eventstreamrpc.model\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ5NTczMQ==", "bodyText": "What's this DEFAULT_PORT_NUMBER for? Why are we hardcoding it? Can we use random port similar to what we do in IPCService?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509495731", "createdAt": "2020-10-21T17:45:59Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUwMzIzNA==", "bodyText": "I'm a bit confused here. We're passing ipcServerSocketPath to the hostname parameter of the IpcServer class constructor. Is this intentional?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509503234", "createdAt": "2020-10-21T17:50:11Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUxMDA2NA==", "bodyText": "Is it safe to hardcode this? Will customer ever need to adjust it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509510064", "createdAt": "2020-10-21T17:53:01Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUxNjY3NA==", "bodyText": "I don't quite get this part. Why are we deleting the socket file? Who is responsible to create it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509516674", "createdAt": "2020-10-21T17:55:44Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUyMDMwOA==", "bodyText": "headers is not used. Can we remove it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509520308", "createdAt": "2020-10-21T17:57:23Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1Mzg3NA==", "bodyText": "What's this for? When do we need to implement this method?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509553874", "createdAt": "2020-10-21T18:28:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1OTk2Ng==", "bodyText": "Is Info the right level? I would remove it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509559966", "createdAt": "2020-10-21T18:33:37Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2MTE0Mw==", "bodyText": "Same here. pretty useless log imo.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509561143", "createdAt": "2020-10-21T18:34:46Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2Nzc5NQ==", "bodyText": "Is this at the right level?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509667795", "createdAt": "2020-10-21T20:27:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending preComponentUpdate event\");\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                componentUpdatePolicyEvents.setPreUpdateEvent(preComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+                CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+                deferUpdateFutures.add(deferUpdateFuture);\n+                // If there are multiple pre component events sent to same service, we will store the latest future\n+                // As the update should be waiting for the latest one to complete.\n+                deferUpdateFuturesMap.put(serviceName, deferUpdateFuture);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending postComponentUpdate event\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NTIwNg==", "bodyText": "I cannot understand this error message by reading this code. The code tells me the future doesn't exist in the map. I have no idea what it means by Time limit to respond to PreComponentUpdateEvent exceeded. To me it show the code be written in a better way.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509675206", "createdAt": "2020-10-21T20:38:34Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NzU1Mw==", "bodyText": "Do you need to have get and remove two operations?\nWhy not just remove, check, close?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509677553", "createdAt": "2020-10-21T20:41:02Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3ODMyOA==", "bodyText": "Why discard all of them?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509678328", "createdAt": "2020-10-21T20:41:53Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3OTc3Mg==", "bodyText": "Instead of passing in a list, why not just return a list? It's not conventional in Java to use parameters for output.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509679772", "createdAt": "2020-10-21T20:43:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5MDIyMA==", "bodyText": "Why does this need to be a public method? It seems an anti-pattern to me that the class expose a public method to allow others to mutate its internal state (e.g. deferUpdateFuturesMap). If at 216, the map is always cleared when sendPreComponentUpdateEvent is called(), why would UpdateSystemSafelyService still need to call this method again?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509690220", "createdAt": "2020-10-21T20:56:53Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending preComponentUpdate event\");\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                componentUpdatePolicyEvents.setPreUpdateEvent(preComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+                CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+                deferUpdateFutures.add(deferUpdateFuture);\n+                // If there are multiple pre component events sent to same service, we will store the latest future\n+                // As the update should be waiting for the latest one to complete.\n+                deferUpdateFuturesMap.put(serviceName, deferUpdateFuture);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending postComponentUpdate event\");\n+                componentUpdatePolicyEvents.setPostUpdateEvent(postComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 256}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjU3NDIw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-514257420", "createdAt": "2020-10-21T23:23:01Z", "commit": {"oid": "bcabb94611e069475c7cb34af16a535d369846f0"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "17b734da09625545b846a6369636deb3f2c2a998", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17b734da09625545b846a6369636deb3f2c2a998", "committedDate": "2020-10-22T00:24:11Z", "message": "Some debugging for failing tests"}, "afterCommit": {"oid": "c79fe7b597c2e6e3e43a7f941a83ee9963b04292", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c79fe7b597c2e6e3e43a7f941a83ee9963b04292", "committedDate": "2020-10-22T00:31:10Z", "message": "Some debugging for failing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0306176c23965dc929432e2bf7ac17147472c0de", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0306176c23965dc929432e2bf7ac17147472c0de", "committedDate": "2020-10-22T00:41:14Z", "message": "Using new IPC Server library"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b447468e0c2a0e618e9e098a1d3ba491fcf940d2", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b447468e0c2a0e618e9e098a1d3ba491fcf940d2", "committedDate": "2020-10-22T00:41:14Z", "message": "Making lifecycle APIs work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7d7683538abd3ae35c654fcb9084d7c3cc83bed", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d7d7683538abd3ae35c654fcb9084d7c3cc83bed", "committedDate": "2020-10-22T00:41:14Z", "message": "Updating the server framework library code and smithy generated code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5b7c364eb4559fa71ec5557e7fc0c7b55059cd2", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a5b7c364eb4559fa71ec5557e7fc0c7b55059cd2", "committedDate": "2020-10-22T00:41:14Z", "message": "Adding unit tests for IPCService, LifecycleService and LifecycleAgent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e978068c7f1822b0bf0ee37e577f2425b9ee9f25", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e978068c7f1822b0bf0ee37e577f2425b9ee9f25", "committedDate": "2020-10-22T00:42:32Z", "message": "Adding event stream agent for CLI and unit tests for CLi event stream agent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ccd0bcb385469adffe696ba89626a1c09d69307", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8ccd0bcb385469adffe696ba89626a1c09d69307", "committedDate": "2020-10-22T00:42:33Z", "message": "Updated to latest code for server library and smithy generated code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b9f02a23a805dd52d9bf8083b5cd3cdc43b78ca", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5b9f02a23a805dd52d9bf8083b5cd3cdc43b78ca", "committedDate": "2020-10-22T00:42:33Z", "message": "Fixing bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04b71128d2e3b70ca4656bd63ffd0919c69c388c", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/04b71128d2e3b70ca4656bd63ffd0919c69c388c", "committedDate": "2020-10-22T00:42:33Z", "message": "Changing the aws-crt version to 1.0.0-event-stream-rpc-SNAPSHOT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02e6fe70d35212800b3bc942747fc427af926fb8", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/02e6fe70d35212800b3bc942747fc427af926fb8", "committedDate": "2020-10-22T00:42:33Z", "message": "Fixing bugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "279972ae457fec7c59f406f886c96d7301316233", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/279972ae457fec7c59f406f886c96d7301316233", "committedDate": "2020-10-22T00:42:33Z", "message": "Fixing ipc server shutdown."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2b4e813f55beba4790f603ebcd4cb77ee8e44b0", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a2b4e813f55beba4790f603ebcd4cb77ee8e44b0", "committedDate": "2020-10-22T00:42:33Z", "message": "Removing windows from build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "597706fa5667c8ddb28f5ee8cddf60e9efaf67b2", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/597706fa5667c8ddb28f5ee8cddf60e9efaf67b2", "committedDate": "2020-10-22T00:42:33Z", "message": "Removing the IPC socket descriptor file in IPC startup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c46650312076f7b6cfe41d3daa93c193c8daea2", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8c46650312076f7b6cfe41d3daa93c193c8daea2", "committedDate": "2020-10-22T00:42:33Z", "message": "Updating integ tests to use the new IPC lifecycle APIs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e442a50989d8005f2a958cd0658f5a99c6bc3b5", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6e442a50989d8005f2a958cd0658f5a99c6bc3b5", "committedDate": "2020-10-22T00:42:33Z", "message": "Keeping old lifecycle APIs working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1cb44db7db10343d17d4d90b38d8986b893c37e", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f1cb44db7db10343d17d4d90b38d8986b893c37e", "committedDate": "2020-10-22T00:42:33Z", "message": "Updating the server and client code for ipc library"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0d611610991cbf6b9494865ebda98d62e95f95b", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d0d611610991cbf6b9494865ebda98d62e95f95b", "committedDate": "2020-10-22T00:42:34Z", "message": "Adding connect message suppliers and using them for IPC connect"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73ed81834a3374fc1e34798545446a3cdf6f7ab0", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/73ed81834a3374fc1e34798545446a3cdf6f7ab0", "committedDate": "2020-10-22T00:42:34Z", "message": "Fixing some tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1cf78efea62a5d4a433295f52ed72651a0635ee", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c1cf78efea62a5d4a433295f52ed72651a0635ee", "committedDate": "2020-10-22T00:42:34Z", "message": "Updating the event stream rpc server, client and model to latest. Also updating the Greengrass IPC model to latest generated code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d5570c27ae29a927de7ca4e80a3ac794724648e", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2d5570c27ae29a927de7ca4e80a3ac794724648e", "committedDate": "2020-10-22T00:42:34Z", "message": "Updating ipc server and client code with latest exception handling fixes to both"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5b87d4c3037269be8eb38ce8b1a692e51e91aea", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f5b87d4c3037269be8eb38ce8b1a692e51e91aea", "committedDate": "2020-10-22T00:42:34Z", "message": "Addressing review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8c6d8fa6d3d6b43e0d1bd3e3de8b7aa10c54f3a", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a8c6d8fa6d3d6b43e0d1bd3e3de8b7aa10c54f3a", "committedDate": "2020-10-22T00:42:34Z", "message": "Fixing some bugs in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98136933e19f552b3e9e42ce4188e477124e86c6", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/98136933e19f552b3e9e42ce4188e477124e86c6", "committedDate": "2020-10-22T00:43:07Z", "message": "Changing the name of the socket path env variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "193b474cd7866eb340f2c72d11adbe3fc2eef457", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/193b474cd7866eb340f2c72d11adbe3fc2eef457", "committedDate": "2020-10-22T00:43:07Z", "message": "Excluding ipc sdk code from unit test coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "163d9121c6328562e18ca1f7a0ba6090b2731292", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/163d9121c6328562e18ca1f7a0ba6090b2731292", "committedDate": "2020-10-22T00:43:07Z", "message": "Increasing timeout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "514bd51c14dade8ebd8bb5f1c255b7125cd34677", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/514bd51c14dade8ebd8bb5f1c255b7125cd34677", "committedDate": "2020-10-22T00:43:07Z", "message": "Changing the version of CRT repo to pull the latest CRT jar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2079e4d73710a59c719efc0ceaafe580e09dac9b", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2079e4d73710a59c719efc0ceaafe580e09dac9b", "committedDate": "2020-10-22T00:43:07Z", "message": "Fixing IPCServicesTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eaefbbe4896bfbe3da7cb3ffb3f9034e6c387eba", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eaefbbe4896bfbe3da7cb3ffb3f9034e6c387eba", "committedDate": "2020-10-22T00:43:07Z", "message": "Attempting to fix transient issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22c3b6001d83d08dd0b56825e33690b89e7f46b2", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/22c3b6001d83d08dd0b56825e33690b89e7f46b2", "committedDate": "2020-10-22T00:43:08Z", "message": "Updated to generated code from latest smithy model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2e7f4c4e26d1fd50f8486f09f79b7d099dc7fcd", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f2e7f4c4e26d1fd50f8486f09f79b7d099dc7fcd", "committedDate": "2020-10-22T00:43:08Z", "message": "Addressing review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a14c52f8876f07fd9845c347ed6b9411653c3b9", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5a14c52f8876f07fd9845c347ed6b9411653c3b9", "committedDate": "2020-10-22T00:43:08Z", "message": "Addressing some more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cd037bc5485564e0c9f85e01cb53ad20729bfc1", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8cd037bc5485564e0c9f85e01cb53ad20729bfc1", "committedDate": "2020-10-22T00:43:08Z", "message": "Making post event and pre component event calls synchronous"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c79fe7b597c2e6e3e43a7f941a83ee9963b04292", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c79fe7b597c2e6e3e43a7f941a83ee9963b04292", "committedDate": "2020-10-22T00:31:10Z", "message": "Some debugging for failing tests"}, "afterCommit": {"oid": "98f5e0fbea8d37ff2bdf514b6ea0f8763a7252d4", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/98f5e0fbea8d37ff2bdf514b6ea0f8763a7252d4", "committedDate": "2020-10-22T00:43:08Z", "message": "Some debugging for failing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c741a29de8d87733809229e13bc24976c5ef74eb", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c741a29de8d87733809229e13bc24976c5ef74eb", "committedDate": "2020-10-22T02:16:30Z", "message": "Some debugging for failing tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "98f5e0fbea8d37ff2bdf514b6ea0f8763a7252d4", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/98f5e0fbea8d37ff2bdf514b6ea0f8763a7252d4", "committedDate": "2020-10-22T00:43:08Z", "message": "Some debugging for failing tests"}, "afterCommit": {"oid": "c741a29de8d87733809229e13bc24976c5ef74eb", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c741a29de8d87733809229e13bc24976c5ef74eb", "committedDate": "2020-10-22T02:16:30Z", "message": "Some debugging for failing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09c3b3fa687808b5483e016fb37a323c38993961", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/09c3b3fa687808b5483e016fb37a323c38993961", "committedDate": "2020-10-22T02:54:55Z", "message": "Adding comments to clarify IpcServer parameters for domain sockets"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "379627323d3ff58f3e90ec8de8079ce94fa7bc64", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/379627323d3ff58f3e90ec8de8079ce94fa7bc64", "committedDate": "2020-10-22T02:51:03Z", "message": "Adding comments to clarify IpcServer parameters for domain sockets"}, "afterCommit": {"oid": "09c3b3fa687808b5483e016fb37a323c38993961", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/09c3b3fa687808b5483e016fb37a323c38993961", "committedDate": "2020-10-22T02:54:55Z", "message": "Adding comments to clarify IpcServer parameters for domain sockets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a7b68f38947691662fe244967a566c10edecc77", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2a7b68f38947691662fe244967a566c10edecc77", "committedDate": "2020-10-22T03:20:38Z", "message": "Making subscribeToComponent synchronous in DeploymentConfigMerging and DeploymentTaskIntegration test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be5880f0f3c5a98933ad9fce9ce28de2160fa1e0", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/be5880f0f3c5a98933ad9fce9ce28de2160fa1e0", "committedDate": "2020-10-22T03:17:37Z", "message": "Making subscribeToComponent synchronous in DeploymentConfigMerging test"}, "afterCommit": {"oid": "2a7b68f38947691662fe244967a566c10edecc77", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2a7b68f38947691662fe244967a566c10edecc77", "committedDate": "2020-10-22T03:20:38Z", "message": "Making subscribeToComponent synchronous in DeploymentConfigMerging and DeploymentTaskIntegration test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzQ5NTQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-514349546", "createdAt": "2020-10-22T04:24:19Z", "commit": {"oid": "2a7b68f38947691662fe244967a566c10edecc77"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzQ5ODE1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#pullrequestreview-514349815", "createdAt": "2020-10-22T04:25:10Z", "commit": {"oid": "2a7b68f38947691662fe244967a566c10edecc77"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3074, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}