{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5ODU3OTAy", "number": 373, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjo0OTowNVrOEaMoww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzoxMjo0MFrOEewx8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTA1NDc1OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjo0OTowNVrOHDePlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMjowNDo1OVrOHEZEmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQwMzI4NQ==", "bodyText": "this would not build, updating the version as 0.0.0-clioveripc-SNAPSHOT will allow github action to pick the corresponding sdk build", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473403285", "createdAt": "2020-08-19T22:49:05Z", "author": {"login": "fahadmohammed01"}, "path": "pom.xml", "diffHunk": "@@ -11,7 +11,8 @@\n             <id>evergreen-ipc-java-sdk</id>\n             <name>Evergreen Ipc Java Sdk</name>\n             <!-- cloud front url fronting the Evergreen Ipc Java Sdk artifact in S3-->\n-            <url>https://d10d248laylpoq.cloudfront.net/</url>\n+<!--            <url>https://d10d248laylpoq.cloudfront.net/</url>-->\n+            <url>file:///Users/abanthiy/workspace/evergreen/aws-greengrass-sdk-java/target</url>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM2NzEzMQ==", "bodyText": "Yes I made this change for local testing. Will remove before pushing", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474367131", "createdAt": "2020-08-21T02:04:59Z", "author": {"login": "abanthiy"}, "path": "pom.xml", "diffHunk": "@@ -11,7 +11,8 @@\n             <id>evergreen-ipc-java-sdk</id>\n             <name>Evergreen Ipc Java Sdk</name>\n             <!-- cloud front url fronting the Evergreen Ipc Java Sdk artifact in S3-->\n-            <url>https://d10d248laylpoq.cloudfront.net/</url>\n+<!--            <url>https://d10d248laylpoq.cloudfront.net/</url>-->\n+            <url>file:///Users/abanthiy/workspace/evergreen/aws-greengrass-sdk-java/target</url>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQwMzI4NQ=="}, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTE4MzQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzoxOTozNlrOHDfkyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzoxOTozNlrOHDfkyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQyNTA5OA==", "bodyText": "Use PackageStore.RECIPE_DIRECTORY", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473425098", "createdAt": "2020-08-19T23:19:36Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTE4NjIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzoyMDoxNVrOHDfmpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzoyMDoxNVrOHDfmpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQyNTU3Mg==", "bodyText": "Use PackageStore.ARTIFACT_DIRECTORY", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473425572", "createdAt": "2020-08-19T23:20:15Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTIyOTIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzozMDozNlrOHDgDhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMjoxMzozMVrOHEZM3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMjk2Ng==", "bodyText": "why not use Utils.copyFolderRecursively()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473432966", "createdAt": "2020-08-19T23:30:36Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest\n+                .toString(), Deployment.DeploymentType.LOCAL, deploymentId);\n+        if (deploymentsQueue == null) {\n+            logger.atError().log(\"Deployments queue not initialized\");\n+            throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+        } else {\n+            if (deploymentsQueue.offer(deployment)) {\n+                logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                return CreateLocalDeploymentResponse.builder().deploymentId(deploymentId).build();\n+            } else {\n+                logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                        .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get status of local deployment with the given deploymentId.\n+     * @param request {@link GetLocalDeploymentStatusRequest}\n+     * @param serviceConfig Cli service configuration\n+     * @return {@link GetLocalDeploymentStatusResponse}\n+     * @throws InvalidArgumentsError thrown when invalid deploymentId format is received\n+     * @throws ResourceNotFoundError thrown when deployment with given Id not found\n+     */\n+    public GetLocalDeploymentStatusResponse getLocalDeploymentStatus(Topics serviceConfig,\n+                                                                     GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError, ResourceNotFoundError {\n+        validateGetLocalDeploymentStatusRequest(request);\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        if (localDeployments.find(request.getDeploymentId()) == null) {\n+            throw new ResourceNotFoundError(\"Cannot find deployment\",\n+                    \"Deployment\", request.getDeploymentId());\n+        } else {\n+            Topic deployment = localDeployments.find(request.getDeploymentId());\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) deployment.getOnce();\n+            DeploymentStatus status =\n+                    (DeploymentStatus) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+            return GetLocalDeploymentStatusResponse.builder()\n+                    .deployment(LocalDeployment.builder().deploymentId(request.getDeploymentId())\n+                            .status(status).build()).build();\n+        }\n+    }\n+\n+    /**\n+     * Lists last 5 local deployments.\n+     * @param serviceConfig CLI service configuration\n+     * @return {@link ListLocalDeploymentResponse}\n+     */\n+    public ListLocalDeploymentResponse listLocalDeployments(Topics serviceConfig) {\n+        List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        localDeployments.deepForEachTopic(topic -> {\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) topic.getOnce();\n+            persistedDeployments.add(LocalDeployment.builder()\n+                    .deploymentId((String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID))\n+                    .status((DeploymentStatus) deploymentDetails.get(\n+                            PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS))\n+                    .build());\n+        });\n+        return ListLocalDeploymentResponse.builder().localDeployments(persistedDeployments).build();\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     * @param serviceConfig CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID);\n+        Topic localDeploymentDetails = localDeployments.lookup(deploymentId);\n+        localDeploymentDetails.withValue(deploymentDetails);\n+        DeploymentStatus status = (DeploymentStatus) deploymentDetails.get(\n+                PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    private void validateGetLocalDeploymentStatusRequest(GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError {\n+        try {\n+            UUID.fromString(request.getDeploymentId());\n+        } catch (IllegalArgumentException e) {\n+            throw new InvalidArgumentsError(\"Invalid deploymentId format received. DeploymentId is a UUID\");\n+        }\n+    }\n+\n+    private static void copyFolderRecursively(Path src, Path des) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM2OTI0Ng==", "bodyText": "Din know that existed. Thanks!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474369246", "createdAt": "2020-08-21T02:13:31Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest\n+                .toString(), Deployment.DeploymentType.LOCAL, deploymentId);\n+        if (deploymentsQueue == null) {\n+            logger.atError().log(\"Deployments queue not initialized\");\n+            throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+        } else {\n+            if (deploymentsQueue.offer(deployment)) {\n+                logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                return CreateLocalDeploymentResponse.builder().deploymentId(deploymentId).build();\n+            } else {\n+                logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                        .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get status of local deployment with the given deploymentId.\n+     * @param request {@link GetLocalDeploymentStatusRequest}\n+     * @param serviceConfig Cli service configuration\n+     * @return {@link GetLocalDeploymentStatusResponse}\n+     * @throws InvalidArgumentsError thrown when invalid deploymentId format is received\n+     * @throws ResourceNotFoundError thrown when deployment with given Id not found\n+     */\n+    public GetLocalDeploymentStatusResponse getLocalDeploymentStatus(Topics serviceConfig,\n+                                                                     GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError, ResourceNotFoundError {\n+        validateGetLocalDeploymentStatusRequest(request);\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        if (localDeployments.find(request.getDeploymentId()) == null) {\n+            throw new ResourceNotFoundError(\"Cannot find deployment\",\n+                    \"Deployment\", request.getDeploymentId());\n+        } else {\n+            Topic deployment = localDeployments.find(request.getDeploymentId());\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) deployment.getOnce();\n+            DeploymentStatus status =\n+                    (DeploymentStatus) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+            return GetLocalDeploymentStatusResponse.builder()\n+                    .deployment(LocalDeployment.builder().deploymentId(request.getDeploymentId())\n+                            .status(status).build()).build();\n+        }\n+    }\n+\n+    /**\n+     * Lists last 5 local deployments.\n+     * @param serviceConfig CLI service configuration\n+     * @return {@link ListLocalDeploymentResponse}\n+     */\n+    public ListLocalDeploymentResponse listLocalDeployments(Topics serviceConfig) {\n+        List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        localDeployments.deepForEachTopic(topic -> {\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) topic.getOnce();\n+            persistedDeployments.add(LocalDeployment.builder()\n+                    .deploymentId((String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID))\n+                    .status((DeploymentStatus) deploymentDetails.get(\n+                            PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS))\n+                    .build());\n+        });\n+        return ListLocalDeploymentResponse.builder().localDeployments(persistedDeployments).build();\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     * @param serviceConfig CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID);\n+        Topic localDeploymentDetails = localDeployments.lookup(deploymentId);\n+        localDeploymentDetails.withValue(deploymentDetails);\n+        DeploymentStatus status = (DeploymentStatus) deploymentDetails.get(\n+                PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    private void validateGetLocalDeploymentStatusRequest(GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError {\n+        try {\n+            UUID.fromString(request.getDeploymentId());\n+        } catch (IllegalArgumentException e) {\n+            throw new InvalidArgumentsError(\"Invalid deploymentId format received. DeploymentId is a UUID\");\n+        }\n+    }\n+\n+    private static void copyFolderRecursively(Path src, Path des) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMjk2Ng=="}, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1OTIzMDQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzozMDo1NVrOHDgEcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMjo1NjoxMVrOHEZ5YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMzIwMA==", "bodyText": "Does this need to be public?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473433200", "createdAt": "2020-08-19T23:30:55Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest\n+                .toString(), Deployment.DeploymentType.LOCAL, deploymentId);\n+        if (deploymentsQueue == null) {\n+            logger.atError().log(\"Deployments queue not initialized\");\n+            throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+        } else {\n+            if (deploymentsQueue.offer(deployment)) {\n+                logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                return CreateLocalDeploymentResponse.builder().deploymentId(deploymentId).build();\n+            } else {\n+                logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                        .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get status of local deployment with the given deploymentId.\n+     * @param request {@link GetLocalDeploymentStatusRequest}\n+     * @param serviceConfig Cli service configuration\n+     * @return {@link GetLocalDeploymentStatusResponse}\n+     * @throws InvalidArgumentsError thrown when invalid deploymentId format is received\n+     * @throws ResourceNotFoundError thrown when deployment with given Id not found\n+     */\n+    public GetLocalDeploymentStatusResponse getLocalDeploymentStatus(Topics serviceConfig,\n+                                                                     GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError, ResourceNotFoundError {\n+        validateGetLocalDeploymentStatusRequest(request);\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        if (localDeployments.find(request.getDeploymentId()) == null) {\n+            throw new ResourceNotFoundError(\"Cannot find deployment\",\n+                    \"Deployment\", request.getDeploymentId());\n+        } else {\n+            Topic deployment = localDeployments.find(request.getDeploymentId());\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) deployment.getOnce();\n+            DeploymentStatus status =\n+                    (DeploymentStatus) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+            return GetLocalDeploymentStatusResponse.builder()\n+                    .deployment(LocalDeployment.builder().deploymentId(request.getDeploymentId())\n+                            .status(status).build()).build();\n+        }\n+    }\n+\n+    /**\n+     * Lists last 5 local deployments.\n+     * @param serviceConfig CLI service configuration\n+     * @return {@link ListLocalDeploymentResponse}\n+     */\n+    public ListLocalDeploymentResponse listLocalDeployments(Topics serviceConfig) {\n+        List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        localDeployments.deepForEachTopic(topic -> {\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) topic.getOnce();\n+            persistedDeployments.add(LocalDeployment.builder()\n+                    .deploymentId((String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID))\n+                    .status((DeploymentStatus) deploymentDetails.get(\n+                            PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS))\n+                    .build());\n+        });\n+        return ListLocalDeploymentResponse.builder().localDeployments(persistedDeployments).build();\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     * @param serviceConfig CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM4MDY0MQ==", "bodyText": "Yes, this is being called by the CLIService to be invoked when deploymentStatusKeeper wants to persist the status of local deployment", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474380641", "createdAt": "2020-08-21T02:56:11Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest\n+                .toString(), Deployment.DeploymentType.LOCAL, deploymentId);\n+        if (deploymentsQueue == null) {\n+            logger.atError().log(\"Deployments queue not initialized\");\n+            throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+        } else {\n+            if (deploymentsQueue.offer(deployment)) {\n+                logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                return CreateLocalDeploymentResponse.builder().deploymentId(deploymentId).build();\n+            } else {\n+                logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                        .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get status of local deployment with the given deploymentId.\n+     * @param request {@link GetLocalDeploymentStatusRequest}\n+     * @param serviceConfig Cli service configuration\n+     * @return {@link GetLocalDeploymentStatusResponse}\n+     * @throws InvalidArgumentsError thrown when invalid deploymentId format is received\n+     * @throws ResourceNotFoundError thrown when deployment with given Id not found\n+     */\n+    public GetLocalDeploymentStatusResponse getLocalDeploymentStatus(Topics serviceConfig,\n+                                                                     GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError, ResourceNotFoundError {\n+        validateGetLocalDeploymentStatusRequest(request);\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        if (localDeployments.find(request.getDeploymentId()) == null) {\n+            throw new ResourceNotFoundError(\"Cannot find deployment\",\n+                    \"Deployment\", request.getDeploymentId());\n+        } else {\n+            Topic deployment = localDeployments.find(request.getDeploymentId());\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) deployment.getOnce();\n+            DeploymentStatus status =\n+                    (DeploymentStatus) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+            return GetLocalDeploymentStatusResponse.builder()\n+                    .deployment(LocalDeployment.builder().deploymentId(request.getDeploymentId())\n+                            .status(status).build()).build();\n+        }\n+    }\n+\n+    /**\n+     * Lists last 5 local deployments.\n+     * @param serviceConfig CLI service configuration\n+     * @return {@link ListLocalDeploymentResponse}\n+     */\n+    public ListLocalDeploymentResponse listLocalDeployments(Topics serviceConfig) {\n+        List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        localDeployments.deepForEachTopic(topic -> {\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) topic.getOnce();\n+            persistedDeployments.add(LocalDeployment.builder()\n+                    .deploymentId((String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID))\n+                    .status((DeploymentStatus) deploymentDetails.get(\n+                            PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS))\n+                    .build());\n+        });\n+        return ListLocalDeploymentResponse.builder().localDeployments(persistedDeployments).build();\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     * @param serviceConfig CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMzIwMA=="}, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzk0MTg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoxNjoyNlrOHE1EFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMTo1NToxMVrOHG37JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNTc1MQ==", "bodyText": "Does orderedDependencies also have main? do we need to filter it since it's not a component? Also internal services?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474825751", "createdAt": "2020-08-21T17:16:26Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNjI1OQ==", "bodyText": "Yes, it includes main. IMO, don't filter it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474826259", "createdAt": "2020-08-21T17:17:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNTc1MQ=="}, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2OTc2NA==", "bodyText": "I filtered main but not internal services. This is how it was in the existing CLI implementation", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r476969764", "createdAt": "2020-08-26T01:55:11Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNTc1MQ=="}, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzk1MTA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoxOTozMFrOHE1JxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMTo1NDozMlrOHG35SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNzIwNQ==", "bodyText": "Should this wait and check if the state transition actually happens before returning success?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474827205", "createdAt": "2020-08-21T17:19:30Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2OTI4OQ==", "bodyText": "Same as below", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r476969289", "createdAt": "2020-08-26T01:54:32Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNzIwNQ=="}, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzk1NzkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoyMTozNFrOHE1Nyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMTo1NDoxOVrOHG34ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyODIzNQ==", "bodyText": "Same here, do we need to wait and validate if the request actually went through?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474828235", "createdAt": "2020-08-21T17:21:34Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2OTEyMw==", "bodyText": "Client can verify that by calling getComponentDetails API. We do not know how long it is going to take to perform the operation.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r476969123", "createdAt": "2020-08-26T01:54:19Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyODIzNQ=="}, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzk4NTg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzozMDo0N1rOHE1fWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMTo1MToxNlrOHG3wWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzMjcyOQ==", "bodyText": "Since this agent is directly interacting with deployments queue now, we should not need LocalDeploymentListener.java anymore right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474832729", "createdAt": "2020-08-21T17:30:47Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2NzAwMg==", "bodyText": "Yes, I will remove LocalDeploymentListener after the CLI agent has been moved to IPC communication.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r476967002", "createdAt": "2020-08-26T01:51:16Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzMjcyOQ=="}, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjE1MTA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToxNDo1MFrOHId0CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToxNDo1MFrOHId0CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzOTExMg==", "bodyText": "Remove commented code?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r478639112", "createdAt": "2020-08-27T19:14:50Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -279,8 +280,12 @@ public IotJobsClient getIotJobsClient(MqttClientConnection connection) {\n     }\n \n     private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n-        String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n-        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        DeploymentDetailsIotJobs deploymentDetailsIotJobs = OBJECT_MAPPER.convertValue(deploymentDetails,\n+                DeploymentDetailsIotJobs.class);\n+        //        String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjcwNjc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/CLIService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxNTozMFrOHIjGLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxNTozMFrOHIjGLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNTY3Ng==", "bodyText": "This can result in index out of bound exception if the client has an opcode > the CliClientOpCodes.values()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r478725676", "createdAt": "2020-08-27T22:15:30Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/CLIService.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package com.aws.iot.evergreen.ipc.modules;\n+\n+import com.aws.iot.evergreen.builtin.services.cli.CLIServiceAgent;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.ipc.services.cli.CliClientOpCodes;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.GenericCliIpcServerException;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CliGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n+import lombok.Data;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+@ImplementsService(name = CLIService.CLI_SERVICE, autostart = true)\n+public class CLIService extends EvergreenService {\n+\n+    private static final ObjectMapper CBOR_MAPPER = new CBORMapper();\n+\n+    public static final String CLI_SERVICE = \"aws.greengrass.ipc.cli\";\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+\n+    @Inject\n+    CLIServiceAgent agent;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    public CLIService(Topics topics) {\n+        super(topics);\n+    }\n+\n+    /**\n+     * Constructor for unit testing.\n+     * @param topics Service config\n+     * @param router {@link IPCRouter}\n+     * @param agent {@link CLIServiceAgent}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     */\n+    public CLIService(Topics topics, IPCRouter router, CLIServiceAgent agent,\n+                      DeploymentStatusKeeper deploymentStatusKeeper) {\n+        super(topics);\n+        this.router = router;\n+        this.agent = agent;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.CLI;\n+        super.postInject();\n+        try {\n+            router.registerServiceCallback(destination.getValue(), this::handleMessage);\n+            logger.atInfo().setEventType(\"ipc-register-request-handler\").addKeyValue(\"destination\", destination.name())\n+                    .log();\n+            deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                    this::deploymentStatusChanged, CLIService.class.getName());\n+        } catch (IPCException e) {\n+            logger.atError().setEventType(\"ipc-register-request-handler-error\").setCause(e)\n+                    .addKeyValue(\"destination\", destination.name())\n+                    .log(\"Failed to register service callback to destination\");\n+        }\n+    }\n+\n+    @Data\n+    public static class LocalDeploymentDetails {\n+        String deploymentId;\n+        DeploymentStatus status;\n+    }\n+\n+    @SuppressWarnings(\"PMD.EmptyIfStmt\")\n+    protected Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        agent.persistLocalDeployment(config, deploymentDetails);\n+        return true;\n+    }\n+\n+    /**\n+     * Handle all requests for CLI from the CLI client.\n+     *\n+     * @param message incoming request\n+     * @param context Context identifying the client and the channel\n+     */\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+    public Future<FrameReader.Message> handleMessage(FrameReader.Message message, ConnectionContext context) {\n+        CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+\n+        ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n+        try {\n+            //TODO: add version compatibility check\n+            CliClientOpCodes opCode = CliClientOpCodes.values()[applicationMessage.getOpCode()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjcxMDQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxNzoxMlrOHIjIbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxNzoxMlrOHIjIbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNjI1NA==", "bodyText": "Didn't we agree to have component configuration in the getComponentDetails or is that covered by another API", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r478726254", "createdAt": "2020-08-27T22:17:12Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,376 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageStore;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class CLIServiceAgent {\n+\n+    public static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+    public static final String LOCAL_DEPLOYMENT_RESOURCE = \"LocalDeployment\";\n+    private static ObjectMapper OBJECT_MAPPER = new ObjectMapper()\n+            .configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNjkxNTIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzoxMTo0MFrOHKoEMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjoxMjo1MVrOHNT50w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw==", "bodyText": "This feels weird, creating an object and then storing as a map. Can we just store it as the object and change the call back functions?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r480904243", "createdAt": "2020-09-01T07:11:40Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -44,44 +49,52 @@\n      * @param serviceName subscribing service name\n      * @return true if call back is registered.\n      */\n-    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n-            Boolean> consumer, String serviceName) {\n-        Map<String, Function<Map<String, Object>, Boolean>> map =\n-                deploymentStatusConsumerMap.getOrDefault(type, new ConcurrentHashMap<>());\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type,\n+                                                    Function<Map<String, Object>, Boolean> consumer,\n+                                                    String serviceName) {\n+        Map<String, Function<Map<String, Object>, Boolean>> map = deploymentStatusConsumerMap\n+                .getOrDefault(type, new ConcurrentHashMap<>());\n         map.putIfAbsent(serviceName, consumer);\n         return deploymentStatusConsumerMap.put(type, map) == null;\n     }\n \n     /**\n      * Persist deployment status in kernel config.\n      *\n-     * @param jobId          id for the deployment.\n+     * @param deploymentId   id for the deployment.\n      * @param deploymentType type of deployment.\n      * @param status         status of deployment.\n      * @param statusDetails  other details of deployment status.\n      */\n-    public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deploymentType,\n-                                                  JobStatus status, Map<String, String> statusDetails) {\n-        // no need to persist status for local deployment\n-        if (deploymentType.equals(DeploymentType.LOCAL)) {\n-            return;\n-        }\n+    public void persistAndPublishDeploymentStatus(String deploymentId, DeploymentType deploymentType, String status,\n+                                                  Map<String, String> statusDetails) {\n \n         //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n         // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n         synchronized (deploymentType) {\n-            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n-            Map<String, Object> deploymentDetails = new HashMap<>();\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n+            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, deploymentId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Map<String, Object> deploymentDetails = null;\n+            if (deploymentType == DeploymentType.IOT_JOBS) {\n+                IotJobsHelper.DeploymentDetailsIotJobs deploymentDetailsIotJobs =\n+                        new IotJobsHelper.DeploymentDetailsIotJobs();\n+                deploymentDetailsIotJobs.setJobId(deploymentId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1ODA4Mw==", "bodyText": "Things like deployment type needs to be stored agnostic of the object type. So we will need to store map. I wanted to have a model for whatever we are storing since it makes it more readable.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r481458083", "createdAt": "2020-09-01T22:05:02Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -44,44 +49,52 @@\n      * @param serviceName subscribing service name\n      * @return true if call back is registered.\n      */\n-    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n-            Boolean> consumer, String serviceName) {\n-        Map<String, Function<Map<String, Object>, Boolean>> map =\n-                deploymentStatusConsumerMap.getOrDefault(type, new ConcurrentHashMap<>());\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type,\n+                                                    Function<Map<String, Object>, Boolean> consumer,\n+                                                    String serviceName) {\n+        Map<String, Function<Map<String, Object>, Boolean>> map = deploymentStatusConsumerMap\n+                .getOrDefault(type, new ConcurrentHashMap<>());\n         map.putIfAbsent(serviceName, consumer);\n         return deploymentStatusConsumerMap.put(type, map) == null;\n     }\n \n     /**\n      * Persist deployment status in kernel config.\n      *\n-     * @param jobId          id for the deployment.\n+     * @param deploymentId   id for the deployment.\n      * @param deploymentType type of deployment.\n      * @param status         status of deployment.\n      * @param statusDetails  other details of deployment status.\n      */\n-    public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deploymentType,\n-                                                  JobStatus status, Map<String, String> statusDetails) {\n-        // no need to persist status for local deployment\n-        if (deploymentType.equals(DeploymentType.LOCAL)) {\n-            return;\n-        }\n+    public void persistAndPublishDeploymentStatus(String deploymentId, DeploymentType deploymentType, String status,\n+                                                  Map<String, String> statusDetails) {\n \n         //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n         // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n         synchronized (deploymentType) {\n-            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n-            Map<String, Object> deploymentDetails = new HashMap<>();\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n+            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, deploymentId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Map<String, Object> deploymentDetails = null;\n+            if (deploymentType == DeploymentType.IOT_JOBS) {\n+                IotJobsHelper.DeploymentDetailsIotJobs deploymentDetailsIotJobs =\n+                        new IotJobsHelper.DeploymentDetailsIotJobs();\n+                deploymentDetailsIotJobs.setJobId(deploymentId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw=="}, "originalCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NzcyNA==", "bodyText": "I agree, having a model makes it more readable.  we can model the values which are agnostic to type using inheritance", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r481467724", "createdAt": "2020-09-01T22:29:40Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -44,44 +49,52 @@\n      * @param serviceName subscribing service name\n      * @return true if call back is registered.\n      */\n-    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n-            Boolean> consumer, String serviceName) {\n-        Map<String, Function<Map<String, Object>, Boolean>> map =\n-                deploymentStatusConsumerMap.getOrDefault(type, new ConcurrentHashMap<>());\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type,\n+                                                    Function<Map<String, Object>, Boolean> consumer,\n+                                                    String serviceName) {\n+        Map<String, Function<Map<String, Object>, Boolean>> map = deploymentStatusConsumerMap\n+                .getOrDefault(type, new ConcurrentHashMap<>());\n         map.putIfAbsent(serviceName, consumer);\n         return deploymentStatusConsumerMap.put(type, map) == null;\n     }\n \n     /**\n      * Persist deployment status in kernel config.\n      *\n-     * @param jobId          id for the deployment.\n+     * @param deploymentId   id for the deployment.\n      * @param deploymentType type of deployment.\n      * @param status         status of deployment.\n      * @param statusDetails  other details of deployment status.\n      */\n-    public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deploymentType,\n-                                                  JobStatus status, Map<String, String> statusDetails) {\n-        // no need to persist status for local deployment\n-        if (deploymentType.equals(DeploymentType.LOCAL)) {\n-            return;\n-        }\n+    public void persistAndPublishDeploymentStatus(String deploymentId, DeploymentType deploymentType, String status,\n+                                                  Map<String, String> statusDetails) {\n \n         //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n         // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n         synchronized (deploymentType) {\n-            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n-            Map<String, Object> deploymentDetails = new HashMap<>();\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n+            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, deploymentId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Map<String, Object> deploymentDetails = null;\n+            if (deploymentType == DeploymentType.IOT_JOBS) {\n+                IotJobsHelper.DeploymentDetailsIotJobs deploymentDetailsIotJobs =\n+                        new IotJobsHelper.DeploymentDetailsIotJobs();\n+                deploymentDetailsIotJobs.setJobId(deploymentId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw=="}, "originalCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMDU5NA==", "bodyText": "Is there a TODO/task for the desired improvement you're discussing here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r482210594", "createdAt": "2020-09-02T16:39:51Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -44,44 +49,52 @@\n      * @param serviceName subscribing service name\n      * @return true if call back is registered.\n      */\n-    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n-            Boolean> consumer, String serviceName) {\n-        Map<String, Function<Map<String, Object>, Boolean>> map =\n-                deploymentStatusConsumerMap.getOrDefault(type, new ConcurrentHashMap<>());\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type,\n+                                                    Function<Map<String, Object>, Boolean> consumer,\n+                                                    String serviceName) {\n+        Map<String, Function<Map<String, Object>, Boolean>> map = deploymentStatusConsumerMap\n+                .getOrDefault(type, new ConcurrentHashMap<>());\n         map.putIfAbsent(serviceName, consumer);\n         return deploymentStatusConsumerMap.put(type, map) == null;\n     }\n \n     /**\n      * Persist deployment status in kernel config.\n      *\n-     * @param jobId          id for the deployment.\n+     * @param deploymentId   id for the deployment.\n      * @param deploymentType type of deployment.\n      * @param status         status of deployment.\n      * @param statusDetails  other details of deployment status.\n      */\n-    public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deploymentType,\n-                                                  JobStatus status, Map<String, String> statusDetails) {\n-        // no need to persist status for local deployment\n-        if (deploymentType.equals(DeploymentType.LOCAL)) {\n-            return;\n-        }\n+    public void persistAndPublishDeploymentStatus(String deploymentId, DeploymentType deploymentType, String status,\n+                                                  Map<String, String> statusDetails) {\n \n         //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n         // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n         synchronized (deploymentType) {\n-            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n-            Map<String, Object> deploymentDetails = new HashMap<>();\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n+            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, deploymentId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Map<String, Object> deploymentDetails = null;\n+            if (deploymentType == DeploymentType.IOT_JOBS) {\n+                IotJobsHelper.DeploymentDetailsIotJobs deploymentDetailsIotJobs =\n+                        new IotJobsHelper.DeploymentDetailsIotJobs();\n+                deploymentDetailsIotJobs.setJobId(deploymentId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw=="}, "originalCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxOTYzNQ==", "bodyText": "Added a TODO to evaluate this approach", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r483719635", "createdAt": "2020-09-04T16:12:51Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -44,44 +49,52 @@\n      * @param serviceName subscribing service name\n      * @return true if call back is registered.\n      */\n-    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n-            Boolean> consumer, String serviceName) {\n-        Map<String, Function<Map<String, Object>, Boolean>> map =\n-                deploymentStatusConsumerMap.getOrDefault(type, new ConcurrentHashMap<>());\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type,\n+                                                    Function<Map<String, Object>, Boolean> consumer,\n+                                                    String serviceName) {\n+        Map<String, Function<Map<String, Object>, Boolean>> map = deploymentStatusConsumerMap\n+                .getOrDefault(type, new ConcurrentHashMap<>());\n         map.putIfAbsent(serviceName, consumer);\n         return deploymentStatusConsumerMap.put(type, map) == null;\n     }\n \n     /**\n      * Persist deployment status in kernel config.\n      *\n-     * @param jobId          id for the deployment.\n+     * @param deploymentId   id for the deployment.\n      * @param deploymentType type of deployment.\n      * @param status         status of deployment.\n      * @param statusDetails  other details of deployment status.\n      */\n-    public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deploymentType,\n-                                                  JobStatus status, Map<String, String> statusDetails) {\n-        // no need to persist status for local deployment\n-        if (deploymentType.equals(DeploymentType.LOCAL)) {\n-            return;\n-        }\n+    public void persistAndPublishDeploymentStatus(String deploymentId, DeploymentType deploymentType, String status,\n+                                                  Map<String, String> statusDetails) {\n \n         //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n         // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n         synchronized (deploymentType) {\n-            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n-            Map<String, Object> deploymentDetails = new HashMap<>();\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n+            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, deploymentId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Map<String, Object> deploymentDetails = null;\n+            if (deploymentType == DeploymentType.IOT_JOBS) {\n+                IotJobsHelper.DeploymentDetailsIotJobs deploymentDetailsIotJobs =\n+                        new IotJobsHelper.DeploymentDetailsIotJobs();\n+                deploymentDetailsIotJobs.setJobId(deploymentId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw=="}, "originalCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNjkxOTUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzoxMjo0MFrOHKoHDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzoxMjo0MFrOHKoHDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDk3NA==", "bodyText": "same as above, can we avoid the serialization and de-serialization ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r480904974", "createdAt": "2020-09-01T07:12:40Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -279,15 +282,15 @@ public IotJobsClient getIotJobsClient(MqttClientConnection connection) {\n     }\n \n     private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n-        String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n-        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        DeploymentDetailsIotJobs deploymentDetailsIotJobs = OBJECT_MAPPER.convertValue(deploymentDetails,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4556, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}