{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NTA3NTAy", "number": 69, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMjo1NjowNFrODiDyRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozODoxM1rODi5ILw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDQwMTk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMjo1NjowNFrOFtJJKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzo0NDoyNlrOFtJUVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MDA0Mg==", "bodyText": "Nit - might as well Get -> Got?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382880042", "createdAt": "2020-02-22T02:56:04Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -370,7 +396,8 @@ private void startStateTransition() throws InterruptedException {\n                                     waitForDependencyReady();\n                                     context.getLog().note(getName(), \"starting\");\n                                 } catch (InterruptedException e) {\n-                                    context.getLog().note(getName(), \"Get interrupted when waiting for dependency ready\");\n+                                    context.getLog()\n+                                            .note(getName(), \"Get interrupted when waiting for dependency ready\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MjkwMQ==", "bodyText": "This was pre-existing, but you're right. Can change.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382882901", "createdAt": "2020-02-22T03:44:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -370,7 +396,8 @@ private void startStateTransition() throws InterruptedException {\n                                     waitForDependencyReady();\n                                     context.getLog().note(getName(), \"starting\");\n                                 } catch (InterruptedException e) {\n-                                    context.getLog().note(getName(), \"Get interrupted when waiting for dependency ready\");\n+                                    context.getLog()\n+                                            .note(getName(), \"Get interrupted when waiting for dependency ready\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MDA0Mg=="}, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDQwNDU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzowMTowNlrOFtJKbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzo0NToyM1rOFtJUew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MDM2NA==", "bodyText": "How did you decide this interval? Wouldn't 1s be too long?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382880364", "createdAt": "2020-02-22T03:01:06Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -627,15 +667,13 @@ private void waitForDependencyReady() throws InterruptedException {\n         synchronized (dependencyReadyLock) {\n             while (!dependencyReady()) {\n                 context.getLog().note(getName(), \"waiting for dependency ready\");\n-                dependencyReadyLock.wait();\n+                dependencyReadyLock.wait(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MjkzOQ==", "bodyText": "Just trying to make the tests pass. This probably isn't the real solution. As you can see, previously it waits forever which I believe is causing some issues. But I won't know until I debug some more on Monday.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382882939", "createdAt": "2020-02-22T03:45:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -627,15 +667,13 @@ private void waitForDependencyReady() throws InterruptedException {\n         synchronized (dependencyReadyLock) {\n             while (!dependencyReady()) {\n                 context.getLog().note(getName(), \"waiting for dependency ready\");\n-                dependencyReadyLock.wait();\n+                dependencyReadyLock.wait(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MDM2NA=="}, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDQwNzI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzowNTo1MFrOFtJLvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzo0NjoxMFrOFtJUxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MDcwMg==", "bodyText": "Hmm, I have not written code to format dependencies with this pattern, it's currently just comma separated service names especially since we haven't changed the recipe model to accept dependency states. For now one of us will need to use Running as the default state", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382880702", "createdAt": "2020-02-22T03:05:50Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -664,27 +702,22 @@ public void postInject() {\n                 }\n             }\n         }).start();\n+    }\n \n-        Node d = config.getChild(\"requires\");\n-        if (d instanceof Topic) {\n-            String ds = ((Topic) d).getOnce().toString();\n-            Matcher m = DEP_PARSE.matcher(ds);\n-            while (m.find()) {\n-                addDependency(m.group(1), m.group(3));\n-            }\n-            if (!m.hitEnd()) {\n-                errored(\"bad dependency syntax\", ds);\n-            }\n-        } else if (d == null) {\n-            return;\n-        } else {\n-            String errMsg = String.format(\"Unrecognized dependency configuration, config content: %s\", d.toString());\n-            context.getLog().error(getName(), errMsg);\n-            // TODO: invalidate the config file\n+    private Map<EvergreenService, State> parseDependencyList(String dependencyList) throws Exception {\n+        Matcher m = DEP_PARSE.matcher(dependencyList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MzAxNQ==", "bodyText": "Right now that is the way that dependencies are formatted (with the default being Running), but Shirley's doc says to remove that behavior. Again, this is unchanged behavior from before and will probably be removed eventually.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382883015", "createdAt": "2020-02-22T03:46:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -664,27 +702,22 @@ public void postInject() {\n                 }\n             }\n         }).start();\n+    }\n \n-        Node d = config.getChild(\"requires\");\n-        if (d instanceof Topic) {\n-            String ds = ((Topic) d).getOnce().toString();\n-            Matcher m = DEP_PARSE.matcher(ds);\n-            while (m.find()) {\n-                addDependency(m.group(1), m.group(3));\n-            }\n-            if (!m.hitEnd()) {\n-                errored(\"bad dependency syntax\", ds);\n-            }\n-        } else if (d == null) {\n-            return;\n-        } else {\n-            String errMsg = String.format(\"Unrecognized dependency configuration, config content: %s\", d.toString());\n-            context.getLog().error(getName(), errMsg);\n-            // TODO: invalidate the config file\n+    private Map<EvergreenService, State> parseDependencyList(String dependencyList) throws Exception {\n+        Matcher m = DEP_PARSE.matcher(dependencyList);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MDcwMg=="}, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDQxMzYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzoxOTo0MlrOFtJO1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzo0Nzo0OFrOFtJVKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MTQ5NA==", "bodyText": "This looks like this will restart all services right? For now it's okay since we have not decided if we will send only added/updated services but curious if this can be done only for updated services if we send the full config.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382881494", "createdAt": "2020-02-22T03:19:42Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -508,4 +518,48 @@ public void addServiceSearchURL(Object url) {\n             }\n         }\n     }\n+\n+    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n+        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+        CompletableFuture<Void> mergeFuture = new CompletableFuture<>();\n+\n+        AtomicInteger allServicesUp = new AtomicInteger(newConfig.size());\n+        EvergreenService.GlobalStateChangeListener listener = (service, was) -> {\n+            if (newConfig.containsKey(service.getName()) && service.getState().equals(State.Running)) {\n+                allServicesUp.decrementAndGet();\n+            }\n+            if (allServicesUp.get() <= 0) {\n+                totallyCompleteFuture.complete(null);\n+            }\n+        };\n+\n+        totallyCompleteFuture.thenRun(() -> {\n+            context.removeGlobalStateChangeListener(listener);\n+        });\n+\n+        context.get(UpdateSystemSafelyService.class)\n+                .addUpdateAction(deploymentId, () -> context.runOnPublishQueueAndWait(() -> {\n+                    try {\n+                        context.addGlobalStateChangeListener(listener);\n+                        mergeMap(timestamp, newConfig);\n+                        mergeFuture.complete(null);\n+                    } catch (IllegalArgumentException e) {\n+                        mergeFuture.completeExceptionally(e);\n+                    }\n+                }));\n+\n+        // Wait for the merge to complete and then have all services start\n+        mergeFuture.thenRun(() -> {\n+            newConfig.keySet().forEach(serviceName -> {\n+                EvergreenService eg = EvergreenService.locate(context, (String) serviceName);\n+                if (eg != null) {\n+                    eg.requestRestart();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MjcxNw==", "bodyText": "Also, since this is not starting up services in order, is it possible this executes more than once for certain services? say A depends on B, both A and B are part of the config so A receives restart request twice, once from here and the second time on account of B being restarted.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382882717", "createdAt": "2020-02-22T03:41:11Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -508,4 +518,48 @@ public void addServiceSearchURL(Object url) {\n             }\n         }\n     }\n+\n+    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n+        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+        CompletableFuture<Void> mergeFuture = new CompletableFuture<>();\n+\n+        AtomicInteger allServicesUp = new AtomicInteger(newConfig.size());\n+        EvergreenService.GlobalStateChangeListener listener = (service, was) -> {\n+            if (newConfig.containsKey(service.getName()) && service.getState().equals(State.Running)) {\n+                allServicesUp.decrementAndGet();\n+            }\n+            if (allServicesUp.get() <= 0) {\n+                totallyCompleteFuture.complete(null);\n+            }\n+        };\n+\n+        totallyCompleteFuture.thenRun(() -> {\n+            context.removeGlobalStateChangeListener(listener);\n+        });\n+\n+        context.get(UpdateSystemSafelyService.class)\n+                .addUpdateAction(deploymentId, () -> context.runOnPublishQueueAndWait(() -> {\n+                    try {\n+                        context.addGlobalStateChangeListener(listener);\n+                        mergeMap(timestamp, newConfig);\n+                        mergeFuture.complete(null);\n+                    } catch (IllegalArgumentException e) {\n+                        mergeFuture.completeExceptionally(e);\n+                    }\n+                }));\n+\n+        // Wait for the merge to complete and then have all services start\n+        mergeFuture.thenRun(() -> {\n+            newConfig.keySet().forEach(serviceName -> {\n+                EvergreenService eg = EvergreenService.locate(context, (String) serviceName);\n+                if (eg != null) {\n+                    eg.requestRestart();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MTQ5NA=="}, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MzExNA==", "bodyText": "Only restarts the services listed in newConfig, so if the config only contains the changed services then only the changed once will be restarted.\nSince it is iterating through newConfig which is a map, it can't tell services to restart twice since each service is one key of the config.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382883114", "createdAt": "2020-02-22T03:47:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -508,4 +518,48 @@ public void addServiceSearchURL(Object url) {\n             }\n         }\n     }\n+\n+    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n+        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+        CompletableFuture<Void> mergeFuture = new CompletableFuture<>();\n+\n+        AtomicInteger allServicesUp = new AtomicInteger(newConfig.size());\n+        EvergreenService.GlobalStateChangeListener listener = (service, was) -> {\n+            if (newConfig.containsKey(service.getName()) && service.getState().equals(State.Running)) {\n+                allServicesUp.decrementAndGet();\n+            }\n+            if (allServicesUp.get() <= 0) {\n+                totallyCompleteFuture.complete(null);\n+            }\n+        };\n+\n+        totallyCompleteFuture.thenRun(() -> {\n+            context.removeGlobalStateChangeListener(listener);\n+        });\n+\n+        context.get(UpdateSystemSafelyService.class)\n+                .addUpdateAction(deploymentId, () -> context.runOnPublishQueueAndWait(() -> {\n+                    try {\n+                        context.addGlobalStateChangeListener(listener);\n+                        mergeMap(timestamp, newConfig);\n+                        mergeFuture.complete(null);\n+                    } catch (IllegalArgumentException e) {\n+                        mergeFuture.completeExceptionally(e);\n+                    }\n+                }));\n+\n+        // Wait for the merge to complete and then have all services start\n+        mergeFuture.thenRun(() -> {\n+            newConfig.keySet().forEach(serviceName -> {\n+                EvergreenService eg = EvergreenService.locate(context, (String) serviceName);\n+                if (eg != null) {\n+                    eg.requestRestart();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MTQ5NA=="}, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDQxNDUxOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/kernel/ServiceConfigMergingTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzoyMTo1MFrOFtJPRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowNTowMlrOFuZ2Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MTYwNQ==", "bodyText": "Nit - This looks okay for now but ideally it'll be helpful if we keep one test class per class", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382881605", "createdAt": "2020-02-22T03:21:50Z", "author": {"login": "shaguptashaikh"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInRelativeOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ServiceConfigMergingTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MzIxMQ==", "bodyText": "I would disagree with that, especially since our classes right now our quite large. That would mean that our test classes would have an enormous number of test cases as well, which isn't ideal. For unit tests it does make sense to separate them by class, but this is more of an integration test (missing the tag right now though). I think that for integration test is makes more sense to separate the test classes based on the piece of functionality that it is testing, like the config update in this case. Of course if everyone agrees that it should be 1 test class per class, then it is easy to move these tests around.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382883211", "createdAt": "2020-02-22T03:49:33Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInRelativeOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ServiceConfigMergingTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MTYwNQ=="}, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0MjY2OQ==", "bodyText": "I also think one test per class is a bit of overkill. We could group corresponding tests together in a test class for better maintainability.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r384142669", "createdAt": "2020-02-25T21:40:53Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInRelativeOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ServiceConfigMergingTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MTYwNQ=="}, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjI4Mw==", "bodyText": "I would revisit this later if the number of additional files grows too much. One approach on the service side was we split the dataplane and control plane tests into separate test packages. We could do something similar here if needed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r384202283", "createdAt": "2020-02-26T00:05:02Z", "author": {"login": "chaurah"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/ServiceConfigMergingTest.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInRelativeOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ServiceConfigMergingTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MTYwNQ=="}, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MDQyMTE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzozNjoyMVrOFtJSkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMzo1NToxOVrOFtJW0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MjQ0OA==", "bodyText": "IIRC the code that processes updates inside this UpdateSystemSafelyService class fails silently on some errors, we would want to capture those as failures and report back, also, not sure how the rest of the code will work, in case of such failures trying to lookup new/updated services and restart them sounds unnecessary", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382882448", "createdAt": "2020-02-22T03:36:21Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -508,4 +518,48 @@ public void addServiceSearchURL(Object url) {\n             }\n         }\n     }\n+\n+    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n+        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+        CompletableFuture<Void> mergeFuture = new CompletableFuture<>();\n+\n+        AtomicInteger allServicesUp = new AtomicInteger(newConfig.size());\n+        EvergreenService.GlobalStateChangeListener listener = (service, was) -> {\n+            if (newConfig.containsKey(service.getName()) && service.getState().equals(State.Running)) {\n+                allServicesUp.decrementAndGet();\n+            }\n+            if (allServicesUp.get() <= 0) {\n+                totallyCompleteFuture.complete(null);\n+            }\n+        };\n+\n+        totallyCompleteFuture.thenRun(() -> {\n+            context.removeGlobalStateChangeListener(listener);\n+        });\n+\n+        context.get(UpdateSystemSafelyService.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MzUzNg==", "bodyText": "Yeah, probably want to wrap all this and catch Throwable to send back to DA.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r382883536", "createdAt": "2020-02-22T03:55:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -508,4 +518,48 @@ public void addServiceSearchURL(Object url) {\n             }\n         }\n     }\n+\n+    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n+        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+        CompletableFuture<Void> mergeFuture = new CompletableFuture<>();\n+\n+        AtomicInteger allServicesUp = new AtomicInteger(newConfig.size());\n+        EvergreenService.GlobalStateChangeListener listener = (service, was) -> {\n+            if (newConfig.containsKey(service.getName()) && service.getState().equals(State.Running)) {\n+                allServicesUp.decrementAndGet();\n+            }\n+            if (allServicesUp.get() <= 0) {\n+                totallyCompleteFuture.complete(null);\n+            }\n+        };\n+\n+        totallyCompleteFuture.thenRun(() -> {\n+            context.removeGlobalStateChangeListener(listener);\n+        });\n+\n+        context.get(UpdateSystemSafelyService.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4MjQ0OA=="}, "originalCommit": {"oid": "e77f1660bc21c5495951e2c9ef468a9eafdddf7b"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTEyNjkxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozMjoxOVrOFuZLEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowNjoyOVrOFuZ4Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MTI0OQ==", "bodyText": "Throw exception instead of silent failure?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r384191249", "createdAt": "2020-02-25T23:32:19Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -589,12 +627,20 @@ public Context getContext() {\n      * @param dependentEvergreenService\n      * @param when\n      */\n-    public void addDependency(EvergreenService dependentEvergreenService, State when) {\n-        if (dependencies == null) {\n-            dependencies = new ConcurrentHashMap<>();\n+    public synchronized void addDependency(EvergreenService dependentEvergreenService, State when) {\n+        if (dependentEvergreenService == null || when == null) {\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "240f74b2cdc52eb5a4a20e66c6e9560d33add15b"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MzM0MA==", "bodyText": "I'd rather not. I wouldn't really consider it a failure since adding a dependency on null, while silly, is really a no-op.\nOf course I can add it if you and others think it is worthwhile, but addDependency gets called from some places which don't have callers, so there's no one to handle the issue.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r384193340", "createdAt": "2020-02-25T23:38:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -589,12 +627,20 @@ public Context getContext() {\n      * @param dependentEvergreenService\n      * @param when\n      */\n-    public void addDependency(EvergreenService dependentEvergreenService, State when) {\n-        if (dependencies == null) {\n-            dependencies = new ConcurrentHashMap<>();\n+    public synchronized void addDependency(EvergreenService dependentEvergreenService, State when) {\n+        if (dependentEvergreenService == null || when == null) {\n+            return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MTI0OQ=="}, "originalCommit": {"oid": "240f74b2cdc52eb5a4a20e66c6e9560d33add15b"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjc3OA==", "bodyText": "I would prefer an explicit failure. Ideally this shouldn't get called at all if there's no dependency right? So it's possible whoever made the request did something incorrectly.\nCan revisit in followup PR.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r384202778", "createdAt": "2020-02-26T00:06:29Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -589,12 +627,20 @@ public Context getContext() {\n      * @param dependentEvergreenService\n      * @param when\n      */\n-    public void addDependency(EvergreenService dependentEvergreenService, State when) {\n-        if (dependencies == null) {\n-            dependencies = new ConcurrentHashMap<>();\n+    public synchronized void addDependency(EvergreenService dependentEvergreenService, State when) {\n+        if (dependentEvergreenService == null || when == null) {\n+            return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MTI0OQ=="}, "originalCommit": {"oid": "240f74b2cdc52eb5a4a20e66c6e9560d33add15b"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTE0MTU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozODoxM1rOFuZTbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo0MDoxNlrOFuZV-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MzM5MA==", "bodyText": "Why the increase and why to 10? (Not for this PR but : Is this something that we may want to make configurable in the future?)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r384193390", "createdAt": "2020-02-25T23:38:13Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -88,7 +91,7 @@ public Kernel() {\n         super(new Context());\n         context.put(Configuration.class, this);\n         context.put(Kernel.class, this);\n-        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "240f74b2cdc52eb5a4a20e66c6e9560d33add15b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NDA0Mg==", "bodyText": "Not actually related to this PR, but this threadpool runs all the backing tasks for all services, so it definitely needs more threads (even more than 10). This probably needs to be switched to a cache threadpool.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/69#discussion_r384194042", "createdAt": "2020-02-25T23:40:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -88,7 +91,7 @@ public Kernel() {\n         super(new Context());\n         context.put(Configuration.class, this);\n         context.put(Kernel.class, this);\n-        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MzM5MA=="}, "originalCommit": {"oid": "240f74b2cdc52eb5a4a20e66c6e9560d33add15b"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4789, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}