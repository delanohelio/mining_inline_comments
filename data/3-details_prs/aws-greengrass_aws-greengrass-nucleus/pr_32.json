{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNzY4Mzc1", "number": 32, "title": "Making multiple coordinated updates to the system config.", "bodyText": "It enables code fragments like:\n    kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(\"test\", \n        ()->kernel.readMerge(Kernel.class.getResource(\"delta.yaml\"), false));\n\nThe readMerge() call reads the deltas in the file \"delta.yaml\", which can\nalso be in JSON or TLog format.  addUpdateAction() causes it to happen when\nthe system is in a safe state.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-01-11T21:57:59Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32", "merged": true, "mergeCommit": {"oid": "c4995f62056c94fb858ba0ec8820e36cc04993a9"}, "closed": true, "closedAt": "2020-01-16T18:29:37Z", "author": {"login": "JamesGosling"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb5Z_SdAH2gAyMzYxNzY4Mzc1OjEyMDQxM2E4YjhiYzMxNjE0NWIxMzNiMTRlYmNmNjI1NjdmNDYxYjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6-ZvbAH2gAyMzYxNzY4Mzc1OjBhYzI4N2MzY2M5ZDYyZDVmNTQ4NTNhYjA0N2EzYTYwZTcxNzhkYTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "120413a8b8bc316145b133b14ebcf62567f461b7", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/120413a8b8bc316145b133b14ebcf62567f461b7", "committedDate": "2020-01-11T21:25:22Z", "message": "Making multiple coordinated updates to the system config.  It enables\ncode fragments like:\n\n    kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(\"test\", \n        ()->kernel.readMerge(Kernel.class.getResource(\"delta.yaml\"), false));\n\nThe readMerge() call reads the deltas in the file \"delta.yaml\", which can\nalso be in JSON or TLog format.  addUpdateAction() causes it to happen when\nthe system is in a safe state."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1bc7066a951cdd500ba87687bc375c83e6b8a0e0", "committedDate": "2020-01-11T22:00:56Z", "message": "Merge branch 'master' into CompoundChanges"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTQ0MTM0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#pullrequestreview-341544134", "createdAt": "2020-01-11T22:31:32Z", "commit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQyMjozMTozM1rOFcnIDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQyMzowNDowNFrOFcnMrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTQ4Ng==", "bodyText": "[nit]\nMaybe useSourceTimestamp or sourceTimestampAvailable.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365545486", "createdAt": "2020-01-11T22:31:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Configuration.java", "diffHunk": "@@ -99,12 +97,13 @@ public void deepForEachTopic(Consumer<Topic> f) {\n         root.deepForEachTopic(f);\n     }\n     public Configuration read(String s) throws IOException {\n-        return s.contains(\":/\") ? read(new URL(s)) : read(Paths.get(s));\n+        return s.contains(\":/\") ? read(new URL(s), false) : read(Paths.get(s));\n     }\n-    public Configuration read(URL url) throws IOException {\n+    public Configuration read(URL url, boolean sourceTimestamp) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTU4Mw==", "bodyText": "Could this be made AutoCloseable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365545583", "createdAt": "2020-01-11T22:34:29Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationWriter.java", "diffHunk": "@@ -12,10 +12,12 @@\n public class ConfigurationWriter implements Closeable, Subscriber {\n     private final Writer out;\n     private final Configuration conf;\n+    private  boolean flushImmediately;\n     public static void dump(Configuration c, Path file) {\n         try (CommitableWriter out = CommitableWriter.abandonOnClose(file);\n                 ConfigurationWriter cs = new ConfigurationWriter(c, out)) {\n             cs.writeAll();\n+            cs.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NTczMQ==", "bodyText": "[nit]\nMaybe something like bubbleUpChanges = true or even simply notifyParentOfChanges =true  instead of transparency. Transparency to me sounds a bit like the change is only ever bubbled up and not handled at all at this node.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365545731", "createdAt": "2020-01-11T22:38:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Node.java", "diffHunk": "@@ -20,6 +20,7 @@ protected Node(Context c, String n, Topics p) {\n     public final Context context;\n     public final String name;\n     public final Topics parent;\n+    private boolean transParent; // parent doesn't get notified of changes to this node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjIzMA==", "bodyText": "I see you're returning the lower 8 bits of the exit code, but why is this needed? Shouldn't it just return the exit code as-is?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365546230", "createdAt": "2020-01-11T22:52:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -40,31 +48,57 @@ public void startup() {\n     }\n     @Override\n     public void run() {\n-//        log().significant(\"running\", this);\n         if (run(\"run\", exit -> {\n-            if (exit == 0) {\n-                setState(State.Finished);\n-                context.getLog().significant(\"Finished\", getName());\n-            } else {\n-                setState(State.Errored);\n-                context.getLog().error(\"Failed\", getName(), exit);\n-            }\n+            currentScript = null;\n+            if(!inShutdown)\n+                if (exit == 0) {\n+                    setState(State.Finished);\n+                    context.getLog().significant(getName(), \"Finished\");\n+                } else {\n+                    setState(State.Errored);\n+                    context.getLog().error(getName(), \"Failed\", exit2String(exit));\n+                }\n         })==RunStatus.NothingDone) {\n-            context.getLog().significant(\"run: NothingDone\", getName());\n+            context.getLog().significant(getName(), \"run: NothingDone\");\n             setState(State.Finished);\n         }\n     }\n-\n+    static final String[] sigCodes = {\n+        \"SIGHUP\", \"SIGINT\", \"SIGQUIT\", \"SIGILL\", \"SIGTRAP\", \"SIGIOT\", \"SIGBUS\", \"SIGFPE\",\n+        \"SIGKILL\", \"SIGUSR1\", \"SIGSEGV\", \"SIGUSR2\", \"SIGPIPE\", \"SIGALRM\", \"SIGTERM\",\n+        \"SIGSTKFLT\", \"SIGCHLD\", \"SIGCONT\", \"SIGSTOP\", \"SIGTSTP\", \"SIGTTIN\", \"SIGTTOU\",\n+        \"SIGURG\", \"SIGXCPU\", \"SIGXFSZ\", \"SIGVTALRM\", \"SIGPROF\", \"SIGWINCH\", \"SIGIO\",\n+        \"SIGPWR\", \"SIGSYS\",\n+    };\n+    public static String exit2String(int exitCode) {\n+        return exitCode>128 && exitCode<129+sigCodes.length\n+            ? sigCodes[exitCode-129]\n+            : \"exit(\"+((exitCode<<24)>>24)+\")\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjY2OA==", "bodyText": "Should the return type be a Duration or a date? Otherwise it is difficult to know (just from the interface) that the long in the return represents time in milliseconds.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365546668", "createdAt": "2020-01-11T23:04:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disrutableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisrutableCheck(DisruptableCheck d) {\n+        disrutableChecks.add(d);\n+    }\n+    public void removeDisrutableCheck(DisruptableCheck d) {\n+        disrutableChecks.remove(d);\n+    }\n+    /**\n+     * \n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);\n+    }\n+    protected synchronized void runUpdateActions() {\n+        for (Map.Entry<String, Crashable> todo : pendingActions.entrySet())\n+            try {\n+                todo.getValue().run();\n+            } catch (Throwable t) {\n+                log.error(getName(), \"Error processing system update\", todo.getKey(), t);\n+            }\n+        pendingActions.clear();\n+        for (DisruptableCheck c : disrutableChecks) c.disruptableCheck(false); // Notify disruption is over\n+    }\n+    @SuppressWarnings(\"SleepWhileInLoop\")\n+    @Override public void run() {\n+        // run() is invoked on it's own thread\n+        log.note(getName(), \"Checking for updates\");\n+        while (!pendingActions.isEmpty()) {\n+            final long now = System.currentTimeMillis();\n+            long maxt = now;\n+\n+            log.note(getName(), \"updates pending:\", pendingActions.size());\n+            for (DisruptableCheck c : disrutableChecks) {\n+                long ct = c.disruptableCheck(true);\n+                if (ct > maxt) maxt = ct;\n+            }\n+            if (maxt > now) try {\n+                log.note(getName(), \"Holding for\", maxt - now, \"millis\u00cf\");\n+                Thread.sleep(maxt - now);\n+            } catch (InterruptedException ex) {\n+            }\n+            else {\n+                log.note(getName(), \"Queueing update actions\");\n+                context.runOnPublishQueueAndWait(() -> {\n+                    log.note(getName(), \"Starting safe-time update\");\n+                    runUpdateActions();\n+                    log.note(getName(), \"Finished read-phase of safe-time update\");\n+                });\n+                log.note(getName(), \"Back on run Q safe-time update\");\n+            }\n+        }\n+        super.run();\n+    }\n+\n+    public static interface DisruptableCheck {\n+        /**\n+         * \n+         * @param disruptionPending true iff a disruption is pending.  After a disruption,\n+         *      disruptableCheck is called with this being false to signal to the handler\n+         *      that it's OK to start activity\n+         * @return Estimated time that this handler will be willing to be disrupted. If\n+         *      the returned value is less than now (System.currentTimeMillis()) the handler\n+         *      is granting permission to be disrupted.  Otherwise, it will be asked again\n+         *      sometime later.\n+         */\n+        public long disruptableCheck(boolean disruptionPending);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f2a6c54543bae2b363dd6e49a8f4818b2392b98", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4f2a6c54543bae2b363dd6e49a8f4818b2392b98", "committedDate": "2020-01-12T01:09:23Z", "message": "Making multiple coordinated updates to the system config.  It enables\ncode fragments like:\n\n    kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(\"test\", \n        ()->kernel.readMerge(Kernel.class.getResource(\"delta.yaml\"), false));\n\nThe readMerge() call reads the deltas in the file \"delta.yaml\", which can\nalso be in JSON or TLog format.  addUpdateAction() causes it to happen when\nthe system is in a safe state."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3f7c8f67268edee3cd878ae177c00e638716231", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f3f7c8f67268edee3cd878ae177c00e638716231", "committedDate": "2020-01-12T01:09:23Z", "message": "Trivial change to trigger build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82fd928d9aeba34eda9c8ab3c9248dfd30ca8334", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/82fd928d9aeba34eda9c8ab3c9248dfd30ca8334", "committedDate": "2020-01-12T01:46:50Z", "message": "Merge origin/CompoundChanges into CompoundChanges\n\nConflicts:\n\tsrc/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b4523d342493751826c6852ba2c3aebea9b2422", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b4523d342493751826c6852ba2c3aebea9b2422", "committedDate": "2020-01-13T04:37:53Z", "message": "Respond to PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNTQ3NTUz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#pullrequestreview-341547553", "createdAt": "2020-01-12T00:37:30Z", "commit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMlQwMDozNzozMFrOFcnY-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QwNjo0NDoxNlrOFcuLIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0OTgxOQ==", "bodyText": "nit: disruptableChecks", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365549819", "createdAt": "2020-01-12T00:37:30Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disrutableChecks = new CopyOnWriteArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0OTgzNQ==", "bodyText": "nit: addDisruptableCheck", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365549835", "createdAt": "2020-01-12T00:37:50Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disrutableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisrutableCheck(DisruptableCheck d) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0OTgzOQ==", "bodyText": "nit: removeDisruptableCheck", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365549839", "createdAt": "2020-01-12T00:38:02Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disrutableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisrutableCheck(DisruptableCheck d) {\n+        disrutableChecks.add(d);\n+    }\n+    public void removeDisrutableCheck(DisruptableCheck d) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY1OTkyMQ==", "bodyText": "nit: can you add a todo for these timeouts? Presumably we want them to be configurable in the future", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365659921", "createdAt": "2020-01-13T06:37:04Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/util/Exec.java", "diffHunk": "@@ -208,17 +206,57 @@ public void run() {\n                         break;\n                 }\n             } catch (Throwable t) {\n-                appendStackTrace(t, out);\n+                // nothing that can go wrong here worries us, they're\n+                // all EOFs\n+                // appendStackTrace(t, out);\n             }\n             if (whenDone != null && numberOfCopiers.decrementAndGet() <= 0)\n                 try {\n-                    process.waitFor(10, TimeUnit.SECONDS);\n-                    whenDone.accept(process.exitValue());\n+                    process.waitFor(10, TimeUnit.SECONDS); // be graceful\n+                    setClosed();\n                 } catch (Throwable t) {\n                     t.printStackTrace(System.out);\n                 }\n         }\n     }\n+    synchronized void setClosed() {\n+        if(!closed) {\n+            IntConsumer wd = whenDone;\n+            int exit = process!=null ? process.exitValue() : -1;\n+            closed = true;\n+            process = null;\n+            stderrc = null;\n+            stdoutc = null;\n+            whenDone = null;\n+            if(wd!=null) wd.accept(exit);\n+            notifyAll();\n+        }\n+    }\n+    public boolean isRunning() { return !closed; }\n+    public synchronized boolean waitClosed(int timeout) {\n+        if(!closed) try {\n+            wait(timeout);\n+        } catch(InterruptedException ie){}\n+        return closed;\n+    }\n+    @Override\n+    public synchronized void close() throws IOException {\n+        if(!closed) {\n+            Process p = process;\n+            if(p!=null) {\n+                p.destroy();\n+                if(!waitClosed(2000)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b4523d342493751826c6852ba2c3aebea9b2422"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY2MDk2MA==", "bodyText": "I'm not sure how this function would be implemented, but since the return value only applies when disruptionPending is true, is it worth splitting this into two functions?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r365660960", "createdAt": "2020-01-13T06:44:16Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disrutableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisrutableCheck(DisruptableCheck d) {\n+        disrutableChecks.add(d);\n+    }\n+    public void removeDisrutableCheck(DisruptableCheck d) {\n+        disrutableChecks.remove(d);\n+    }\n+    /**\n+     * \n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);\n+    }\n+    protected synchronized void runUpdateActions() {\n+        for (Map.Entry<String, Crashable> todo : pendingActions.entrySet())\n+            try {\n+                todo.getValue().run();\n+            } catch (Throwable t) {\n+                log.error(getName(), \"Error processing system update\", todo.getKey(), t);\n+            }\n+        pendingActions.clear();\n+        for (DisruptableCheck c : disrutableChecks) c.disruptableCheck(false); // Notify disruption is over\n+    }\n+    @SuppressWarnings(\"SleepWhileInLoop\")\n+    @Override public void run() {\n+        // run() is invoked on it's own thread\n+        log.note(getName(), \"Checking for updates\");\n+        while (!pendingActions.isEmpty()) {\n+            final long now = System.currentTimeMillis();\n+            long maxt = now;\n+\n+            log.note(getName(), \"updates pending:\", pendingActions.size());\n+            for (DisruptableCheck c : disrutableChecks) {\n+                long ct = c.disruptableCheck(true);\n+                if (ct > maxt) maxt = ct;\n+            }\n+            if (maxt > now) try {\n+                log.note(getName(), \"Holding for\", maxt - now, \"millis\u00cf\");\n+                Thread.sleep(maxt - now);\n+            } catch (InterruptedException ex) {\n+            }\n+            else {\n+                log.note(getName(), \"Queueing update actions\");\n+                context.runOnPublishQueueAndWait(() -> {\n+                    log.note(getName(), \"Starting safe-time update\");\n+                    runUpdateActions();\n+                    log.note(getName(), \"Finished read-phase of safe-time update\");\n+                });\n+                log.note(getName(), \"Back on run Q safe-time update\");\n+            }\n+        }\n+        super.run();\n+    }\n+\n+    public static interface DisruptableCheck {\n+        /**\n+         * \n+         * @param disruptionPending true iff a disruption is pending.  After a disruption,\n+         *      disruptableCheck is called with this being false to signal to the handler\n+         *      that it's OK to start activity\n+         * @return Estimated time that this handler will be willing to be disrupted. If\n+         *      the returned value is less than now (System.currentTimeMillis()) the handler\n+         *      is granting permission to be disrupted.  Otherwise, it will be asked again\n+         *      sometime later.\n+         */\n+        public long disruptableCheck(boolean disruptionPending);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU0NjY2OA=="}, "originalCommit": {"oid": "1bc7066a951cdd500ba87687bc375c83e6b8a0e0"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/094079a156977e8274233eab8b7673fd18aa16f5", "committedDate": "2020-01-14T00:28:51Z", "message": "Respond to PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMjY3Nzc0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#pullrequestreview-342267774", "createdAt": "2020-01-14T02:59:17Z", "commit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMjo1OToxN1rOFdK-jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQwMjo1OToxN1rOFdK-jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzMjg3Ng==", "bodyText": "Any reason why these are removed? I think Shirley's doc on states still has Unstable in it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366132876", "createdAt": "2020-01-14T02:59:17Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/dependency/State.java", "diffHunk": "@@ -34,20 +34,20 @@\n      * ever take a significant amount of time to run.\n      */\n     Running(true, true, true),\n-    /**\n-     * Running, but experiencing problems that the service is attempting to\n-     * repair itself\n-     */\n-    Unstable(false, true, false),\n+//    /**\n+//     * Running, but experiencing problems that the service is attempting to\n+//     * repair itself\n+//     */\n+//    Unstable(false, true, false),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNjgxMzMy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#pullrequestreview-342681332", "createdAt": "2020-01-14T16:47:49Z", "commit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNjo0Nzo1MFrOFdecTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNjo0OTozMVrOFdegGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1MTc5MA==", "bodyText": "nit: looks like a weird character \"\u00cf\" got added to the end of millis", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366451790", "createdAt": "2020-01-14T16:47:50Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.add(d);\n+    }\n+    public void removeDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.remove(d);\n+    }\n+    /**\n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed.\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);\n+    }\n+    protected synchronized void runUpdateActions() {\n+        for (Map.Entry<String, Crashable> todo : pendingActions.entrySet())\n+            try {\n+                todo.getValue().run();\n+            } catch (Throwable t) {\n+                log.error(getName(), \"Error processing system update\", todo.getKey(), t);\n+            }\n+        pendingActions.clear();\n+        for (DisruptableCheck c : disruptableChecks) c.disruptionCompleted(); // Notify disruption is over\n+    }\n+    @SuppressWarnings(\"SleepWhileInLoop\")\n+    @Override public void run() {\n+        // run() is invoked on it's own thread\n+        log.note(getName(), \"Checking for updates\");\n+        while (!pendingActions.isEmpty()) {\n+            final long now = System.currentTimeMillis();\n+            long maxt = now;\n+\n+            log.note(getName(), \"updates pending:\", pendingActions.size());\n+            for (DisruptableCheck c : disruptableChecks) {\n+                long ct = c.whenIsDisruptionOK();\n+                if (ct > maxt) maxt = ct;\n+            }\n+            if (maxt > now) try {\n+                log.note(getName(), \"Holding for\", maxt - now, \"millis\u00cf\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1MjMyNw==", "bodyText": "you used to have a clock that could be injected. Is that still available?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366452327", "createdAt": "2020-01-14T16:48:47Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.add(d);\n+    }\n+    public void removeDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.remove(d);\n+    }\n+    /**\n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed.\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);\n+    }\n+    protected synchronized void runUpdateActions() {\n+        for (Map.Entry<String, Crashable> todo : pendingActions.entrySet())\n+            try {\n+                todo.getValue().run();\n+            } catch (Throwable t) {\n+                log.error(getName(), \"Error processing system update\", todo.getKey(), t);\n+            }\n+        pendingActions.clear();\n+        for (DisruptableCheck c : disruptableChecks) c.disruptionCompleted(); // Notify disruption is over\n+    }\n+    @SuppressWarnings(\"SleepWhileInLoop\")\n+    @Override public void run() {\n+        // run() is invoked on it's own thread\n+        log.note(getName(), \"Checking for updates\");\n+        while (!pendingActions.isEmpty()) {\n+            final long now = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ1Mjc2MA==", "bodyText": "what does the boolean signify here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366452760", "createdAt": "2020-01-14T16:49:31Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.add(d);\n+    }\n+    public void removeDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.remove(d);\n+    }\n+    /**\n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed.\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);\n+    }\n+    protected synchronized void runUpdateActions() {\n+        for (Map.Entry<String, Crashable> todo : pendingActions.entrySet())\n+            try {\n+                todo.getValue().run();\n+            } catch (Throwable t) {\n+                log.error(getName(), \"Error processing system update\", todo.getKey(), t);\n+            }\n+        pendingActions.clear();\n+        for (DisruptableCheck c : disruptableChecks) c.disruptionCompleted(); // Notify disruption is over\n+    }\n+    @SuppressWarnings(\"SleepWhileInLoop\")\n+    @Override public void run() {\n+        // run() is invoked on it's own thread\n+        log.note(getName(), \"Checking for updates\");\n+        while (!pendingActions.isEmpty()) {\n+            final long now = System.currentTimeMillis();\n+            long maxt = now;\n+\n+            log.note(getName(), \"updates pending:\", pendingActions.size());\n+            for (DisruptableCheck c : disruptableChecks) {\n+                long ct = c.whenIsDisruptionOK();\n+                if (ct > maxt) maxt = ct;\n+            }\n+            if (maxt > now) try {\n+                log.note(getName(), \"Holding for\", maxt - now, \"millis\u00cf\");\n+                Thread.sleep(maxt - now);\n+            } catch (InterruptedException ex) {\n+            }\n+            else {\n+                log.note(getName(), \"Queueing update actions\");\n+                context.runOnPublishQueueAndWait(() -> {\n+                    log.note(getName(), \"Starting safe-time update\");\n+                    runUpdateActions();\n+                    log.note(getName(), \"Finished read-phase of safe-time update\");\n+                });\n+                log.note(getName(), \"Back on run Q safe-time update\");\n+            }\n+        }\n+        super.run();\n+    }\n+\n+    public static interface DisruptableCheck {\n+        /**\n+         * Inform a listener that a disruption is pending to find out when a disruption\n+         * is acceptable.\n+         * @return Estimated time when this handler will be willing to be disrupted,\n+         *      expressed as milliseconds since the epoch. If\n+         *      the returned value is less than now (System.currentTimeMillis()) the handler\n+         *      is granting permission to be disrupted.  Otherwise, it will be asked again\n+         *      sometime later.\n+         */\n+        public long whenIsDisruptionOK();\n+        /** After a disruption, this is called to signal to the handler that the\n+         * disruption is over and it's OK to start activity */\n+        public boolean disruptionCompleted();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTExMTUx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#pullrequestreview-342911151", "createdAt": "2020-01-14T23:41:26Z", "commit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMzo0MToyNlrOFdpWnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDoxNjowNFrOFdp6dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzMDU1Ng==", "bodyText": "Yeah I noticed this bug as well. Have a temporary check in #30", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366630556", "createdAt": "2020-01-14T23:41:26Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/ShellRunner.java", "diffHunk": "@@ -21,16 +21,18 @@\n         @Override\n         public synchronized Exec setup(String note, String command, EvergreenService onBehalfOf) {\n             if (!isEmpty(command) && onBehalfOf != null) {\n-                if (!isEmpty(note))\n+                if (!isEmpty(note) && log!=null /* !!?!! */)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzMjgxMQ==", "bodyText": "Will this result in run() being called multiple times?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366632811", "createdAt": "2020-01-14T23:49:55Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.*;\n+import com.aws.iot.evergreen.util.Log;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import javax.inject.*;\n+\n+/**\n+ * Handles requests to update the system's configuration during safe times.\n+ * (or anything else that's disruptive and shouldn't be done until the system\n+ * is in a \"safe\" state).\n+ * \n+ * It maintains two lists: one is a list of actions that will be executed when the\n+ * system is next \"disruptable\".  This is typically code that is going to install an update.\n+ * \n+ * The other is a list of functions that are called to check if the system is \"disruptable\".\n+ * For example, a TV might not be disruptable if it is being used, or a robot if it is\n+ * in motion.\n+ * \n+ * If the update service is periodic, update actions will only be processed at that time.\n+ * Otherwise, it the update will be processed immediately, assuming that all disruptability\n+ * checks pass.\n+ */\n+@ImplementsService(name = \"update\", autostart = true)\n+@Singleton\n+public class UpdateSystemSafelyService extends EvergreenService {\n+    @Inject Log log;\n+    private final LinkedHashMap<String, Crashable> pendingActions = new LinkedHashMap<>();\n+    private final CopyOnWriteArrayList<DisruptableCheck> disruptableChecks = new CopyOnWriteArrayList<>();\n+\n+    public UpdateSystemSafelyService(Topics c) {\n+        super(c);\n+    }\n+    public void addDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.add(d);\n+    }\n+    public void removeDisruptableCheck(DisruptableCheck d) {\n+        disruptableChecks.remove(d);\n+    }\n+    /**\n+     * @param tag used both as a printable description and a de-duplication key.  eg. If\n+     *          the action is installing a new config file, the tag should probably be the\n+     *          URL of the config.  If a key is duplicated by subsequent actions, they\n+     *          are suppressed.\n+     * @param action The action to be performed.\n+     */\n+    public synchronized void addUpdateAction(String tag, Crashable action) {\n+        pendingActions.put(tag, action);\n+        log.note(getName(), \"Adding update action\", tag);\n+        if (!isPeriodic()) setState(State.Running);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzODc1MA==", "bodyText": "So basically if the 'install' part of a configuration file changed, the service will automatically re-install , if any other parts changed, service will restart. Should we skip child.childOf(\"shutdown\") ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366638750", "createdAt": "2020-01-15T00:12:36Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -18,6 +18,14 @@\n public class GenericExternalService extends EvergreenService {\n     public GenericExternalService(Topics c) {\n         super(c);\n+        c.subscribe((what,child)->{\n+            if(c.parentNeedsToKnow()) {\n+                context.getLog().warn(getName(),\"responding to change to\",child);\n+                if(child.childOf(\"install\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzOTczMw==", "bodyText": "Should run(\"shutdown\") be before closing the Exec or after?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/32#discussion_r366639733", "createdAt": "2020-01-15T00:16:04Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -40,34 +48,56 @@ public void startup() {\n     }\n     @Override\n     public void run() {\n-//        log().significant(\"running\", this);\n         if (run(\"run\", exit -> {\n-            if (exit == 0) {\n-                setState(State.Finished);\n-                context.getLog().significant(\"Finished\", getName());\n-            } else {\n-                setState(State.Errored);\n-                context.getLog().error(\"Failed\", getName(), exit);\n-            }\n+            currentScript = null;\n+            if(!inShutdown)\n+                if (exit == 0) {\n+                    setState(State.Finished);\n+                    context.getLog().significant(getName(), \"Finished\");\n+                } else {\n+                    setState(State.Errored);\n+                    context.getLog().error(getName(), \"Failed\", exit2String(exit));\n+                }\n         })==RunStatus.NothingDone) {\n-            context.getLog().significant(\"run: NothingDone\", getName());\n+            context.getLog().significant(getName(), \"run: NothingDone\");\n             setState(State.Finished);\n         }\n     }\n-\n+    static final String[] sigCodes = {\n+        \"SIGHUP\", \"SIGINT\", \"SIGQUIT\", \"SIGILL\", \"SIGTRAP\", \"SIGIOT\", \"SIGBUS\", \"SIGFPE\",\n+        \"SIGKILL\", \"SIGUSR1\", \"SIGSEGV\", \"SIGUSR2\", \"SIGPIPE\", \"SIGALRM\", \"SIGTERM\",\n+        \"SIGSTKFLT\", \"SIGCHLD\", \"SIGCONT\", \"SIGSTOP\", \"SIGTSTP\", \"SIGTTIN\", \"SIGTTOU\",\n+        \"SIGURG\", \"SIGXCPU\", \"SIGXFSZ\", \"SIGVTALRM\", \"SIGPROF\", \"SIGWINCH\", \"SIGIO\",\n+        \"SIGPWR\", \"SIGSYS\",\n+    };\n+    public static String exit2String(int exitCode) {\n+        return exitCode>128 && exitCode<129+sigCodes.length\n+            ? sigCodes[exitCode-129]\n+            : \"exit(\"+((exitCode<<24)>>24)+\")\";\n+    }\n+    private boolean inShutdown;\n     @Override\n     public void shutdown() {\n+        inShutdown = true;\n+//        context.getLog().significant(this,\"starting shutdown\");\n+        Exec e = currentScript;\n+        if(e!=null && e.isRunning()) try {\n+            context.getLog().significant(getName(),\"shutting down\",e);\n+            e.close();\n+            e.waitClosed(1000);\n+//            new Throwable().printStackTrace();\n+        } catch(IOException ioe) {\n+            context.getLog().error(\n+                    this,\"shutdown failure\",Utils.getUltimateMessage(ioe));\n+        }\n //        context.getLog().significant(\"shutdown\", this);\n         run(\"shutdown\", null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "094079a156977e8274233eab8b7673fd18aa16f5"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0756605816cba277be1d7324a5a8b0bd231cbb97", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0756605816cba277be1d7324a5a8b0bd231cbb97", "committedDate": "2020-01-16T17:51:28Z", "message": "Respond to PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c29f15fd7f298a8c6b6eaee480ce15ea27781ffa", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c29f15fd7f298a8c6b6eaee480ce15ea27781ffa", "committedDate": "2020-01-16T18:11:15Z", "message": "Merge branch 'master' into CompoundChanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6d3379b80873ea9b2951d946f24a53b956e7681", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c6d3379b80873ea9b2951d946f24a53b956e7681", "committedDate": "2020-01-16T18:21:33Z", "message": "Making multiple coordinated updates to the system config.  It enables\ncode fragments like:\n\n    kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(\"test\", \n        ()->kernel.readMerge(Kernel.class.getResource(\"delta.yaml\"), false));\n\nThe readMerge() call reads the deltas in the file \"delta.yaml\", which can\nalso be in JSON or TLog format.  addUpdateAction() causes it to happen when\nthe system is in a safe state."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65439889bdd454a93cc120931c3de14d47798d25", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/65439889bdd454a93cc120931c3de14d47798d25", "committedDate": "2020-01-16T18:22:49Z", "message": "Respond to PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db71c0a641fac9a3f4d324b414164226478e6477", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/db71c0a641fac9a3f4d324b414164226478e6477", "committedDate": "2020-01-16T18:23:39Z", "message": "Respond to PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8137eea97fa759b46fd181ed019d55fdeea19ab0", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8137eea97fa759b46fd181ed019d55fdeea19ab0", "committedDate": "2020-01-16T18:23:39Z", "message": "Respond to PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ac287c3cc9d62d5f54853ab047a3a60e7178da0", "author": {"user": {"login": "JamesGosling", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0ac287c3cc9d62d5f54853ab047a3a60e7178da0", "committedDate": "2020-01-16T18:24:46Z", "message": "\"Unstable\" eliminated -- right or wrong?"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2435, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}