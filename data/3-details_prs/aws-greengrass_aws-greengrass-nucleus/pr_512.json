{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMjYzMzU1", "number": 512, "title": "Pubsub IPC event stream integration", "bodyText": "Issue #, if available:\nDescription of changes:\nWhy is this change necessary:\nPubSub IPC changes using new event stream\nHow was this change tested:\nHave verified in integration tests that the PubSub APIs work with new IPC server\nAny additional information or context required to review the change:\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-10-09T00:19:16Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512", "merged": true, "mergeCommit": {"oid": "8515b8e7767ed1e9ee892c9b14058c9524123a06"}, "closed": true, "closedAt": "2020-10-26T23:03:25Z", "author": {"login": "nikkhilmuthye"}, "timelineItems": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQsh9EAFqTUwNTMxNjAwMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdWb0pxgH2gAyNTAwMjYzMzU1OjhiMDMyMjk2N2E2MjgwMzVlYWNiNDJmMzI0Nzg2ZGM1ZGNmNjY3MGM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzE2MDAz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-505316003", "createdAt": "2020-10-09T02:12:55Z", "commit": {"oid": "9f7c414503ee454ef945d42d9041ea3f99858e59"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjoxMjo1NVrOHe37Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjoxMjo1NVrOHe37Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzNTYwNw==", "bodyText": "I think you extend the wrong parent class. It should be GeneratedAbstractPublishToTopicOperationHandler. GeneratedAbstractPublishToIoTCoreOperationHandler is for MQTTClient.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r502135607", "createdAt": "2020-10-09T02:12:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.DefaultConcurrentHashMap;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ResourceNotFoundError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import lombok.Getter;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+import software.amazon.eventstream.iot.server.ServerStreamEventPublisher;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final Map<String, Set<ServerStreamEventPublisher<IoTCoreMessage>>> listeners =\n+            new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);\n+    private static final Map<String, ServerStreamEventPublisher<IoTCoreMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f7c414503ee454ef945d42d9041ea3f99858e59"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzE2MjU1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-505316255", "createdAt": "2020-10-09T02:13:49Z", "commit": {"oid": "9f7c414503ee454ef945d42d9041ea3f99858e59"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjoxMzo0OVrOHe39DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMjoxMzo0OVrOHe39DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzNjA3Ng==", "bodyText": "Same here. For internal pubsub, it should extend to GeneratedAbstractSubscribeToTopicOperationHandler and GeneratedAbstractPublishToTopicOperationHandler", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r502136076", "createdAt": "2020-10-09T02:13:49Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.DefaultConcurrentHashMap;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ResourceNotFoundError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import lombok.Getter;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+import software.amazon.eventstream.iot.server.ServerStreamEventPublisher;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final Map<String, Set<ServerStreamEventPublisher<IoTCoreMessage>>> listeners =\n+            new DefaultConcurrentHashMap<>(CopyOnWriteArraySet::new);\n+    private static final Map<String, ServerStreamEventPublisher<IoTCoreMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest publishRequest) {\n+            if (!listeners.containsKey(publishRequest.getTopicName())) {\n+                // Still technically successful, just no one was subscribed\n+                return new PublishToIoTCoreResponse();\n+            }\n+            Set<ServerStreamEventPublisher<IoTCoreMessage>> contexts = listeners.get(publishRequest.getTopicName());\n+\n+            executor.execute(() -> contexts.forEach(c -> {\n+                log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Sending publish event {} to {}\", publishRequest);\n+                MQTTMessage mqttMessage = new MQTTMessage();\n+                mqttMessage.setPayload(publishRequest.getPayload());\n+                mqttMessage.setTopicName(publishRequest.getTopicName());\n+                IoTCoreMessage ioTCoreMessage = new IoTCoreMessage();\n+                ioTCoreMessage.setMessage(mqttMessage);\n+                c.sendStreamEvent(ioTCoreMessage);\n+            }));\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+            // NA\n+        }\n+    }\n+\n+    static class UnsubscribeFromIoTCoreOperationHandler", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f7c414503ee454ef945d42d9041ea3f99858e59"}, "originalPosition": 95}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f7c414503ee454ef945d42d9041ea3f99858e59", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9f7c414503ee454ef945d42d9041ea3f99858e59", "committedDate": "2020-10-09T00:17:25Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "ac1753a36d93e58bfd62204593c6fd765fd65ff7", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ac1753a36d93e58bfd62204593c6fd765fd65ff7", "committedDate": "2020-10-09T02:49:13Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ac1753a36d93e58bfd62204593c6fd765fd65ff7", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ac1753a36d93e58bfd62204593c6fd765fd65ff7", "committedDate": "2020-10-09T02:49:13Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "fce568b04f1c103920ffccfff3ae75b40bf91652", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fce568b04f1c103920ffccfff3ae75b40bf91652", "committedDate": "2020-10-09T04:23:13Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fce568b04f1c103920ffccfff3ae75b40bf91652", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fce568b04f1c103920ffccfff3ae75b40bf91652", "committedDate": "2020-10-09T04:23:13Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "dec46cac5a92793fa0e713265b4079fdac5fc1b3", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dec46cac5a92793fa0e713265b4079fdac5fc1b3", "committedDate": "2020-10-09T05:36:07Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dec46cac5a92793fa0e713265b4079fdac5fc1b3", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dec46cac5a92793fa0e713265b4079fdac5fc1b3", "committedDate": "2020-10-09T05:36:07Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "5182df6b456ca420db9ea2219d56a0d84a4d70d8", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5182df6b456ca420db9ea2219d56a0d84a4d70d8", "committedDate": "2020-10-09T23:50:48Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5182df6b456ca420db9ea2219d56a0d84a4d70d8", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5182df6b456ca420db9ea2219d56a0d84a4d70d8", "committedDate": "2020-10-09T23:50:48Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "31fb2373a94fa60134bbc231cc91f148a7337f2a", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/31fb2373a94fa60134bbc231cc91f148a7337f2a", "committedDate": "2020-10-19T23:23:04Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "31fb2373a94fa60134bbc231cc91f148a7337f2a", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/31fb2373a94fa60134bbc231cc91f148a7337f2a", "committedDate": "2020-10-19T23:23:04Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3df9d641668744e085e3cfffd0f55296fd094a3", "committedDate": "2020-10-21T00:02:50Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjUxMTU1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-513251155", "createdAt": "2020-10-21T01:51:33Z", "commit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo1MTozNFrOHlXTxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo1NDozNFrOHlXW4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MTI1Mw==", "bodyText": "log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r508941253", "createdAt": "2020-10-21T01:51:34Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -362,4 +373,120 @@ public void onStreamClosed() {\n         lifecycleIPCEventStreamAgent.sendPostComponentUpdateEvent(new PostComponentUpdateEvent());\n         assertTrue(cdl.await(TIMEOUT_FOR_LIFECYCLE_SECONDS, TimeUnit.SECONDS));\n     }\n+\n+    @Test\n+    void GIVEN_PubSubEventStreamClient_WHEN_subscribe_and_unsubscribe_THEN_publishes_only_once() throws Exception {\n+        String topicName = \"topicName\";\n+        SubscribeToTopicRequest subscribeToTopicRequest = new SubscribeToTopicRequest();\n+        subscribeToTopicRequest.setTopic(topicName);\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        AtomicInteger atomicInteger = new AtomicInteger();\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+            greengrassCoreIPCClient.subscribeToTopic(subscribeToTopicRequest,\n+                    Optional.of(new StreamResponseHandler<SubscriptionResponseMessage>() {\n+                @Override\n+                public void onStreamEvent(SubscriptionResponseMessage message) {\n+                    assertNotNull(message.getBinaryMessage());\n+                    assertNull(message.getJsonMessage());\n+                    assertEquals(\"ABCDEFG\", new String(message.getBinaryMessage().getMessage()));\n+                    atomicInteger.incrementAndGet();\n+                    cdl.countDown();\n+                }\n+\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MTQxMQ==", "bodyText": "log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r508941411", "createdAt": "2020-10-21T01:52:08Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -362,4 +373,120 @@ public void onStreamClosed() {\n         lifecycleIPCEventStreamAgent.sendPostComponentUpdateEvent(new PostComponentUpdateEvent());\n         assertTrue(cdl.await(TIMEOUT_FOR_LIFECYCLE_SECONDS, TimeUnit.SECONDS));\n     }\n+\n+    @Test\n+    void GIVEN_PubSubEventStreamClient_WHEN_subscribe_and_unsubscribe_THEN_publishes_only_once() throws Exception {\n+        String topicName = \"topicName\";\n+        SubscribeToTopicRequest subscribeToTopicRequest = new SubscribeToTopicRequest();\n+        subscribeToTopicRequest.setTopic(topicName);\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        AtomicInteger atomicInteger = new AtomicInteger();\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+            greengrassCoreIPCClient.subscribeToTopic(subscribeToTopicRequest,\n+                    Optional.of(new StreamResponseHandler<SubscriptionResponseMessage>() {\n+                @Override\n+                public void onStreamEvent(SubscriptionResponseMessage message) {\n+                    assertNotNull(message.getBinaryMessage());\n+                    assertNull(message.getJsonMessage());\n+                    assertEquals(\"ABCDEFG\", new String(message.getBinaryMessage().getMessage()));\n+                    atomicInteger.incrementAndGet();\n+                    cdl.countDown();\n+                }\n+\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;\n+                }\n+\n+                @Override\n+                public void onStreamClosed() {\n+\n+                }\n+            }));\n+            CountDownLatch subscriptionLatch = new CountDownLatch(1);\n+            CountDownLatch unsubscriptionLatch = new CountDownLatch(1);\n+            Slf4jLogAdapter.addGlobalListener(m -> {\n+                if (m.getMessage().contains(\"Subscribing to topic\")) {\n+                    subscriptionLatch.countDown();\n+                }\n+                if (m.getMessage().contains(\"Unsubscribing from topic\")) {\n+                    unsubscriptionLatch.countDown();\n+                }\n+            });\n+            assertTrue(subscriptionLatch.await(10, TimeUnit.SECONDS));\n+\n+            PublishToTopicRequest publishToTopicRequest = new PublishToTopicRequest();\n+            publishToTopicRequest.setTopic(topicName);\n+            PublishMessage publishMessage = new PublishMessage();\n+            BinaryMessage binaryMessage = new BinaryMessage();\n+            binaryMessage.setMessage(\"ABCDEFG\".getBytes());\n+            publishMessage.setBinaryMessage(binaryMessage);\n+            publishToTopicRequest.setPublishMessage(publishMessage);\n+            greengrassCoreIPCClient.publishToTopic(publishToTopicRequest, Optional.empty()).getResponse().get(10, TimeUnit.SECONDS);\n+            assertTrue(cdl.await(20, TimeUnit.SECONDS));\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_PubSubEventStreamClient_WHEN_subscribe_to_another_source_THEN_does_not_publish()\n+            throws Exception {\n+        String topicName = \"topicName\";\n+        String sourceName = \"sourceName\";\n+        SubscribeToTopicRequest subscribeToTopicRequest = new SubscribeToTopicRequest();\n+        subscribeToTopicRequest.setTopic(topicName);\n+        subscribeToTopicRequest.setSource(sourceName);\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        AtomicInteger atomicInteger = new AtomicInteger();\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+            greengrassCoreIPCClient.subscribeToTopic(subscribeToTopicRequest,\n+                    Optional.of(new StreamResponseHandler<SubscriptionResponseMessage>() {\n+                @Override\n+                public void onStreamEvent(SubscriptionResponseMessage message) {\n+                    assertNotNull(message.getBinaryMessage());\n+                    assertNull(message.getJsonMessage());\n+                    assertEquals(\"ABCDEFG\", new String(message.getBinaryMessage().getMessage()));\n+                    atomicInteger.incrementAndGet();\n+                    cdl.countDown();\n+                }\n+\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MjA0OQ==", "bodyText": "This should be using the old implementation so that everything can talk together. Old ipc, new ipc, and lambda (lambda uses the old IPC API, but within the JVM, not the network)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r508942049", "createdAt": "2020-10-21T01:54:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3df9d641668744e085e3cfffd0f55296fd094a3", "committedDate": "2020-10-21T00:02:50Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "d388704bde808dfaafbbcbe9c5826a5d7256fcdd", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d388704bde808dfaafbbcbe9c5826a5d7256fcdd", "committedDate": "2020-10-21T02:05:56Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d388704bde808dfaafbbcbe9c5826a5d7256fcdd", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d388704bde808dfaafbbcbe9c5826a5d7256fcdd", "committedDate": "2020-10-21T02:05:56Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6f3d6ab0df9afa5ff35e06ee831053f46e0611e8", "committedDate": "2020-10-21T21:23:52Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjA5Nzk0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-514209794", "createdAt": "2020-10-21T21:45:38Z", "commit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTo0NTozOFrOHmHRmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoxMDozMlrOHmIXRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyNzEzMQ==", "bodyText": "https://github.com/aws/aws-greengrass-nucleus/blob/master/src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCAgent.java#L60\nhttps://github.com/aws/aws-greengrass-nucleus/blob/master/src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCAgent.java#L102\nhttps://github.com/aws/aws-greengrass-nucleus/blob/master/src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCAgent.java#L130\nThese three methods need to be copied over here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509727131", "createdAt": "2020-10-21T21:45:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MjA0OQ=="}, "originalCommit": {"oid": "c3df9d641668744e085e3cfffd0f55296fd094a3"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczNjAxMA==", "bodyText": "Why do we care about source? This is new to me.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509736010", "createdAt": "2020-10-21T21:57:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczODA1NQ==", "bodyText": "Again. Why do we check the source of the publish message? What's the use case?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509738055", "createdAt": "2020-10-21T22:00:19Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }\n+    }\n+\n+\n+    class PublishToTopicOperationHandler extends GeneratedAbstractPublishToTopicOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToTopicResponse handleRequest(PublishToTopicRequest publishRequest) {\n+            if (!allSourcesListeners.containsKey(publishRequest.getTopic())\n+                    && !particularSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                // Still technically successful, just no one was subscribed\n+                return new PublishToTopicResponse();\n+            }\n+\n+            executor.execute(() -> {\n+                Set<Object> contexts = new HashSet<>();\n+                if (allSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                    contexts.addAll(allSourcesListeners.get(publishRequest.getTopic()));\n+                }\n+\n+                if (particularSourcesListeners.containsKey(publishRequest.getTopic())\n+                        && particularSourcesListeners.get(publishRequest.getTopic()).containsKey(serviceName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTczOTQyOQ==", "bodyText": "log something before just dropping the message on the floor?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509739429", "createdAt": "2020-10-21T22:01:57Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }\n+    }\n+\n+\n+    class PublishToTopicOperationHandler extends GeneratedAbstractPublishToTopicOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToTopicResponse handleRequest(PublishToTopicRequest publishRequest) {\n+            if (!allSourcesListeners.containsKey(publishRequest.getTopic())\n+                    && !particularSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                // Still technically successful, just no one was subscribed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0MDk4Mg==", "bodyText": "These can be extracted out from the foreach loop.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509740982", "createdAt": "2020-10-21T22:04:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }\n+    }\n+\n+\n+    class PublishToTopicOperationHandler extends GeneratedAbstractPublishToTopicOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToTopicResponse handleRequest(PublishToTopicRequest publishRequest) {\n+            if (!allSourcesListeners.containsKey(publishRequest.getTopic())\n+                    && !particularSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                // Still technically successful, just no one was subscribed\n+                return new PublishToTopicResponse();\n+            }\n+\n+            executor.execute(() -> {\n+                Set<Object> contexts = new HashSet<>();\n+                if (allSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                    contexts.addAll(allSourcesListeners.get(publishRequest.getTopic()));\n+                }\n+\n+                if (particularSourcesListeners.containsKey(publishRequest.getTopic())\n+                        && particularSourcesListeners.get(publishRequest.getTopic()).containsKey(serviceName)) {\n+                    contexts.addAll(particularSourcesListeners.get(publishRequest.getTopic()).get(serviceName));\n+                }\n+                contexts.forEach(context -> {\n+                    log.atDebug().kv(SERVICE_NAME, serviceName)\n+                            .log(\"Sending publish event {}\", publishRequest);\n+                    SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+                    publishRequest.getPublishMessage().selfDesignateSetUnionMember();\n+                    if (publishRequest.getPublishMessage().getJsonMessage() != null) {\n+                        message.setJsonMessage(publishRequest.getPublishMessage().getJsonMessage());\n+                    }\n+                    if (publishRequest.getPublishMessage().getBinaryMessage() != null) {\n+                        message.setBinaryMessage(publishRequest.getPublishMessage().getBinaryMessage());\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc0NDk2NA==", "bodyText": "How does this even work? For handling subscribe request, you put the service name into the serviceToPublisherMap  but then no one is reading from the map. For handling publish request, the subscribers are read from allSourcesListeners and particularSourcesListeners. How these two are connected together? I'm lost here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r509744964", "createdAt": "2020-10-21T22:10:32Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.ipc.services.pubsub.PubSubUnsubscribeRequest;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Map<String, Set<Object>>> particularSourcesListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, StreamEventPublisher<SubscriptionResponseMessage>> serviceToPublisherMap =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param subscribeRequest subscribe request\n+     * @param cb               callback to be called for each published message\n+     */\n+    public void subscribe(SubscribeToTopicRequest subscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        // TODO: What models should we use?\n+        handleSubscribeToTopicRequest(subscribeRequest, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param unsubscribeRequest request containing the topic to unsubscribe from\n+     * @param cb                 callback to remove from subscription\n+     */\n+    public void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", unsubscribeRequest.getTopic());\n+        if (allSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            allSourcesListeners.get(unsubscribeRequest.getTopic()).remove(cb);\n+        }\n+        if (particularSourcesListeners.containsKey(unsubscribeRequest.getTopic())) {\n+            particularSourcesListeners.get(unsubscribeRequest.getTopic()).values()\n+                    .forEach(listeners -> listeners.remove(cb));\n+        }\n+    }\n+\n+\n+    private void handleSubscribeToTopicRequest(SubscribeToTopicRequest subscribeRequest, String serviceName,\n+                                               Object handler) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atInfo().kv(SERVICE_NAME, serviceName)\n+                .log(\"Subscribing to topic {}, {}\", subscribeRequest.getTopic(), serviceName);\n+        if (Utils.isEmpty(subscribeRequest.getSource())) {\n+            allSourcesListeners.computeIfAbsent(subscribeRequest.getTopic(), k -> new HashSet<>()).add(handler);\n+        } else {\n+            particularSourcesListeners\n+                    .computeIfAbsent(subscribeRequest.getTopic(), k -> new ConcurrentHashMap<>())\n+                    .computeIfAbsent(subscribeRequest.getSource(), k -> ConcurrentHashMap.newKeySet())\n+                    .add(handler);\n+        }\n+    }\n+\n+\n+    class PublishToTopicOperationHandler extends GeneratedAbstractPublishToTopicOperationHandler {\n+        private final String serviceName;\n+\n+        protected PublishToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            // NA\n+        }\n+\n+        @Override\n+        public PublishToTopicResponse handleRequest(PublishToTopicRequest publishRequest) {\n+            if (!allSourcesListeners.containsKey(publishRequest.getTopic())\n+                    && !particularSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                // Still technically successful, just no one was subscribed\n+                return new PublishToTopicResponse();\n+            }\n+\n+            executor.execute(() -> {\n+                Set<Object> contexts = new HashSet<>();\n+                if (allSourcesListeners.containsKey(publishRequest.getTopic())) {\n+                    contexts.addAll(allSourcesListeners.get(publishRequest.getTopic()));\n+                }\n+\n+                if (particularSourcesListeners.containsKey(publishRequest.getTopic())\n+                        && particularSourcesListeners.get(publishRequest.getTopic()).containsKey(serviceName)) {\n+                    contexts.addAll(particularSourcesListeners.get(publishRequest.getTopic()).get(serviceName));\n+                }\n+                contexts.forEach(context -> {\n+                    log.atDebug().kv(SERVICE_NAME, serviceName)\n+                            .log(\"Sending publish event {}\", publishRequest);\n+                    SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+                    publishRequest.getPublishMessage().selfDesignateSetUnionMember();\n+                    if (publishRequest.getPublishMessage().getJsonMessage() != null) {\n+                        message.setJsonMessage(publishRequest.getPublishMessage().getJsonMessage());\n+                    }\n+                    if (publishRequest.getPublishMessage().getBinaryMessage() != null) {\n+                        message.setBinaryMessage(publishRequest.getPublishMessage().getBinaryMessage());\n+                    }\n+                    if (context instanceof StreamEventPublisher) {\n+                        ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message);\n+                    } else if (context instanceof Consumer) {\n+                        ((Consumer<SubscriptionResponseMessage>) context).accept(message);\n+                    }\n+                });\n+            });\n+            return new PublishToTopicResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+            // NA\n+        }\n+    }\n+\n+    class SubscribeToTopicOperationHandler extends GeneratedAbstractSubscribeToTopicOperationHandler {\n+        @Getter\n+        private final String serviceName;\n+        private String subscribeTopic;\n+        private String subscribeToSource;\n+\n+        protected SubscribeToTopicOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribeTopic) && allSourcesListeners.containsKey(subscribeTopic)) {\n+                if (allSourcesListeners.get(subscribeTopic).remove(this)) {\n+                    log.atDebug().kv(SERVICE_NAME, serviceName)\n+                            .log(\"Client disconnected, removing subscription {}\", subscribeTopic);\n+                }\n+                if (allSourcesListeners.get(subscribeTopic).isEmpty()) {\n+                    allSourcesListeners.remove(subscribeTopic);\n+                }\n+            } else if (!Utils.isEmpty(subscribeTopic) && !Utils.isEmpty(subscribeToSource)\n+                    && particularSourcesListeners.containsKey(subscribeTopic)) {\n+                if (particularSourcesListeners.get(subscribeTopic).get(subscribeToSource).remove(this)) {\n+                    log.atDebug().kv(SERVICE_NAME, serviceName)\n+                            .log(\"Client disconnected, removing subscription {} for source\",\n+                                    subscribeTopic, subscribeToSource);\n+                }\n+                if (particularSourcesListeners.get(subscribeTopic).get(subscribeToSource).isEmpty()) {\n+                    particularSourcesListeners.remove(subscribeTopic);\n+                }\n+                if (particularSourcesListeners.get(subscribeTopic).isEmpty()) {\n+                    particularSourcesListeners.remove(subscribeTopic);\n+                }\n+            }\n+\n+        }\n+\n+        @Override\n+        public SubscribeToTopicResponse handleRequest(SubscribeToTopicRequest subscribeRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8"}, "originalPosition": 195}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6f3d6ab0df9afa5ff35e06ee831053f46e0611e8", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6f3d6ab0df9afa5ff35e06ee831053f46e0611e8", "committedDate": "2020-10-21T21:23:52Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "6214fe9984bf1a091e36efaebc7b523f3adad96e", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6214fe9984bf1a091e36efaebc7b523f3adad96e", "committedDate": "2020-10-21T22:58:21Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d88cb602778a7f457f25c47e836b91ced9317fe9", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d88cb602778a7f457f25c47e836b91ced9317fe9", "committedDate": "2020-10-22T15:50:51Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6214fe9984bf1a091e36efaebc7b523f3adad96e", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6214fe9984bf1a091e36efaebc7b523f3adad96e", "committedDate": "2020-10-21T22:58:21Z", "message": "Implement PubSub IPC Event Stream Integration."}, "afterCommit": {"oid": "d88cb602778a7f457f25c47e836b91ced9317fe9", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d88cb602778a7f457f25c47e836b91ced9317fe9", "committedDate": "2020-10-22T15:50:51Z", "message": "Implement PubSub IPC Event Stream Integration."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3c154fe30897f00df41fbf1e3a72a52c6a7cfb2", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e3c154fe30897f00df41fbf1e3a72a52c6a7cfb2", "committedDate": "2020-10-22T16:15:08Z", "message": "Fix tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "042c16164339f44238b03c3cc46cca5b5fc56ed7", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/042c16164339f44238b03c3cc46cca5b5fc56ed7", "committedDate": "2020-10-22T18:36:36Z", "message": "Add AuthZ code for new PubSub."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f7dd5343a707b01efac35aa4e5ab8748ef10973", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0f7dd5343a707b01efac35aa4e5ab8748ef10973", "committedDate": "2020-10-22T18:37:59Z", "message": "Merge branch 'master' into pubsubIpcIntegration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a1d0dc13c5ffda1275736349d5a4d8f66ccbda4", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4a1d0dc13c5ffda1275736349d5a4d8f66ccbda4", "committedDate": "2020-10-22T18:39:17Z", "message": "Remove duplicate code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d92f28c0d70fa55211049bd5649e9a2b8070ea65", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d92f28c0d70fa55211049bd5649e9a2b8070ea65", "committedDate": "2020-10-22T20:39:37Z", "message": "Merge branch 'master' into pubsubIpcIntegration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1aad79c80b88caa861d94da6303aed156d071969", "committedDate": "2020-10-23T03:00:11Z", "message": "Remove source reference. Add more unit tests."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba451e5ca01f7bfdb2a54f2ae40c077ec597132b", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ba451e5ca01f7bfdb2a54f2ae40c077ec597132b", "committedDate": "2020-10-23T02:57:13Z", "message": "Remove source reference. Add more unit tests."}, "afterCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1aad79c80b88caa861d94da6303aed156d071969", "committedDate": "2020-10-23T03:00:11Z", "message": "Remove source reference. Add more unit tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MjUyNjEw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-515252610", "createdAt": "2020-10-23T03:28:11Z", "commit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMzoyODoxMVrOHm67xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMzoyODoxMVrOHm67xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU3MzUwOA==", "bodyText": "these operations should be taken from the SDK like MQTT is doing. so it would be aws.greengrass#publish", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r510573508", "createdAt": "2020-10-23T03:28:11Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -54,9 +77,44 @@\n     private static IPCClient client;\n     public static Permission TES_DEFAULT_POLICY =\n             Permission.builder().principal(\"*\").operation(\"getCredentials\").resource(null).build();\n+    private static final String newACl =\n+            \"{  \\n\" +\n+            \"   \\\"aws.greengrass.ipc.pubsub\\\":[\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"policyId10\\\":{\\n\" +\n+            \"            \\\"policyDescription\\\":\\\"access to pubsub topics for ServiceName\\\",\\n\" +\n+            \"            \\\"operations\\\":[\\n\" +\n+            \"              \\\"*\\\"\\n\" +\n+            \"            ],\\n\" +\n+            \"            \\\"resources\\\":[\\n\" +\n+            \"              \\\"*\\\"\\n\" +\n+            \"            ]\\n\" +\n+            \"          }\\n\" +\n+            \"        }\\n\" +\n+            \"    ]\\n\" +\n+            \"}\";\n+\n+    private static final String oldACl =\n+            \"{  \\n\" +\n+            \"   \\\"aws.greengrass.ipc.pubsub\\\":[\\n\" +\n+            \"        {\\n\" +\n+            \"          \\\"policyId4\\\":{\\n\" +\n+            \"            \\\"policyDescription\\\":\\\"access to pubsub topics for ServiceName\\\",\\n\" +\n+            \"            \\\"operations\\\":[\\n\" +\n+            \"              \\\"publish\\\"\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MjUzNTAz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-515253503", "createdAt": "2020-10-23T03:31:53Z", "commit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODMyODEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-515832813", "createdAt": "2020-10-23T16:38:42Z", "commit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjozODo0M1rOHnVYVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzowOToyNVrOHnWX1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNjgwNw==", "bodyText": "remove allSources prefix.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511006807", "createdAt": "2020-10-23T16:38:43Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwOTk3Ng==", "bodyText": "This signature still requires lambdaManager to import the data model. Why not just change it to:\npublic void publish(String topic, String serviceName, byte[] payload) {\n    handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(payload));\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511009976", "createdAt": "2020-10-23T16:44:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", topic);\n+        if (allSourcesListeners.containsKey(topic)) {\n+            allSourcesListeners.get(topic).remove(cb);\n+        }\n+        if (allSourcesListeners.get(topic).isEmpty()) {\n+            allSourcesListeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param jsonMessage   JSON message to publish.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic,\n+                                          Optional<Map<String, Object>> jsonMessage,\n+                                          Optional<byte[]> binaryMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxMTE4OQ==", "bodyText": "Don't use empty string. It doesn't help debugging. Let the client pass in a service name.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511011189", "createdAt": "2020-10-23T16:46:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", topic);\n+        if (allSourcesListeners.containsKey(topic)) {\n+            allSourcesListeners.get(topic).remove(cb);\n+        }\n+        if (allSourcesListeners.get(topic).isEmpty()) {\n+            allSourcesListeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param jsonMessage   JSON message to publish.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic,\n+                                          Optional<Map<String, Object>> jsonMessage,\n+                                          Optional<byte[]> binaryMessage) {\n+        return handlePublishToTopicRequest(topic, \"\", jsonMessage, binaryMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNDEyNQ==", "bodyText": "Why asynchronous?  Why put asynchronous here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511014125", "createdAt": "2020-10-23T16:52:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", topic);\n+        if (allSourcesListeners.containsKey(topic)) {\n+            allSourcesListeners.get(topic).remove(cb);\n+        }\n+        if (allSourcesListeners.get(topic).isEmpty()) {\n+            allSourcesListeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param jsonMessage   JSON message to publish.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic,\n+                                          Optional<Map<String, Object>> jsonMessage,\n+                                          Optional<byte[]> binaryMessage) {\n+        return handlePublishToTopicRequest(topic, \"\", jsonMessage, binaryMessage);\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        if (!allSourcesListeners.containsKey(topic)) {\n+            log.atDebug().log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+\n+        executor.execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNjIwMw==", "bodyText": "What if one of the callbacks blocks? Now the rest will also be blocked. The callback needs to run in a thread pool. And ideally for the same callback, all the messages should be running on the same thread so that we have a guarantee of order.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511016203", "createdAt": "2020-10-23T16:56:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        log.debug(\"Unsubscribing from topic {}\", topic);\n+        if (allSourcesListeners.containsKey(topic)) {\n+            allSourcesListeners.get(topic).remove(cb);\n+        }\n+        if (allSourcesListeners.get(topic).isEmpty()) {\n+            allSourcesListeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param jsonMessage   JSON message to publish.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic,\n+                                          Optional<Map<String, Object>> jsonMessage,\n+                                          Optional<byte[]> binaryMessage) {\n+        return handlePublishToTopicRequest(topic, \"\", jsonMessage, binaryMessage);\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        if (!allSourcesListeners.containsKey(topic)) {\n+            log.atDebug().log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+\n+        executor.execute(() -> {\n+            Set<Object> contexts = new HashSet<>();\n+            if (allSourcesListeners.containsKey(topic)) {\n+                contexts.addAll(allSourcesListeners.get(topic));\n+            }\n+\n+            SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+            if (jsonMessage.isPresent()) {\n+                JsonMessage message1 = new JsonMessage();\n+                message1.setMessage(jsonMessage.get());\n+                message.setJsonMessage(message1);\n+            }\n+            if (binaryMessage.isPresent()) {\n+                BinaryMessage binaryMessage1 = new BinaryMessage();\n+                binaryMessage1.setMessage(binaryMessage.get());\n+                message.setBinaryMessage(binaryMessage1);\n+            }\n+\n+            contexts.forEach(context -> {\n+                log.atDebug().kv(SERVICE_NAME, serviceName)\n+                        .log(\"Sending publish event for topic {}\", topic);\n+                if (context instanceof StreamEventPublisher) {\n+                    ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message);\n+                } else if (context instanceof Consumer) {\n+                    ((Consumer<SubscriptionResponseMessage>) context).accept(message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxOTU2OA==", "bodyText": "Can we keep the same signature as\npublic void subscribe(PubSubSubscribeRequest subscribeRequest, Consumer<MessagePublishedEvent> cb)\n\nand handle the translation in this class?\nThe reason is this will keep the lambda manager simpler (one less dependency).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511019568", "createdAt": "2020-10-23T17:02:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMDExMg==", "bodyText": "Same here. keep the same signature as\npublic void unsubscribe(PubSubUnsubscribeRequest unsubscribeRequest, Consumer<MessagePublishedEvent> cb)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511020112", "createdAt": "2020-10-23T17:03:35Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to remove from subscription\n+     */\n+    public void unsubscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMzA2MA==", "bodyText": "Also update this to have client pass in the service name.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511023060", "createdAt": "2020-10-23T17:09:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> allSourcesListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic topic name.\n+     * @param cb    callback to be called for each published message\n+     */\n+    public void subscribe(String topic, Consumer<SubscriptionResponseMessage> cb) {\n+        handleSubscribeToTopicRequest(topic, \"\", cb);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxOTU2OA=="}, "originalCommit": {"oid": "1aad79c80b88caa861d94da6303aed156d071969"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d9abccf439481169e5d4e64e6eb4682e1f8b628", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4d9abccf439481169e5d4e64e6eb4682e1f8b628", "committedDate": "2020-10-23T18:18:05Z", "message": "Merge branch 'master' into pubsubIpcIntegration6"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f5d26651fb4eb51172b5b037fbe39f52c936f4e8", "committedDate": "2020-10-23T21:05:55Z", "message": "Address PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDI1MjA2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-516025206", "createdAt": "2020-10-23T21:39:42Z", "commit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTozOTo0MlrOHnfKzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo0NDowOFrOHnfQyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NzE4Mw==", "bodyText": "use computeIfPresent to be threadsafe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511167183", "createdAt": "2020-10-23T21:39:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NzIwOQ==", "bodyText": "same", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511167209", "createdAt": "2020-10-23T21:39:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }\n+        if (listeners.get(topic).isEmpty()) {\n+            listeners.remove(topic);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODcxMw==", "bodyText": "compute if present", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511168713", "createdAt": "2020-10-23T21:44:08Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }\n+        if (listeners.get(topic).isEmpty()) {\n+            listeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param serviceName   name of the service publishing the message.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        if (!listeners.containsKey(topic)) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+\n+        Set<Object> contexts = new HashSet<>();\n+        if (listeners.containsKey(topic)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDMxNjY4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-516031668", "createdAt": "2020-10-23T21:55:33Z", "commit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1NTozM1rOHnffww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjozNzowNlrOHngNWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MjU0Nw==", "bodyText": "It's a weird name. Just call it PublishEvent?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511172547", "createdAt": "2020-10-23T21:55:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/MessagePublishedEvent.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class MessagePublishedEvent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MzAxNg==", "bodyText": "Adjust order.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511173016", "createdAt": "2020-10-23T21:57:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }\n+        if (listeners.get(topic).isEmpty()) {\n+            listeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param serviceName   name of the service publishing the message.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE4MjcxOQ==", "bodyText": "Why is the publishedEvent only getting the binary payload? Is it correct?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511182719", "createdAt": "2020-10-23T22:31:32Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<MessagePublishedEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        if (listeners.containsKey(topic)) {\n+            listeners.get(topic).remove(cb);\n+        }\n+        if (listeners.get(topic).isEmpty()) {\n+            listeners.remove(topic);\n+        }\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param serviceName   name of the service publishing the message.\n+     * @param binaryMessage Binary message to publish.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        if (!listeners.containsKey(topic)) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+\n+        Set<Object> contexts = new HashSet<>();\n+        if (listeners.containsKey(topic)) {\n+            contexts.addAll(listeners.get(topic));\n+        }\n+\n+        SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+        MessagePublishedEvent publishedEvent = MessagePublishedEvent.builder().topic(topic).build();\n+        if (jsonMessage.isPresent()) {\n+            JsonMessage message1 = new JsonMessage();\n+            message1.setMessage(jsonMessage.get());\n+            message.setJsonMessage(message1);\n+        }\n+        if (binaryMessage.isPresent()) {\n+            BinaryMessage binaryMessage1 = new BinaryMessage();\n+            binaryMessage1.setMessage(binaryMessage.get());\n+            message.setBinaryMessage(binaryMessage1);\n+            publishedEvent.setPayload(binaryMessage.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE4NDIxOQ==", "bodyText": "Can you add a few more test cases? e.g.\n\nThe payload is json type\nThe payload is binary type\nWhen multiple messages are published, the subscribers receives the messages in the order that they're published.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511184219", "createdAt": "2020-10-23T22:37:06Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class PubSubIPCEventStreamAgentTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d26651fb4eb51172b5b037fbe39f52c936f4e8"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e6bee2ccb2471092ea3f65c45739ab2b7f315706", "committedDate": "2020-10-24T00:04:58Z", "message": "Address PR comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "81f0bf5abb8a817144f3d648242b4892f68fdd2b", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/81f0bf5abb8a817144f3d648242b4892f68fdd2b", "committedDate": "2020-10-23T22:33:12Z", "message": "Address PR comments."}, "afterCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e6bee2ccb2471092ea3f65c45739ab2b7f315706", "committedDate": "2020-10-24T00:04:58Z", "message": "Address PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MTUwNzU4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-516150758", "createdAt": "2020-10-24T02:13:04Z", "commit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMjoxMzowNFrOHnkq_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwMjoxNDo0MVrOHnktiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI1NzM0Mw==", "bodyText": "in this case using get and then checking for null makes more sense than compute I think, sorry if I commented the other way before.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511257343", "createdAt": "2020-10-24T02:13:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = new HashSet<>();\n+        listeners.computeIfPresent(topic, (s, objects) -> {\n+            contexts.addAll(listeners.get(topic));\n+            return objects;\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI1Nzk5Mg==", "bodyText": "I think we may want to just fire and forget.\n@fengwa-aws what do you say?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511257992", "createdAt": "2020-10-24T02:14:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = new HashSet<>();\n+        listeners.computeIfPresent(topic, (s, objects) -> {\n+            contexts.addAll(listeners.get(topic));\n+            return objects;\n+        });\n+        if (contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        synchronized (listeners.get(topic)) {\n+\n+            SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+            PublishEvent publishedEvent = PublishEvent.builder().topic(topic).build();\n+            if (jsonMessage.isPresent()) {\n+                JsonMessage message1 = new JsonMessage();\n+                message1.setMessage(jsonMessage.get());\n+                message.setJsonMessage(message1);\n+                try {\n+                    publishedEvent.setPayload(SERIALIZER.writeValueAsBytes(jsonMessage.get()));\n+                } catch (JsonProcessingException e) {\n+                    log.atError().cause(e).kv(SERVICE_NAME, serviceName)\n+                            .log(\"Unable to serialize JSON message.\");\n+                }\n+            }\n+            if (binaryMessage.isPresent()) {\n+                BinaryMessage binaryMessage1 = new BinaryMessage();\n+                binaryMessage1.setMessage(binaryMessage.get());\n+                message.setBinaryMessage(binaryMessage1);\n+                publishedEvent.setPayload(binaryMessage.get());\n+            }\n+\n+            List<Future<?>> futures = new ArrayList<>();\n+            contexts.forEach(context -> {\n+                log.atDebug().kv(SERVICE_NAME, serviceName)\n+                        .log(\"Sending publish event for topic {}\", topic);\n+                if (context instanceof StreamEventPublisher) {\n+                    Future<?> submit = executor.submit(() -> {\n+                        ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message);\n+                    });\n+                    futures.add(submit);\n+                } else if (context instanceof Consumer) {\n+                    Future<?> submit = executor.submit(() -> {\n+                        ((Consumer<PublishEvent>) context).accept(publishedEvent);\n+                    });\n+                    futures.add(submit);\n+                }\n+            });\n+            futures.forEach(future -> {\n+                try {\n+                    future.get();\n+                } catch (InterruptedException | ExecutionException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mjk5NTA0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-516299504", "createdAt": "2020-10-24T18:58:14Z", "commit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxODo1ODoxNFrOHnzq0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMDowOToyNlrOHn0Eeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwMzA1Ng==", "bodyText": "nit: Handle the subscription request from internal plugin services.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511503056", "createdAt": "2020-10-24T18:58:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwOTQ0Nw==", "bodyText": "The synchronization shouldn't occur on the topic. Instead it should be on the subscriber. What needs to happen here is to make sure the subscriber handles the messages in a sequential order. Take a look at this SO post (https://stackoverflow.com/questions/2153663/controlling-task-execution-order-with-executorservice) for some inspiration.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511509447", "createdAt": "2020-10-24T20:06:49Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = new HashSet<>();\n+        listeners.computeIfPresent(topic, (s, objects) -> {\n+            contexts.addAll(listeners.get(topic));\n+            return objects;\n+        });\n+        if (contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        synchronized (listeners.get(topic)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUwOTYyNg==", "bodyText": "I think it's beneficial for the customers if we can guarantee the messages are delivered to the subscriber in the order they're published.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r511509626", "createdAt": "2020-10-24T20:09:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private ExecutorService executor;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = new HashSet<>();\n+        listeners.computeIfPresent(topic, (s, objects) -> {\n+            contexts.addAll(listeners.get(topic));\n+            return objects;\n+        });\n+        if (contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        synchronized (listeners.get(topic)) {\n+\n+            SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+            PublishEvent publishedEvent = PublishEvent.builder().topic(topic).build();\n+            if (jsonMessage.isPresent()) {\n+                JsonMessage message1 = new JsonMessage();\n+                message1.setMessage(jsonMessage.get());\n+                message.setJsonMessage(message1);\n+                try {\n+                    publishedEvent.setPayload(SERIALIZER.writeValueAsBytes(jsonMessage.get()));\n+                } catch (JsonProcessingException e) {\n+                    log.atError().cause(e).kv(SERVICE_NAME, serviceName)\n+                            .log(\"Unable to serialize JSON message.\");\n+                }\n+            }\n+            if (binaryMessage.isPresent()) {\n+                BinaryMessage binaryMessage1 = new BinaryMessage();\n+                binaryMessage1.setMessage(binaryMessage.get());\n+                message.setBinaryMessage(binaryMessage1);\n+                publishedEvent.setPayload(binaryMessage.get());\n+            }\n+\n+            List<Future<?>> futures = new ArrayList<>();\n+            contexts.forEach(context -> {\n+                log.atDebug().kv(SERVICE_NAME, serviceName)\n+                        .log(\"Sending publish event for topic {}\", topic);\n+                if (context instanceof StreamEventPublisher) {\n+                    Future<?> submit = executor.submit(() -> {\n+                        ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message);\n+                    });\n+                    futures.add(submit);\n+                } else if (context instanceof Consumer) {\n+                    Future<?> submit = executor.submit(() -> {\n+                        ((Consumer<PublishEvent>) context).accept(publishedEvent);\n+                    });\n+                    futures.add(submit);\n+                }\n+            });\n+            futures.forEach(future -> {\n+                try {\n+                    future.get();\n+                } catch (InterruptedException | ExecutionException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI1Nzk5Mg=="}, "originalCommit": {"oid": "e6bee2ccb2471092ea3f65c45739ab2b7f315706"}, "originalPosition": 165}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b04d7492a434df4c8a1ad22d598e5a53e416de54", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b04d7492a434df4c8a1ad22d598e5a53e416de54", "committedDate": "2020-10-25T23:58:34Z", "message": "Address PR comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ffaec38fe3695dbb8334f5f9c70c6d4d1de79f3d", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ffaec38fe3695dbb8334f5f9c70c6d4d1de79f3d", "committedDate": "2020-10-26T04:30:42Z", "message": "Add Ordered Executor Service."}, "afterCommit": {"oid": "fdb2e06cf9b57b9c1940c477842903959fd4699a", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fdb2e06cf9b57b9c1940c477842903959fd4699a", "committedDate": "2020-10-26T04:33:09Z", "message": "Add Ordered Executor Service."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "183f99d38881fe1de31941226c2fb120914f1dfd", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/183f99d38881fe1de31941226c2fb120914f1dfd", "committedDate": "2020-10-26T15:52:46Z", "message": "Add Ordered Executor Service."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fdb2e06cf9b57b9c1940c477842903959fd4699a", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fdb2e06cf9b57b9c1940c477842903959fd4699a", "committedDate": "2020-10-26T04:33:09Z", "message": "Add Ordered Executor Service."}, "afterCommit": {"oid": "183f99d38881fe1de31941226c2fb120914f1dfd", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/183f99d38881fe1de31941226c2fb120914f1dfd", "committedDate": "2020-10-26T15:52:46Z", "message": "Add Ordered Executor Service."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e34a3c88651bd5b786257ce61a521aaccc625515", "committedDate": "2020-10-26T16:10:23Z", "message": "Merge branch 'master' into pubsubIpcIntegration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTM1MjIz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-516935223", "createdAt": "2020-10-26T16:05:15Z", "commit": {"oid": "183f99d38881fe1de31941226c2fb120914f1dfd"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjowNToxNlrOHoW2Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjoxMjo0NFrOHoXLAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3OTM3MQ==", "bodyText": "You can use injection to make this ordered executor", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512079371", "createdAt": "2020-10-26T16:05:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.OrderedExecutorService;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    private final OrderedExecutorService orderedExecutorService;\n+    private final AuthorizationHandler authorizationHandler;\n+\n+    @Inject\n+    PubSubIPCEventStreamAgent(AuthorizationHandler authorizationHandler, ExecutorService executor) {\n+        this.authorizationHandler = authorizationHandler;\n+        orderedExecutorService = new OrderedExecutorService(executor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "183f99d38881fe1de31941226c2fb120914f1dfd"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MDQyMg==", "bodyText": "add @Inject", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512080422", "createdAt": "2020-10-26T16:06:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "183f99d38881fe1de31941226c2fb120914f1dfd"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NDczNw==", "bodyText": "not sure that the sync is needed since you're using concurrent hashmap, as long as you use that correctly this shouldn't be needed. But that's ok I guess", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512084737", "createdAt": "2020-10-26T16:12:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        boolean isFirst = false;\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            if (dependencyQueue == null) {\n+                dependencyQueue = new LinkedBlockingDeque<>();\n+                keyedOrderedTasks.put(key, dependencyQueue);\n+                isFirst = true;\n+            }\n+\n+            orderedTask = wrap(task, dependencyQueue, key);\n+            if (!isFirst) {\n+                dependencyQueue.add(orderedTask);\n+            }\n+        }\n+\n+        // execute method can block, call it outside synchronize block\n+        if (isFirst) {\n+            executor.execute(orderedTask);\n+        }\n+    }\n+\n+    private Runnable wrap(Runnable task, BlockingQueue<Runnable> dependencyQueue, Object key) {\n+        return new OrderedTask(task, dependencyQueue, key);\n+    }\n+\n+    class OrderedTask implements Runnable {\n+        private final BlockingQueue<Runnable> nextOrderedTasksQueue;\n+        private final Runnable task;\n+        private final Object key;\n+\n+        public OrderedTask(Runnable task, BlockingQueue<Runnable> nextOrderedTasksQueue, Object key) {\n+            this.task = task;\n+            this.nextOrderedTasksQueue = nextOrderedTasksQueue;\n+            this.key = key;\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        @Override\n+        public void run() {\n+            try {\n+                task.run();\n+            } catch (Throwable e) {\n+                log.atError().cause(e).log(\"Error executing ordered task for key: {}\", this.key);\n+            } finally {\n+                AtomicReference<Runnable> nextTask = new AtomicReference<>();\n+                synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTgxNzEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-516981713", "createdAt": "2020-10-26T16:51:43Z", "commit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNjo1MTo0NFrOHoZAsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzowNzowMlrOHoZv-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjExNDg2Nw==", "bodyText": "not needed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512114867", "createdAt": "2020-10-26T16:51:44Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        boolean isFirst = false;\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            if (dependencyQueue == null) {\n+                dependencyQueue = new LinkedBlockingDeque<>();\n+                keyedOrderedTasks.put(key, dependencyQueue);\n+                isFirst = true;\n+            }\n+\n+            orderedTask = wrap(task, dependencyQueue, key);\n+            if (!isFirst) {\n+                dependencyQueue.add(orderedTask);\n+            }\n+        }\n+\n+        // execute method can block, call it outside synchronize block\n+        if (isFirst) {\n+            executor.execute(orderedTask);\n+        }\n+    }\n+\n+    private Runnable wrap(Runnable task, BlockingQueue<Runnable> dependencyQueue, Object key) {\n+        return new OrderedTask(task, dependencyQueue, key);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjExNjMwNw==", "bodyText": "use computeIfAbsent", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512116307", "createdAt": "2020-10-26T16:52:56Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        boolean isFirst = false;\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            if (dependencyQueue == null) {\n+                dependencyQueue = new LinkedBlockingDeque<>();\n+                keyedOrderedTasks.put(key, dependencyQueue);\n+                isFirst = true;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNDE5Ng==", "bodyText": "Unit tests for this class are missing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512124196", "createdAt": "2020-10-26T17:02:50Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNTA4Mg==", "bodyText": "replace nextOrderedTasksQueue with runnables?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512125082", "createdAt": "2020-10-26T17:04:12Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        boolean isFirst = false;\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            if (dependencyQueue == null) {\n+                dependencyQueue = new LinkedBlockingDeque<>();\n+                keyedOrderedTasks.put(key, dependencyQueue);\n+                isFirst = true;\n+            }\n+\n+            orderedTask = wrap(task, dependencyQueue, key);\n+            if (!isFirst) {\n+                dependencyQueue.add(orderedTask);\n+            }\n+        }\n+\n+        // execute method can block, call it outside synchronize block\n+        if (isFirst) {\n+            executor.execute(orderedTask);\n+        }\n+    }\n+\n+    private Runnable wrap(Runnable task, BlockingQueue<Runnable> dependencyQueue, Object key) {\n+        return new OrderedTask(task, dependencyQueue, key);\n+    }\n+\n+    class OrderedTask implements Runnable {\n+        private final BlockingQueue<Runnable> nextOrderedTasksQueue;\n+        private final Runnable task;\n+        private final Object key;\n+\n+        public OrderedTask(Runnable task, BlockingQueue<Runnable> nextOrderedTasksQueue, Object key) {\n+            this.task = task;\n+            this.nextOrderedTasksQueue = nextOrderedTasksQueue;\n+            this.key = key;\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        @Override\n+        public void run() {\n+            try {\n+                task.run();\n+            } catch (Throwable e) {\n+                log.atError().cause(e).log(\"Error executing ordered task for key: {}\", this.key);\n+            } finally {\n+                AtomicReference<Runnable> nextTask = new AtomicReference<>();\n+                synchronized (keyedOrderedTasks) {\n+                    keyedOrderedTasks.computeIfPresent(key, (o, runnables) -> {\n+                        if (runnables.isEmpty()) {\n+                            return null;\n+                        }\n+                        nextTask.set(nextOrderedTasksQueue.poll());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyNjk3MQ==", "bodyText": "Should the key of the orderedTasks be topic?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512126971", "createdAt": "2020-10-26T17:07:02Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/pubsub/PubSubIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.builtin.services.pubsub;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.OrderedExecutorService;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToTopicOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.BinaryMessage;\n+import software.amazon.awssdk.aws.greengrass.model.JsonMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToTopicResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscriptionResponseMessage;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n+\n+public class PubSubIPCEventStreamAgent {\n+    private static final Logger log = LogManager.getLogger(PubSubIPCEventStreamAgent.class);\n+    private static final String SERVICE_NAME = \"service-name\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, Set<Object>> listeners = new ConcurrentHashMap<>();\n+\n+    private final OrderedExecutorService orderedExecutorService;\n+    private final AuthorizationHandler authorizationHandler;\n+\n+    @Inject\n+    PubSubIPCEventStreamAgent(AuthorizationHandler authorizationHandler, ExecutorService executor) {\n+        this.authorizationHandler = authorizationHandler;\n+        orderedExecutorService = new OrderedExecutorService(executor);\n+    }\n+\n+    public SubscribeToTopicOperationHandler getSubscribeToTopicHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToTopicOperationHandler(context);\n+    }\n+\n+    public PublishToTopicOperationHandler getPublishToTopicHandler(OperationContinuationHandlerContext context) {\n+        return new PublishToTopicOperationHandler(context);\n+    }\n+\n+    /**\n+     * Handle the subscription request from internal plugin services.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to be called for each published message\n+     * @param serviceName name of the service subscribing.\n+     */\n+    public void subscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        handleSubscribeToTopicRequest(topic, serviceName, cb);\n+    }\n+\n+    /**\n+     * Unsubscribe from a topic for internal plugin services.\n+     *\n+     * @param topic       topic name.\n+     * @param cb          callback to remove from subscription\n+     * @param serviceName name of the service unsubscribing.\n+     */\n+    public void unsubscribe(String topic, Consumer<PublishEvent> cb, String serviceName) {\n+        log.atDebug().kv(SERVICE_NAME, serviceName).log(\"Unsubscribing from topic {}\", topic);\n+        listeners.computeIfPresent(topic, (s, objects) ->\n+                objects.remove(cb) && objects.isEmpty() ? null : objects);\n+    }\n+\n+    /**\n+     * Publish a message to all subscribers.\n+     *\n+     * @param topic         publish topic.\n+     * @param binaryMessage Binary message to publish.\n+     * @param serviceName   name of the service publishing the message.\n+     * @return response\n+     */\n+    public PublishToTopicResponse publish(String topic, byte[] binaryMessage, String serviceName) {\n+        return handlePublishToTopicRequest(topic, serviceName, Optional.empty(), Optional.of(binaryMessage));\n+    }\n+\n+    private PublishToTopicResponse handlePublishToTopicRequest(String topic,\n+                                                               String serviceName,\n+                                                               Optional<Map<String, Object>> jsonMessage,\n+                                                               Optional<byte[]> binaryMessage) {\n+        Set<Object> contexts = listeners.get(topic);\n+        if (contexts == null || contexts.isEmpty()) {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"No one subscribed to topic {}. Returning.\", topic);\n+            // Still technically successful, just no one was subscribed\n+            return new PublishToTopicResponse();\n+        }\n+        SubscriptionResponseMessage message = new SubscriptionResponseMessage();\n+        PublishEvent publishedEvent = PublishEvent.builder().topic(topic).build();\n+        if (jsonMessage.isPresent()) {\n+            JsonMessage message1 = new JsonMessage();\n+            message1.setMessage(jsonMessage.get());\n+            message.setJsonMessage(message1);\n+            try {\n+                publishedEvent.setPayload(SERIALIZER.writeValueAsBytes(jsonMessage.get()));\n+            } catch (JsonProcessingException e) {\n+                log.atError().cause(e).kv(SERVICE_NAME, serviceName)\n+                        .log(\"Unable to serialize JSON message.\");\n+            }\n+        }\n+        if (binaryMessage.isPresent()) {\n+            BinaryMessage binaryMessage1 = new BinaryMessage();\n+            binaryMessage1.setMessage(binaryMessage.get());\n+            message.setBinaryMessage(binaryMessage1);\n+            publishedEvent.setPayload(binaryMessage.get());\n+        }\n+\n+        contexts.forEach(context -> {\n+            log.atDebug().kv(SERVICE_NAME, serviceName)\n+                    .log(\"Sending publish event for topic {}\", topic);\n+            if (context instanceof StreamEventPublisher) {\n+                orderedExecutorService.execute(() ->\n+                        ((StreamEventPublisher<SubscriptionResponseMessage>) context).sendStreamEvent(message),\n+                        topic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e34a3c88651bd5b786257ce61a521aaccc625515"}, "originalPosition": 139}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33903a5c12421e814cfed979c69f05dea199a42e", "committedDate": "2020-10-26T18:58:10Z", "message": "Address PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDkyOTM0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-517092934", "createdAt": "2020-10-26T19:07:15Z", "commit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowNzoxNVrOHoeYUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowNzoxNVrOHoeYUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMjgzNQ==", "bodyText": "you shouldn't need to synchronize on it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512202835", "createdAt": "2020-10-26T19:07:15Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDkzNzg5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-517093789", "createdAt": "2020-10-26T19:08:28Z", "commit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowODoyOFrOHoea3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOTowODoyOFrOHoea3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMzQ4Ng==", "bodyText": "this doesn't verify anything because it is in a separate thread, so throwing won't fail the test", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512203486", "createdAt": "2020-10-26T19:08:28Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/util/OrderedExecutorServiceTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class OrderedExecutorServiceTest {\n+    private static OrderedExecutorService orderedExecutorService;\n+\n+    @BeforeAll\n+    static void startUp() {\n+        orderedExecutorService = new OrderedExecutorService(Executors.newCachedThreadPool());\n+    }\n+\n+    @Test\n+    void GIVEN_multiple_keys_and_tasks_WHEN_esecute_THEN_executes_in_proper_order_for_each_key()\n+            throws InterruptedException {\n+        String key = UUID.randomUUID().toString();\n+        String key2 = UUID.randomUUID().toString();\n+\n+        Queue<String> queue = new LinkedList<>();\n+        List<Runnable> tasks = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            String randomString = UUID.randomUUID().toString();\n+            queue.add(randomString);\n+            tasks.add(createRunnable(randomString, queue));\n+        }\n+        Queue<String> queue2 = new LinkedList<>();\n+        List<Runnable> tasks2 = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            String randomString = UUID.randomUUID().toString();\n+            queue2.add(randomString);\n+            tasks2.add(createRunnable(randomString, queue2));\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            orderedExecutorService.execute(tasks.get(i), key);\n+            orderedExecutorService.execute(tasks2.get(i), key2);\n+        }\n+        while (!orderedExecutorService.getKeyedOrderedTasks().isEmpty()) {\n+            TimeUnit.SECONDS.sleep(1);\n+        }\n+    }\n+\n+    private Runnable createRunnable(final String randomStringToCheck, final Queue<String> queue){\n+        return () -> {\n+            String firstRandomVarFromQueue = queue.poll();\n+            assertEquals(randomStringToCheck, firstRandomVarFromQueue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "344b4dd7d036e0f35e1d02a0d229896c8928541f", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/344b4dd7d036e0f35e1d02a0d229896c8928541f", "committedDate": "2020-10-26T19:55:34Z", "message": "Address PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTU1Mjc5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-517155279", "createdAt": "2020-10-26T20:36:44Z", "commit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDozNjo0NFrOHohYyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMDozNjo0NFrOHohYyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1MjEwNw==", "bodyText": "why not inside the compute? execute shouldn't be blocking", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512252107", "createdAt": "2020-10-26T20:36:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            keyedOrderedTasks.computeIfAbsent(key, o -> {\n+                isFirst.set(true);\n+                return new LinkedBlockingDeque<>();\n+            });\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);\n+            orderedTask = new OrderedTask(task, dependencyQueue, key);\n+            if (!isFirst.get()) {\n+                dependencyQueue.add(orderedTask);\n+            }\n+        }\n+\n+        // execute method can block, call it outside synchronize block\n+        if (isFirst.get()) {\n+            executor.execute(orderedTask);\n+        }\n+    }\n+\n+    class OrderedTask implements Runnable {\n+        private final BlockingQueue<Runnable> runnables;\n+        private final Runnable task;\n+        private final Object key;\n+\n+        public OrderedTask(Runnable task, BlockingQueue<Runnable> runnables, Object key) {\n+            this.task = task;\n+            this.runnables = runnables;\n+            this.key = key;\n+        }\n+\n+        @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+        @Override\n+        public void run() {\n+            try {\n+                task.run();\n+            } catch (Throwable e) {\n+                log.atError().cause(e).log(\"Error executing ordered task for key: {}\", this.key);\n+            } finally {\n+                AtomicReference<Runnable> nextTask = new AtomicReference<>();\n+                synchronized (keyedOrderedTasks) {\n+                    keyedOrderedTasks.computeIfPresent(key, (o, runnables) -> {\n+                        if (runnables.isEmpty()) {\n+                            return null;\n+                        }\n+                        nextTask.set(this.runnables.poll());\n+                        return runnables;\n+                    });\n+                }\n+                if (nextTask.get() != null) {\n+                    executor.execute(nextTask.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33903a5c12421e814cfed979c69f05dea199a42e"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41fdea8658d6b903b6cc06a9377104d9bfd6a4ec", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/41fdea8658d6b903b6cc06a9377104d9bfd6a4ec", "committedDate": "2020-10-26T21:20:15Z", "message": "Don't need a ConcurrentHashMap."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTg3MDcz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-517187073", "createdAt": "2020-10-26T21:24:10Z", "commit": {"oid": "41fdea8658d6b903b6cc06a9377104d9bfd6a4ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMToyNDoxMFrOHoi8JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMToyNDoxMFrOHoi8JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NzU0MQ==", "bodyText": "don't call get. just use the return from the compute", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512277541", "createdAt": "2020-10-26T21:24:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/util/OrderedExecutorService.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+/**\n+ * This Executor warrants task ordering for tasks with same key (key have to implement hashCode and equal methods\n+ * correctly).\n+ */\n+public class OrderedExecutorService implements Executor {\n+    private static final Logger log = LogManager.getLogger(OrderedExecutorService.class);\n+    private final Executor executor;\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<Object, BlockingQueue<Runnable>> keyedOrderedTasks = new HashMap<>();\n+\n+    @Inject\n+    public OrderedExecutorService(Executor executor) {\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public void execute(Runnable task) {\n+        // task without key can be executed immediately\n+        executor.execute(task);\n+    }\n+\n+    /**\n+     * Executes the given command at some time in the future.  The command may execute in a new thread,\n+     * in a pooled thread, or in the calling thread, at the discretion of the {@code Executor} implementation.\n+     * The tasks with the same key will run sequentially. If no key is provided, the task will executed without\n+     * any ordering.\n+     *\n+     * @param task  the runnable task\n+     * @param key   The key by which to order the tasks.\n+     */\n+    public void execute(Runnable task, Object key) {\n+        if (key == null) { // if key is null, execute without ordering\n+            execute(task);\n+            return;\n+        }\n+\n+        AtomicBoolean isFirst = new AtomicBoolean(false);\n+        Runnable orderedTask;\n+        synchronized (keyedOrderedTasks) {\n+            keyedOrderedTasks.computeIfAbsent(key, o -> {\n+                isFirst.set(true);\n+                return new LinkedBlockingDeque<>();\n+            });\n+            BlockingQueue<Runnable> dependencyQueue = keyedOrderedTasks.get(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41fdea8658d6b903b6cc06a9377104d9bfd6a4ec"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bacee5b2fd3f54911e6feda2314287b9f03c6f8", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6bacee5b2fd3f54911e6feda2314287b9f03c6f8", "committedDate": "2020-10-26T21:28:07Z", "message": "Address PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTkxNTkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-517191591", "createdAt": "2020-10-26T21:31:33Z", "commit": {"oid": "6bacee5b2fd3f54911e6feda2314287b9f03c6f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTozMTozNFrOHojKqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQyMTozMTozNFrOHojKqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI4MTI1Ng==", "bodyText": "use executor.shutdown() and then assertTrue(executor.awaitTermination(1, TimeUnit.Seconds))", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#discussion_r512281256", "createdAt": "2020-10-26T21:31:34Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/util/OrderedExecutorServiceTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.greengrass.util;\n+\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class OrderedExecutorServiceTest {\n+    private static OrderedExecutorService orderedExecutorService;\n+    private volatile static Throwable lastThrownException = null;\n+\n+    @BeforeAll\n+    static void startUp() {\n+        orderedExecutorService = new OrderedExecutorService(Executors.newCachedThreadPool());\n+    }\n+\n+    @Test\n+    void GIVEN_multiple_keys_and_tasks_WHEN_esecute_THEN_executes_in_proper_order_for_each_key()\n+            throws InterruptedException {\n+        String key = UUID.randomUUID().toString();\n+        String key2 = UUID.randomUUID().toString();\n+\n+        Queue<String> queue = new LinkedList<>();\n+        List<Runnable> tasks = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            String randomString = UUID.randomUUID().toString();\n+            queue.add(randomString);\n+            tasks.add(createRunnable(randomString, queue));\n+        }\n+        Queue<String> queue2 = new LinkedList<>();\n+        List<Runnable> tasks2 = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            String randomString = UUID.randomUUID().toString();\n+            queue2.add(randomString);\n+            tasks2.add(createRunnable(randomString, queue2));\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            orderedExecutorService.execute(tasks.get(i), key);\n+            orderedExecutorService.execute(tasks2.get(i), key2);\n+        }\n+        while (!orderedExecutorService.getKeyedOrderedTasks().isEmpty()) {\n+            TimeUnit.SECONDS.sleep(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bacee5b2fd3f54911e6feda2314287b9f03c6f8"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MTkxNjk5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-517191699", "createdAt": "2020-10-26T21:31:43Z", "commit": {"oid": "6bacee5b2fd3f54911e6feda2314287b9f03c6f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjAzOTEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/512#pullrequestreview-517203913", "createdAt": "2020-10-26T21:53:13Z", "commit": {"oid": "6bacee5b2fd3f54911e6feda2314287b9f03c6f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b0322967a628035eacb42f324786dc5dcf6670c", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8b0322967a628035eacb42f324786dc5dcf6670c", "committedDate": "2020-10-26T22:08:31Z", "message": "Merge branch 'master' into pubsubIpcIntegration"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3113, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}