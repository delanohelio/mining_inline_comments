{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMTY2NDk0", "number": 55, "title": "Lifecycle IPC service implementation", "bodyText": "Issue #, if available:\nDescription of changes:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-02-06T23:42:55Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55", "merged": true, "mergeCommit": {"oid": "fd155f654228fc5b02ea3d66f4eb27e2f9ea21ae"}, "closed": true, "closedAt": "2020-02-14T03:36:31Z", "author": {"login": "MikeDombo"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBzy3-ABqjMwMTU5MTY0NzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcELLSkAFqTM1ODc3NDE2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7b3234dba7085ae6fa5861a193a8e133398ad342", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7b3234dba7085ae6fa5861a193a8e133398ad342", "committedDate": "2020-02-06T23:42:11Z", "message": "Lifecycle IPC"}, "afterCommit": {"oid": "ab6f8dfec7edcc9949b5e055a759540b3e6787d4", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab6f8dfec7edcc9949b5e055a759540b3e6787d4", "committedDate": "2020-02-07T00:00:32Z", "message": "Lifecycle IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab6f8dfec7edcc9949b5e055a759540b3e6787d4", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab6f8dfec7edcc9949b5e055a759540b3e6787d4", "committedDate": "2020-02-07T00:00:32Z", "message": "Lifecycle IPC"}, "afterCommit": {"oid": "ee259a9514a37081b4ae473210785b65cee3c906", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ee259a9514a37081b4ae473210785b65cee3c906", "committedDate": "2020-02-10T21:22:53Z", "message": "Lifecycle IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee259a9514a37081b4ae473210785b65cee3c906", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ee259a9514a37081b4ae473210785b65cee3c906", "committedDate": "2020-02-10T21:22:53Z", "message": "Lifecycle IPC"}, "afterCommit": {"oid": "b8271568a10bbeb2c2761a16302c5f9a62e7233d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b8271568a10bbeb2c2761a16302c5f9a62e7233d", "committedDate": "2020-02-10T22:39:16Z", "message": "Lifecycle IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b8271568a10bbeb2c2761a16302c5f9a62e7233d", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b8271568a10bbeb2c2761a16302c5f9a62e7233d", "committedDate": "2020-02-10T22:39:16Z", "message": "Lifecycle IPC"}, "afterCommit": {"oid": "0b91ab0008d725d223aeecc83009bd21aa72697e", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b91ab0008d725d223aeecc83009bd21aa72697e", "committedDate": "2020-02-11T00:41:05Z", "message": "Lifecycle IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "251be8e063c3defc2c445eeab40c0fb4c6296479", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/251be8e063c3defc2c445eeab40c0fb4c6296479", "committedDate": "2020-02-11T19:11:29Z", "message": "Merge branch 'master' into lifecycle"}, "afterCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0206eb5c791c46b96dea20fef8a6a6f7377692ab", "committedDate": "2020-02-13T00:11:50Z", "message": "Lifecycle IPC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTQzNTQ5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358543549", "createdAt": "2020-02-13T20:54:34Z", "commit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo1NDozNFrOFpjNxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowODo0MFrOFpjmmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExMjkwMw==", "bodyText": "Also add super.postInject();", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379112903", "createdAt": "2020-02-13T20:54:34Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<RequestContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNzgwMg==", "bodyText": "Any specific reason for using context here as key, instead of sourceServiceName?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379117802", "createdAt": "2020-02-13T21:05:29Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<RequestContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req, RequestContext context) {\n+        State s = State.valueOf(req.getState());\n+        Optional<EvergreenService> service =\n+                Optional.ofNullable(kernel.context.get(EvergreenService.class, context.getServiceName()));\n+\n+        GeneralResponse<Void, LifecycleResponseStatus> resp = new GeneralResponse<>();\n+        if (service.isPresent()) {\n+            service.get().setState(s);\n+            resp.setError(LifecycleResponseStatus.Success);\n+        } else {\n+            resp.setError(LifecycleResponseStatus.InvalidRequest);\n+            resp.setErrorMessage(\"Service could not be found\");\n+        }\n+\n+        return resp;\n+    }\n+\n+    /**\n+     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n+     * service's lifecyle changes).\n+     *\n+     * @param listenRequest incoming listen request\n+     * @param context caller context\n+     * @return response\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> listen(LifecycleListenRequest listenRequest,\n+                                                                 RequestContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.compute(listenRequest.getServiceName(), (key, old) -> {\n+            if (old == null) {\n+                old = new ConcurrentHashMap<>();\n+            }\n+            old.put(context, sendStateUpdateToListener(listenRequest, context));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODA0Mg==", "bodyText": "[Minor] maybe ConnectionHandler?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379118042", "createdAt": "2020-02-13T21:05:59Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/ConnectionHandle.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+\n+import java.util.concurrent.Future;\n+\n+@FunctionalInterface\n+public interface ConnectionHandle {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODUxNg==", "bodyText": "super.postInject", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379118516", "createdAt": "2020-02-13T21:07:03Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/LifecycleIPCService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.ipc.modules;\n+\n+\n+import com.aws.iot.evergreen.builtin.services.lifecycle.LifecycleIPCAgent;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader.Message;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.util.Log;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+import static com.aws.iot.evergreen.util.Log.Level;\n+\n+\n+//TODO: see if this needs to be a GGService\n+@ImplementsService(name = \"lifecycleipc\", autostart = true)\n+public class LifecycleIPCService extends EvergreenService {\n+    private ObjectMapper mapper = new CBORMapper();\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    Log log;\n+\n+    @Inject\n+    private LifecycleIPCAgent agent;\n+\n+    public LifecycleIPCService(Topics c) {\n+        super(c);\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        try {\n+            router.registerServiceCallback(LIFECYCLE_SERVICE_NAME, this::handleMessage);\n+        } catch (IPCException e) {\n+            log.log(Level.Error, \"Error registering callback for service \" + LIFECYCLE_SERVICE_NAME);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExOTI1OA==", "bodyText": "[Minor] Any reason for not using: https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/tuple/Pair.html ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379119258", "createdAt": "2020-02-13T21:08:40Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/util/Pair.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package com.aws.iot.evergreen.util;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+\n+@Data\n+@AllArgsConstructor\n+public class Pair<L, R> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTYxODIz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358561823", "createdAt": "2020-02-13T21:25:07Z", "commit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMToyNTowN1rOFpkEpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTo0MTo1MFrOFpkiNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNjk1MA==", "bodyText": "Why the value of this map needs to be a map?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379126950", "createdAt": "2020-02-13T21:25:07Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNzUzMg==", "bodyText": "I'd prefer renaming RequestContext into something like IPCClientConnectionContext", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379127532", "createdAt": "2020-02-13T21:26:22Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<RequestContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req, RequestContext context) {\n+        State s = State.valueOf(req.getState());\n+        Optional<EvergreenService> service =\n+                Optional.ofNullable(kernel.context.get(EvergreenService.class, context.getServiceName()));\n+\n+        GeneralResponse<Void, LifecycleResponseStatus> resp = new GeneralResponse<>();\n+        if (service.isPresent()) {\n+            service.get().setState(s);\n+            resp.setError(LifecycleResponseStatus.Success);\n+        } else {\n+            resp.setError(LifecycleResponseStatus.InvalidRequest);\n+            resp.setErrorMessage(\"Service could not be found\");\n+        }\n+\n+        return resp;\n+    }\n+\n+    /**\n+     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n+     * service's lifecyle changes).\n+     *\n+     * @param listenRequest incoming listen request\n+     * @param context caller context\n+     * @return response\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> listen(LifecycleListenRequest listenRequest,\n+                                                                 RequestContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.compute(listenRequest.getServiceName(), (key, old) -> {\n+            if (old == null) {\n+                old = new ConcurrentHashMap<>();\n+            }\n+            old.put(context, sendStateUpdateToListener(listenRequest, context));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExNzgwMg=="}, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyODUyNg==", "bodyText": "I feel this should be a method of RequestContext , like Future<> requestContext.sendMessage, and you can do synchronize on the object inside the method", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379128526", "createdAt": "2020-02-13T21:28:33Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<RequestContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req, RequestContext context) {\n+        State s = State.valueOf(req.getState());\n+        Optional<EvergreenService> service =\n+                Optional.ofNullable(kernel.context.get(EvergreenService.class, context.getServiceName()));\n+\n+        GeneralResponse<Void, LifecycleResponseStatus> resp = new GeneralResponse<>();\n+        if (service.isPresent()) {\n+            service.get().setState(s);\n+            resp.setError(LifecycleResponseStatus.Success);\n+        } else {\n+            resp.setError(LifecycleResponseStatus.InvalidRequest);\n+            resp.setErrorMessage(\"Service could not be found\");\n+        }\n+\n+        return resp;\n+    }\n+\n+    /**\n+     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n+     * service's lifecyle changes).\n+     *\n+     * @param listenRequest incoming listen request\n+     * @param context caller context\n+     * @return response\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> listen(LifecycleListenRequest listenRequest,\n+                                                                 RequestContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.compute(listenRequest.getServiceName(), (key, old) -> {\n+            if (old == null) {\n+                old = new ConcurrentHashMap<>();\n+            }\n+            old.put(context, sendStateUpdateToListener(listenRequest, context));\n+            return old;\n+        });\n+\n+        return GeneralResponse.<Void, LifecycleResponseStatus>builder().error(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n+                                                               RequestContext context) {\n+        return (oldState, newState) -> {\n+            executor.submit(() -> {\n+                // Synchronize on context so that we only try to send 1 update at a time to a given client\n+                synchronized (context) {\n+                    StateTransitionEvent trans =\n+                            StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n+                                    .service(listenRequest.getServiceName()).build();\n+\n+                    GeneralRequest<StateTransitionEvent, LifecycleRequestTypes> req =\n+                            GeneralRequest.<StateTransitionEvent, LifecycleRequestTypes>builder()\n+                                    .type(LifecycleRequestTypes.transition).request(trans).build();\n+\n+                    try {\n+                        // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                        ConnectionHandle connectionHandle =\n+                                router.getConnectionHandle(context, this::handleConnectionClosed);\n+                        if (connectionHandle != null) {\n+                            connectionHandle.sendAndReceive(LIFECYCLE_SERVICE_NAME,\n+                                    new FrameReader.Message(IPCUtil.encode(req))).get();\n+                        }\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNDUxNw==", "bodyText": "Haven't look too detailed into the code. I feel having both IPCRouter and MessageRouter is confusing", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379134517", "createdAt": "2020-02-13T21:41:50Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -57,7 +57,7 @@ public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n     @Override\n     public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n         super.channelUnregistered(ctx);\n-        // TODO: Handle de-registration of any listeners such as Lifecycle https://issues.amazon.com/issues/P32808717\n+        router.clientDisconnected(ctx.channel().attr(CONNECTION_CONTEXT_KEY).get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTg4NDY3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358588467", "createdAt": "2020-02-13T22:10:10Z", "commit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxMDoxMFrOFplVeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjoxNjoxN1rOFplfpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzY0Mg==", "bodyText": "The naming is a little confusing to me. reportState() ( and listen() below) , both means 'handleReportStateFromClient' and 'handlListenFromClient' .", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379147642", "createdAt": "2020-02-13T22:10:10Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    private static final Map<String, Map<RequestContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<RequestContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req, RequestContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1MDI0NA==", "bodyText": "Actually I feel that IPCRouter can be removed. registerCallback(dest, callback) can be put into LifecycleService, the new functions you added like connect/disconnect/sendResponseMessage can be methods in RequestContext", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379150244", "createdAt": "2020-02-13T22:16:17Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/MessageRouter.java", "diffHunk": "@@ -57,7 +57,7 @@ public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n     @Override\n     public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n         super.channelUnregistered(ctx);\n-        // TODO: Handle de-registration of any listeners such as Lifecycle https://issues.amazon.com/issues/P32808717\n+        router.clientDisconnected(ctx.channel().attr(CONNECTION_CONTEXT_KEY).get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNDUxNw=="}, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0206eb5c791c46b96dea20fef8a6a6f7377692ab", "committedDate": "2020-02-13T00:11:50Z", "message": "Lifecycle IPC"}, "afterCommit": {"oid": "cc7fc181166e9c0e95c17a12ffe720a496193cb1", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cc7fc181166e9c0e95c17a12ffe720a496193cb1", "committedDate": "2020-02-13T23:00:23Z", "message": "Lifecycle IPC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/baaf591f729be7db0fec921787b0bba4b6e6e805", "committedDate": "2020-02-13T23:15:17Z", "message": "Lifecycle IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc7fc181166e9c0e95c17a12ffe720a496193cb1", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cc7fc181166e9c0e95c17a12ffe720a496193cb1", "committedDate": "2020-02-13T23:00:23Z", "message": "Lifecycle IPC"}, "afterCommit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/baaf591f729be7db0fec921787b0bba4b6e6e805", "committedDate": "2020-02-13T23:15:17Z", "message": "Lifecycle IPC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjM4NTA1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358638505", "createdAt": "2020-02-14T00:07:24Z", "commit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fade2a9fcf5726b66f1e8cdddbfbc18854bf33cf", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fade2a9fcf5726b66f1e8cdddbfbc18854bf33cf", "committedDate": "2020-02-14T01:02:40Z", "message": "Merge branch 'master' into lifecycle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjYxOTQ0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358661944", "createdAt": "2020-02-14T01:21:49Z", "commit": {"oid": "fade2a9fcf5726b66f1e8cdddbfbc18854bf33cf"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToyMTo1MFrOFppC5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToyMjoyNlrOFppDfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODQyMA==", "bodyText": "I feel ConnectionHandle can be merged with ClientContext , sendAndReceive() is a method of ClientContext", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379208420", "createdAt": "2020-02-14T01:21:50Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/ConnectionHandle.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+\n+import java.util.concurrent.Future;\n+\n+@FunctionalInterface\n+public interface ConnectionHandle {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODA0Mg=="}, "originalCommit": {"oid": "0206eb5c791c46b96dea20fef8a6a6f7377692ab"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwODU3NA==", "bodyText": "I feel add disconnect handler doesn't fit in the function name getConnectionHandle()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379208574", "createdAt": "2020-02-14T01:22:26Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "diffHunk": "@@ -50,4 +66,103 @@ public void registerServiceCallback(String destination, IPCCallback callback) th\n     public IPCCallback getCallbackForDestination(String destination) {\n         return destinationCallbackMap.get(destination);\n     }\n+\n+    /**\n+     * Tries to get a connection handle from a context. The connection handle can be used to send\n+     * requests to the client and then wait for a response.\n+     *\n+     * @param connectionContext  The request context of the client that you want the handle to.\n+     * @param disconnectCallback Function to be called when the client disconnects. Use for cleaning up\n+     *                           extra listeners.\n+     * @return\n+     */\n+    @Nullable\n+    public ConnectionHandle getConnectionHandle(ConnectionContext connectionContext,\n+                                                Consumer<ConnectionContext> disconnectCallback) {\n+        Channel channel = clientToChannelMap.get(connectionContext);\n+        if (channel == null) {\n+            return null;\n+        }\n+\n+        clientToDisconnectorsMap.compute(connectionContext, (key, value) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fade2a9fcf5726b66f1e8cdddbfbc18854bf33cf"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjYyMjU5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358662259", "createdAt": "2020-02-14T01:22:56Z", "commit": {"oid": "fade2a9fcf5726b66f1e8cdddbfbc18854bf33cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NzQ4NTcx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358748571", "createdAt": "2020-02-14T07:16:08Z", "commit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxNjowOFrOFptaiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxNjowOFrOFptaiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDAwOA==", "bodyText": "why so we need to store Client and SequenceNumber instead of just the sequence number and future", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379280008", "createdAt": "2020-02-14T07:16:08Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "diffHunk": "@@ -50,4 +66,103 @@ public void registerServiceCallback(String destination, IPCCallback callback) th\n     public IPCCallback getCallbackForDestination(String destination) {\n         return destinationCallbackMap.get(destination);\n     }\n+\n+    /**\n+     * Tries to get a connection handle from a context. The connection handle can be used to send\n+     * requests to the client and then wait for a response.\n+     *\n+     * @param connectionContext  The request context of the client that you want the handle to.\n+     * @param disconnectCallback Function to be called when the client disconnects. Use for cleaning up\n+     *                           extra listeners.\n+     * @return\n+     */\n+    @Nullable\n+    public ConnectionHandle getConnectionHandle(ConnectionContext connectionContext,\n+                                                Consumer<ConnectionContext> disconnectCallback) {\n+        Channel channel = clientToChannelMap.get(connectionContext);\n+        if (channel == null) {\n+            return null;\n+        }\n+\n+        clientToDisconnectorsMap.compute(connectionContext, (key, value) -> {\n+            if (value == null) {\n+                value = new ArrayList<>();\n+            }\n+            value.add(disconnectCallback);\n+            return value;\n+        });\n+\n+        return (destination, message) -> {\n+            FrameReader.MessageFrame requestFrame =\n+                    new FrameReader.MessageFrame(destination, message, FrameReader.FrameType.REQUEST);\n+\n+            CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+            sequenceNumberToCallbackMap\n+                    .put(new ClientAndSequenceNumber(requestFrame.sequenceNumber, connectionContext), fut);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NzQ5MTI3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358749127", "createdAt": "2020-02-14T07:17:43Z", "commit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxNzo0M1rOFptcTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzoxNzo0M1rOFptcTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MDQ2Mw==", "bodyText": "lets first remove the context from clientToChannelMap before going through the list of call backs", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379280463", "createdAt": "2020-02-14T07:17:43Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/IPCRouter.java", "diffHunk": "@@ -50,4 +66,103 @@ public void registerServiceCallback(String destination, IPCCallback callback) th\n     public IPCCallback getCallbackForDestination(String destination) {\n         return destinationCallbackMap.get(destination);\n     }\n+\n+    /**\n+     * Tries to get a connection handle from a context. The connection handle can be used to send\n+     * requests to the client and then wait for a response.\n+     *\n+     * @param connectionContext  The request context of the client that you want the handle to.\n+     * @param disconnectCallback Function to be called when the client disconnects. Use for cleaning up\n+     *                           extra listeners.\n+     * @return\n+     */\n+    @Nullable\n+    public ConnectionHandle getConnectionHandle(ConnectionContext connectionContext,\n+                                                Consumer<ConnectionContext> disconnectCallback) {\n+        Channel channel = clientToChannelMap.get(connectionContext);\n+        if (channel == null) {\n+            return null;\n+        }\n+\n+        clientToDisconnectorsMap.compute(connectionContext, (key, value) -> {\n+            if (value == null) {\n+                value = new ArrayList<>();\n+            }\n+            value.add(disconnectCallback);\n+            return value;\n+        });\n+\n+        return (destination, message) -> {\n+            FrameReader.MessageFrame requestFrame =\n+                    new FrameReader.MessageFrame(destination, message, FrameReader.FrameType.REQUEST);\n+\n+            CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+            sequenceNumberToCallbackMap\n+                    .put(new ClientAndSequenceNumber(requestFrame.sequenceNumber, connectionContext), fut);\n+\n+            channel.writeAndFlush(requestFrame);\n+\n+            return fut;\n+        };\n+    }\n+\n+    /**\n+     * Only called by MessageRouter, do not call in any other place.\n+     * Called when a client disconnects from the server.\n+     *\n+     * @param context client which disconnected's context\n+     */\n+    public void clientDisconnected(ConnectionContext context) {\n+        List<Consumer<ConnectionContext>> disconnectors = clientToDisconnectorsMap.get(context);\n+        if (disconnectors != null) {\n+            disconnectors.forEach(d -> d.accept(context));\n+        }\n+\n+        clientToChannelMap.remove(context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NzYxNjA0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358761604", "createdAt": "2020-02-14T07:52:57Z", "commit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzo1Mjo1N1rOFpuDrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwNzo1Mjo1N1rOFpuDrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5MDU0Mg==", "bodyText": "We need to uniquely identify each connection at-least for logging and debugging purposes. May be a client Id?\nAlso add equals() and hashcode(), relying on the object itself for uniqueness is fragile.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379290542", "createdAt": "2020-02-14T07:52:57Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/common/ConnectionContext.java", "diffHunk": "@@ -7,6 +7,6 @@\n @AllArgsConstructor\n @Data\n @ToString\n-public class RequestContext {\n+public class ConnectionContext {\n     private String serviceName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NzcyOTQ1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358772945", "createdAt": "2020-02-14T08:20:28Z", "commit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODoyMDoyOVrOFpul5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODoyMDoyOVrOFpul5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5OTMwMw==", "bodyText": "do we need this synchronization? even if we limit this here, there would be another service trying to send a message to the client at the same time. IPCService should be support multiple code paths sending message to a client concurrently.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379299303", "createdAt": "2020-02-14T08:20:29Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n+    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<ConnectionContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req     incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req,\n+                                                                      ConnectionContext context) {\n+        State s = State.valueOf(req.getState());\n+        Optional<EvergreenService> service =\n+                Optional.ofNullable(kernel.context.get(EvergreenService.class, context.getServiceName()));\n+\n+        GeneralResponse<Void, LifecycleResponseStatus> resp = new GeneralResponse<>();\n+        if (service.isPresent()) {\n+            service.get().setState(s);\n+            resp.setError(LifecycleResponseStatus.Success);\n+        } else {\n+            resp.setError(LifecycleResponseStatus.InvalidRequest);\n+            resp.setErrorMessage(\"Service could not be found\");\n+        }\n+\n+        return resp;\n+    }\n+\n+    /**\n+     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n+     * service's lifecyle changes).\n+     *\n+     * @param listenRequest incoming listen request\n+     * @param context       caller context\n+     * @return response\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> listenToStateChanges(LifecycleListenRequest listenRequest,\n+                                                                               ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.compute(listenRequest.getServiceName(), (key, old) -> {\n+            if (old == null) {\n+                old = new ConcurrentHashMap<>();\n+            }\n+            old.put(context, sendStateUpdateToListener(listenRequest, context));\n+            return old;\n+        });\n+\n+        return GeneralResponse.<Void, LifecycleResponseStatus>builder().error(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n+                                                               ConnectionContext context) {\n+        return (oldState, newState) -> {\n+            executor.submit(() -> {\n+                // Synchronize on context so that we only try to send 1 update at a time to a given client\n+                synchronized (context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Nzc0MTY2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#pullrequestreview-358774166", "createdAt": "2020-02-14T08:23:03Z", "commit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODoyMzowM1rOFpupwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODoyMzowM1rOFpupwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMwMDI4OA==", "bodyText": "if the same connections listens to state changes for the same service n times, do we need to send n state change messages?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/55#discussion_r379300288", "createdAt": "2020-02-14T08:23:03Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.ConnectionHandle;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.function.BiConsumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.ipc.services.lifecycle.Lifecycle.LIFECYCLE_SERVICE_NAME;\n+\n+/**\n+ * Class to handle business logic for all Lifecycle requests over IPC.\n+ */\n+public class LifecycleIPCAgent implements InjectionActions {\n+    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n+    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private ExecutorService executor;\n+\n+    private EvergreenService.GlobalStateChangeListener onServiceChange = (service, prev) -> {\n+        Map<ConnectionContext, BiConsumer<State, State>> callbacks = listeners.get(service.getName());\n+        if (callbacks != null) {\n+            callbacks.values().forEach(x -> x.accept(prev, service.getState()));\n+        }\n+    };\n+\n+    public LifecycleIPCAgent() {\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        kernel.context.addGlobalStateChangeListener(onServiceChange);\n+    }\n+\n+    /**\n+     * Report the state of the service which the request is coming from.\n+     *\n+     * @param req     incoming request\n+     * @param context caller context\n+     * @return response for setting state\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> reportState(StateChangeRequest req,\n+                                                                      ConnectionContext context) {\n+        State s = State.valueOf(req.getState());\n+        Optional<EvergreenService> service =\n+                Optional.ofNullable(kernel.context.get(EvergreenService.class, context.getServiceName()));\n+\n+        GeneralResponse<Void, LifecycleResponseStatus> resp = new GeneralResponse<>();\n+        if (service.isPresent()) {\n+            service.get().setState(s);\n+            resp.setError(LifecycleResponseStatus.Success);\n+        } else {\n+            resp.setError(LifecycleResponseStatus.InvalidRequest);\n+            resp.setErrorMessage(\"Service could not be found\");\n+        }\n+\n+        return resp;\n+    }\n+\n+    /**\n+     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n+     * service's lifecyle changes).\n+     *\n+     * @param listenRequest incoming listen request\n+     * @param context       caller context\n+     * @return response\n+     */\n+    public GeneralResponse<Void, LifecycleResponseStatus> listenToStateChanges(LifecycleListenRequest listenRequest,\n+                                                                               ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        listeners.compute(listenRequest.getServiceName(), (key, old) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baaf591f729be7db0fec921787b0bba4b6e6e805"}, "originalPosition": 99}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2466, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}