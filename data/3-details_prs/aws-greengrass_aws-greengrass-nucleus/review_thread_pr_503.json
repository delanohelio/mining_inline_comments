{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4NzEyODIw", "number": 503, "reviewThreads": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODo0MjoxOVrOEq4AMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzozNjoyN1rOEsOTLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzkzMjAwOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/resources/com/aws/greengrass/integrationtests/deployment/ComponentConfigTest_DeployDocument_1.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODo0MjoxOVrOHdVOgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODo0ODo1MlrOHdVdGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxODUzMA==", "bodyText": "Heads up: Packages is a deprecated term. It will be replaced by Components before re:Invent so be ready with a plan to change it over.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500518530", "createdAt": "2020-10-06T18:42:19Z", "author": {"login": "ravenway"}, "path": "src/integrationtests/resources/com/aws/greengrass/integrationtests/deployment/ComponentConfigTest_DeployDocument_1.json", "diffHunk": "@@ -0,0 +1,18 @@\n+{\n+  \"DeploymentId\": \"arn:aws:us-east-1:greengrass:configuration:thinggroup/group1:1\",\n+  \"RootPackages\": [\n+    \"ComponentConfigurationTestService\"\n+  ],\n+  \"Packages\": [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fe6e1a8c7f88b7d93e2e3d08fefc362a21a2a6c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMjI2NA==", "bodyText": "Thanks. Also note this one is kernel's internal model - so we should be fine to change it after cloud", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500522264", "createdAt": "2020-10-06T18:48:52Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/resources/com/aws/greengrass/integrationtests/deployment/ComponentConfigTest_DeployDocument_1.json", "diffHunk": "@@ -0,0 +1,18 @@\n+{\n+  \"DeploymentId\": \"arn:aws:us-east-1:greengrass:configuration:thinggroup/group1:1\",\n+  \"RootPackages\": [\n+    \"ComponentConfigurationTestService\"\n+  ],\n+  \"Packages\": [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxODUzMA=="}, "originalCommit": {"oid": "8fe6e1a8c7f88b7d93e2e3d08fefc362a21a2a6c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDQ4Njc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/model/DeploymentPackageConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMToyODoxM1rOHdamSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMDo1NzoxNlrOHe2LPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNjUzOQ==", "bodyText": "Will this be deprecated? If so could you add @deprecated annotation?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500606539", "createdAt": "2020-10-06T21:28:13Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/deployment/model/DeploymentPackageConfiguration.java", "diffHunk": "@@ -40,4 +38,25 @@\n \n     @JsonProperty(\"Configuration\")\n     private Map<String, Object> configuration = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cad1771433ccb823bb45965bc43e5c57f91846f2"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEwNjk0Mg==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502106942", "createdAt": "2020-10-09T00:57:16Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/deployment/model/DeploymentPackageConfiguration.java", "diffHunk": "@@ -40,4 +38,25 @@\n \n     @JsonProperty(\"Configuration\")\n     private Map<String, Object> configuration = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNjUzOQ=="}, "originalCommit": {"oid": "cad1771433ccb823bb45965bc43e5c57f91846f2"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTE4OTE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMzowNzo1MFrOHdhBZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoyNDoxM1rOHd7iIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMTc4Mw==", "bodyText": "Note: this can potentially merge a null value. Not sure if that's desired", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500711783", "createdAt": "2020-10-07T03:07:50Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,41 +198,161 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    private Map<String, Object> resolveConfigurationToApply(ConfigurationUpdateOperation configurationUpdateOperation,\n+                                                            ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.lookupTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                                         .map(ComponentConfiguration::getDefaultConfiguration)\n+                                         .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // deal with no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig != null) {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            } else {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            }\n+        }\n+\n+        // deal with update\n+        return applyUpdateToCurrentConfig(currentRunningConfig, configurationUpdateOperation, defaultConfig);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map applyUpdateToCurrentConfig(Map<String, Object> currentRunningConfig,\n+                                           ConfigurationUpdateOperation configurationUpdateOperation,\n+                                           JsonNode defaultConfiguration) {\n+\n+        // initialize to empty map if null because we will use this map as the base.\n+        if (currentRunningConfig == null) {\n+            currentRunningConfig = new HashMap<>();\n+        }\n+\n+        // perform RESET first\n+        currentRunningConfig =\n+                reset(currentRunningConfig, defaultConfiguration, configurationUpdateOperation.getPathsToReset());\n+\n+        // perform MERGE secondly\n+        deepMerge(currentRunningConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return currentRunningConfig;\n+\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map reset(Map original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            JsonNode targetNode = defaultValue.at(jsonPointer);\n+\n+            if ((targetNode.isMissingNode())) {\n+                // missing default value -> remove the entry completely\n+                // note: remove, rather than setting to null.\n+                ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.getMatchingProperty());\n+\n+            } else {\n+                // target is container node, or a value node, including null node -> replace the entry\n+                ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.getMatchingProperty(), targetNode);\n+            }\n+        }\n+\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Map deepMerge(@Nonnull Map original, Map newMap) {\n+        if (newMap == null || newMap.isEmpty()) {\n+            return original;\n+        }\n+\n+        for (Object key : newMap.keySet()) {\n+            if (newMap.get(key) instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                Map originalChild = (Map) original.get(key);\n+                Map newChild = (Map) newMap.get(key);\n+                original.put(key, deepMerge(originalChild, newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides.\n+                // This branch also handles the list with entire replacement.\n+                // Note: There is no support for list append or insert at index operations.\n+                original.put(key, newMap.get(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NjE0Nw==", "bodyText": "Yep. That is desired. Initially I didn't want to differentiate an explicit null vs missing key - but @fengwa-aws mentioned that since the config will be eventually distributed to user, it's better to keep it as is. I'm also adding a test for the explicit null case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501146147", "createdAt": "2020-10-07T16:24:13Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,41 +198,161 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    private Map<String, Object> resolveConfigurationToApply(ConfigurationUpdateOperation configurationUpdateOperation,\n+                                                            ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.lookupTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                                         .map(ComponentConfiguration::getDefaultConfiguration)\n+                                         .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // deal with no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig != null) {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            } else {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            }\n+        }\n+\n+        // deal with update\n+        return applyUpdateToCurrentConfig(currentRunningConfig, configurationUpdateOperation, defaultConfig);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map applyUpdateToCurrentConfig(Map<String, Object> currentRunningConfig,\n+                                           ConfigurationUpdateOperation configurationUpdateOperation,\n+                                           JsonNode defaultConfiguration) {\n+\n+        // initialize to empty map if null because we will use this map as the base.\n+        if (currentRunningConfig == null) {\n+            currentRunningConfig = new HashMap<>();\n+        }\n+\n+        // perform RESET first\n+        currentRunningConfig =\n+                reset(currentRunningConfig, defaultConfiguration, configurationUpdateOperation.getPathsToReset());\n+\n+        // perform MERGE secondly\n+        deepMerge(currentRunningConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return currentRunningConfig;\n+\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map reset(Map original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            JsonNode targetNode = defaultValue.at(jsonPointer);\n+\n+            if ((targetNode.isMissingNode())) {\n+                // missing default value -> remove the entry completely\n+                // note: remove, rather than setting to null.\n+                ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.getMatchingProperty());\n+\n+            } else {\n+                // target is container node, or a value node, including null node -> replace the entry\n+                ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.getMatchingProperty(), targetNode);\n+            }\n+        }\n+\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Map deepMerge(@Nonnull Map original, Map newMap) {\n+        if (newMap == null || newMap.isEmpty()) {\n+            return original;\n+        }\n+\n+        for (Object key : newMap.keySet()) {\n+            if (newMap.get(key) instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                Map originalChild = (Map) original.get(key);\n+                Map newChild = (Map) newMap.get(key);\n+                original.put(key, deepMerge(originalChild, newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides.\n+                // This branch also handles the list with entire replacement.\n+                // Note: There is no support for list append or insert at index operations.\n+                original.put(key, newMap.get(key));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMTc4Mw=="}, "originalCommit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTE5MTk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMzowOTozOVrOHdhDDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjozMTo0OFrOHd72Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMjIwNg==", "bodyText": "What happens here if originalChild is null? What's supposed to happen?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500712206", "createdAt": "2020-10-07T03:09:39Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,41 +198,161 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    private Map<String, Object> resolveConfigurationToApply(ConfigurationUpdateOperation configurationUpdateOperation,\n+                                                            ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.lookupTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                                         .map(ComponentConfiguration::getDefaultConfiguration)\n+                                         .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // deal with no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig != null) {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            } else {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            }\n+        }\n+\n+        // deal with update\n+        return applyUpdateToCurrentConfig(currentRunningConfig, configurationUpdateOperation, defaultConfig);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map applyUpdateToCurrentConfig(Map<String, Object> currentRunningConfig,\n+                                           ConfigurationUpdateOperation configurationUpdateOperation,\n+                                           JsonNode defaultConfiguration) {\n+\n+        // initialize to empty map if null because we will use this map as the base.\n+        if (currentRunningConfig == null) {\n+            currentRunningConfig = new HashMap<>();\n+        }\n+\n+        // perform RESET first\n+        currentRunningConfig =\n+                reset(currentRunningConfig, defaultConfiguration, configurationUpdateOperation.getPathsToReset());\n+\n+        // perform MERGE secondly\n+        deepMerge(currentRunningConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return currentRunningConfig;\n+\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map reset(Map original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            JsonNode targetNode = defaultValue.at(jsonPointer);\n+\n+            if ((targetNode.isMissingNode())) {\n+                // missing default value -> remove the entry completely\n+                // note: remove, rather than setting to null.\n+                ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.getMatchingProperty());\n+\n+            } else {\n+                // target is container node, or a value node, including null node -> replace the entry\n+                ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.getMatchingProperty(), targetNode);\n+            }\n+        }\n+\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Map deepMerge(@Nonnull Map original, Map newMap) {\n+        if (newMap == null || newMap.isEmpty()) {\n+            return original;\n+        }\n+\n+        for (Object key : newMap.keySet()) {\n+            if (newMap.get(key) instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                Map originalChild = (Map) original.get(key);\n+                Map newChild = (Map) newMap.get(key);\n+                original.put(key, deepMerge(originalChild, newChild));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE1MTI4Mw==", "bodyText": "Great catch. It didn't really happen integ tests hit coz it's hard to get a null Map, although totally possible. If originalChild is null and newChild is not null, then originalChild should be merged with newChild (even for the case newChild is emptyMap). I will remove the @Nonnull assumption for original and handle it at the beginning - basically every level, both map could be null", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501151283", "createdAt": "2020-10-07T16:31:48Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,41 +198,161 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    @SuppressWarnings(\"rawtypes\")\n+    private Map<String, Object> resolveConfigurationToApply(ConfigurationUpdateOperation configurationUpdateOperation,\n+                                                            ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.lookupTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                                         .map(ComponentConfiguration::getDefaultConfiguration)\n+                                         .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // deal with no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig != null) {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            } else {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            }\n+        }\n+\n+        // deal with update\n+        return applyUpdateToCurrentConfig(currentRunningConfig, configurationUpdateOperation, defaultConfig);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map applyUpdateToCurrentConfig(Map<String, Object> currentRunningConfig,\n+                                           ConfigurationUpdateOperation configurationUpdateOperation,\n+                                           JsonNode defaultConfiguration) {\n+\n+        // initialize to empty map if null because we will use this map as the base.\n+        if (currentRunningConfig == null) {\n+            currentRunningConfig = new HashMap<>();\n+        }\n+\n+        // perform RESET first\n+        currentRunningConfig =\n+                reset(currentRunningConfig, defaultConfiguration, configurationUpdateOperation.getPathsToReset());\n+\n+        // perform MERGE secondly\n+        deepMerge(currentRunningConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return currentRunningConfig;\n+\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private Map reset(Map original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            JsonNode targetNode = defaultValue.at(jsonPointer);\n+\n+            if ((targetNode.isMissingNode())) {\n+                // missing default value -> remove the entry completely\n+                // note: remove, rather than setting to null.\n+                ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.getMatchingProperty());\n+\n+            } else {\n+                // target is container node, or a value node, including null node -> replace the entry\n+                ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.getMatchingProperty(), targetNode);\n+            }\n+        }\n+\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Map deepMerge(@Nonnull Map original, Map newMap) {\n+        if (newMap == null || newMap.isEmpty()) {\n+            return original;\n+        }\n+\n+        for (Object key : newMap.keySet()) {\n+            if (newMap.get(key) instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                Map originalChild = (Map) original.get(key);\n+                Map newChild = (Map) newMap.get(key);\n+                original.put(key, deepMerge(originalChild, newChild));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxMjIwNg=="}, "originalCommit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTIwNTY2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMzoxNzo1OFrOHdhLEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMzoxNzo1OFrOHdhLEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcxNDI1Nw==", "bodyText": "should the last } also be escaped for good measure? Also, can this be more strict? It'll basically match anything. It's actually less restrictive than other matchers in this file so I'm concerned about the config resolving to broken state.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r500714257", "createdAt": "2020-10-07T03:17:58Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -55,12 +62,21 @@\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n     private static final Pattern SAME_INTERPOLATION_REGEX =\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n+\n+    // pattern matches {group1:group2}. Note char in both group can't be }, but can be special char like / and .\n+    private static final Pattern SAME_COMPONENT_INTERPOLATION_REGEX = Pattern.compile(\"\\\\{([^}]+):([^}]+)}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afa0b685f8e82278710848bb6dc135f87ef32269"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTUwODY4OnYy", "diffSide": "RIGHT", "path": "CONFIGURE_COMPONENT_README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMjo0OTowOVrOHec6sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODowNzo1NVrOHeqf1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5MzEwNQ==", "bodyText": "What's the use-case for allowing this? Scenario: my component's configuration as a default value on a key, and someone sets this key to null. As a consumer of the key, will I retrieve the default value or null? In other words: is null treated differently than \"unset\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501693105", "createdAt": "2020-10-08T12:49:09Z", "author": {"login": "philcali"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,\n+regardless of the order they are given in the JSON Object.\n+\n+#### 2.3.1 RESET\n+RESET takes a list of String.\n+Each string is a JSON Pointer: https://tools.ietf.org/html/rfc6901.\n+\n+1. If a default value doesn't exist at this JSON pointer location, then the key/value pair will be removed entirely. \n+1. If a default value exists at this JSON pointer location, then the value of configuration will be reset to the default value.\n+\n+##### RESET doesn't support using index for an Array/List!!\n+Although JSON pointer supports use indexes to locate an element in an Array/List, **we don't support use\n+JSON pointer to reset an element in an Array/List for re:Invent 2020**. The reason is that resetting an element of an array\n+might cause removal for an index, elements shifting in the array, and other indeterministic results. \n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+##### RESET the entire configuration\n+Empty String is JSON pointer's way to refer to the whole document. So you could simply do\n+\n+```json\n+{\n+  \"RESET\":  [\"\"]\n+}\n+```\n+\n+Note that if the empty string appears in the list of `RESET`, then the rest of pointers in the list will be ignored, and the configuration\n+will just be reset to the default configuration entirely.\n+\n+\n+##### What happens if I reset to a default value and my default value is null or empty?\n+In general, Greengrass V2 will reset to the default value as is, instead of dropping null or empty values, including:\n+\n+1. Default value has an empty List. ex. `{\"emptyListKey\": []}`. An empty list will be reset with JSON pointer: `/emptyListKey`.\n+1. Default value has an empty Map/Object. `{\"emptyMapKey\": {}}`. An empty map will be reset with JSON pointer: `/emptyMapKey`.\n+1. Default value has an empty String. `{\"emptyStringKey\": \"\"\"}`. An empty String will be reset with JSON pointer: `/emptyStringKey`.\n+1. Default value has a null. `{\"defaultIsNullKey\":null}`. A null will be reset with JSON pointer: `/defaultIsNullKey`.\n+\n+#### 2.3.2 MERGE\n+`MERGE` takes an object, representing new configuration that should be merging in.\n+\n+The given object is merged to the existing configuration object level by level. \n+\n+At every level,\n+1. if a key already exists, then the value will be overridden by the value that is merging in.\n+2. If a key doesn't exist, then key-value pair that is merging in will be added. Note a key that is not existed in the default value,\n+could also be added.\n+\n+##### MERGE doesn't support Array/List append or insertion at index operations!!\n+Similar to removal, list append and insertion index require handling addtional complexity of array index changing, elements\n+shifting, and other indeterministic results.\n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+However, it's still possible to override the entire list.\n+If you really need to make updates at the element level, think about using a map instead, by giving each element an unique key.\n+\n+##### Can I merge in a new key-value pair, which was not part of the default configuration?\n+YES. We are providing the flexibility to do so, so that new configurations could be added during deployments.\n+\n+##### Can I merge empty values?\n+YES. You can merge empty String, List, or Object/Map.\n+\n+##### Can I merge `null` as a value for a key?\n+YES. When reading the merged configuration, you will be able to find the key with value as `null`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNTYwNQ==", "bodyText": "They are treated differently. You will get a null. It's for the case where there were feedback people want to merge in a explicit null", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501915605", "createdAt": "2020-10-08T18:07:55Z", "author": {"login": "leaf94"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,\n+regardless of the order they are given in the JSON Object.\n+\n+#### 2.3.1 RESET\n+RESET takes a list of String.\n+Each string is a JSON Pointer: https://tools.ietf.org/html/rfc6901.\n+\n+1. If a default value doesn't exist at this JSON pointer location, then the key/value pair will be removed entirely. \n+1. If a default value exists at this JSON pointer location, then the value of configuration will be reset to the default value.\n+\n+##### RESET doesn't support using index for an Array/List!!\n+Although JSON pointer supports use indexes to locate an element in an Array/List, **we don't support use\n+JSON pointer to reset an element in an Array/List for re:Invent 2020**. The reason is that resetting an element of an array\n+might cause removal for an index, elements shifting in the array, and other indeterministic results. \n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+##### RESET the entire configuration\n+Empty String is JSON pointer's way to refer to the whole document. So you could simply do\n+\n+```json\n+{\n+  \"RESET\":  [\"\"]\n+}\n+```\n+\n+Note that if the empty string appears in the list of `RESET`, then the rest of pointers in the list will be ignored, and the configuration\n+will just be reset to the default configuration entirely.\n+\n+\n+##### What happens if I reset to a default value and my default value is null or empty?\n+In general, Greengrass V2 will reset to the default value as is, instead of dropping null or empty values, including:\n+\n+1. Default value has an empty List. ex. `{\"emptyListKey\": []}`. An empty list will be reset with JSON pointer: `/emptyListKey`.\n+1. Default value has an empty Map/Object. `{\"emptyMapKey\": {}}`. An empty map will be reset with JSON pointer: `/emptyMapKey`.\n+1. Default value has an empty String. `{\"emptyStringKey\": \"\"\"}`. An empty String will be reset with JSON pointer: `/emptyStringKey`.\n+1. Default value has a null. `{\"defaultIsNullKey\":null}`. A null will be reset with JSON pointer: `/defaultIsNullKey`.\n+\n+#### 2.3.2 MERGE\n+`MERGE` takes an object, representing new configuration that should be merging in.\n+\n+The given object is merged to the existing configuration object level by level. \n+\n+At every level,\n+1. if a key already exists, then the value will be overridden by the value that is merging in.\n+2. If a key doesn't exist, then key-value pair that is merging in will be added. Note a key that is not existed in the default value,\n+could also be added.\n+\n+##### MERGE doesn't support Array/List append or insertion at index operations!!\n+Similar to removal, list append and insertion index require handling addtional complexity of array index changing, elements\n+shifting, and other indeterministic results.\n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+However, it's still possible to override the entire list.\n+If you really need to make updates at the element level, think about using a map instead, by giving each element an unique key.\n+\n+##### Can I merge in a new key-value pair, which was not part of the default configuration?\n+YES. We are providing the flexibility to do so, so that new configurations could be added during deployments.\n+\n+##### Can I merge empty values?\n+YES. You can merge empty String, List, or Object/Map.\n+\n+##### Can I merge `null` as a value for a key?\n+YES. When reading the merged configuration, you will be able to find the key with value as `null`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5MzEwNQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTU4NTE4OnYy", "diffSide": "RIGHT", "path": "CONFIGURE_COMPONENT_README.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzowNzo1NlrOHedqqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzozMzowNVrOHe0cgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwNTM4Ng==", "bodyText": "Understanding that mutation and validation are distinct problems, without schema validation, this is a scary thing to allow. A component's recipe is a static, and therefore structural changes can impact the component's lifecycle in non-obvious ways (ie: changing a complex object into a primitive, or vice-versa). Until proper schema validation exists, I wonder if it makes sense to validate that the mutated object is structurally similar to the default configuration object.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501705386", "createdAt": "2020-10-08T13:07:56Z", "author": {"login": "philcali"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,\n+regardless of the order they are given in the JSON Object.\n+\n+#### 2.3.1 RESET\n+RESET takes a list of String.\n+Each string is a JSON Pointer: https://tools.ietf.org/html/rfc6901.\n+\n+1. If a default value doesn't exist at this JSON pointer location, then the key/value pair will be removed entirely. \n+1. If a default value exists at this JSON pointer location, then the value of configuration will be reset to the default value.\n+\n+##### RESET doesn't support using index for an Array/List!!\n+Although JSON pointer supports use indexes to locate an element in an Array/List, **we don't support use\n+JSON pointer to reset an element in an Array/List for re:Invent 2020**. The reason is that resetting an element of an array\n+might cause removal for an index, elements shifting in the array, and other indeterministic results. \n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+##### RESET the entire configuration\n+Empty String is JSON pointer's way to refer to the whole document. So you could simply do\n+\n+```json\n+{\n+  \"RESET\":  [\"\"]\n+}\n+```\n+\n+Note that if the empty string appears in the list of `RESET`, then the rest of pointers in the list will be ignored, and the configuration\n+will just be reset to the default configuration entirely.\n+\n+\n+##### What happens if I reset to a default value and my default value is null or empty?\n+In general, Greengrass V2 will reset to the default value as is, instead of dropping null or empty values, including:\n+\n+1. Default value has an empty List. ex. `{\"emptyListKey\": []}`. An empty list will be reset with JSON pointer: `/emptyListKey`.\n+1. Default value has an empty Map/Object. `{\"emptyMapKey\": {}}`. An empty map will be reset with JSON pointer: `/emptyMapKey`.\n+1. Default value has an empty String. `{\"emptyStringKey\": \"\"\"}`. An empty String will be reset with JSON pointer: `/emptyStringKey`.\n+1. Default value has a null. `{\"defaultIsNullKey\":null}`. A null will be reset with JSON pointer: `/defaultIsNullKey`.\n+\n+#### 2.3.2 MERGE\n+`MERGE` takes an object, representing new configuration that should be merging in.\n+\n+The given object is merged to the existing configuration object level by level. \n+\n+At every level,\n+1. if a key already exists, then the value will be overridden by the value that is merging in.\n+2. If a key doesn't exist, then key-value pair that is merging in will be added. Note a key that is not existed in the default value,\n+could also be added.\n+\n+##### MERGE doesn't support Array/List append or insertion at index operations!!\n+Similar to removal, list append and insertion index require handling addtional complexity of array index changing, elements\n+shifting, and other indeterministic results.\n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+However, it's still possible to override the entire list.\n+If you really need to make updates at the element level, think about using a map instead, by giving each element an unique key.\n+\n+##### Can I merge in a new key-value pair, which was not part of the default configuration?\n+YES. We are providing the flexibility to do so, so that new configurations could be added during deployments.\n+\n+##### Can I merge empty values?\n+YES. You can merge empty String, List, or Object/Map.\n+\n+##### Can I merge `null` as a value for a key?\n+YES. When reading the merged configuration, you will be able to find the key with value as `null`.\n+\n+##### Can I merge in a new value whose type is different from original value's type for the same key?\n+YES. The new value will be merged in and overrides the old value.\n+This allows you to potentially change the configuration object's structure. See the following example:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNjk4NQ==", "bodyText": "Yes. When I implemented it, I also feel our decision about this one is a little less restrictive. Basically we want to provide max flexibility for customers while they could then do validation in their component code. That's why I listed out clearly in the README.\nI'd say for current revision let's keep it this way. But I'd like to hear @JamesGosling and @JamieHunter 's thought for the reInvent behavior if we want to outlaw this.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501916985", "createdAt": "2020-10-08T18:10:07Z", "author": {"login": "leaf94"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,\n+regardless of the order they are given in the JSON Object.\n+\n+#### 2.3.1 RESET\n+RESET takes a list of String.\n+Each string is a JSON Pointer: https://tools.ietf.org/html/rfc6901.\n+\n+1. If a default value doesn't exist at this JSON pointer location, then the key/value pair will be removed entirely. \n+1. If a default value exists at this JSON pointer location, then the value of configuration will be reset to the default value.\n+\n+##### RESET doesn't support using index for an Array/List!!\n+Although JSON pointer supports use indexes to locate an element in an Array/List, **we don't support use\n+JSON pointer to reset an element in an Array/List for re:Invent 2020**. The reason is that resetting an element of an array\n+might cause removal for an index, elements shifting in the array, and other indeterministic results. \n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+##### RESET the entire configuration\n+Empty String is JSON pointer's way to refer to the whole document. So you could simply do\n+\n+```json\n+{\n+  \"RESET\":  [\"\"]\n+}\n+```\n+\n+Note that if the empty string appears in the list of `RESET`, then the rest of pointers in the list will be ignored, and the configuration\n+will just be reset to the default configuration entirely.\n+\n+\n+##### What happens if I reset to a default value and my default value is null or empty?\n+In general, Greengrass V2 will reset to the default value as is, instead of dropping null or empty values, including:\n+\n+1. Default value has an empty List. ex. `{\"emptyListKey\": []}`. An empty list will be reset with JSON pointer: `/emptyListKey`.\n+1. Default value has an empty Map/Object. `{\"emptyMapKey\": {}}`. An empty map will be reset with JSON pointer: `/emptyMapKey`.\n+1. Default value has an empty String. `{\"emptyStringKey\": \"\"\"}`. An empty String will be reset with JSON pointer: `/emptyStringKey`.\n+1. Default value has a null. `{\"defaultIsNullKey\":null}`. A null will be reset with JSON pointer: `/defaultIsNullKey`.\n+\n+#### 2.3.2 MERGE\n+`MERGE` takes an object, representing new configuration that should be merging in.\n+\n+The given object is merged to the existing configuration object level by level. \n+\n+At every level,\n+1. if a key already exists, then the value will be overridden by the value that is merging in.\n+2. If a key doesn't exist, then key-value pair that is merging in will be added. Note a key that is not existed in the default value,\n+could also be added.\n+\n+##### MERGE doesn't support Array/List append or insertion at index operations!!\n+Similar to removal, list append and insertion index require handling addtional complexity of array index changing, elements\n+shifting, and other indeterministic results.\n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+However, it's still possible to override the entire list.\n+If you really need to make updates at the element level, think about using a map instead, by giving each element an unique key.\n+\n+##### Can I merge in a new key-value pair, which was not part of the default configuration?\n+YES. We are providing the flexibility to do so, so that new configurations could be added during deployments.\n+\n+##### Can I merge empty values?\n+YES. You can merge empty String, List, or Object/Map.\n+\n+##### Can I merge `null` as a value for a key?\n+YES. When reading the merged configuration, you will be able to find the key with value as `null`.\n+\n+##### Can I merge in a new value whose type is different from original value's type for the same key?\n+YES. The new value will be merged in and overrides the old value.\n+This allows you to potentially change the configuration object's structure. See the following example:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwNTM4Ng=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3ODU5NQ==", "bodyText": "No, I think the algorithm you got here should not conflate validation and mutation (I like what you have). I guess this is more about input validation from the various interfaces to fail as early as possible.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502078595", "createdAt": "2020-10-08T23:33:05Z", "author": {"login": "philcali"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,\n+regardless of the order they are given in the JSON Object.\n+\n+#### 2.3.1 RESET\n+RESET takes a list of String.\n+Each string is a JSON Pointer: https://tools.ietf.org/html/rfc6901.\n+\n+1. If a default value doesn't exist at this JSON pointer location, then the key/value pair will be removed entirely. \n+1. If a default value exists at this JSON pointer location, then the value of configuration will be reset to the default value.\n+\n+##### RESET doesn't support using index for an Array/List!!\n+Although JSON pointer supports use indexes to locate an element in an Array/List, **we don't support use\n+JSON pointer to reset an element in an Array/List for re:Invent 2020**. The reason is that resetting an element of an array\n+might cause removal for an index, elements shifting in the array, and other indeterministic results. \n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+##### RESET the entire configuration\n+Empty String is JSON pointer's way to refer to the whole document. So you could simply do\n+\n+```json\n+{\n+  \"RESET\":  [\"\"]\n+}\n+```\n+\n+Note that if the empty string appears in the list of `RESET`, then the rest of pointers in the list will be ignored, and the configuration\n+will just be reset to the default configuration entirely.\n+\n+\n+##### What happens if I reset to a default value and my default value is null or empty?\n+In general, Greengrass V2 will reset to the default value as is, instead of dropping null or empty values, including:\n+\n+1. Default value has an empty List. ex. `{\"emptyListKey\": []}`. An empty list will be reset with JSON pointer: `/emptyListKey`.\n+1. Default value has an empty Map/Object. `{\"emptyMapKey\": {}}`. An empty map will be reset with JSON pointer: `/emptyMapKey`.\n+1. Default value has an empty String. `{\"emptyStringKey\": \"\"\"}`. An empty String will be reset with JSON pointer: `/emptyStringKey`.\n+1. Default value has a null. `{\"defaultIsNullKey\":null}`. A null will be reset with JSON pointer: `/defaultIsNullKey`.\n+\n+#### 2.3.2 MERGE\n+`MERGE` takes an object, representing new configuration that should be merging in.\n+\n+The given object is merged to the existing configuration object level by level. \n+\n+At every level,\n+1. if a key already exists, then the value will be overridden by the value that is merging in.\n+2. If a key doesn't exist, then key-value pair that is merging in will be added. Note a key that is not existed in the default value,\n+could also be added.\n+\n+##### MERGE doesn't support Array/List append or insertion at index operations!!\n+Similar to removal, list append and insertion index require handling addtional complexity of array index changing, elements\n+shifting, and other indeterministic results.\n+\n+Hence, we've decided to postpone the support for an Array/List to post re:Invent 2020.\n+\n+However, it's still possible to override the entire list.\n+If you really need to make updates at the element level, think about using a map instead, by giving each element an unique key.\n+\n+##### Can I merge in a new key-value pair, which was not part of the default configuration?\n+YES. We are providing the flexibility to do so, so that new configurations could be added during deployments.\n+\n+##### Can I merge empty values?\n+YES. You can merge empty String, List, or Object/Map.\n+\n+##### Can I merge `null` as a value for a key?\n+YES. When reading the merged configuration, you will be able to find the key with value as `null`.\n+\n+##### Can I merge in a new value whose type is different from original value's type for the same key?\n+YES. The new value will be merged in and overrides the old value.\n+This allows you to potentially change the configuration object's structure. See the following example:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwNTM4Ng=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTU5NTI2OnYy", "diffSide": "RIGHT", "path": "RECIPE_REFERENCE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoxMDoyMFrOHedw5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoxMDoyMFrOHedw5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwNjk4Mg==", "bodyText": "If I'm allowed to MERGE the args field to a single level key, how will these default values be applied?\nDiscussed offline: it's how it works, but it would fail interpolation on the component service lifecycle, thus failing the deployment.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501706982", "createdAt": "2020-10-08T13:10:20Z", "author": {"login": "philcali"}, "path": "RECIPE_REFERENCE.md", "diffHunk": "@@ -18,31 +18,36 @@ ComponentVersion: 1.0.0\n ComponentDescription: hello world from greengrass!\n ComponentPublisher: Amazon\n ComponentType: aws.greengrass.generic\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    args:\n+      windowsArg: Hello Windows\n+      linuxArg: Hello Linux", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mjk4NDg2OnYy", "diffSide": "RIGHT", "path": "CONFIGURE_COMPONENT_README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoyNjoyM1rOHerMAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTozNDo0OVrOHe3RWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyNjkxMw==", "bodyText": "I thought we're not supporting path in re:Invent?\nWhat is exactly a path? Does it include the leafKey?\nCan you also add a real example below?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501926913", "createdAt": "2020-10-08T18:26:23Z", "author": {"login": "fengwang666"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNDg5MA==", "bodyText": "my bad. \"path\" is to indicate that it is nested structure. It's not a reserved keyword. Will update it to remove the confusion", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502124890", "createdAt": "2020-10-09T01:34:49Z", "author": {"login": "leaf94"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyNjkxMw=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzAzMDMzOnYy", "diffSide": "RIGHT", "path": "CONFIGURE_COMPONENT_README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODozODowNVrOHernkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTozNToyN1rOHe3R_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzMzk2OQ==", "bodyText": "Then let's remove the YAML sample? This readme will be public, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501933969", "createdAt": "2020-10-08T18:38:05Z", "author": {"login": "fengwang666"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNTA1NA==", "bodyText": "All our recipes are in YAML though so I also included YAML for default config", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502125054", "createdAt": "2020-10-09T01:35:27Z", "author": {"login": "leaf94"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzMzk2OQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzA1ODc4OnYy", "diffSide": "RIGHT", "path": "CONFIGURE_COMPONENT_README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODo0NjoyMlrOHer5ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTozNTozMlrOHe3SDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzODYxOA==", "bodyText": "Can I have more than one REST and MERGE?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501938618", "createdAt": "2020-10-08T18:46:22Z", "author": {"login": "fengwang666"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNTA2OQ==", "bodyText": "No. Will update", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502125069", "createdAt": "2020-10-09T01:35:32Z", "author": {"login": "leaf94"}, "path": "CONFIGURE_COMPONENT_README.md", "diffHunk": "@@ -0,0 +1,182 @@\n+# Configure A Component\n+Each Greengrass V2 component could define its own default configuration which would be used by default.\n+\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**.\n+\n+Note: updating configuration is only supported for the **target components** of a deployment.\n+\n+## 1. Define Default Configuration for a Component\n+The default configuration is defined in the recipe file.\n+\n+In YAML, \n+```yaml\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    path:\n+      leafKey: default value of /path/leafKey\n+    listKey:\n+      - 'item1'\n+      - 'item2'\n+    emptyStringKey: ''\n+    emptyListKey: []\n+    emptyMap: {}\n+    defaultIsNullKey: null\n+```\n+\n+or in JSON,\n+```json\n+{\n+   \"ComponentConfiguration\": {\n+      \"DefaultConfiguration\": {\n+         \"singleLevelKey\": \"default value of singleLevelKey\",\n+         \"path\": {\n+            \"leafKey\": \"default value of /path/leafKey\"\n+         },\n+         \"listKey\": [\n+            \"item1\",\n+            \"item2\"\n+         ],\n+         \"emptyStringKey\": \"\",\n+         \"emptyListKey\": [],\n+         \"emptyMap\": {},\n+         \"defaultIsNullKey\": null\n+      }\n+   }\n+}\n+```\n+\n+## 2. Update Configuration for a Component\n+A deployment, either from cloud or local device, could optionally provide a configuration update instruction to update\n+the configuration for a deployment's **target components**, with the following syntax.\n+\n+\n+### 2.1 JSON vs YAML\n+Currently, we only support JSON. We will support YAML as a fast-follow after re:Invent 2020.\n+\n+### 2.2 Sample\n+```json\n+{\n+  \"RESET\": [\n+       \"/someOtherKey\", \"/some/nested/path\"\n+  ],\n+  \"MERGE\": {\n+    \"singleLevelKey\" : \"updated value of singleLevelKey\",\n+    \"newSingleLevelKey\": \"I was not in the default value and could be added.\",\n+    \"listKey\": [\"item3\"],\n+    \"path\" : {\n+      \"leafKey\": \"updated value of /path/leafKey\",\n+      \"newLeafKey\": \"value of /path/newLeafKey\"\n+    }\n+  }\n+}\n+```\n+### 2.3 Syntax\n+It accepts only `RESET` and `MERGE` as top-level keys. The configuration will first perform `RESET` and then perform `MERGE`,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzODYxOA=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzEwMzQyOnYy", "diffSide": "RIGHT", "path": "RECIPE_REFERENCE.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODo1ODozMVrOHesVeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTozNjoxOVrOHe3Stw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk0NTcyMQ==", "bodyText": "Both double parenthesis and single parenthesis are used. Can we consolidate to use one of them?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r501945721", "createdAt": "2020-10-08T18:58:31Z", "author": {"login": "fengwang666"}, "path": "RECIPE_REFERENCE.md", "diffHunk": "@@ -18,31 +18,36 @@ ComponentVersion: 1.0.0\n ComponentDescription: hello world from greengrass!\n ComponentPublisher: Amazon\n ComponentType: aws.greengrass.generic\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    args:\n+      windowsArg: Hello Windows\n+      linuxArg: Hello Linux\n+\n+ComponentDependencies:\n+  variant.Python3:\n+    VersionRequirement: ^3.5\n+    DependencyType: SOFT\n+\n Manifests:\n   - Platform:\n       os: windows\n       architecture: x86_64\n     Lifecycle:\n       Run:\n-        python3 {{artifacts:path}}/hello_windows_server.py\n+        python3 {{artifacts:path}}/hello_windows_server.py {configuration:/args/windowsArg}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNTIzOQ==", "bodyText": "Yes. Single curly brace will be the final one and double will be removed together with parameters clean up", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502125239", "createdAt": "2020-10-09T01:36:19Z", "author": {"login": "leaf94"}, "path": "RECIPE_REFERENCE.md", "diffHunk": "@@ -18,31 +18,36 @@ ComponentVersion: 1.0.0\n ComponentDescription: hello world from greengrass!\n ComponentPublisher: Amazon\n ComponentType: aws.greengrass.generic\n+ComponentConfiguration:\n+  DefaultConfiguration:\n+    singleLevelKey: default value of singleLevelKey\n+    args:\n+      windowsArg: Hello Windows\n+      linuxArg: Hello Linux\n+\n+ComponentDependencies:\n+  variant.Python3:\n+    VersionRequirement: ^3.5\n+    DependencyType: SOFT\n+\n Manifests:\n   - Platform:\n       os: windows\n       architecture: x86_64\n     Lifecycle:\n       Run:\n-        python3 {{artifacts:path}}/hello_windows_server.py\n+        python3 {{artifacts:path}}/hello_windows_server.py {configuration:/args/windowsArg}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk0NTcyMQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzcyOTkxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoxNjozMVrOHeyQmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTo0MDoyNlrOHe3WWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mjc3OQ==", "bodyText": "Configurations or configurations?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502042779", "createdAt": "2020-10-08T22:16:31Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -40,12 +46,15 @@\n \n import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n import static com.aws.greengrass.lifecyclemanager.Kernel.SERVICE_TYPE_TOPIC_KEY;\n \n public class KernelConfigResolver {\n     private static final Logger LOGGER = LogManager.getLogger(KernelConfigResolver.class);\n     public static final String VERSION_CONFIG_KEY = \"version\";\n     public static final String PARAMETERS_CONFIG_KEY = \"parameters\";\n+    public static final String CONFIGURATIONS_CONFIG_KEY = \"Configurations\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNjE2OQ==", "bodyText": "Good catch. Should be lower case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502126169", "createdAt": "2020-10-09T01:40:26Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -40,12 +46,15 @@\n \n import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICE_DEPENDENCIES_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n import static com.aws.greengrass.lifecyclemanager.Kernel.SERVICE_TYPE_TOPIC_KEY;\n \n public class KernelConfigResolver {\n     private static final Logger LOGGER = LogManager.getLogger(KernelConfigResolver.class);\n     public static final String VERSION_CONFIG_KEY = \"version\";\n     public static final String PARAMETERS_CONFIG_KEY = \"parameters\";\n+    public static final String CONFIGURATIONS_CONFIG_KEY = \"Configurations\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mjc3OQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzczNzQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoxOTo1MFrOHeyVXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTozNzozMFrOHe3TnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mzk5OQ==", "bodyText": "Make this a static variable.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502043999", "createdAt": "2020-10-08T22:19:50Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -55,42 +64,68 @@\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n     private static final Pattern SAME_INTERPOLATION_REGEX =\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n+\n+    // pattern matches {group1:group2}. ex. {configuration:/singleLevelKey}\n+    // Group 1 could only be word or dot (.). It is for the namespace such as \"artifacts\" and \"configuration\".\n+    // Group 2 is the key. For namespace \"configuration\", it needs to support arbitrary JSON pointer.\n+    // so it can take any character but not be ':' or '}', because these breaks the interpolation placeholder format.\n+    private static final Pattern SAME_COMPONENT_INTERPOLATION_REGEX = Pattern.compile(\"\\\\{([.\\\\w]+):([^:}]+)}\");\n+\n+\n+    // pattern matches {group1:group2:group3}.\n+    // ex. {aws.iot.aws.iot.gg.test.integ.ComponentConfigTestService:configuration:/singleLevelKey}\n+    // Group 1 could only be word or dot (.). It is for the component name.\n+    // Group 1 could only be word or dot (.). It is for the namespace such as \"artifacts\" and \"configuration\".\n+    // Group 2 is the key. For namespace \"configuration\", it needs to support arbitrary JSON pointer.\n+    // so it can take any character but not be ':' or '}', because these breaks the interpolation placeholder format.\n+    private static final Pattern CROSS_COMPONENT_INTERPOLATION_REGEX =\n+            Pattern.compile(\"\\\\{([.\\\\w]+):([.\\\\w]+):([^:}]+)}\");\n+\n     static final String PARAM_NAMESPACE = \"params\";\n+    static final String CONFIGURATION_NAMESPACE = \"configuration\";\n     static final String PARAM_VALUE_SUFFIX = \".value\";\n     static final String PATH_KEY = \"path\";\n     static final String DECOMPRESSED_PATH_KEY = \"decompressedPath\";\n \n     private static final String NO_RECIPE_ERROR_FORMAT = \"Failed to find component recipe for {}\";\n \n+    // https://tools.ietf.org/html/rfc6901#section-5\n+    private static final String JSON_POINTER_WHOLE_DOC = \"\";\n+\n     // Map from Namespace -> Key -> Function which returns the replacement value\n     private final Map<String, Map<String, CrashableFunction<ComponentIdentifier, String, PackageLoadingException>>>\n             systemParameters = new HashMap<>();\n \n     private final ComponentStore componentStore;\n     private final Kernel kernel;\n \n+    private final ObjectMapper mapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNTQ2OQ==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502125469", "createdAt": "2020-10-09T01:37:30Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -55,42 +64,68 @@\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n     private static final Pattern SAME_INTERPOLATION_REGEX =\n             Pattern.compile(\"\\\\{\\\\{\" + WORD_GROUP + \":\" + WORD_GROUP + \"}}\");\n+\n+    // pattern matches {group1:group2}. ex. {configuration:/singleLevelKey}\n+    // Group 1 could only be word or dot (.). It is for the namespace such as \"artifacts\" and \"configuration\".\n+    // Group 2 is the key. For namespace \"configuration\", it needs to support arbitrary JSON pointer.\n+    // so it can take any character but not be ':' or '}', because these breaks the interpolation placeholder format.\n+    private static final Pattern SAME_COMPONENT_INTERPOLATION_REGEX = Pattern.compile(\"\\\\{([.\\\\w]+):([^:}]+)}\");\n+\n+\n+    // pattern matches {group1:group2:group3}.\n+    // ex. {aws.iot.aws.iot.gg.test.integ.ComponentConfigTestService:configuration:/singleLevelKey}\n+    // Group 1 could only be word or dot (.). It is for the component name.\n+    // Group 1 could only be word or dot (.). It is for the namespace such as \"artifacts\" and \"configuration\".\n+    // Group 2 is the key. For namespace \"configuration\", it needs to support arbitrary JSON pointer.\n+    // so it can take any character but not be ':' or '}', because these breaks the interpolation placeholder format.\n+    private static final Pattern CROSS_COMPONENT_INTERPOLATION_REGEX =\n+            Pattern.compile(\"\\\\{([.\\\\w]+):([.\\\\w]+):([^:}]+)}\");\n+\n     static final String PARAM_NAMESPACE = \"params\";\n+    static final String CONFIGURATION_NAMESPACE = \"configuration\";\n     static final String PARAM_VALUE_SUFFIX = \".value\";\n     static final String PATH_KEY = \"path\";\n     static final String DECOMPRESSED_PATH_KEY = \"decompressedPath\";\n \n     private static final String NO_RECIPE_ERROR_FORMAT = \"Failed to find component recipe for {}\";\n \n+    // https://tools.ietf.org/html/rfc6901#section-5\n+    private static final String JSON_POINTER_WHOLE_DOC = \"\";\n+\n     // Map from Namespace -> Key -> Function which returns the replacement value\n     private final Map<String, Map<String, CrashableFunction<ComponentIdentifier, String, PackageLoadingException>>>\n             systemParameters = new HashMap<>();\n \n     private final ComponentStore componentStore;\n     private final Kernel kernel;\n \n+    private final ObjectMapper mapper = new ObjectMapper();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0Mzk5OQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mzc0NzAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoyMzozOVrOHeybNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTozNzozNVrOHe3TqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTQ5NQ==", "bodyText": "nit: update the comment", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502045495", "createdAt": "2020-10-08T22:23:39Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -125,30 +178,31 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n      * Processes lifecycle section of each package and add it to the config.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNTQ4MQ==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502125481", "createdAt": "2020-10-09T01:37:35Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -125,30 +178,31 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n      * Processes lifecycle section of each package and add it to the config.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTQ5NQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mzc0Nzc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoyNDowNVrOHeybug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTozODowMlrOHe3UDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTYyNg==", "bodyText": "packagesToDeploy -> componentsToDeploy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502045626", "createdAt": "2020-10-08T22:24:05Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -125,30 +178,31 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n      * Processes lifecycle section of each package and add it to the config.\n      */\n     private Map<String, Object> getServiceConfig(ComponentIdentifier componentIdentifier, DeploymentDocument document,\n-                                                 List<ComponentIdentifier> packagesToDeploy,\n-                                                 Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>>\n-                                                         parameterAndDependencyCache)\n+            List<ComponentIdentifier> packagesToDeploy,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNTU4MA==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502125580", "createdAt": "2020-10-09T01:38:02Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -125,30 +178,31 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n      * Processes lifecycle section of each package and add it to the config.\n      */\n     private Map<String, Object> getServiceConfig(ComponentIdentifier componentIdentifier, DeploymentDocument document,\n-                                                 List<ComponentIdentifier> packagesToDeploy,\n-                                                 Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>>\n-                                                         parameterAndDependencyCache)\n+            List<ComponentIdentifier> packagesToDeploy,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NTYyNg=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mzc1NzAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoyNzo1NVrOHeyhVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTo0MzowMFrOHe3YeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NzA2Mg==", "bodyText": "Pull reset and deepMerge into a separate class. They are independent from kernel config and can be tested more thoroughly using unit tests. This KernelConfigResolver is getting too big.\nAlso I would make the method signature more consistent:\nJsonNode reset(JsonNode original, JsonNode defaultValue, List<String> paths)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502047062", "createdAt": "2020-10-08T22:27:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNjcxMg==", "bodyText": "Yes. I'm hoping to do that after parameter cleanup.\nAbout the signature - I also thought about it but I didn't go with that because it kinda gives an impression the responsibility is to convert a \"JsonNode\". However, the responsibility for this method is to take a Map and return another Map. Hence I kept the Map", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502126712", "createdAt": "2020-10-09T01:43:00Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NzA2Mg=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzgwOTU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjo1MDowNlrOHezBDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTo0MzozOVrOHe3ZDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1NTE4MQ==", "bodyText": "Why allow nullable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502055181", "createdAt": "2020-10-08T22:50:06Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNjg2Mg==", "bodyText": "Not really allow but just to be more robust.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502126862", "createdAt": "2020-10-09T01:43:39Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1NTE4MQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 351}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzgxOTk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjo1NDo0NVrOHezHQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo1MTozM1rOHfRlXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1Njc3MQ==", "bodyText": "You'll end up having a lot of copies if the nesting is deep. I would be fine just mutating the map. Since the user of this method is only us, it's safe as long as the caller knows this is a mutating method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502056771", "createdAt": "2020-10-08T22:54:45Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzQ2Mg==", "bodyText": "Initially I made it that way. But Jason convinced me with 2 points.\n\nPractically, we don't really foresee this map to be have deeply nested.\nThere are many several places mutating this map far away. If one of them accidentally use an immutable map in the future, it will break completely.\n\nHence, I decided to gain more robustness with the sacrifice. I'm open to discuss this a little bit more though", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502127462", "createdAt": "2020-10-09T01:46:16Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1Njc3MQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTUyOQ==", "bodyText": "That's the problem of this class. We're passing the references over all the place.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502129529", "createdAt": "2020-10-09T01:55:21Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1Njc3MQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NTk5OA==", "bodyText": "Oh when I say far away - I mean not in this class. For example, when read out from kernel, it could give out a immutable map", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502555998", "createdAt": "2020-10-09T16:51:33Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1Njc3MQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mzg0NzQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzowMTo0MVrOHezXbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTo0Nzo0NFrOHe3cuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2MDkwOQ==", "bodyText": "Is this supposed to replace the intepolate on line567 or they're separate? Can you rename it a bit differently? such as interpolateNew.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502060909", "createdAt": "2020-10-08T23:01:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzgwMQ==", "bodyText": "Yes. I intentionally kept them the same name coz they are the exact same step for two different paths - and soon when we delete the legacy path, it will be easy.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502127801", "createdAt": "2020-10-09T01:47:44Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -159,29 +213,374 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel) {\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2MDkwOQ=="}, "originalCommit": {"oid": "23ae406261e032cdce920523cdd9fb54c0015276"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mzg5NTYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzoxNDowMFrOHez0MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTo0ODowOFrOHe3dFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2ODI3Mg==", "bodyText": "namespace can be null so reverse the comparison order to avoid NPE.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502068272", "createdAt": "2020-10-08T23:14:00Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -163,29 +217,375 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyNzg5NA==", "bodyText": "Done.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502127894", "createdAt": "2020-10-09T01:48:08Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -163,29 +217,375 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA2ODI3Mg=="}, "originalCommit": {"oid": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6"}, "originalPosition": 405}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzkxODE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzoxOToxNVrOHe0A6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMTo0OToxMFrOHe3d-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3MTUzMA==", "bodyText": "Is this desirable? If the client is expecting the configuration value is a string, but the node the path points to is an object, apparently something is wrong.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502071530", "createdAt": "2020-10-08T23:19:15Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -163,29 +217,375 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(componentIdentifier.getName(), key,\n+                                                             resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String configReplacement = lookupSystemConfig(componentIdentifier, namespace, key);\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError()\n+                        .kv(\"interpolation placeholder\", matcher.group())\n+                        .kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+        }\n+\n+        // Handle cross-component interpolation. ex. {aws.iot.gg.component1:configuration:/singleLevelKey}\n+        matcher = CROSS_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String targetComponent = matcher.group(1);\n+            String namespace = matcher.group(2);\n+            String key = matcher.group(3);\n+\n+            // only interpolate if target component is a direct dependency\n+            if (!dependencies.contains(targetComponent)) {\n+                LOGGER.atError()\n+                        .kv(\"interpolation text\", matcher.group())\n+                        .kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component it's not a direct dependency.\");\n+                continue;\n+            }\n+\n+            if (!resolvedKernelServiceConfig.containsKey(targetComponent)) {\n+                LOGGER.atError()\n+                        .kv(\"interpolation text\", matcher.group())\n+                        .kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component is not in resolved kernel services.\"\n+                                     + \" This indicates the dependency resolution is broken.\");\n+                continue;\n+            }\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(targetComponent, key, resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String version =\n+                        (String) ((Map) resolvedKernelServiceConfig.get(targetComponent)).get(VERSION_CONFIG_KEY);\n+\n+                String configReplacement =\n+                        lookupSystemConfig(new ComponentIdentifier(targetComponent, new Semver(version)), namespace,\n+                                           key);\n+\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError()\n+                        .kv(\"interpolation placeholder\", matcher.group())\n+                        .kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+\n+        }\n+\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Find the configuration value for a component.\n+     *\n+     * @param componentName               component name\n+     * @param path                        path to the value\n+     * @param resolvedKernelServiceConfig resolved kernel service config to search from\n+     * @return configuration value for the path; empty if not found.\n+     */\n+    private Optional<String> lookupConfigurationValueForComponent(String componentName, String path,\n+            Map<String, Object> resolvedKernelServiceConfig) {\n+\n+        Map componentResolvedConfig;\n+\n+        if (resolvedKernelServiceConfig.containsKey(componentName) && ((Map) resolvedKernelServiceConfig.get(\n+                componentName)).containsKey(CONFIGURATIONS_CONFIG_KEY)) {\n+            componentResolvedConfig =\n+                    (Map) ((Map) resolvedKernelServiceConfig.get(componentName)).get(CONFIGURATIONS_CONFIG_KEY);\n+        } else {\n+            return Optional.empty();\n+        }\n+\n+        JsonNode targetNode = mapper.convertValue(componentResolvedConfig, JsonNode.class).at(path);\n+\n+        if (targetNode.isValueNode()) {\n+            return Optional.of(targetNode.asText());\n+        }\n+\n+        if (targetNode.isMissingNode()) {\n+            LOGGER.atError()\n+                    .addKeyValue(\"Path\", path)\n+                    .log(\"Failed to interpolate configuration due to missing value node at given path\");\n+            return Optional.empty();\n+        }\n+\n+        if (targetNode.isContainerNode()) {\n+            // return a serialized string for container node\n+            return Optional.of(targetNode.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6"}, "originalPosition": 523}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyODEyMg==", "bodyText": "Can be discussed. I initially logged error and retain the interpolation placeholder, but then I thought there might be a use case for passing down a JSON string, so I changed it to provide the flexibility.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502128122", "createdAt": "2020-10-09T01:49:10Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -163,29 +217,375 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate = document.getDeploymentPackageConfigurationList()\n+                .stream()\n+                .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                // only allow update config for root\n+                // no need to check version because root's version will be pinned\n+                .filter(DeploymentPackageConfiguration::isRootComponent)\n+                .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation)\n+                .filter(Objects::nonNull)\n+                .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig.put(CONFIGURATIONS_CONFIG_KEY,\n+                                  resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATIONS_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(mapper.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return mapper.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = mapper.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return mapper.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError()\n+                        .kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).replace(jsonPointer.last().getMatchingProperty(),\n+                                                                       targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError()\n+                            .kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return mapper.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws PackageLoadingException when fails to read\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws PackageLoadingException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(componentIdentifier.getName(), key,\n+                                                             resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String configReplacement = lookupSystemConfig(componentIdentifier, namespace, key);\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError()\n+                        .kv(\"interpolation placeholder\", matcher.group())\n+                        .kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+        }\n+\n+        // Handle cross-component interpolation. ex. {aws.iot.gg.component1:configuration:/singleLevelKey}\n+        matcher = CROSS_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String targetComponent = matcher.group(1);\n+            String namespace = matcher.group(2);\n+            String key = matcher.group(3);\n+\n+            // only interpolate if target component is a direct dependency\n+            if (!dependencies.contains(targetComponent)) {\n+                LOGGER.atError()\n+                        .kv(\"interpolation text\", matcher.group())\n+                        .kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component it's not a direct dependency.\");\n+                continue;\n+            }\n+\n+            if (!resolvedKernelServiceConfig.containsKey(targetComponent)) {\n+                LOGGER.atError()\n+                        .kv(\"interpolation text\", matcher.group())\n+                        .kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component is not in resolved kernel services.\"\n+                                     + \" This indicates the dependency resolution is broken.\");\n+                continue;\n+            }\n+\n+            if (namespace.equals(CONFIGURATION_NAMESPACE)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(targetComponent, key, resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String version =\n+                        (String) ((Map) resolvedKernelServiceConfig.get(targetComponent)).get(VERSION_CONFIG_KEY);\n+\n+                String configReplacement =\n+                        lookupSystemConfig(new ComponentIdentifier(targetComponent, new Semver(version)), namespace,\n+                                           key);\n+\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError()\n+                        .kv(\"interpolation placeholder\", matcher.group())\n+                        .kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+\n+        }\n+\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Find the configuration value for a component.\n+     *\n+     * @param componentName               component name\n+     * @param path                        path to the value\n+     * @param resolvedKernelServiceConfig resolved kernel service config to search from\n+     * @return configuration value for the path; empty if not found.\n+     */\n+    private Optional<String> lookupConfigurationValueForComponent(String componentName, String path,\n+            Map<String, Object> resolvedKernelServiceConfig) {\n+\n+        Map componentResolvedConfig;\n+\n+        if (resolvedKernelServiceConfig.containsKey(componentName) && ((Map) resolvedKernelServiceConfig.get(\n+                componentName)).containsKey(CONFIGURATIONS_CONFIG_KEY)) {\n+            componentResolvedConfig =\n+                    (Map) ((Map) resolvedKernelServiceConfig.get(componentName)).get(CONFIGURATIONS_CONFIG_KEY);\n+        } else {\n+            return Optional.empty();\n+        }\n+\n+        JsonNode targetNode = mapper.convertValue(componentResolvedConfig, JsonNode.class).at(path);\n+\n+        if (targetNode.isValueNode()) {\n+            return Optional.of(targetNode.asText());\n+        }\n+\n+        if (targetNode.isMissingNode()) {\n+            LOGGER.atError()\n+                    .addKeyValue(\"Path\", path)\n+                    .log(\"Failed to interpolate configuration due to missing value node at given path\");\n+            return Optional.empty();\n+        }\n+\n+        if (targetNode.isContainerNode()) {\n+            // return a serialized string for container node\n+            return Optional.of(targetNode.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3MTUzMA=="}, "originalCommit": {"oid": "e8037676ac1b2ce0d71bad899758e4250c0bfbc6"}, "originalPosition": 523}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Nzk0Njg5OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMjozMDoxMFrOHfaBwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwMDowNzozN1rOHfbe0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY5NDMzNw==", "bodyText": "Is this temporary?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502694337", "createdAt": "2020-10-09T22:30:10Z", "author": {"login": "ShirleyZheng92"}, "path": "pom.xml", "diffHunk": "@@ -105,7 +105,7 @@\n         <dependency>\n             <groupId>com.aws.iot</groupId>\n             <artifactId>component-common</artifactId>\n-            <version>0.0.0-SNAPSHOT</version>\n+            <version>0.0.0-config-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4b7155df6ea4e3dab0a00b70888971efc343411"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxODE2MA==", "bodyText": "Yes. Will change it back after common has been pushed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502718160", "createdAt": "2020-10-10T00:07:37Z", "author": {"login": "leaf94"}, "path": "pom.xml", "diffHunk": "@@ -105,7 +105,7 @@\n         <dependency>\n             <groupId>com.aws.iot</groupId>\n             <artifactId>component-common</artifactId>\n-            <version>0.0.0-SNAPSHOT</version>\n+            <version>0.0.0-config-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY5NDMzNw=="}, "originalCommit": {"oid": "d4b7155df6ea4e3dab0a00b70888971efc343411"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODAwMTkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMjo1MDoxNlrOHfajkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzo1ODo1NVrOHfbZXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwMjk5Mg==", "bodyText": "Isn't array treated as object?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502702992", "createdAt": "2020-10-09T22:50:16Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNjc2Ng==", "bodyText": "Nah. I also learned from Jackson's node relationship this time. In short: JsonNode -> ContainerNode (ObjectNode  or ArrayNode) / ValueNode (NullNode, NumericNode, ...)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502716766", "createdAt": "2020-10-09T23:58:55Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwMjk5Mg=="}, "originalCommit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODAxMTM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMjo1NToxOVrOHfaopQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzo1NToxNFrOHfbXGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNDI5Mw==", "bodyText": "'parent' or 'target' ? Also why it can't be a container node?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502704293", "createdAt": "2020-10-09T22:55:19Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head()))\n+                            .replace(jsonPointer.last().getMatchingProperty(), targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNjE4NQ==", "bodyText": "parent. if you reset something say /parent/target then /parent must be a container, and it can't be a value like {\"parent\": \"I'm a value node\" }. This case, the reset is invalid and will be ignored.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502716185", "createdAt": "2020-10-09T23:55:14Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head()))\n+                            .replace(jsonPointer.last().getMatchingProperty(), targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNDI5Mw=="}, "originalCommit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODA1MTE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzoyMjoyNlrOHfa_Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzo1Mzo1M1rOHfbWDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMDAzOQ==", "bodyText": "You already interpolate config at L166. Why need to interpolate here before configs are resolved? Will this cause new service use old config from dependencies?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502710039", "createdAt": "2020-10-09T23:22:26Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -104,51 +135,80 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n      * retrieves its recipe, then merges the parameter values into the recipe, and last transform it to a kernel config\n      * key-value pair.\n      *\n-     * @param packagesToDeploy package identifiers for resolved packages that are to be deployed\n-     * @param document         deployment document\n-     * @param rootPackages     root level packages\n+     * @param componentsToDeploy package identifiers for resolved packages of complete dependency graph across groups\n+     * @param document           deployment document\n+     * @param rootPackages       root level packages\n      * @return a kernel config map\n      * @throws PackageLoadingException if any service package was unable to be loaded\n-     * @throws IOException for directory issues\n+     * @throws IOException             for directory issues\n      */\n-    public Map<String, Object> resolve(List<ComponentIdentifier> packagesToDeploy, DeploymentDocument document,\n-                                       List<String> rootPackages) throws PackageLoadingException, IOException {\n+\n+    public Map<String, Object> resolve(List<ComponentIdentifier> componentsToDeploy, DeploymentDocument document,\n+            List<String> rootPackages) throws PackageLoadingException, IOException {\n         Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>> parameterAndDependencyCache =\n                 new ConcurrentHashMap<>();\n         Map<String, Object> servicesConfig = new HashMap<>();\n-        for (ComponentIdentifier packageToDeploy : packagesToDeploy) {\n-            servicesConfig.put(packageToDeploy.getName(),\n-                    getServiceConfig(packageToDeploy, document, packagesToDeploy, parameterAndDependencyCache));\n+\n+        // resolve configuration\n+        for (ComponentIdentifier componentToDeploy : componentsToDeploy) {\n+            servicesConfig.put(componentToDeploy.getName(),\n+                               getServiceConfig(componentToDeploy, document, componentsToDeploy,\n+                                                parameterAndDependencyCache));\n         }\n+\n+        // Interpolate configurations\n+        for (ComponentIdentifier resolvedComponentsToDeploy : componentsToDeploy) {\n+            ComponentRecipe componentRecipe = componentStore.getPackageRecipe(resolvedComponentsToDeploy);\n+\n+            Object existingLifecycle = ((Map) servicesConfig.get(resolvedComponentsToDeploy.getName()))\n+                    .get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+\n+            Object interpolatedLifecycle = interpolate(existingLifecycle, resolvedComponentsToDeploy,\n+                                                       componentRecipe.getDependencies().keySet(), servicesConfig);\n+\n+            ((Map) servicesConfig.get(resolvedComponentsToDeploy.getName()))\n+                    .put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, interpolatedLifecycle);\n+        }\n+\n         servicesConfig.put(kernel.getMain().getName(), getMainConfig(rootPackages));\n \n         // Services need to be under the services namespace in kernel config\n         return Collections.singletonMap(SERVICES_NAMESPACE_TOPIC, servicesConfig);\n     }\n \n-    /*\n-     * Processes lifecycle section of each package and add it to the config.\n+    /**\n+     * Build the kernel config for a service/component by processing deployment document.\n+     *\n+     * @param componentIdentifier         target component id\n+     * @param document                    deployment doc for the current deployment\n+     * @param componentsToDeploy          the entire list of components that would be deployed to the device cross\n+     *                                    groups\n+     * @param parameterAndDependencyCache cache for processing parameter and dependency\n+     * @return a built map representing the kernel config under \"services\" key for a particular component\n+     * @throws PackageLoadingException if any service package was unable to be loaded\n+     * @throws IOException             for directory issues\n      */\n     private Map<String, Object> getServiceConfig(ComponentIdentifier componentIdentifier, DeploymentDocument document,\n-                                                 List<ComponentIdentifier> packagesToDeploy,\n-                                                 Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>>\n-                                                         parameterAndDependencyCache)\n+            List<ComponentIdentifier> componentsToDeploy,\n+            Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>> parameterAndDependencyCache)\n             throws PackageLoadingException, IOException {\n+\n         ComponentRecipe componentRecipe = componentStore.getPackageRecipe(componentIdentifier);\n \n         Set<ComponentParameter> resolvedParams = resolveParameterValuesToUse(document, componentRecipe);\n         parameterAndDependencyCache\n                 .put(componentIdentifier, new Pair<>(resolvedParams, componentRecipe.getDependencies().keySet()));\n \n+\n         Map<String, Object> resolvedServiceConfig = new HashMap<>();\n \n         // Interpolate parameters\n-        resolvedServiceConfig.put(GreengrassService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                interpolate(componentRecipe.getLifecycle(), componentIdentifier, packagesToDeploy, document,\n-                        parameterAndDependencyCache));\n+        resolvedServiceConfig.put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                                  interpolate(componentRecipe.getLifecycle(), componentIdentifier, componentsToDeploy,\n+                                              document, parameterAndDependencyCache));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNTkxOQ==", "bodyText": "That's the old one. Will it as deprecated", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502715919", "createdAt": "2020-10-09T23:53:53Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -104,51 +135,80 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n      * retrieves its recipe, then merges the parameter values into the recipe, and last transform it to a kernel config\n      * key-value pair.\n      *\n-     * @param packagesToDeploy package identifiers for resolved packages that are to be deployed\n-     * @param document         deployment document\n-     * @param rootPackages     root level packages\n+     * @param componentsToDeploy package identifiers for resolved packages of complete dependency graph across groups\n+     * @param document           deployment document\n+     * @param rootPackages       root level packages\n      * @return a kernel config map\n      * @throws PackageLoadingException if any service package was unable to be loaded\n-     * @throws IOException for directory issues\n+     * @throws IOException             for directory issues\n      */\n-    public Map<String, Object> resolve(List<ComponentIdentifier> packagesToDeploy, DeploymentDocument document,\n-                                       List<String> rootPackages) throws PackageLoadingException, IOException {\n+\n+    public Map<String, Object> resolve(List<ComponentIdentifier> componentsToDeploy, DeploymentDocument document,\n+            List<String> rootPackages) throws PackageLoadingException, IOException {\n         Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>> parameterAndDependencyCache =\n                 new ConcurrentHashMap<>();\n         Map<String, Object> servicesConfig = new HashMap<>();\n-        for (ComponentIdentifier packageToDeploy : packagesToDeploy) {\n-            servicesConfig.put(packageToDeploy.getName(),\n-                    getServiceConfig(packageToDeploy, document, packagesToDeploy, parameterAndDependencyCache));\n+\n+        // resolve configuration\n+        for (ComponentIdentifier componentToDeploy : componentsToDeploy) {\n+            servicesConfig.put(componentToDeploy.getName(),\n+                               getServiceConfig(componentToDeploy, document, componentsToDeploy,\n+                                                parameterAndDependencyCache));\n         }\n+\n+        // Interpolate configurations\n+        for (ComponentIdentifier resolvedComponentsToDeploy : componentsToDeploy) {\n+            ComponentRecipe componentRecipe = componentStore.getPackageRecipe(resolvedComponentsToDeploy);\n+\n+            Object existingLifecycle = ((Map) servicesConfig.get(resolvedComponentsToDeploy.getName()))\n+                    .get(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n+\n+            Object interpolatedLifecycle = interpolate(existingLifecycle, resolvedComponentsToDeploy,\n+                                                       componentRecipe.getDependencies().keySet(), servicesConfig);\n+\n+            ((Map) servicesConfig.get(resolvedComponentsToDeploy.getName()))\n+                    .put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, interpolatedLifecycle);\n+        }\n+\n         servicesConfig.put(kernel.getMain().getName(), getMainConfig(rootPackages));\n \n         // Services need to be under the services namespace in kernel config\n         return Collections.singletonMap(SERVICES_NAMESPACE_TOPIC, servicesConfig);\n     }\n \n-    /*\n-     * Processes lifecycle section of each package and add it to the config.\n+    /**\n+     * Build the kernel config for a service/component by processing deployment document.\n+     *\n+     * @param componentIdentifier         target component id\n+     * @param document                    deployment doc for the current deployment\n+     * @param componentsToDeploy          the entire list of components that would be deployed to the device cross\n+     *                                    groups\n+     * @param parameterAndDependencyCache cache for processing parameter and dependency\n+     * @return a built map representing the kernel config under \"services\" key for a particular component\n+     * @throws PackageLoadingException if any service package was unable to be loaded\n+     * @throws IOException             for directory issues\n      */\n     private Map<String, Object> getServiceConfig(ComponentIdentifier componentIdentifier, DeploymentDocument document,\n-                                                 List<ComponentIdentifier> packagesToDeploy,\n-                                                 Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>>\n-                                                         parameterAndDependencyCache)\n+            List<ComponentIdentifier> componentsToDeploy,\n+            Map<ComponentIdentifier, Pair<Set<ComponentParameter>, Set<String>>> parameterAndDependencyCache)\n             throws PackageLoadingException, IOException {\n+\n         ComponentRecipe componentRecipe = componentStore.getPackageRecipe(componentIdentifier);\n \n         Set<ComponentParameter> resolvedParams = resolveParameterValuesToUse(document, componentRecipe);\n         parameterAndDependencyCache\n                 .put(componentIdentifier, new Pair<>(resolvedParams, componentRecipe.getDependencies().keySet()));\n \n+\n         Map<String, Object> resolvedServiceConfig = new HashMap<>();\n \n         // Interpolate parameters\n-        resolvedServiceConfig.put(GreengrassService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                interpolate(componentRecipe.getLifecycle(), componentIdentifier, packagesToDeploy, document,\n-                        parameterAndDependencyCache));\n+        resolvedServiceConfig.put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n+                                  interpolate(componentRecipe.getLifecycle(), componentIdentifier, componentsToDeploy,\n+                                              document, parameterAndDependencyCache));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMDAzOQ=="}, "originalCommit": {"oid": "e9bcde9fc75f7404957220c0d37d3a002330259c"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODA3MDg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzozNjoyN1rOHfbKIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwMDowNzo0MlrOHfbe1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjg2Ng==", "bodyText": "add @deprecated", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502712866", "createdAt": "2020-10-09T23:36:27Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head()))\n+                            .replace(jsonPointer.last().getMatchingProperty(), targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return MAPPER.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws IOException for directory issues\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws IOException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws IOException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (CONFIGURATION_NAMESPACE.equals(namespace)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(componentIdentifier.getName(), key,\n+                                                             resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String configReplacement = lookupSystemConfig(componentIdentifier, namespace, key);\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError().kv(\"interpolation placeholder\", matcher.group()).kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+        }\n+\n+        // Handle cross-component interpolation. ex. {aws.iot.gg.component1:configuration:/singleLevelKey}\n+        matcher = CROSS_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String targetComponent = matcher.group(1);\n+            String namespace = matcher.group(2);\n+            String key = matcher.group(3);\n+\n+            // only interpolate if target component is a direct dependency\n+            if (!dependencies.contains(targetComponent)) {\n+                LOGGER.atError().kv(\"interpolation text\", matcher.group()).kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component it's not a direct dependency.\");\n+                continue;\n+            }\n+\n+            if (!resolvedKernelServiceConfig.containsKey(targetComponent)) {\n+                LOGGER.atError().kv(\"interpolation text\", matcher.group()).kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component is not in resolved kernel services.\"\n+                                     + \" This indicates the dependency resolution is broken.\");\n+                continue;\n+            }\n+\n+            if (CONFIGURATION_NAMESPACE.equals(namespace)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(targetComponent, key, resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String version =\n+                        (String) ((Map) resolvedKernelServiceConfig.get(targetComponent)).get(VERSION_CONFIG_KEY);\n+\n+                String configReplacement =\n+                        lookupSystemConfig(new ComponentIdentifier(targetComponent, new Semver(version)), namespace,\n+                                           key);\n+\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError().kv(\"interpolation placeholder\", matcher.group()).kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+\n+        }\n+\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Find the configuration value for a component.\n+     *\n+     * @param componentName               component name\n+     * @param path                        path to the value\n+     * @param resolvedKernelServiceConfig resolved kernel service config to search from\n+     * @return configuration value for the path; empty if not found.\n+     */\n+    private Optional<String> lookupConfigurationValueForComponent(String componentName, String path,\n+            Map<String, Object> resolvedKernelServiceConfig) {\n+\n+        Map componentResolvedConfig;\n+\n+        if (resolvedKernelServiceConfig.containsKey(componentName) && ((Map) resolvedKernelServiceConfig\n+                .get(componentName)).containsKey(CONFIGURATION_CONFIG_KEY)) {\n+            componentResolvedConfig =\n+                    (Map) ((Map) resolvedKernelServiceConfig.get(componentName)).get(CONFIGURATION_CONFIG_KEY);\n+        } else {\n+            return Optional.empty();\n+        }\n+\n+        JsonNode targetNode = MAPPER.convertValue(componentResolvedConfig, JsonNode.class).at(path);\n+\n+        if (targetNode.isValueNode()) {\n+            return Optional.of(targetNode.asText());\n+        }\n+\n+        if (targetNode.isMissingNode()) {\n+            LOGGER.atError().addKeyValue(\"Path\", path)\n+                    .log(\"Failed to interpolate configuration due to missing value node at given path\");\n+            return Optional.empty();\n+        }\n+\n+        if (targetNode.isContainerNode()) {\n+            // return a serialized string for container node\n+            return Optional.of(targetNode.toString());\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Nullable\n+    private String lookupSystemConfig(ComponentIdentifier component, String namespace, String key) throws IOException {\n+        // Handle system-wide configuration\n+        Map<String, CrashableFunction<ComponentIdentifier, String, IOException>> systemParams =\n+                systemParameters.getOrDefault(namespace, Collections.emptyMap());\n+        if (systemParams.containsKey(key)) {\n+            return systemParams.get(key).apply(component);\n+        }\n+        return null;\n+    }\n+\n+    /***************** end of new configuration code path. *******************/\n+\n     /*\n      * For each lifecycle key-value pair of a package, substitute parameter values.\n      */\n+    @SuppressWarnings(\"checkstyle:OverloadMethodsDeclarationOrder\")\n     private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea5e3390db3eb816a0e41cc26cc040b23e29d05b"}, "originalPosition": 581}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxODE2Nw==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/503#discussion_r502718167", "createdAt": "2020-10-10T00:07:42Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -157,37 +217,369 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n         resolvedServiceConfig.put(SERVICE_DEPENDENCIES_NAMESPACE_TOPIC, dependencyConfig);\n \n         // State information for deployments\n-        handleComponentVersionConfigs(\n-                componentIdentifier, componentRecipe.getVersion().getValue(), resolvedServiceConfig);\n+        handleComponentVersionConfigs(componentIdentifier, componentRecipe.getVersion().getValue(),\n+                                      resolvedServiceConfig);\n         Map<String, String> map = new HashMap<>();\n         for (ComponentParameter resolvedParam : resolvedParams) {\n             map.put(resolvedParam.getName(), resolvedParam.getValue());\n         }\n         resolvedServiceConfig.put(PARAMETERS_CONFIG_KEY, map);\n \n+        // Resolve config\n+        Optional<ConfigurationUpdateOperation> optionalConfigUpdate =\n+                document.getDeploymentPackageConfigurationList().stream()\n+                        .filter(e -> e.getPackageName().equals(componentRecipe.getComponentName()))\n+\n+                        // only allow update config for root\n+                        // no need to check version because root's version will be pinned\n+                        .filter(DeploymentPackageConfiguration::isRootComponent)\n+                        .map(DeploymentPackageConfiguration::getConfigurationUpdateOperation).filter(Objects::nonNull)\n+                        .findAny();\n+\n+        Map<String, Object> resolvedConfiguration =\n+                resolveConfigurationToApply(optionalConfigUpdate.orElse(null), componentRecipe);\n+\n+        resolvedServiceConfig\n+                .put(CONFIGURATION_CONFIG_KEY, resolvedConfiguration == null ? new HashMap<>() : resolvedConfiguration);\n+\n         return resolvedServiceConfig;\n     }\n \n+    /**\n+     * Resolve configurations to apply for a component. It resolves based on current running config, default config, and\n+     * config update operation.\n+     *\n+     * @param configurationUpdateOperation nullable component configuration update operation.\n+     * @param componentRecipe              component recipe containing default configuration.\n+     * @return resolved configuration for this component. non null.\n+     */\n+    private Map<String, Object> resolveConfigurationToApply(\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+\n+        // try read the running service config\n+        Map<String, Object> currentRunningConfig = null;\n+\n+        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+        if (serviceTopics != null) {\n+            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+            if (configuration != null) {\n+                currentRunningConfig = configuration.toPOJO();\n+            }\n+        }\n+\n+        // get default config\n+        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                .map(ComponentConfiguration::getDefaultConfiguration)\n+                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+\n+        // no update\n+        if (configurationUpdateOperation == null) {\n+            if (currentRunningConfig == null) {\n+                // no update nor running config, so it should return return the default config.\n+                return MAPPER.convertValue(defaultConfig, Map.class);\n+            } else {\n+                // no update but there is running config, so it should return running config as is.\n+                return currentRunningConfig;\n+            }\n+        }\n+\n+        // perform RESET and then MERGE in order\n+        Map<String, Object> resolvedConfig;\n+\n+        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n+\n+        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+\n+        return resolvedConfig;\n+    }\n+\n+    private Map<String, Object> reset(Map<String, Object> original, JsonNode defaultValue, List<String> pathsToReset) {\n+        if (pathsToReset == null || pathsToReset.isEmpty()) {\n+            return original;\n+        }\n+\n+        // convert to JsonNode for path navigation\n+        JsonNode node = MAPPER.convertValue(original, JsonNode.class);\n+\n+        for (String pointer : pathsToReset) {\n+            // special case handling for reset whole document\n+            if (pointer.equals(JSON_POINTER_WHOLE_DOC)) {\n+                // reset to entire default value node and return because there is no need to process further\n+                return MAPPER.convertValue(defaultValue, Map.class);\n+            }\n+\n+            // regular pointer handling\n+            JsonPointer jsonPointer = JsonPointer.compile(pointer);\n+\n+            if (node.at(jsonPointer.head()).isArray()) {\n+                // no support for resetting an element of array\n+                LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                        .log(\"Failed to reset because provided pointer for reset points to an element of array.\");\n+                continue;\n+            }\n+\n+            JsonNode targetDefaultNode = defaultValue.at(jsonPointer);\n+\n+            if (targetDefaultNode.isMissingNode()) {\n+                // missing default value -> remove the entry completely\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head())).remove(jsonPointer.last().getMatchingProperty());\n+                } else {\n+                    // parent is missing node, or value node. Do nothing.\n+                    LOGGER.atDebug().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Parent is missing node or value node. Noop for reset.\");\n+                }\n+            } else {\n+                // target is container node, or a value node, including null node.\n+                // replace the entry\n+                if (node.at(jsonPointer.head()).isObject()) {\n+                    ((ObjectNode) node.at(jsonPointer.head()))\n+                            .replace(jsonPointer.last().getMatchingProperty(), targetDefaultNode);\n+                } else {\n+                    // parent is not a container node. should not happen.\n+                    LOGGER.atError().kv(\"pointer provided\", jsonPointer)\n+                            .log(\"Failed to reset because provided pointer points to a parent who is not a container \"\n+                                         + \"node. Please reset the component configurations entirely\");\n+                }\n+            }\n+        }\n+\n+        return MAPPER.convertValue(node, Map.class);\n+    }\n+\n+    private static Map<String, Object> deepMerge(@Nullable Map<String, Object> original,\n+            @Nullable Map<String, Object> newMap) {\n+\n+        if (original == null) {\n+            if (newMap == null) {\n+                return null;    // both are null. return null.\n+            } else {\n+                // original is null but newMap is not, return new map\n+                return new HashMap<>(newMap); // deep copy for being more robust to handle immutable map\n+            }\n+        }\n+\n+        Map<String, Object> mergedMap = new HashMap<>(original);  // deep copy for robustness against immutable map\n+\n+        if (newMap == null || newMap.isEmpty()) {\n+            // original is not null but new map is null or empty, return original\n+            return mergedMap;\n+        }\n+\n+        // start merging process\n+        for (Map.Entry<String, Object> newMapEntry : newMap.entrySet()) {\n+            String key = newMapEntry.getKey();\n+            Object newChild = newMapEntry.getValue();\n+            Object originalChild = original.get(key);\n+\n+            if (newChild instanceof Map && original.get(key) instanceof Map) {\n+                // if both are container node, recursively deep merge for children\n+                // note either originalChild nor newChild could be null here as they are instance of Map\n+                mergedMap.put(key, deepMerge((Map<String, Object>) originalChild, (Map<String, Object>) newChild));\n+            } else {\n+                // This branch supports container node -> value node and vice versa as it just overrides the value.\n+                // This branch also handles the list with entire replacement.\n+                // Note: we don't support list operations such as appending to an list or inserting to a index of a lit.\n+                // This branch also handles setting explict null value.\n+                mergedMap.put(key, newChild);\n+            }\n+        }\n+        return mergedMap;\n+    }\n+\n+    /**\n+     * Interpolate the lifecycle commands with resolved component configuration values and system configuration values.\n+     *\n+     * @param configValue                 original value; could be Map or String\n+     * @param componentIdentifier         target component id\n+     * @param dependencies                name set of component's dependencies\n+     * @param resolvedKernelServiceConfig resolved kernel configuration under \"Service\" key\n+     * @return the interpolated lifecycle object\n+     * @throws IOException for directory issues\n+     */\n+    private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws IOException {\n+        Object result = configValue;\n+\n+        if (configValue instanceof String) {\n+            result = replace((String) configValue, componentIdentifier, dependencies, resolvedKernelServiceConfig);\n+        }\n+        if (configValue instanceof Map) {\n+            Map<String, Object> childConfigMap = (Map<String, Object>) configValue;\n+            Map<String, Object> resolvedChildConfig = new HashMap<>();\n+            for (Entry<String, Object> childLifecycle : childConfigMap.entrySet()) {\n+                resolvedChildConfig.put(childLifecycle.getKey(),\n+                                        interpolate(childLifecycle.getValue(), componentIdentifier, dependencies,\n+                                                    resolvedKernelServiceConfig));\n+            }\n+            result = resolvedChildConfig;\n+        }\n+\n+        // No list handling because lists are outlawed under \"Lifecycle\" key\n+        return result;\n+    }\n+\n+    private String replace(String stringValue, ComponentIdentifier componentIdentifier, Set<String> dependencies,\n+            Map<String, Object> resolvedKernelServiceConfig) throws IOException {\n+\n+        Matcher matcher;\n+\n+        // Handle same-component interpolation. ex. {configuration:/singleLevelKey}\n+        matcher = SAME_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String namespace = matcher.group(1);\n+            String key = matcher.group(2);\n+\n+            if (CONFIGURATION_NAMESPACE.equals(namespace)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(componentIdentifier.getName(), key,\n+                                                             resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String configReplacement = lookupSystemConfig(componentIdentifier, namespace, key);\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError().kv(\"interpolation placeholder\", matcher.group()).kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+        }\n+\n+        // Handle cross-component interpolation. ex. {aws.iot.gg.component1:configuration:/singleLevelKey}\n+        matcher = CROSS_COMPONENT_INTERPOLATION_REGEX.matcher(stringValue);\n+\n+        while (matcher.find()) {\n+            String targetComponent = matcher.group(1);\n+            String namespace = matcher.group(2);\n+            String key = matcher.group(3);\n+\n+            // only interpolate if target component is a direct dependency\n+            if (!dependencies.contains(targetComponent)) {\n+                LOGGER.atError().kv(\"interpolation text\", matcher.group()).kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component it's not a direct dependency.\");\n+                continue;\n+            }\n+\n+            if (!resolvedKernelServiceConfig.containsKey(targetComponent)) {\n+                LOGGER.atError().kv(\"interpolation text\", matcher.group()).kv(\"target component\", targetComponent)\n+                        .kv(\"main component\", componentIdentifier.getName())\n+                        .log(\"Failed to interpolate because the target component is not in resolved kernel services.\"\n+                                     + \" This indicates the dependency resolution is broken.\");\n+                continue;\n+            }\n+\n+            if (CONFIGURATION_NAMESPACE.equals(namespace)) {\n+                Optional<String> configReplacement =\n+                        lookupConfigurationValueForComponent(targetComponent, key, resolvedKernelServiceConfig);\n+                if (configReplacement.isPresent()) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement.get());\n+                }\n+\n+            } else if (systemParameters.containsKey(namespace)) {\n+                String version =\n+                        (String) ((Map) resolvedKernelServiceConfig.get(targetComponent)).get(VERSION_CONFIG_KEY);\n+\n+                String configReplacement =\n+                        lookupSystemConfig(new ComponentIdentifier(targetComponent, new Semver(version)), namespace,\n+                                           key);\n+\n+                if (configReplacement != null) {\n+                    stringValue = stringValue.replace(matcher.group(), configReplacement);\n+                }\n+            } else {\n+                // unrecognized namespace\n+                LOGGER.atError().kv(\"interpolation placeholder\", matcher.group()).kv(\"namespace\", namespace)\n+                        .log(\"Failed to interpolate because of unrecognized namespace for interpolation.\");\n+            }\n+\n+        }\n+\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Find the configuration value for a component.\n+     *\n+     * @param componentName               component name\n+     * @param path                        path to the value\n+     * @param resolvedKernelServiceConfig resolved kernel service config to search from\n+     * @return configuration value for the path; empty if not found.\n+     */\n+    private Optional<String> lookupConfigurationValueForComponent(String componentName, String path,\n+            Map<String, Object> resolvedKernelServiceConfig) {\n+\n+        Map componentResolvedConfig;\n+\n+        if (resolvedKernelServiceConfig.containsKey(componentName) && ((Map) resolvedKernelServiceConfig\n+                .get(componentName)).containsKey(CONFIGURATION_CONFIG_KEY)) {\n+            componentResolvedConfig =\n+                    (Map) ((Map) resolvedKernelServiceConfig.get(componentName)).get(CONFIGURATION_CONFIG_KEY);\n+        } else {\n+            return Optional.empty();\n+        }\n+\n+        JsonNode targetNode = MAPPER.convertValue(componentResolvedConfig, JsonNode.class).at(path);\n+\n+        if (targetNode.isValueNode()) {\n+            return Optional.of(targetNode.asText());\n+        }\n+\n+        if (targetNode.isMissingNode()) {\n+            LOGGER.atError().addKeyValue(\"Path\", path)\n+                    .log(\"Failed to interpolate configuration due to missing value node at given path\");\n+            return Optional.empty();\n+        }\n+\n+        if (targetNode.isContainerNode()) {\n+            // return a serialized string for container node\n+            return Optional.of(targetNode.toString());\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Nullable\n+    private String lookupSystemConfig(ComponentIdentifier component, String namespace, String key) throws IOException {\n+        // Handle system-wide configuration\n+        Map<String, CrashableFunction<ComponentIdentifier, String, IOException>> systemParams =\n+                systemParameters.getOrDefault(namespace, Collections.emptyMap());\n+        if (systemParams.containsKey(key)) {\n+            return systemParams.get(key).apply(component);\n+        }\n+        return null;\n+    }\n+\n+    /***************** end of new configuration code path. *******************/\n+\n     /*\n      * For each lifecycle key-value pair of a package, substitute parameter values.\n      */\n+    @SuppressWarnings(\"checkstyle:OverloadMethodsDeclarationOrder\")\n     private Object interpolate(Object configValue, ComponentIdentifier componentIdentifier,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjg2Ng=="}, "originalCommit": {"oid": "ea5e3390db3eb816a0e41cc26cc040b23e29d05b"}, "originalPosition": 581}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 611, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}