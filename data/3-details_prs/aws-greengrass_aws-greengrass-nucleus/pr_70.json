{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NTE1NDIy", "number": 70, "title": "Deployments - Update Kernel config with changes from deployment", "bodyText": "Issue #, if available:\nDescription of changes:\nChanges for kernel config update for deployments\nBuilt on the deployment orchestrator layout that executes a deployment as a state machine and checks for relevant schedules / prereqs for each step. The original layout was written to package-manager-poc branch. Not all changes from that branch are included in this PR, they will be pulled in as parallel tasks for DA and package manager are done.\nAssumptions were made for package manager interface\nFurther changes to be made to this pull request\n\nUnit tests\nConsume updates after changes to kernel for handling merge config are merged\nConsume updates after currently open package manager pull requests are merged\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-02-21T23:32:27Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70", "merged": true, "mergeCommit": {"oid": "ef63128121e8d6187fe9b76a115fed723e4f3f4f"}, "closed": true, "closedAt": "2020-02-26T23:40:44Z", "author": {"login": "shaguptashaikh"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGosSKAFqTM2Mjk3ODQyNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIPXyVAFqTM2NTMyMDQ2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyOTc4NDI3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-362978427", "createdAt": "2020-02-21T23:40:27Z", "commit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMzo0MDoyN1rOFtHo1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMzo1MTo1NVrOFtHybQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTM4Mw==", "bodyText": "Looks like this shouldn't be a builder, but just a constructor.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382855383", "createdAt": "2020-02-21T23:40:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/state/DownloadedState.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.aws.iot.evergreen.deployment.state;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.DeploymentProcess;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.Map;\n+import java.util.function.BiPredicate;\n+\n+@AllArgsConstructor\n+public class DownloadedState implements State {\n+\n+    private final DeploymentProcess deploymentProcess;\n+\n+    private final Kernel kernel;\n+\n+    private final PackageManager packageManager;\n+\n+    Log log;\n+\n+    @Override\n+    public boolean canProceed() {\n+        log.log(Log.Level.Note, \"<Downloaded>: checking if deployment can proceed\");\n+        // check update kernel conditions\n+        DeploymentPacket packet = deploymentProcess.getDeploymentPacket();\n+        BiPredicate<Kernel, Map<String, Map<String, Parameter>>> updateCondition = packet.getUpdateCondition();\n+        if (updateCondition != null) {\n+            return updateCondition.test(kernel, packet.getTargetPackageConfigs());\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void proceed() {\n+        log.log(Log.Level.Note, \"<Downloaded>: proceed\");\n+        // resolve kernel config\n+        try {\n+            deploymentProcess.setResolvedKernelConfig(resolveKernelConfig());\n+            deploymentProcess.setCurrentState(deploymentProcess.getUpdatingKernelState());\n+        } catch (Exception e) {\n+            // TODO : Mark the deployment failed\n+            log.error(\"Error moving out of downlaoded state\");\n+        }\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        // TODO : Set state to Canceled, cleanup, revert package cache updates, etc\n+    }\n+\n+    private Map<Object, Object> resolveKernelConfig() throws Exception {\n+        Map<String, Map<String, Parameter>> targetPackageConfigs =\n+                deploymentProcess.getDeploymentPacket().getTargetPackageConfigs();\n+        ConfigResolver configResolver =\n+                ConfigResolver.builder().kernel(kernel).targetPackageConfigs(targetPackageConfigs)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTcyNQ==", "bodyText": "Probably this should be done at the last possible moment so that the \"updatedMainConfig\" is as close to accurate as it can be.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382855725", "createdAt": "2020-02-21T23:41:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTkxMQ==", "bodyText": "Are we expecting Throwable? Can this be narrowed down at all?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382855911", "createdAt": "2020-02-21T23:42:47Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjA0Mg==", "bodyText": "just call get which will return null anyway if the key isn't in the map.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382856042", "createdAt": "2020-02-21T23:43:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjE4Nw==", "bodyText": "[nit]\nUse method reference instead of lambda.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382856187", "createdAt": "2020-02-21T23:44:08Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjQzNA==", "bodyText": "Instead of checking if it isn't a Map, why not check that it is a String since you cast it on the next line?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382856434", "createdAt": "2020-02-21T23:45:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (!(lifecycle.get(lifecycleKey) instanceof Map)) {\n+            String value = (String) lifecycle.get(lifecycleKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NjgxNw==", "bodyText": "Only call put once you're done with the for loop and all replacements are done. I don't see any reason why it needs to be updated on each loop.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382856817", "createdAt": "2020-02-21T23:47:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (!(lifecycle.get(lifecycleKey) instanceof Map)) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value.replaceAll(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+                lifecycle.put(lifecycleKey, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzUyNQ==", "bodyText": "Odd to have lifecycle as an output variable. Can you just make this method create and return the map?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382857525", "createdAt": "2020-02-21T23:50:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (!(lifecycle.get(lifecycleKey) instanceof Map)) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value.replaceAll(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+                lifecycle.put(lifecycleKey, value);\n+            }\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Map.Entry<Object, Object> lifecycleEntry : childLifecycleMap.entrySet()) {\n+                interpolate(lifecycleEntry.getKey(), childLifecycleMap, parametersFromDeployment, packageParameters);\n+            }\n+        }\n+    }\n+\n+    private Map<Object, Object> getUpdatedMainConfig(Map<String, Package> targetPackages) {\n+        Set<String> kernelDependencies =\n+                kernel.orderedDependencies().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(removedTopLevelPackages);\n+        kernelDependencies\n+                .addAll(targetPackages.values().stream().map(p -> p.getServiceName()).collect(Collectors.toSet()));\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        addServiceDependencies(mainLifecycleMap, kernelDependencies);\n+\n+        return mainLifecycleMap;\n+    }\n+\n+    void addServiceDependencies(Map<Object, Object> lifecycle, final Set<String> dependencies) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzgzNw==", "bodyText": "The kernelDependencies you have here is a list of all services in the kernel, so I don't think that it is doing what you want it to. I believe you're trying to find the dependencies of main, right? If so, you can do kernel.getMain().dependencies.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r382857837", "createdAt": "2020-02-21T23:51:55Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment =\n+                targetPackageConfigs.containsKey(packageName) ? targetPackageConfigs.get(packageName) : null;\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (!(lifecycle.get(lifecycleKey) instanceof Map)) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value.replaceAll(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+                lifecycle.put(lifecycleKey, value);\n+            }\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Map.Entry<Object, Object> lifecycleEntry : childLifecycleMap.entrySet()) {\n+                interpolate(lifecycleEntry.getKey(), childLifecycleMap, parametersFromDeployment, packageParameters);\n+            }\n+        }\n+    }\n+\n+    private Map<Object, Object> getUpdatedMainConfig(Map<String, Package> targetPackages) {\n+        Set<String> kernelDependencies =\n+                kernel.orderedDependencies().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(removedTopLevelPackages);\n+        kernelDependencies\n+                .addAll(targetPackages.values().stream().map(p -> p.getServiceName()).collect(Collectors.toSet()));\n+\n+        Map<Object, Object> mainLifecycleMap = new HashMap<>();\n+        addServiceDependencies(mainLifecycleMap, kernelDependencies);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzAwNzQw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-363700740", "createdAt": "2020-02-24T21:07:15Z", "commit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMTowNzoxNVrOFtv3Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMTowNzoxNVrOFtv3Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUxNDQyMg==", "bodyText": "Return the interface, not the implementation. This should just return a  Map<EvergreenService, State>.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383514422", "createdAt": "2020-02-24T21:07:15Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -748,6 +748,10 @@ protected void addDependencies(HashSet<EvergreenService> deps) {\n         }\n     }\n \n+    public ConcurrentHashMap<EvergreenService, State> getDependencies() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzAxNjEy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-363701612", "createdAt": "2020-02-24T21:08:43Z", "commit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNzM5Mzk0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-363739394", "createdAt": "2020-02-24T22:13:19Z", "commit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjoxNzo0NFrOFtx6RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjoyNzowOFrOFtyKvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0Nzk3Mg==", "bodyText": "I think these should be parameters to the resolveConfig method. Also, do you plan to modify these as per the interface defined in #71", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383547972", "createdAt": "2020-02-24T22:17:44Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODU3Mg==", "bodyText": "It is not clear yet, how are we modeling the conditions so I would remove any code that uses these right now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383548572", "createdAt": "2020-02-24T22:19:07Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPacket.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.function.BiPredicate;\n+\n+@Getter\n+@Builder\n+public class DeploymentPacket {\n+\n+    private Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private BiPredicate<Kernel, Map<String, Map<String, Parameter>>> downloadCondition;\n+\n+    private BiPredicate<Kernel, Map<String, Map<String, Parameter>>> updateCondition;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODgyOA==", "bodyText": "The prototype for this should match with the interfaces defined in #71", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383548828", "createdAt": "2020-02-24T22:19:39Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPacket.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.function.BiPredicate;\n+\n+@Getter\n+@Builder\n+public class DeploymentPacket {\n+\n+    private Map<String, Map<String, Parameter>> targetPackageConfigs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MjE5MQ==", "bodyText": "Why is this not in proceed() method? CanProceed() here should just verify if the kernel can be updated at this time. If there is not such check then this should just return true for now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383552191", "createdAt": "2020-02-24T22:27:08Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/state/UpdatingKernelState.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.aws.iot.evergreen.deployment.state;\n+\n+import com.aws.iot.evergreen.deployment.DeploymentProcess;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+@RequiredArgsConstructor\n+public class UpdatingKernelState implements State {\n+\n+    private final DeploymentProcess deploymentProcess;\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private boolean updateFinished = false;\n+\n+    private static final String ROLLBACK_SNAPSHOT_PATH_FORMAT = \"rollback_snapshot_%s.tlog\";\n+\n+    @Override\n+    public boolean canProceed() {\n+        log.log(Log.Level.Note, \"<Updating>: updating kernel\");\n+\n+        // TODO : After taking this snapshot, deployment can wait for some time before performing a safe update\n+        // so consider moving this to Kernel\n+        String rollbackSnapshotPath =\n+                String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentProcess.getDeploymentPacket().getDeploymentId());\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(kernel.configPath.resolve(rollbackSnapshotPath));\n+        } catch (IOException e) {\n+            log.error(\"Error taking kernel snapshot\");\n+        }\n+\n+        // merge config\n+        Map<Object, Object> resolvedConfig = deploymentProcess.getResolvedKernelConfig();\n+        try {\n+            // TODO : Uncomment once following change to Kernel is merged\n+            // kernel.mergeInNewConfig(deploymentProcess.getDeploymentPacket().getDeploymentId(),\n+            // deploymentProcess.getDeploymentPacket().getDeploymentCreationTimestamp(),\n+            // resolvedConfig);\n+        } catch (Exception e) {\n+            log.error(\"Deployment failed, rolling back\");\n+            // TODO : Rollback handling should be more sophisticated, should it be its own state? Should it have retries?\n+            // Should revert changes to the local fleets-packages map/package registry as needed\n+            // All rolled back services should be restarted\n+\n+            // rollback to snapshot without waiting for a safe time\n+            try {\n+                kernel.read(kernel.configPath.resolve(rollbackSnapshotPath));\n+                // TODO : Set deployment status to RolledBack?\n+                log.log(Log.Level.Note, \"Deployment rolled back\");\n+            } catch (IOException re) {\n+                // TODO : Set deployment status to Failed_RolledBack?\n+                log.error(\"Failed to rollback deployment\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODM0MjU5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-363834259", "createdAt": "2020-02-25T02:30:17Z", "commit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMjozMDoxN1rOFt2urA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMjo0NjoyMFrOFt29kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNjkyNA==", "bodyText": "You can use @Value annotation", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383626924", "createdAt": "2020-02-25T02:30:17Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/Parameter.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+\n+@Getter\n+@AllArgsConstructor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNzIyNw==", "bodyText": "Why do you need to use Map<String, Parameter>? What's the key of this map?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383627227", "createdAt": "2020-02-25T02:31:29Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyOTYyNw==", "bodyText": "Agree with Amit. I would remove any code that is not used right now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383629627", "createdAt": "2020-02-25T02:41:34Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPacket.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+import java.util.Map;\n+import java.util.function.BiPredicate;\n+\n+@Getter\n+@Builder\n+public class DeploymentPacket {\n+\n+    private Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private BiPredicate<Kernel, Map<String, Map<String, Parameter>>> downloadCondition;\n+\n+    private BiPredicate<Kernel, Map<String, Map<String, Parameter>>> updateCondition;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODU3Mg=="}, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDQzNQ==", "bodyText": "Why is the value an Object?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383630435", "createdAt": "2020-02-25T02:45:07Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/model/Package.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.aws.iot.evergreen.packagemanager.model;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.Getter;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+@Getter\n+public class Package {\n+\n+    private final String serviceName;\n+\n+    private final String packageName;\n+\n+    private final String packageVersion;\n+\n+    private final Map<String, Object> lifecycle;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzMDczOQ==", "bodyText": "Can we not use recursive? I find it not very readable in general.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r383630739", "createdAt": "2020-02-25T02:46:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0Nzk3Mg=="}, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzA5OTg4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-364309988", "createdAt": "2020-02-25T17:18:06Z", "commit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNzoxODowOFrOFuOTqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNzoxODowOFrOFuOTqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAxMzIyNA==", "bodyText": "Can you explain the packageName's @JsonProperty value of \" \"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384013224", "createdAt": "2020-02-25T17:18:08Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/model/Package.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.aws.iot.evergreen.packagemanager.model;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.Getter;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+@Getter\n+public class Package {\n+\n+    private final String serviceName;\n+\n+    private final String packageName;\n+\n+    private final String packageVersion;\n+\n+    private final Map<String, Object> lifecycle;\n+\n+    private final Set<String> artifactUrls;\n+\n+    private final Set<Dependency> dependencies;\n+\n+    private final Set<Parameter> parameters;\n+\n+    private final Map<String, Package> dependencyPackageMap;\n+\n+    @JsonCreator\n+    public Package(@JsonProperty(\"service\") String serviceName, @JsonProperty(\" \") String packageName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d2fbfbfa8f0da04bc181a115e6b1b3d08b073c7"}, "originalPosition": 36}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3f9d03e61e540ac845179cb8f54c9d0967e7c43", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3f9d03e61e540ac845179cb8f54c9d0967e7c43", "committedDate": "2020-02-25T20:35:15Z", "message": "Merged new changes from master and made relevant changes"}, "afterCommit": {"oid": "20ca8d2a11289171a0734005e4fbcca5849b6f90", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/20ca8d2a11289171a0734005e4fbcca5849b6f90", "committedDate": "2020-02-25T19:59:56Z", "message": "Changes to update application layer protocol (#67)\n\n* Changes to update application layer protocol\r\n\r\n* removed * imports\r\n\r\n* addressed PR  comments\r\n\r\n* fixed check style issues\r\n\r\n* minor refactoring based on PR\r\n\r\n* Update pom.xml\r\n\r\nCo-authored-by: Michael Dombrowski <mikepi3.14@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTExMTg1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-364511185", "createdAt": "2020-02-25T22:56:23Z", "commit": {"oid": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjo1NjoyM1rOFuYU2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzowNTowMlrOFuYiQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3NzM2OQ==", "bodyText": "These lambdas can be changed to function references which should be more efficient since they won't create new objects for each run.\nex: convert p -> p.getServiceName() --> Package::getServiceName. IntelliJ can do this automatically.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384177369", "createdAt": "2020-02-25T22:56:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs\n+ */\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment = targetPackageConfigs.get(packageName);\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values\n+     *\n+     * @param lifecycleKey key of the key value pair in lifecycle map\n+     * @param lifecycle lifecycle map\n+     * @param parametersFromDeployment parameters set in deployment for package\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Map.Entry<Object, Object> lifecycleEntry : childLifecycleMap.entrySet()) {\n+                interpolate(lifecycleEntry.getKey(), childLifecycleMap, parametersFromDeployment, packageParameters);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Recompute main service dependencies for deployment\n+     *\n+     * @param targetPackages top level packages\n+     * @return main service with updated dependencies\n+     * @throws Throwable\n+     */\n+    private Map<Object, Object> getUpdatedMainConfig(Map<String, Package> targetPackages) throws Throwable {\n+        Set<String> kernelDependencies =\n+                kernel.getMain().getDependencies().keySet().stream().map(s -> s.getName()).collect(Collectors.toSet());\n+        kernelDependencies.removeAll(removedTopLevelPackages);\n+        kernelDependencies\n+                .addAll(targetPackages.values().stream().map(p -> p.getServiceName()).collect(Collectors.toSet()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3ODMyMA==", "bodyText": "This can be Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle()); if I'm not mistaken.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384178320", "createdAt": "2020-02-25T22:58:47Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs\n+ */\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3ODU4Nw==", "bodyText": "Since this seems to only use the key, why not just use the keySet instead of entrySet?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384178587", "createdAt": "2020-02-25T22:59:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs\n+ */\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment = targetPackageConfigs.get(packageName);\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3ODk2MQ==", "bodyText": "Looks like this only uses the key here too, so maybe just use the keySet.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384178961", "createdAt": "2020-02-25T23:00:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.AllArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs\n+ */\n+@AllArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config\n+     *\n+     * @param newConfig instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>();\n+        lifecycle.putAll(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment = targetPackageConfigs.get(packageName);\n+        for (Map.Entry<Object, Object> lifecycleEntry : lifecycle.entrySet()) {\n+            interpolate(lifecycleEntry.getKey(), lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames = pkg.getDependencyPackageMap().values().stream().\n+                map(dependency -> dependency.getServiceName()).collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values\n+     *\n+     * @param lifecycleKey key of the key value pair in lifecycle map\n+     * @param lifecycle lifecycle map\n+     * @param parametersFromDeployment parameters set in deployment for package\n+     * @param packageParameters all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,\n+                             Map<String, Parameter> parametersFromDeployment,\n+                             Set<Package.Parameter> packageParameters) {\n+        if (lifecycle.get(lifecycleKey) instanceof String) {\n+            String value = (String) lifecycle.get(lifecycleKey);\n+\n+            // Handle package parameters\n+            for (final Package.Parameter parameter : packageParameters) {\n+                String paramValue = parameter.getDefaultValue();\n+                if (parametersFromDeployment != null && parametersFromDeployment.containsKey(parameter.getName())) {\n+                    paramValue = parametersFromDeployment.get(parameter.getName()).getValue();\n+                }\n+                value = value.replace(String.format(PARAMETER_REFERENCE_FORMAT, parameter.getName()), paramValue);\n+            }\n+            lifecycle.put(lifecycleKey, value);\n+\n+            // TODO : Handle system parameters\n+        } else {\n+            Map<Object, Object> childLifecycleMap = (Map<Object, Object>) lifecycle.get(lifecycleKey);\n+            for (Map.Entry<Object, Object> lifecycleEntry : childLifecycleMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MDMxMQ==", "bodyText": "Jason just merged, so I'm assuming that you'll bring in his things instead of defining your own, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384180311", "createdAt": "2020-02-25T23:03:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -0,0 +1,18 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.packagemanager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE4MDgwMA==", "bodyText": "Technically I think this is part of the GIVEN since you're setting up what the mocks will do.\nThe \"WHEN\" should be the call to your code under test, which looks like like 79 to me.\nThen the \"THEN\" should be all your assertions.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384180800", "createdAt": "2020-02-25T23:05:02Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/ConfigResolverTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class ConfigResolverTest {\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    EvergreenService mainService;\n+\n+    @Mock\n+    EvergreenService alreadyRunningService;\n+\n+    @Mock\n+    Log log;\n+\n+    private static final String LIFECYCLE_INSTALL_KEY = \"install\";\n+    private static final String LIFECYCLE_RUN_KEY = \"run\";\n+    private static final String LIFECYCLE_REQUIRES_KEY = \"requires\";\n+    private static final String LIFECYCLE_MOCK_INSTALL_COMMAND_FORMAT =\n+            \"echo installing service in Package %s with param {{params:%s_Param_1.value}}\";\n+    private static final String LIFECYCLE_MOCK_RUN_COMMAND_FORMAT =\n+            \"echo running service in Package %s with param {{params:%s_Param_2.value}}\";\n+\n+    private static final String TEST_INPUT_PACKAGE_A = \"PackageA\";\n+    private static final String TEST_INPUT_PACKAGE_B = \"PackageB\";\n+\n+    @Test\n+    public void GIVEN_deployment_for_package_WHEN_config_resolution_requested_THEN_add_service_and_dependency_service()\n+            throws Throwable {\n+        // GIVEN\n+        Map<String, Map<String, Parameter>> targetPackageConfigs = Collections.emptyMap();\n+\n+        Package topLevelPackage =\n+                getPackage(TEST_INPUT_PACKAGE_A, \"1.2\", Collections.singletonMap(TEST_INPUT_PACKAGE_B, \"2.3\"),\n+                        Collections.emptyMap());\n+        Package dependencyPackage =\n+                getPackage(TEST_INPUT_PACKAGE_B, \"2.3\", Collections.emptyMap(), Collections.emptyMap());\n+        topLevelPackage.getDependencyPackageMap().put(TEST_INPUT_PACKAGE_B, dependencyPackage);\n+        Map<String, Package> targetPackages = Collections.singletonMap(TEST_INPUT_PACKAGE_A, topLevelPackage);\n+\n+        Set<String> removedTopLevelPackages = Collections.emptySet();\n+\n+        ConfigResolver configResolver =\n+                new ConfigResolver(kernel, log, targetPackageConfigs, targetPackages, removedTopLevelPackages);\n+\n+        // WHEN\n+        when(kernel.getMain()).thenReturn(mainService);\n+        when(mainService.getName()).thenReturn(\"main\");\n+        when(mainService.getDependencies()).thenReturn(Collections.singletonMap(alreadyRunningService, State.Running));\n+        when(alreadyRunningService.getName()).thenReturn(\"IpcService\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728"}, "originalPosition": 76}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f620b0781f4c09f7c50433767e6f0ba7bc4c0728", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f620b0781f4c09f7c50433767e6f0ba7bc4c0728", "committedDate": "2020-02-25T22:23:36Z", "message": "Deployments - Update Kernel config with changes from depployment"}, "afterCommit": {"oid": "6c91ebc21c4a59eff49b0024e54ba2bd5122f2f4", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6c91ebc21c4a59eff49b0024e54ba2bd5122f2f4", "committedDate": "2020-02-25T23:10:07Z", "message": "Deployments - Update Kernel config with changes from depployment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6c91ebc21c4a59eff49b0024e54ba2bd5122f2f4", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6c91ebc21c4a59eff49b0024e54ba2bd5122f2f4", "committedDate": "2020-02-25T23:10:07Z", "message": "Deployments - Update Kernel config with changes from depployment"}, "afterCommit": {"oid": "f9d990bb3d354cf3ab801f74225ac07d16e6b981", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f9d990bb3d354cf3ab801f74225ac07d16e6b981", "committedDate": "2020-02-25T23:53:36Z", "message": "Deployments - Update Kernel config with changes from depployment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTQ1OTE4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-365145918", "createdAt": "2020-02-26T18:40:25Z", "commit": {"oid": "f9d990bb3d354cf3ab801f74225ac07d16e6b981"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODo0MDoyNlrOFu3c0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODo0NDo1N1rOFu3l5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4NzMxNQ==", "bodyText": "[nit]\nYou can make the logger static too.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384687315", "createdAt": "2020-02-26T18:40:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs.\n+ */\n+@RequiredArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private final Set<String> removedTopLevelPackages;\n+\n+    private final Logger logger = LogManager.getLogger(getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9d990bb3d354cf3ab801f74225ac07d16e6b981"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4ODIyMQ==", "bodyText": "Since I merged my change, getMain() does not need to throw Throwable anymore, so you can remove this check.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384688221", "createdAt": "2020-02-26T18:42:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.model.Package;\n+import com.aws.iot.evergreen.util.Log;\n+import lombok.Builder;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+@Builder\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    private final Log log;\n+\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    private final Map<String, Package> targetPackages;\n+\n+    private Set<String> removedTopLevelPackages;\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            return newConfig;\n+        } catch (Throwable t) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTkxMQ=="}, "originalCommit": {"oid": "4a64d6d7d4b39dd467880cc66d0d98d418307be1"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4OTYzNg==", "bodyText": "If you were not aware, James added a templating system: https://github.com/aws/aws-greengrass-kernel/blob/3d6671737dbd585a09b685207a82a99d5933fef1/src/main/java/com/aws/iot/evergreen/kernel/EZTemplates.java#L27.\nSo we might want to use that if possible. But maybe it isn't possible and that's fine.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384689636", "createdAt": "2020-02-26T18:44:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.Parameter;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs.\n+ */\n+@RequiredArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    // Mapping of package name -> parameter name -> parameter value set in deployment\n+    private final Map<String, Map<String, Parameter>> targetPackageConfigs;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Map<String, Package> targetPackages;\n+\n+    private final Set<String> removedTopLevelPackages;\n+\n+    private final Logger logger = LogManager.getLogger(getClass());\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel.\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception when an error occurs while processing config or downstream\n+     */\n+    public Map<Object, Object> resolveConfig() throws Exception {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            targetPackages.forEach((packageName, pkg) -> processPackage(newConfig, packageName, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig(targetPackages));\n+\n+            return newConfig;\n+        } catch (Throwable t) {\n+            logger.atError().log(\"Error encountred while generating kernel config\");\n+            throw new Exception(\"Error resolving config\", t);\n+        }\n+    }\n+\n+    /**\n+     * Processes lifecycle section of each packaage and adds it to the config.\n+     *\n+     * @param newConfig   instance of config that services are to be added to\n+     * @param packageName name of the package to generate config for\n+     * @param pkg         package object with package information\n+     */\n+    // TODO : Revisit after the Kernel config syntax is updated, DA currently does not understand the lifecycle syntax\n+    private void processPackage(Map<Object, Object> newConfig, String packageName, Package pkg) {\n+        Map<Object, Object> lifecycle = new HashMap<>(pkg.getLifecycle());\n+\n+        // Interpolate parameters\n+        Map<String, Parameter> parametersFromDeployment = targetPackageConfigs.get(packageName);\n+        for (Object lifecycleKey : lifecycle.keySet()) {\n+            interpolate(lifecycleKey, lifecycle, parametersFromDeployment, pkg.getParameters());\n+        }\n+\n+        // Generate requires list\n+        Set<String> dependencyServiceNames =\n+                pkg.getDependencyPackageMap().values().stream().map(Package::getServiceName)\n+                        .collect(Collectors.toSet());\n+        addServiceDependencies(lifecycle, dependencyServiceNames);\n+\n+        lifecycle.put(VERSION_CONFIG_KEY, pkg.getPackageVersion());\n+        newConfig.put(pkg.getServiceName(), lifecycle);\n+\n+        // Process dependency packages\n+        pkg.getDependencyPackageMap().forEach(\n+                (dependencyPackageName, dependencyPackage) -> processPackage(newConfig, dependencyPackageName,\n+                        dependencyPackage));\n+    }\n+\n+    /**\n+     * For lifecycle key-value pair of a package, substitutes parameter values.\n+     *\n+     * @param lifecycleKey             key of the key value pair in lifecycle map\n+     * @param lifecycle                lifecycle map\n+     * @param parametersFromDeployment parameters set in deployment for package\n+     * @param packageParameters        all parameters configured for package\n+     */\n+    private void interpolate(Object lifecycleKey, Map<Object, Object> lifecycle,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9d990bb3d354cf3ab801f74225ac07d16e6b981"}, "originalPosition": 102}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f9d990bb3d354cf3ab801f74225ac07d16e6b981", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f9d990bb3d354cf3ab801f74225ac07d16e6b981", "committedDate": "2020-02-25T23:53:36Z", "message": "Deployments - Update Kernel config with changes from depployment"}, "afterCommit": {"oid": "7e7704299e970229ab6afc148860107d7e0a428d", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7e7704299e970229ab6afc148860107d7e0a428d", "committedDate": "2020-02-26T19:53:48Z", "message": "Deployments - Update Kernel config with changes from depployment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTk4MDA1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-365198005", "createdAt": "2020-02-26T19:56:07Z", "commit": {"oid": "7e7704299e970229ab6afc148860107d7e0a428d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1NjowN1rOFu6DuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTo1NzoyM1rOFu6GTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMDA0MA==", "bodyText": "Log the error itself using setCause(e).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384730040", "createdAt": "2020-02-26T19:56:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/ConfigResolver.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * For deployment with a map of package dependency trees, generates\n+ * Kernel config to be merged and interpolates parameter values into the configs.\n+ */\n+@RequiredArgsConstructor\n+public class ConfigResolver {\n+\n+    private final Kernel kernel;\n+\n+    // Mapping of top level package name -> resolved dependency tree\n+    private final Set<Package> packagesToDeploy;\n+\n+    private final Set<String> removedTopLevelPackages;\n+\n+    private static final Logger logger = LogManager.getLogger(ConfigResolver.class);\n+\n+    private static final String REQUIRES_CONFIG_KEY = \"requires\";\n+    private static final String VERSION_CONFIG_KEY = \"version\";\n+    private static final String PARAMETER_REFERENCE_FORMAT = \"{{params:%s.value}}\";\n+\n+    /**\n+     * Generates config to be merged with kernel.\n+     *\n+     * @return kernel config to be merged\n+     * @throws Exception when an error occurs while processing config or downstream\n+     */\n+    public Map<Object, Object> resolveConfig() {\n+        try {\n+            Map<Object, Object> newConfig = new HashMap<>();\n+\n+            packagesToDeploy.forEach(pkg -> processPackage(newConfig, pkg));\n+\n+            newConfig.put(kernel.getMain().getName(), getUpdatedMainConfig());\n+\n+            return newConfig;\n+        } catch (Exception e) {\n+            logger.atError().log(\"Error encountred while generating kernel config\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e7704299e970229ab6afc148860107d7e0a428d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMDcwMw==", "bodyText": "Update the year in your copyright notice.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384730703", "createdAt": "2020-02-26T19:57:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/state/DownloadedState.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e7704299e970229ab6afc148860107d7e0a428d"}, "originalPosition": 1}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e7704299e970229ab6afc148860107d7e0a428d", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7e7704299e970229ab6afc148860107d7e0a428d", "committedDate": "2020-02-26T19:53:48Z", "message": "Deployments - Update Kernel config with changes from depployment"}, "afterCommit": {"oid": "8b48a12179910cfb6d2dd65a3aa0b266849c7050", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8b48a12179910cfb6d2dd65a3aa0b266849c7050", "committedDate": "2020-02-26T20:07:18Z", "message": "Deployments - Update Kernel config with changes from depployment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8b48a12179910cfb6d2dd65a3aa0b266849c7050", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8b48a12179910cfb6d2dd65a3aa0b266849c7050", "committedDate": "2020-02-26T20:07:18Z", "message": "Deployments - Update Kernel config with changes from depployment"}, "afterCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "committedDate": "2020-02-26T21:03:53Z", "message": "Deployments - Update Kernel config with changes from depployment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjQ1Nzc1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-365245775", "createdAt": "2020-02-26T21:12:58Z", "commit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxMjo1OFrOFu8Ztg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjo0MTozMlrOFu_EZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2ODQzOA==", "bodyText": "Nice!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384768438", "createdAt": "2020-02-26T21:12:58Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/Package.java", "diffHunk": "@@ -66,11 +71,11 @@ public Package(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion reci\n                    @JsonProperty(\"Version\") Semver packageVersion,\n                    @JsonProperty(\"Description\") String description,\n                    @JsonProperty(\"Publisher\") String publisher,\n-                   @JsonProperty(\"Parameters\") HashSet<PackageParameter> packageParameters,\n-                   @JsonProperty(\"Lifecycle\") HashMap<String, Object> lifecycle,\n-                   @JsonProperty(\"Artifacts\") ArrayList<String> artifacts,\n-                   @JsonProperty(\"Dependencies\") HashMap<String, String> dependencies,\n-                   @JsonProperty(\"Requires\") ArrayList<String> requires) throws SemverException {\n+                   @JsonProperty(\"Parameters\") Set<PackageParameter> packageParameters,\n+                   @JsonProperty(\"Lifecycle\") Map<String, Object> lifecycle,\n+                   @JsonProperty(\"Artifacts\") List<String> artifacts,\n+                   @JsonProperty(\"Dependencies\") Map<String, String> dependencies,\n+                   @JsonProperty(\"Requires\") List<String> requires) throws SemverException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MDA5OA==", "bodyText": "Could be long for now and I assume this is epoch milli second. But I'd prefer Instant instead.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384770098", "createdAt": "2020-02-26T21:15:53Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPacket.java", "diffHunk": "@@ -0,0 +1,17 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+\n+@Getter\n+@Builder\n+public class DeploymentPacket {\n+\n+    private String deploymentId;\n+\n+    private long deploymentCreationTimestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MTk3Ng==", "bodyText": "[nit] On the top?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384771976", "createdAt": "2020-02-26T21:18:57Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;\n+\n+    @Getter\n+    @Setter\n+    private Map<Object, Object> resolvedKernelConfig;\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjU4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Set<String> removedTopLevelPackages;\n          \n          \n            \n                private Set<String> removedTopLevelPackageNames; \n          \n      \n    \n    \n  \n\nmight be better since the type is Set<String> instead of Set<Package>", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384772589", "createdAt": "2020-02-26T21:20:05Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mjg5OQ==", "bodyText": "[Optional] This feels like a DeploymentStateMachine even...", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384772899", "createdAt": "2020-02-26T21:20:44Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDU2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                int duration = 2;\n          \n          \n            \n                                Thread.sleep(TimeUnit.SECONDS.toMillis(2));\n          \n          \n            \n                                TimeUnit.MILLISECONDS.sleep(2);\n          \n      \n    \n    \n  \n\nAlso consider making 2 a class constant.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384774561", "createdAt": "2020-02-26T21:23:51Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;\n+\n+    @Getter\n+    @Setter\n+    private Map<Object, Object> resolvedKernelConfig;\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);\n+\n+    /**\n+     * Constructor to initialize deployment process.\n+     *\n+     * @param packet parsed deployment document\n+     * @param kernel running kernel instance\n+     */\n+    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n+        this.downloadedState = new DownloadedState(this, kernel);\n+        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n+\n+        // TODO : Change this to appropriate initial state when the initial state is implemented\n+        this.currentState = this.downloadedState;\n+        this.deploymentPacket = packet;\n+    }\n+\n+    /**\n+     * Execute deployment.\n+     */\n+    public void proceed() {\n+        while (!currentState.isFinalState()) {\n+            if (currentState.canProceed()) {\n+                currentState.proceed();\n+            } else {\n+                try {\n+                    int duration = 2;\n+                    Thread.sleep(TimeUnit.SECONDS.toMillis(2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDcyMQ==", "bodyText": "[nit] If this is indeed a state machine, then execute or run is better then proceed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384774721", "createdAt": "2020-02-26T21:24:11Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;\n+\n+    @Getter\n+    @Setter\n+    private Map<Object, Object> resolvedKernelConfig;\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);\n+\n+    /**\n+     * Constructor to initialize deployment process.\n+     *\n+     * @param packet parsed deployment document\n+     * @param kernel running kernel instance\n+     */\n+    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n+        this.downloadedState = new DownloadedState(this, kernel);\n+        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n+\n+        // TODO : Change this to appropriate initial state when the initial state is implemented\n+        this.currentState = this.downloadedState;\n+        this.deploymentPacket = packet;\n+    }\n+\n+    /**\n+     * Execute deployment.\n+     */\n+    public void proceed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NzAwMQ==", "bodyText": "I think ConfigResolver could be singleton. Maybe put a TODO about we need to consider using DI here instead of creating it every time.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384777001", "createdAt": "2020-02-26T21:28:32Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/state/DownloadedState.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment.state;\n+\n+import com.aws.iot.evergreen.deployment.ConfigResolver;\n+import com.aws.iot.evergreen.deployment.DeploymentProcess;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.Map;\n+\n+/**\n+ * Deployment state after package dependencies have been resolved and packages have been downloaded.\n+ * Generates config to be merged when appropriate.\n+ */\n+@RequiredArgsConstructor\n+public class DownloadedState implements State {\n+\n+    private final DeploymentProcess deploymentProcess;\n+\n+    private final Kernel kernel;\n+\n+    private static final Logger logger = LogManager.getLogger(DownloadedState.class);\n+\n+    @Override\n+    public boolean canProceed() {\n+        logger.atInfo().log(\"<Downloaded>: checking if deployment can proceed\");\n+        // check update kernel conditions\n+        return true;\n+    }\n+\n+    @Override\n+    public void proceed() {\n+        logger.atInfo().log(\"<Downloaded>: proceed\");\n+        // resolve kernel config\n+        try {\n+            deploymentProcess.setResolvedKernelConfig(resolveKernelConfig());\n+            deploymentProcess.setCurrentState(deploymentProcess.getUpdatingKernelState());\n+        } catch (Exception e) {\n+            // TODO : Mark the deployment failed\n+            logger.atError().setEventType(\"donwloaded-state-error\").setCause(e).log(\"Error in downloaded state\");\n+        }\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        // TODO : Cleanup, revert package cache updates, etc\n+    }\n+\n+    private Map<Object, Object> resolveKernelConfig() {\n+        ConfigResolver configResolver = new ConfigResolver(kernel, deploymentProcess.getPackagesToDeploy(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NjcyMw==", "bodyText": "I think we should update the currentState here since we are handling the state.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384786723", "createdAt": "2020-02-26T21:47:43Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentProcess.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.deployment.model.DeploymentPacket;\n+import com.aws.iot.evergreen.deployment.state.DownloadedState;\n+import com.aws.iot.evergreen.deployment.state.State;\n+import com.aws.iot.evergreen.deployment.state.UpdatingKernelState;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import lombok.Getter;\n+import lombok.Setter;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Deployment as a process that controls state transition and passes context among\n+ * deployment states.\n+ */\n+public class DeploymentProcess {\n+\n+    @Getter\n+    private final State downloadedState;\n+\n+    @Getter\n+    private final State updatingKernelState;\n+\n+    @Getter\n+    @Setter\n+    private volatile State currentState;\n+\n+    @Getter\n+    private final DeploymentPacket deploymentPacket;\n+\n+    @Getter\n+    @Setter\n+    private Set<Package> packagesToDeploy;\n+\n+    @Getter\n+    @Setter\n+    private Set<String> removedTopLevelPackages;\n+\n+    @Getter\n+    @Setter\n+    private Map<Object, Object> resolvedKernelConfig;\n+\n+    private static final Logger logger = LogManager.getLogger(DeploymentProcess.class);\n+\n+    /**\n+     * Constructor to initialize deployment process.\n+     *\n+     * @param packet parsed deployment document\n+     * @param kernel running kernel instance\n+     */\n+    public DeploymentProcess(DeploymentPacket packet, Kernel kernel) {\n+        this.downloadedState = new DownloadedState(this, kernel);\n+        this.updatingKernelState = new UpdatingKernelState(this, kernel);\n+\n+        // TODO : Change this to appropriate initial state when the initial state is implemented\n+        this.currentState = this.downloadedState;\n+        this.deploymentPacket = packet;\n+    }\n+\n+    /**\n+     * Execute deployment.\n+     */\n+    public void proceed() {\n+        while (!currentState.isFinalState()) {\n+            if (currentState.canProceed()) {\n+                currentState.proceed();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjA0OA==", "bodyText": "private", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384812048", "createdAt": "2020-02-26T22:41:23Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/ConfigResolverTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.aws.iot.evergreen.packagemanager.models.RecipeTemplateVersion;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class ConfigResolverTest {\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    EvergreenService mainService;\n+\n+    @Mock\n+    EvergreenService alreadyRunningService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjEzMw==", "bodyText": "On the top", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#discussion_r384812133", "createdAt": "2020-02-26T22:41:32Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/ConfigResolverTest.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageParameter;\n+import com.aws.iot.evergreen.packagemanager.models.RecipeTemplateVersion;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class ConfigResolverTest {\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    EvergreenService mainService;\n+\n+    @Mock\n+    EvergreenService alreadyRunningService;\n+\n+    private static final String LIFECYCLE_INSTALL_KEY = \"install\";\n+    private static final String LIFECYCLE_RUN_KEY = \"run\";\n+    private static final String LIFECYCLE_REQUIRES_KEY = \"requires\";\n+    private static final String LIFECYCLE_MOCK_INSTALL_COMMAND_FORMAT =\n+            \"echo installing service in Package %s with param {{params:%s_Param_1.value}}\";\n+    private static final String LIFECYCLE_MOCK_RUN_COMMAND_FORMAT =\n+            \"echo running service in Package %s with param {{params:%s_Param_2.value}}\";\n+\n+    private static final String TEST_INPUT_PACKAGE_A = \"PackageA\";\n+    private static final String TEST_INPUT_PACKAGE_B = \"PackageB\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eb65a5dd4ce84d62b2a80b73e6298151a6e66ce", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7eb65a5dd4ce84d62b2a80b73e6298151a6e66ce", "committedDate": "2020-02-26T23:29:53Z", "message": "Deployments - Update Kernel config with changes from depployment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6d1c075ce30b4c4c44248cc5b5b607b8f489e2a8", "committedDate": "2020-02-26T21:03:53Z", "message": "Deployments - Update Kernel config with changes from depployment"}, "afterCommit": {"oid": "7eb65a5dd4ce84d62b2a80b73e6298151a6e66ce", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7eb65a5dd4ce84d62b2a80b73e6298151a6e66ce", "committedDate": "2020-02-26T23:29:53Z", "message": "Deployments - Update Kernel config with changes from depployment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzIwNDY4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/70#pullrequestreview-365320468", "createdAt": "2020-02-26T23:32:02Z", "commit": {"oid": "7eb65a5dd4ce84d62b2a80b73e6298151a6e66ce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2263, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}