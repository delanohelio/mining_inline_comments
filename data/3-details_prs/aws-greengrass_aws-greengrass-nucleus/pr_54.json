{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNjE5MjA2", "number": 54, "title": "Add unit testing for IPC and update for Netty-based IPC Client", "bodyText": "Issue #, if available:\nDescription of changes:\nAdd unit testing for IPC and update for Netty-based IPC Client. Now pulls in message decoder/encoder from SDK package so that code isn't duplicated.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-02-05T22:33:59Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54", "merged": true, "mergeCommit": {"oid": "e1e0ee3256170f929cf72ba2459fcca1123746b4"}, "closed": true, "closedAt": "2020-02-06T23:24:29Z", "author": {"login": "MikeDombo"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBd3MCAH2gAyMzcxNjE5MjA2OjBiMzU5YTA4ZDM0OTBjYTg5MzViODIxYTY4Y2FkZGU5MDBjOTNjYjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBzRYagFqTM1NDg0MzE5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0b359a08d3490ca8935b821a68cadde900c93cb5", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b359a08d3490ca8935b821a68cadde900c93cb5", "committedDate": "2020-02-05T22:27:32Z", "message": "Fix writing effective config and getting paths of CommitableFile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a5e2e32a5d5223808d82be8486da9f4b7632b83", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6a5e2e32a5d5223808d82be8486da9f4b7632b83", "committedDate": "2020-02-05T22:29:16Z", "message": "Add unit tests for IPC server"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "478a27e9055bee747f5615f12c03f22236691aaf", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/478a27e9055bee747f5615f12c03f22236691aaf", "committedDate": "2020-02-05T22:33:40Z", "message": "Update to match IPC client changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbd28eac0d9844bd0a5fbef5ebb94738d75da002", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cbd28eac0d9844bd0a5fbef5ebb94738d75da002", "committedDate": "2020-02-05T23:04:12Z", "message": "Merge branch 'master' into netty_client_changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0487faf174865d66ed37a559e017c7545ba50652", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0487faf174865d66ed37a559e017c7545ba50652", "committedDate": "2020-02-06T00:07:10Z", "message": "Merge branch 'master' into netty_client_changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/316542c6089da88a4b8a5107dae97e5dba39dfbf", "committedDate": "2020-02-06T00:27:56Z", "message": "Merge branch 'master' into netty_client_changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MTMyNjA5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#pullrequestreview-354132609", "createdAt": "2020-02-06T00:24:07Z", "commit": {"oid": "0487faf174865d66ed37a559e017c7545ba50652"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDoyNjowMVrOFmLw3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDo0MTozNVrOFmMBIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4Mjk0Mg==", "bodyText": "Super clear! Helped a lot for reading tests.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375582942", "createdAt": "2020-02-06T00:26:01Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/IPCRouterTest.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class IPCRouterTest {\n+    @Mock\n+    Log log;\n+\n+    @Test\n+    public void GIVEN_function_WHEN_register_callback_THEN_callback_can_be_called() throws Throwable {\n+        IPCRouter router = new IPCRouter(log);\n+\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        router.registerServiceCallback(\"dest\", (a, b) -> {\n+            cdl.countDown();\n+            return null;\n+        });\n+\n+        router.getCallbackForDestination(\"dest\").onMessage(null, null);\n+        assertTrue(cdl.await(100, TimeUnit.MILLISECONDS));\n+    }\n+\n+    @Test\n+    public void GIVEN_already_registered_function_WHEN_register_callback_THEN_exception_is_thrown() throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0487faf174865d66ed37a559e017c7545ba50652"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDUyMw==", "bodyText": "I like AuthRequestType.Auth better. (plural -> singular)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375584523", "createdAt": "2020-02-06T00:31:59Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import org.junit.jupiter.api.Test;\n+\n+import static com.aws.iot.evergreen.ipc.handler.AuthHandler.AUTH_TOKEN_LOOKUP_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AuthHandlerTest {\n+    private static final String SERVICE_NAME = \"ServiceName\";\n+\n+    @Test\n+    public void GIVEN_service_WHEN_register_auth_token_THEN_client_can_be_authenticated_with_token() throws Exception {\n+        Configuration config = new Configuration(new Context());\n+        AuthHandler.registerAuthToken(new EvergreenService(config.lookupTopics(SERVICE_NAME)));\n+        Object authToken = config.find(SERVICE_NAME, \"_UID\").getOnce();\n+\n+        assertNotNull(authToken);\n+        assertEquals(SERVICE_NAME, config.find(AUTH_TOKEN_LOOKUP_KEY, (String) authToken).getOnce());\n+\n+        AuthHandler auth = new AuthHandler(config);\n+        RequestContext authContext = auth.doAuth(new FrameReader.Message(IPCUtil\n+                .encode(GeneralRequest.builder().type(AuthRequestTypes.Auth).request(authToken).build())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NTU1Ng==", "bodyText": "For long tests, maybe adding //GIVEN //WHEN //THEN will be helpful", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375585556", "createdAt": "2020-02-06T00:35:58Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.util.Attribute;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class MessageRouterTest {\n+    public static final String ERROR_MESSAGE = \"AAAAAAH!\";\n+    @Mock\n+    AuthHandler mockAuth;\n+    @Mock\n+    IPCRouter ipcRouter;\n+    @Mock\n+    ChannelHandlerContext mockCtx;\n+    @Mock\n+    Channel mockChannel;\n+    @Mock\n+    Attribute<RequestContext> mockAttr;\n+    RequestContext mockAttrValue = null;\n+\n+    private MessageRouter router;\n+\n+    @BeforeEach\n+    public void setupMocks() throws Exception {\n+        router = new MessageRouter(mock(Log.class), mockAuth, ipcRouter);\n+\n+        when(mockCtx.channel()).thenReturn(mockChannel);\n+        when(mockChannel.attr(any())).thenReturn((Attribute) mockAttr);\n+        doAnswer((invocation) -> mockAttrValue = invocation.getArgument(0)).when(mockAttr).set(any());\n+        lenient().when(mockChannel.remoteAddress()).thenReturn(LocalAddress.ANY);\n+\n+        router.channelRegistered(mockCtx);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_auth_request_THEN_server_validates_token_and_authenticates_client() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NjIwMA==", "bodyText": "times(1) can be removed. save as several occurrences below", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375586200", "createdAt": "2020-02-06T00:38:24Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.util.Attribute;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class MessageRouterTest {\n+    public static final String ERROR_MESSAGE = \"AAAAAAH!\";\n+    @Mock\n+    AuthHandler mockAuth;\n+    @Mock\n+    IPCRouter ipcRouter;\n+    @Mock\n+    ChannelHandlerContext mockCtx;\n+    @Mock\n+    Channel mockChannel;\n+    @Mock\n+    Attribute<RequestContext> mockAttr;\n+    RequestContext mockAttrValue = null;\n+\n+    private MessageRouter router;\n+\n+    @BeforeEach\n+    public void setupMocks() throws Exception {\n+        router = new MessageRouter(mock(Log.class), mockAuth, ipcRouter);\n+\n+        when(mockCtx.channel()).thenReturn(mockChannel);\n+        when(mockChannel.attr(any())).thenReturn((Attribute) mockAttr);\n+        doAnswer((invocation) -> mockAttrValue = invocation.getArgument(0)).when(mockAttr).set(any());\n+        lenient().when(mockChannel.remoteAddress()).thenReturn(LocalAddress.ANY);\n+\n+        router.channelRegistered(mockCtx);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_auth_request_THEN_server_validates_token_and_authenticates_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        RequestContext requestCtx = new RequestContext();\n+        requestCtx.serviceName = \"ABC\";\n+        when(mockAuth.doAuth(any())).thenReturn(requestCtx);\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(AUTH_SERVICE, responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Success\"));\n+        assertEquals(requestCtx, mockAttrValue);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_bad_auth_request_THEN_server_validates_token_and_rejects_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        when(mockAuth.doAuth(any())).thenThrow(new IPCClientNotAuthorizedException(\"No Auth!\"));\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(1)).addListener(eq(ChannelFutureListener.CLOSE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NzEwNA==", "bodyText": "Seems this could be moved to beforeEach. ArgumentCaptor could be an @Captor class field", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375587104", "createdAt": "2020-02-06T00:41:35Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.util.Attribute;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class MessageRouterTest {\n+    public static final String ERROR_MESSAGE = \"AAAAAAH!\";\n+    @Mock\n+    AuthHandler mockAuth;\n+    @Mock\n+    IPCRouter ipcRouter;\n+    @Mock\n+    ChannelHandlerContext mockCtx;\n+    @Mock\n+    Channel mockChannel;\n+    @Mock\n+    Attribute<RequestContext> mockAttr;\n+    RequestContext mockAttrValue = null;\n+\n+    private MessageRouter router;\n+\n+    @BeforeEach\n+    public void setupMocks() throws Exception {\n+        router = new MessageRouter(mock(Log.class), mockAuth, ipcRouter);\n+\n+        when(mockCtx.channel()).thenReturn(mockChannel);\n+        when(mockChannel.attr(any())).thenReturn((Attribute) mockAttr);\n+        doAnswer((invocation) -> mockAttrValue = invocation.getArgument(0)).when(mockAttr).set(any());\n+        lenient().when(mockChannel.remoteAddress()).thenReturn(LocalAddress.ANY);\n+\n+        router.channelRegistered(mockCtx);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_auth_request_THEN_server_validates_token_and_authenticates_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        RequestContext requestCtx = new RequestContext();\n+        requestCtx.serviceName = \"ABC\";\n+        when(mockAuth.doAuth(any())).thenReturn(requestCtx);\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(AUTH_SERVICE, responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Success\"));\n+        assertEquals(requestCtx, mockAttrValue);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_bad_auth_request_THEN_server_validates_token_and_rejects_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        when(mockAuth.doAuth(any())).thenThrow(new IPCClientNotAuthorizedException(\"No Auth!\"));\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(1)).addListener(eq(ChannelFutureListener.CLOSE));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(AUTH_SERVICE, responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Unauthorized\"));\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Error while authenticating client\"));\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_any_request_THEN_server_forces_them_to_authenticate_first() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(\"Destination\", new FrameReader.Message(new byte[0]), FrameReader.FrameType.REQUEST);\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(1)).addListener(eq(ChannelFutureListener.CLOSE));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(\"Destination\", responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Error while authenticating client\"));\n+    }\n+\n+    @Test\n+    public void GIVEN_authenticated_client_WHEN_request_with_unregistered_destination_THEN_respond_with_error() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        // Pretend that we are authenticated\n+        when(mockAttr.get()).thenReturn(new RequestContext());\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(\"Destination\", new FrameReader.Message(new byte[0]), FrameReader.FrameType.REQUEST);\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+        verify(ipcRouter, times(1)).getCallbackForDestination(eq(\"Destination\"));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(\"Destination\", responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Destination handler not found\"));\n+    }\n+\n+    @Test\n+    public void GIVEN_authenticated_client_WHEN_request_with_normal_return_THEN_respond_with_message() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        // Pretend that we are authenticated\n+        when(mockAttr.get()).thenReturn(new RequestContext());\n+        // Setup handler for destination\n+        when(ipcRouter.getCallbackForDestination(anyString())).thenReturn((message, ctx) -> {\n+            CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+            fut.complete(new FrameReader.Message(\"Success\".getBytes()));\n+            return fut;\n+        });\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(\"Destination\", new FrameReader.Message(new byte[0]), FrameReader.FrameType.REQUEST);\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+        verify(ipcRouter, times(1)).getCallbackForDestination(eq(\"Destination\"));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(\"Destination\", responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertEquals(\"Success\", new String(responseFrame.message.getPayload()));\n+    }\n+\n+    @Test\n+    public void GIVEN_authenticated_client_WHEN_request_with_exceptional_return_THEN_respond_with_error() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 190}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MTQ0MTcx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#pullrequestreview-354144171", "createdAt": "2020-02-06T01:01:13Z", "commit": {"oid": "0487faf174865d66ed37a559e017c7545ba50652"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMTowMjoyNlrOFmMWjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMTo0Njo1NVrOFmNBVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ==", "bodyText": "Not related to this pull request, but can you change this to not use hardcoded string \"_UID\".", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375592591", "createdAt": "2020-02-06T01:02:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {\n         Topic uid = s.config.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5ODAyNw==", "bodyText": "Not related to this pull request, but I think it's cleaner to move this method into the GenericExternalService class. Not block this pull request though.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375598027", "createdAt": "2020-02-06T01:23:13Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMTg3NQ==", "bodyText": "getOnce() is marked as deprecated. Is this a misuse?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375601875", "createdAt": "2020-02-06T01:39:23Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -46,7 +50,7 @@ public RequestContext doAuth(FrameReader.Message request) throws IPCClientNotAut\n         String authToken = decodedRequest.getRequest();\n \n         // Lookup the provided auth token to associate it with a service (or reject it)\n-        String serviceName = (String) kernel.getRoot().lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();\n+        String serviceName = (String) config.lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMzEyOA==", "bodyText": "Also at line 33, what if the random generated authToken collides with an existing one? Right now it seems it would overwrite the existing one. Isn't that wrong?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375603128", "createdAt": "2020-02-06T01:44:59Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {\n         Topic uid = s.config.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ=="}, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMzU0MQ==", "bodyText": "line 59-60, can you change serviceName to be private and use constructor?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375603541", "createdAt": "2020-02-06T01:46:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -46,7 +50,7 @@ public RequestContext doAuth(FrameReader.Message request) throws IPCClientNotAut\n         String authToken = decodedRequest.getRequest();\n \n         // Lookup the provided auth token to associate it with a service (or reject it)\n-        String serviceName = (String) kernel.getRoot().lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();\n+        String serviceName = (String) config.lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMTg3NQ=="}, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 48}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4da926e04a410557c7a06f6b7dcc68315dc7304f", "committedDate": "2020-02-06T00:51:05Z", "message": "Address PR comments"}, "afterCommit": {"oid": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "committedDate": "2020-02-06T02:01:46Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e42c387d8840ccecea8dc43d6a7b395c1f7e2913", "committedDate": "2020-02-06T02:01:46Z", "message": "Address PR comments"}, "afterCommit": {"oid": "bfab30bd85e2682ad5b2b9c182993313c2c9f84c", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bfab30bd85e2682ad5b2b9c182993313c2c9f84c", "committedDate": "2020-02-06T02:05:37Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0Nzc3OTA3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#pullrequestreview-354777907", "createdAt": "2020-02-06T21:17:10Z", "commit": {"oid": "bfab30bd85e2682ad5b2b9c182993313c2c9f84c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb9322e1c51882e9626a3f4f4a35e4d038174921", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cb9322e1c51882e9626a3f4f4a35e4d038174921", "committedDate": "2020-02-06T23:07:07Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bfab30bd85e2682ad5b2b9c182993313c2c9f84c", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bfab30bd85e2682ad5b2b9c182993313c2c9f84c", "committedDate": "2020-02-06T02:05:37Z", "message": "Address PR comments"}, "afterCommit": {"oid": "cb9322e1c51882e9626a3f4f4a35e4d038174921", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cb9322e1c51882e9626a3f4f4a35e4d038174921", "committedDate": "2020-02-06T23:07:07Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODQzMTk4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#pullrequestreview-354843198", "createdAt": "2020-02-06T23:24:09Z", "commit": {"oid": "cb9322e1c51882e9626a3f4f4a35e4d038174921"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2463, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}