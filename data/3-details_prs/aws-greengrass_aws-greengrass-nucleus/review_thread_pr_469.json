{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyMTIxOTAx", "number": 469, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxOTozODozMFrOEnMRbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToxNTo0OFrOEoOV4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTMwOTg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxOTozODozMFrOHXp4qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMzowMDozMFrOHXzTwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2NTU0NQ==", "bodyText": "Does customer need to explicitly specify LOCAL in versionRequirement?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494565545", "createdAt": "2020-09-24T19:38:30Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTkzOA==", "bodyText": "No, customer doesn't need to. We use LOCAL group for local development, the target components of LOCAL group mean they are local override, so keep using local available version.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494719938", "createdAt": "2020-09-25T03:00:30Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2NTU0NQ=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTQ5MDE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDozMjo0M1rOHXrmWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMzowMzoyNFrOHXzWqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MzYyNw==", "bodyText": "If other group contains a component that's not in the deployed group, will this be also marked as target?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494593627", "createdAt": "2020-09-24T20:32:43Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.componentmanager;\n+\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n+import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n+import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n+import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.model.DeploymentDocument;\n+import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.vdurmont.semver4j.Requirement;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n+\n+@NoArgsConstructor\n+public class SimplifiedDependencyResolver {\n+    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n+\n+    @Inject\n+    private ComponentManager componentManager;\n+\n+    /**\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n+     *\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n+     */\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n+                    .log(\"Found component configuration\");\n+            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n+            componentNameToVersionConstraints.get(e.getPackageName())\n+                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n+            targetComponentsToResolve.add(e.getPackageName());\n+        });\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n+                .kv(\"targetComponents\", targetComponentsToResolve)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Start to resolve group dependencies\");\n+        // resolve target components dependencies\n+        for (String component : targetComponentsToResolve) {\n+            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Finish resolving group dependencies\");\n+        return new ArrayList<>(resolvedComponents.values());\n+    }\n+\n+\n+    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n+                                                       Map<String, Map<String, Requirement>>\n+                                                               componentNameToVersionConstraints) {\n+        Set<String> targetComponents = new HashSet<>();\n+        groupToTargetComponentDetails.forEach(node -> {\n+            Topics groupTopics = (Topics) node;\n+            String groupName = groupTopics.getName();\n+            if (!groupName.equals(deploymentGroupName)) {\n+                groupTopics.forEach(componentTopic -> {\n+                    targetComponents.add(componentTopic.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMDY4Mw==", "bodyText": "Yes, the purpose of these piece of code is to retrieve the other groups' target components. They should be resolved (including their dependencies) and running on the device at the time.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494720683", "createdAt": "2020-09-25T03:03:24Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.componentmanager;\n+\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n+import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n+import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n+import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.model.DeploymentDocument;\n+import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.vdurmont.semver4j.Requirement;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n+\n+@NoArgsConstructor\n+public class SimplifiedDependencyResolver {\n+    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n+\n+    @Inject\n+    private ComponentManager componentManager;\n+\n+    /**\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n+     *\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n+     */\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n+                    .log(\"Found component configuration\");\n+            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n+            componentNameToVersionConstraints.get(e.getPackageName())\n+                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n+            targetComponentsToResolve.add(e.getPackageName());\n+        });\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n+                .kv(\"targetComponents\", targetComponentsToResolve)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Start to resolve group dependencies\");\n+        // resolve target components dependencies\n+        for (String component : targetComponentsToResolve) {\n+            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Finish resolving group dependencies\");\n+        return new ArrayList<>(resolvedComponents.values());\n+    }\n+\n+\n+    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n+                                                       Map<String, Map<String, Requirement>>\n+                                                               componentNameToVersionConstraints) {\n+        Set<String> targetComponents = new HashSet<>();\n+        groupToTargetComponentDetails.forEach(node -> {\n+            Topics groupTopics = (Topics) node;\n+            String groupName = groupTopics.getName();\n+            if (!groupName.equals(deploymentGroupName)) {\n+                groupTopics.forEach(componentTopic -> {\n+                    targetComponents.add(componentTopic.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MzYyNw=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTUwODUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMDozODoxNFrOHXrxVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMzowNzoxMVrOHXzaMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NjQzOQ==", "bodyText": "componentNameToVersionConstraints doesn't have the deployment doc added yet. Why can you resolve component dependencies here? What if the versionConstraints of a component in deployment doc is conflicting with other component version requirement?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494596439", "createdAt": "2020-09-24T20:38:14Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.componentmanager;\n+\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n+import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n+import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n+import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.model.DeploymentDocument;\n+import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.vdurmont.semver4j.Requirement;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n+\n+@NoArgsConstructor\n+public class SimplifiedDependencyResolver {\n+    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n+\n+    @Inject\n+    private ComponentManager componentManager;\n+\n+    /**\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n+     *\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n+     */\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n+                    .log(\"Found component configuration\");\n+            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n+            componentNameToVersionConstraints.get(e.getPackageName())\n+                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n+            targetComponentsToResolve.add(e.getPackageName());\n+        });\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n+                .kv(\"targetComponents\", targetComponentsToResolve)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Start to resolve group dependencies\");\n+        // resolve target components dependencies\n+        for (String component : targetComponentsToResolve) {\n+            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Finish resolving group dependencies\");\n+        return new ArrayList<>(resolvedComponents.values());\n+    }\n+\n+\n+    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n+                                                       Map<String, Map<String, Requirement>>\n+                                                               componentNameToVersionConstraints) {\n+        Set<String> targetComponents = new HashSet<>();\n+        groupToTargetComponentDetails.forEach(node -> {\n+            Topics groupTopics = (Topics) node;\n+            String groupName = groupTopics.getName();\n+            if (!groupName.equals(deploymentGroupName)) {\n+                groupTopics.forEach(componentTopic -> {\n+                    targetComponents.add(componentTopic.getName());\n+                    componentNameToVersionConstraints.putIfAbsent(componentTopic.getName(), new HashMap<>());\n+                    Map<Object, Object> componentDetails = (Map) componentTopic.toPOJO();\n+                    componentNameToVersionConstraints.get(componentTopic.getName()).put(groupName, Requirement\n+                            .buildNPM(componentDetails.get(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).toString()));\n+                });\n+            }\n+        });\n+\n+        return targetComponents;\n+    }\n+\n+    private Map<String, ComponentIdentifier> populateOtherGroupsComponentsDependencies(\n+            Topics groupToTargetComponentDetails, String deploymentGroupName,\n+            Map<String, Map<String, Requirement>> componentNameToVersionConstraints) throws PackagingException {\n+        Set<String> otherGroupTargetComponents =\n+                getOtherGroupsTargetComponents(groupToTargetComponentDetails, deploymentGroupName,\n+                        componentNameToVersionConstraints);\n+        logger.atDebug().kv(\"otherGroupTargets\", otherGroupTargetComponents)\n+                .log(\"Found the other group target components\");\n+        // populate other groups target components dependencies\n+        // retrieve only dependency active version, update version requirement map\n+        Map<String, ComponentIdentifier> resolvedComponent = new HashMap<>();\n+        for (String targetComponent : otherGroupTargetComponents) {\n+            resolvedComponent.putAll(resolveComponentDependencies(targetComponent, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager\n+                            .getActiveAndSatisfiedComponentMetadata(name, requirements)));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMTU4NQ==", "bodyText": "For the other groups, their dependencies should already be resolved and running on the device. The purpose of this iteration is to 1) build component to version requirements map because current deploying group can have common dependencies with the other groups; 2) get the other groups' resolved version because dependency resolver is supposed to return the full list of components.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494721585", "createdAt": "2020-09-25T03:07:11Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.componentmanager;\n+\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n+import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n+import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n+import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.model.DeploymentDocument;\n+import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.vdurmont.semver4j.Requirement;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n+\n+@NoArgsConstructor\n+public class SimplifiedDependencyResolver {\n+    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n+\n+    @Inject\n+    private ComponentManager componentManager;\n+\n+    /**\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n+     *\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n+     */\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n+                    .log(\"Found component configuration\");\n+            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n+            componentNameToVersionConstraints.get(e.getPackageName())\n+                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n+            targetComponentsToResolve.add(e.getPackageName());\n+        });\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n+                .kv(\"targetComponents\", targetComponentsToResolve)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Start to resolve group dependencies\");\n+        // resolve target components dependencies\n+        for (String component : targetComponentsToResolve) {\n+            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Finish resolving group dependencies\");\n+        return new ArrayList<>(resolvedComponents.values());\n+    }\n+\n+\n+    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n+                                                       Map<String, Map<String, Requirement>>\n+                                                               componentNameToVersionConstraints) {\n+        Set<String> targetComponents = new HashSet<>();\n+        groupToTargetComponentDetails.forEach(node -> {\n+            Topics groupTopics = (Topics) node;\n+            String groupName = groupTopics.getName();\n+            if (!groupName.equals(deploymentGroupName)) {\n+                groupTopics.forEach(componentTopic -> {\n+                    targetComponents.add(componentTopic.getName());\n+                    componentNameToVersionConstraints.putIfAbsent(componentTopic.getName(), new HashMap<>());\n+                    Map<Object, Object> componentDetails = (Map) componentTopic.toPOJO();\n+                    componentNameToVersionConstraints.get(componentTopic.getName()).put(groupName, Requirement\n+                            .buildNPM(componentDetails.get(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).toString()));\n+                });\n+            }\n+        });\n+\n+        return targetComponents;\n+    }\n+\n+    private Map<String, ComponentIdentifier> populateOtherGroupsComponentsDependencies(\n+            Topics groupToTargetComponentDetails, String deploymentGroupName,\n+            Map<String, Map<String, Requirement>> componentNameToVersionConstraints) throws PackagingException {\n+        Set<String> otherGroupTargetComponents =\n+                getOtherGroupsTargetComponents(groupToTargetComponentDetails, deploymentGroupName,\n+                        componentNameToVersionConstraints);\n+        logger.atDebug().kv(\"otherGroupTargets\", otherGroupTargetComponents)\n+                .log(\"Found the other group target components\");\n+        // populate other groups target components dependencies\n+        // retrieve only dependency active version, update version requirement map\n+        Map<String, ComponentIdentifier> resolvedComponent = new HashMap<>();\n+        for (String targetComponent : otherGroupTargetComponents) {\n+            resolvedComponent.putAll(resolveComponentDependencies(targetComponent, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager\n+                            .getActiveAndSatisfiedComponentMetadata(name, requirements)));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NjQzOQ=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTU4NjE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMTowMjoxMVrOHXsgYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToxMTo0MFrOHZMCzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg==", "bodyText": "Is this the entire recipe content string match? Will version check be simpler?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494608482", "createdAt": "2020-09-24T21:02:11Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMTg4NA==", "bodyText": "It needs to do content comparison because private registry name occlusion feature - private is same version as public, but private needs to replace public.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494721884", "createdAt": "2020-09-25T03:08:25Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODEwNg==", "bodyText": "It also has the additional benefit (implicitly) to recover mutated/corrupted recipe...", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495188106", "createdAt": "2020-09-25T19:25:13Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3Mzc3Mg==", "bodyText": "I'd prefer jsonNode object comparison. But that can be implemented later", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496173772", "createdAt": "2020-09-28T19:11:40Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTYzNDI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMToxNzo0N1rOHXs90g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMzoyMjowNVrOHXzoXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA==", "bodyText": "What is the sort based on?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494616018", "createdAt": "2020-09-24T21:17:47Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -209,6 +210,39 @@ ComponentMetadata getPackageMetadata(@NonNull ComponentIdentifier pkgId) throws\n         return componentMetadataList;\n     }\n \n+    Optional<ComponentIdentifier> findBestMatchAvailableComponent(@NonNull String componentName,\n+                                                                  @NonNull Requirement requirement)\n+            throws PackageLoadingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Optional.empty();\n+        }\n+\n+        Arrays.sort(recipeFiles);\n+\n+        List<ComponentIdentifier> componentIdentifierList = new ArrayList<>();\n+        for (File recipeFile : recipeFiles) {\n+            String recipeComponentName = parsePackageNameFromFileName(recipeFile.getName());\n+\n+            if (!recipeComponentName.equalsIgnoreCase(componentName)) {\n+                continue;\n+            }\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+            if (requirement.isSatisfiedBy(version)) {\n+                componentIdentifierList.add(new ComponentIdentifier(componentName, version));\n+            }\n+        }\n+        componentIdentifierList.sort(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMjEyOQ==", "bodyText": "based upon semver ordering implemented in Semver4j library which will ensure 1.10 > 1.9 :)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494722129", "createdAt": "2020-09-25T03:09:31Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -209,6 +210,39 @@ ComponentMetadata getPackageMetadata(@NonNull ComponentIdentifier pkgId) throws\n         return componentMetadataList;\n     }\n \n+    Optional<ComponentIdentifier> findBestMatchAvailableComponent(@NonNull String componentName,\n+                                                                  @NonNull Requirement requirement)\n+            throws PackageLoadingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Optional.empty();\n+        }\n+\n+        Arrays.sort(recipeFiles);\n+\n+        List<ComponentIdentifier> componentIdentifierList = new ArrayList<>();\n+        for (File recipeFile : recipeFiles) {\n+            String recipeComponentName = parsePackageNameFromFileName(recipeFile.getName());\n+\n+            if (!recipeComponentName.equalsIgnoreCase(componentName)) {\n+                continue;\n+            }\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+            if (requirement.isSatisfiedBy(version)) {\n+                componentIdentifierList.add(new ComponentIdentifier(componentName, version));\n+            }\n+        }\n+        componentIdentifierList.sort(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMjYxMA==", "bodyText": "Default sort is ascending order, so the latest version would be last. Is that what you are expecting?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494722610", "createdAt": "2020-09-25T03:11:18Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -209,6 +210,39 @@ ComponentMetadata getPackageMetadata(@NonNull ComponentIdentifier pkgId) throws\n         return componentMetadataList;\n     }\n \n+    Optional<ComponentIdentifier> findBestMatchAvailableComponent(@NonNull String componentName,\n+                                                                  @NonNull Requirement requirement)\n+            throws PackageLoadingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Optional.empty();\n+        }\n+\n+        Arrays.sort(recipeFiles);\n+\n+        List<ComponentIdentifier> componentIdentifierList = new ArrayList<>();\n+        for (File recipeFile : recipeFiles) {\n+            String recipeComponentName = parsePackageNameFromFileName(recipeFile.getName());\n+\n+            if (!recipeComponentName.equalsIgnoreCase(componentName)) {\n+                continue;\n+            }\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+            if (requirement.isSatisfiedBy(version)) {\n+                componentIdentifierList.add(new ComponentIdentifier(componentName, version));\n+            }\n+        }\n+        componentIdentifierList.sort(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNTIxNA==", "bodyText": "I want descending order. I think you override ComponentIdentifier::compareTo method, so now it's sorted in descending order.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494725214", "createdAt": "2020-09-25T03:22:05Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -209,6 +210,39 @@ ComponentMetadata getPackageMetadata(@NonNull ComponentIdentifier pkgId) throws\n         return componentMetadataList;\n     }\n \n+    Optional<ComponentIdentifier> findBestMatchAvailableComponent(@NonNull String componentName,\n+                                                                  @NonNull Requirement requirement)\n+            throws PackageLoadingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Optional.empty();\n+        }\n+\n+        Arrays.sort(recipeFiles);\n+\n+        List<ComponentIdentifier> componentIdentifierList = new ArrayList<>();\n+        for (File recipeFile : recipeFiles) {\n+            String recipeComponentName = parsePackageNameFromFileName(recipeFile.getName());\n+\n+            if (!recipeComponentName.equalsIgnoreCase(componentName)) {\n+                continue;\n+            }\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+            if (requirement.isSatisfiedBy(version)) {\n+                componentIdentifierList.add(new ComponentIdentifier(componentName, version));\n+            }\n+        }\n+        componentIdentifierList.sort(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTY0OTQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMToyMjo0NFrOHXtGxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMzoxMToyN1rOHXzeUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxODMwOA==", "bodyText": "Does it mean findComponentRecipeContent() can return file name instead of file content?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494618308", "createdAt": "2020-09-24T21:22:44Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -98,25 +98,27 @@ void savePackageRecipe(@NonNull ComponentIdentifier pkgId, String recipeContent)\n      * @throws PackageLoadingException if fails to parse the recipe file.\n      */\n     Optional<ComponentRecipe> findPackageRecipe(@NonNull ComponentIdentifier pkgId) throws PackageLoadingException {\n-        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+        Optional<String> recipeContent = findComponentRecipeContent(pkgId);\n+\n+        return recipeContent.isPresent() ? RecipeLoader.loadFromFile(recipeContent.get()) : Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMjY0Mw==", "bodyText": "As mentioned above, it needs content comparison to support name occlusion feature.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494722643", "createdAt": "2020-09-25T03:11:27Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -98,25 +98,27 @@ void savePackageRecipe(@NonNull ComponentIdentifier pkgId, String recipeContent)\n      * @throws PackageLoadingException if fails to parse the recipe file.\n      */\n     Optional<ComponentRecipe> findPackageRecipe(@NonNull ComponentIdentifier pkgId) throws PackageLoadingException {\n-        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+        Optional<String> recipeContent = findComponentRecipeContent(pkgId);\n+\n+        return recipeContent.isPresent() ? RecipeLoader.loadFromFile(recipeContent.get()) : Optional.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxODMwOA=="}, "originalCommit": {"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTMzNjEzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOToyMDoxM1rOHYPwCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOToyNjoyMVrOHYP6yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NTkzMA==", "bodyText": "Just to point out that this changes from the existing behavior for \"currently running version will be retained\". The new behavior for currently running version might not be retained - depend on cloud's result. I think that's what we want (so that transitive dependencies could be auto bumped for newer version within the specified version range...) Just double check on this change of behavior", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495185930", "createdAt": "2020-09-25T19:20:13Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +147,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5094d0c393254a8459ae93a87757d270885e2488"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODY4MQ==", "bodyText": "yes, that is what we want. By launch, we have the process alway trying to update to the latest versions of dependencies. Next, we will consider adding options to let customer keep the existing running version.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495188681", "createdAt": "2020-09-25T19:26:21Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +147,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NTkzMA=="}, "originalCommit": {"oid": "5094d0c393254a8459ae93a87757d270885e2488"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM0Mzg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOToyMzowOVrOHYP04w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOToyOTo0NlrOHYQApA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NzE3MQ==", "bodyText": "Sorry didn't thought about when looking at the code yesterday - should we just skip calling cloud if it's a builtin service?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495187171", "createdAt": "2020-09-25T19:23:09Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +147,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5094d0c393254a8459ae93a87757d270885e2488"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MDE4MA==", "bodyText": "I am thinking if it has recipes in cloud, it could be updated.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495190180", "createdAt": "2020-09-25T19:29:46Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +147,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NzE3MQ=="}, "originalCommit": {"oid": "5094d0c393254a8459ae93a87757d270885e2488"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTc4MjIzOnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozMzozM1rOHZIxag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozMzozM1rOHZIxag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMDE3MA==", "bodyText": "Temporarily lower integration test coverage ratio since the new DR process is not integrated into the deployment workflow yet. Once switch to the new process, the coverage will be resumed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496120170", "createdAt": "2020-09-28T17:33:33Z", "author": {"login": "wikimonkey"}, "path": "pom.xml", "diffHunk": "@@ -469,12 +469,12 @@\n                                         <limit>\n                                             <counter>INSTRUCTION</counter>\n                                             <value>COVEREDRATIO</value>\n-                                            <minimum>0.59</minimum>\n+                                            <minimum>0.58</minimum>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjEyNTYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToxMzowN1rOHZMFtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTozNjowMVrOHZMzyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NDUxNg==", "bodyText": "NIT: add a comment. requirementMap is a groupId->requirement map", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496174516", "createdAt": "2020-09-28T19:13:07Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -333,6 +418,32 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n         }\n     }\n \n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NjMxMw==", "bodyText": "will add", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496186313", "createdAt": "2020-09-28T19:36:01Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -333,6 +418,32 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n         }\n     }\n \n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NDUxNg=="}, "originalCommit": {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjEzMTc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToxNDo1NlrOHZMJag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTo0OToxN1rOHZNOjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTQ2Ng==", "bodyText": "How is this different from findActiveAndSatisfiedPackageMetadata?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496175466", "createdAt": "2020-09-28T19:14:56Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -333,6 +418,32 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n         }\n     }\n \n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n+                                                             Map<String, Requirement> requirementMap)\n+            throws PackagingException {\n+        return getActiveAndSatisfiedComponentMetadata(componentName, mergeVersionRequirements(requirementMap));\n+    }\n+\n+    private ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName, Requirement requirement)\n+            throws PackagingException {\n+        Optional<ComponentMetadata> componentMetadataOptional =\n+                findActiveAndSatisfiedPackageMetadata(componentName, requirement);\n+        if (!componentMetadataOptional.isPresent()) {\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"There is no version of component %s satisfying %s\", componentName, requirement));\n+        }\n+\n+        return componentMetadataOptional.get();\n+    }\n+\n+    private Optional<ComponentIdentifier> findActiveAndSatisfiedComponent(String componentName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NTg3OA==", "bodyText": "this returns component identifier, no need to read recipe from file. findActiveAndSatisfiedPackageMetadata  will be cleaned out once we made the switch.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496185878", "createdAt": "2020-09-28T19:35:07Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -333,6 +418,32 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n         }\n     }\n \n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n+                                                             Map<String, Requirement> requirementMap)\n+            throws PackagingException {\n+        return getActiveAndSatisfiedComponentMetadata(componentName, mergeVersionRequirements(requirementMap));\n+    }\n+\n+    private ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName, Requirement requirement)\n+            throws PackagingException {\n+        Optional<ComponentMetadata> componentMetadataOptional =\n+                findActiveAndSatisfiedPackageMetadata(componentName, requirement);\n+        if (!componentMetadataOptional.isPresent()) {\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"There is no version of component %s satisfying %s\", componentName, requirement));\n+        }\n+\n+        return componentMetadataOptional.get();\n+    }\n+\n+    private Optional<ComponentIdentifier> findActiveAndSatisfiedComponent(String componentName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTQ2Ng=="}, "originalCommit": {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5MzE2NA==", "bodyText": "Ok. you can add @deprecated on findActiveAndSatisfiedPackageMetadata later", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496193164", "createdAt": "2020-09-28T19:49:17Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -333,6 +418,32 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n         }\n     }\n \n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n+                                                             Map<String, Requirement> requirementMap)\n+            throws PackagingException {\n+        return getActiveAndSatisfiedComponentMetadata(componentName, mergeVersionRequirements(requirementMap));\n+    }\n+\n+    private ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName, Requirement requirement)\n+            throws PackagingException {\n+        Optional<ComponentMetadata> componentMetadataOptional =\n+                findActiveAndSatisfiedPackageMetadata(componentName, requirement);\n+        if (!componentMetadataOptional.isPresent()) {\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"There is no version of component %s satisfying %s\", componentName, requirement));\n+        }\n+\n+        return componentMetadataOptional.get();\n+    }\n+\n+    private Optional<ComponentIdentifier> findActiveAndSatisfiedComponent(String componentName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTQ2Ng=="}, "originalCommit": {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjEzNDczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOToxNTo0OFrOHZMLIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTozNTo1MlrOHZMzgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTkwNg==", "bodyText": "This can be in the platform resolver class. Also add a TODO to add osVersion", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496175906", "createdAt": "2020-09-28T19:15:48Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -90,6 +101,42 @@ public ComponentServiceHelper(GreengrassComponentServiceClientFactory clientFact\n         return ret;\n     }\n \n+    // Even though the cloud API signature can take a list of components at the same dependency level to resolve, the\n+    // algorithm is going through the dependencies node by node, so one time one component got resolved.\n+    ComponentContent resolveComponentVersion(String componentName, Semver localCandidateVersion,\n+                                             Map<String, Requirement> versionRequirements)\n+            throws NoAvailableComponentVersionException, ComponentVersionNegotiationException {\n+\n+        ComponentPlatform platform = new ComponentPlatform().withOs(PlatformResolver.CURRENT_PLATFORM.getOs().getName())\n+                .withArchitecture(PlatformResolver.CURRENT_PLATFORM.getArchitecture().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NjI0Mg==", "bodyText": "I would rather keep it here because ComponentPlatform is GCS coral object. Will add comment.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496186242", "createdAt": "2020-09-28T19:35:52Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -90,6 +101,42 @@ public ComponentServiceHelper(GreengrassComponentServiceClientFactory clientFact\n         return ret;\n     }\n \n+    // Even though the cloud API signature can take a list of components at the same dependency level to resolve, the\n+    // algorithm is going through the dependencies node by node, so one time one component got resolved.\n+    ComponentContent resolveComponentVersion(String componentName, Semver localCandidateVersion,\n+                                             Map<String, Requirement> versionRequirements)\n+            throws NoAvailableComponentVersionException, ComponentVersionNegotiationException {\n+\n+        ComponentPlatform platform = new ComponentPlatform().withOs(PlatformResolver.CURRENT_PLATFORM.getOs().getName())\n+                .withArchitecture(PlatformResolver.CURRENT_PLATFORM.getArchitecture().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTkwNg=="}, "originalCommit": {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 553, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}