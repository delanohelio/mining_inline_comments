{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5ODg1OTE3", "number": 75, "title": "Package Manager Dependency Resolution", "bodyText": "Issue #, if available:\nDescription of changes:\nPackage dependency resolution impl with overall package manager resolve packages flow.\nSend for merging the others work into the flow, such as recipe downloading.\nMany more package dependency resolution test cases are to be added. But at least it works for this sprint's demo case.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-02-25T23:47:23Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75", "merged": true, "mergeCommit": {"oid": "3b39a0c2c794cd5281874afb7df8bc19374c0a69"}, "closed": true, "closedAt": "2020-02-27T04:40:32Z", "author": {"login": "wikimonkey"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcH7C3igBqjMwNzE1MTI4MTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcITnLeAH2gAyMzc5ODg1OTE3OjE0NmFmYzg1ZDlmMWM0YzNmMDEyNzk3NzAzZmE3MTlhNGFlOWE4Mjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8eaf5250fac6c785d54f883f35ded1fd04d32ceb", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8eaf5250fac6c785d54f883f35ded1fd04d32ceb", "committedDate": "2020-02-25T23:43:28Z", "message": "package manager API definition"}, "afterCommit": {"oid": "33228fe81b27d37d2762684bca84d9921090e92f", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/33228fe81b27d37d2762684bca84d9921090e92f", "committedDate": "2020-02-25T23:50:38Z", "message": "package manager API definition"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTM4NTc3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-364538577", "createdAt": "2020-02-26T00:02:43Z", "commit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowMjo0M1rOFuZzUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowMjo0M1rOFuZzUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMTU1NQ==", "bodyText": "Just use @value as mentioned in previous PR?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384201555", "createdAt": "2020-02-26T00:02:43Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageMetadata.java", "diffHunk": "@@ -2,29 +2,26 @@\n \n import com.aws.iot.evergreen.util.Utils;\n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n import java.util.Collections;\n import java.util.Set;\n \n @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTQwNTcw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-364540570", "createdAt": "2020-02-26T00:08:03Z", "commit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowODowNFrOFuZ6Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowODowNFrOFuZ6Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzI5NA==", "bodyText": "Same as above, use @value and @Setter?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384203294", "createdAt": "2020-02-26T00:08:04Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTQxMDMz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-364541033", "createdAt": "2020-02-26T00:09:22Z", "commit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowOToyMlrOFuZ7rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowOToyMlrOFuZ7rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzY5Mg==", "bodyText": "Should be final? Any changes during dependency resolution will show up in the output in the final Package object I think.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384203692", "createdAt": "2020-02-26T00:09:22Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter\n+@Setter\n @ToString\n-@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n @EqualsAndHashCode(onlyExplicitlyIncluded = true)\n public class PackageRegistryEntry {\n \n     @EqualsAndHashCode.Include\n-    String name;\n+    private final String name;\n \n     @EqualsAndHashCode.Include\n-    Semver version;\n+    private Semver version;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTQxMzgw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-364541380", "createdAt": "2020-02-26T00:10:29Z", "commit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMDoyOVrOFuZ9Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMDoyOVrOFuZ9Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDA1MA==", "bodyText": "we should still check and make sure the incoming semver is of type npm", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384204050", "createdAt": "2020-02-26T00:10:29Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter\n+@Setter\n @ToString\n-@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n @EqualsAndHashCode(onlyExplicitlyIncluded = true)\n public class PackageRegistryEntry {\n \n     @EqualsAndHashCode.Include\n-    String name;\n+    private final String name;\n \n     @EqualsAndHashCode.Include\n-    Semver version;\n+    private Semver version;\n \n-    Set<Reference> dependBy;\n+    private final Map<String, Reference> dependsBy;\n \n-    Set<Reference> dependOn;\n+    private final Map<String, Reference> dependsOn;\n \n-    public PackageRegistryEntry(String name, String version) {\n+    public PackageRegistryEntry(String name, Semver version, Map<String, Reference> dependsBy) {\n         this.name = name;\n-        this.version = new Semver(version, Semver.SemverType.NPM);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTQxNjA5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-364541609", "createdAt": "2020-02-26T00:11:06Z", "commit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMTowNlrOFuZ92g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMTowNlrOFuZ92g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDI1MA==", "bodyText": "Same questions as above.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384204250", "createdAt": "2020-02-26T00:11:06Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter\n+@Setter\n @ToString\n-@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n @EqualsAndHashCode(onlyExplicitlyIncluded = true)\n public class PackageRegistryEntry {\n \n     @EqualsAndHashCode.Include\n-    String name;\n+    private final String name;\n \n     @EqualsAndHashCode.Include\n-    Semver version;\n+    private Semver version;\n \n-    Set<Reference> dependBy;\n+    private final Map<String, Reference> dependsBy;\n \n-    Set<Reference> dependOn;\n+    private final Map<String, Reference> dependsOn;\n \n-    public PackageRegistryEntry(String name, String version) {\n+    public PackageRegistryEntry(String name, Semver version, Map<String, Reference> dependsBy) {\n         this.name = name;\n-        this.version = new Semver(version, Semver.SemverType.NPM);\n-        this.dependBy = new HashSet<>();\n-        this.dependOn = new HashSet<>();\n+        this.version = version;\n+        this.dependsBy = dependsBy;\n+        this.dependsOn = new HashMap<>();\n     }\n \n-    @Getter\n-    @ToString\n-    @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)\n-    @EqualsAndHashCode\n+    @Data\n+    @AllArgsConstructor\n     public static class Reference {\n-        String name;\n+        private final String name;\n \n-        Semver version;\n+        private Semver version;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTMzOTMw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-364533930", "createdAt": "2020-02-25T23:51:04Z", "commit": {"oid": "8eaf5250fac6c785d54f883f35ded1fd04d32ceb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo1MTowNFrOFuZjbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxMToyM1rOFuZ-Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NzQ4NQ==", "bodyText": "[nit]\nRemove unnecessary whitespace.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384197485", "createdAt": "2020-02-25T23:51:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8eaf5250fac6c785d54f883f35ded1fd04d32ceb"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5OTQ4Nw==", "bodyText": "If this doesn't absolute need to be a single thread, then just get an executor using @Inject so that the Context will provide it to you.\nProbably all these fields should be final too.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384199487", "createdAt": "2020-02-25T23:56:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33228fe81b27d37d2762684bca84d9921090e92f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMDQ5OA==", "bodyText": "Why is the package manager storing the proposed packages as a field? This would seem to be something which is specific to deployment, and really should not be a field but passed as a parameter.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384200498", "createdAt": "2020-02-25T23:59:38Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMDk5Mw==", "bodyText": "Can we get a reasonable message here about what is conflicting?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384200993", "createdAt": "2020-02-26T00:01:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjAwNg==", "bodyText": "Why is this correct? If we're using a new version of a package, why are we pulling the dependencies from the currently installed version?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384202006", "createdAt": "2020-02-26T00:04:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjQ4MA==", "bodyText": "Why is the version null?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384202480", "createdAt": "2020-02-26T00:05:35Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());\n+                devicePackages.put(proposedPackage.getName(), devicePackage);\n+\n+                for (PackageMetadata proposedDependency : proposedPackage.getDependsOn()) {\n+                    devicePackage.getDependsOn().put(proposedDependency.getName(),\n+                            new PackageRegistryEntry.Reference(proposedDependency.getName(), null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzUxMQ==", "bodyText": "Where'd all the comments go? The section above wait more readable. This section is quite tricky and I would benefit greatly from more comments IMO.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384203511", "createdAt": "2020-02-26T00:08:47Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDAzMQ==", "bodyText": "All JavaDoc needs two asterisks /**.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384204031", "createdAt": "2020-02-26T00:10:24Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),\n+                        devicePackage == null ? new HashMap<>() : devicePackage.getDependsBy());\n+                devicePackages.put(proposedPackage.getName(), devicePackage);\n+\n+                for (PackageMetadata proposedDependency : proposedPackage.getDependsOn()) {\n+                    devicePackage.getDependsOn().put(proposedDependency.getName(),\n+                            new PackageRegistryEntry.Reference(proposedDependency.getName(), null,\n+                                    proposedDependency.getVersionConstraint()));\n+\n+                    PackageRegistryEntry dependencyPackageEntry = devicePackages.get(proposedDependency.getName());\n+                    if (dependencyPackageEntry == null) {\n+                        dependencyPackageEntry =\n+                                new PackageRegistryEntry(proposedDependency.getName(), null, new HashMap<>());\n+                        devicePackages.put(proposedDependency.getName(), dependencyPackageEntry);\n+                    }\n+                    PackageRegistryEntry.Reference dependBy =\n+                            dependencyPackageEntry.getDependsBy().get(proposedPackage.getName());\n+                    if (dependBy != null) {\n+                        dependBy.setVersion(proposedPackage.getVersion());\n+                        dependBy.setConstraint(proposedPackage.getVersionConstraint());\n+                    } else {\n+                        dependencyPackageEntry.getDependsBy().put(proposedPackage.getName(),\n+                                new PackageRegistryEntry.Reference(proposedPackage.getName(),\n+                                        proposedPackage.getVersion(), proposedDependency.getVersionConstraint()));\n+                    }\n+\n+                    processingQueue.offer(proposedDependency);\n+                }\n+            }\n+\n+            // third to update its dependent\n+            for (PackageRegistryEntry.Reference dependBy : devicePackage.getDependsBy().values()) {\n+                PackageRegistryEntry dependent = devicePackages.get(dependBy.getName());\n+                PackageRegistryEntry.Reference reference = dependent.getDependsOn().get(devicePackage.getName());\n+                if (reference.getVersion() == null || !reference.getVersion().isEqualTo(devicePackage.getVersion())) {\n+                    reference.setVersion(devicePackage.getVersion());\n+                }\n+            }\n+        }\n+    }\n+\n+    /*\n+     * Given a set of pending refresh packages, download the package recipes and artifacts in background\n+     * Return the packages got successfully downloaded\n+     */\n+    private Set<PackageRegistryEntry> downloadPackages(Set<PackageRegistryEntry> pendingDownloadPackages) {\n         return null;\n     }\n \n+    /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNDMzMA==", "bodyText": "Please add JavaDoc to all public interfaces.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384204330", "createdAt": "2020-02-26T00:11:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageRegistry.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+\n+import java.util.List;\n+\n+public interface PackageRegistry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTQyOTAw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-364542900", "createdAt": "2020-02-26T00:14:48Z", "commit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxNDo0OFrOFuaERg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxNDo0OFrOFuaERg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNTg5NA==", "bodyText": "Might be better to just store the entire package object after resolution based on the whiteboard discussion", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384205894", "createdAt": "2020-02-26T00:14:48Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageRegistry.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+\n+import java.util.List;\n+\n+public interface PackageRegistry {\n+\n+    List<PackageRegistryEntry> findActivePackages();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTQzODI4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-364543828", "createdAt": "2020-02-26T00:17:12Z", "commit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxNzoxM1rOFuaHzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoxNzoxM1rOFuaHzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwNjc5Ng==", "bodyText": "Return is being ignored here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384206796", "createdAt": "2020-02-26T00:17:13Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTQ2NzAy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-364546702", "createdAt": "2020-02-26T00:25:31Z", "commit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoyNTozMVrOFuaRtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDoyNTozMVrOFuaRtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwOTMzNA==", "bodyText": "Based on the incoming request, devicePackages is actually the active packages currently on device right? Not the full contents of the cache?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384209334", "createdAt": "2020-02-26T00:25:31Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "abadc3b797670c97ea3e6cc32c689265b54dedf4", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/abadc3b797670c97ea3e6cc32c689265b54dedf4", "committedDate": "2020-02-26T03:01:12Z", "message": "handle some comments"}, "afterCommit": {"oid": "c4bd245237887e1d1cad8784ba06be1939f9e710", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c4bd245237887e1d1cad8784ba06be1939f9e710", "committedDate": "2020-02-26T06:34:33Z", "message": "handle some comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDM2NDAx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365036401", "createdAt": "2020-02-26T16:13:27Z", "commit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjoxMzoyN1rOFuyGsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjoxMzoyN1rOFuyGsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTczMA==", "bodyText": "Since these are PackageRegistry related, do you think some of this can be abstracted out and moved into the package registry? It feels like this method is doing too much bookkeeping in addition to the resolution. I think it should be easier to read if it just did resolution and then let the registry update the DB for bookkeeping.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384599730", "createdAt": "2020-02-26T16:13:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"\n+                                    + \" dependent %s constraint\", proposedPackage, dependsBy));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTM2Mzk1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365136395", "createdAt": "2020-02-26T18:26:42Z", "commit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyNjo0MlrOFu2_RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxODoyNzozN1rOFu3BLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3OTc0OA==", "bodyText": "Why adding final? Our code style guidelines say to keep things as non-final unless it is a risk. Do you think there's a risk here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384679748", "createdAt": "2020-02-26T18:26:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MDIzOQ==", "bodyText": "This isn't control flow though, you're doing data manipulations here, which is why I suggested moving it to the registry class. At this point, the control is basically done since you know what version of that package you'll be using.\nAlso you told me earlier that that PackageRegistryEntry and Reference were only for the database, so why should the package manager be manipulating these data objects? It seems that that job should be handled only by the package registry.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384680239", "createdAt": "2020-02-26T18:27:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"\n+                                    + \" dependent %s constraint\", proposedPackage, dependsBy));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTczMA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 108}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "153cbad0cfb1fd9774d9676d6df724ad9b17f188", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/153cbad0cfb1fd9774d9676d6df724ad9b17f188", "committedDate": "2020-02-26T18:39:13Z", "message": "checkstyle, renaming"}, "afterCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/52d4846befa64a44c00e3b059d4f6750ee9cad9a", "committedDate": "2020-02-26T18:40:25Z", "message": "checkstyle, renaming"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTc4OTEy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365178912", "createdAt": "2020-02-26T19:28:42Z", "commit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOToyODo0MlrOFu5Ciw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDoyMDo1MlrOFu60RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMzM1NQ==", "bodyText": "nit: ...List -> ...Map?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384713355", "createdAt": "2020-02-26T19:28:42Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxODQ0NA==", "bodyText": "Not sure if this condition will actually occur.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384718444", "createdAt": "2020-02-26T19:37:13Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0MjQ2OA==", "bodyText": "I agree with Michael. I find this block of code pretty difficult to read. It's probably cleaner to abstract the operations on PackageRegistryEntry to separate methods on PackageRegistry. For example, you can have method like:\n// Probably bad name, for explanation purpose.\nClass PackageVersion {\n    String packageName;\n    SemVer version;\n    String versionConstraint;\n}\nList<PackageVersion> getDependencies(PackageVersion pkg);\nvoid addDependency(PackageVersion depender, PackageVersion dependee);\nvoid removeDependency(PackageVersion depender, PackageVersion dependee);\nboolean dependOn(PackageVersion depender, PackageVersion dependee);\nList<PackageVersion> findConflictDependency(PackageVersion pkg1, PackageVersion pkg2);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384742468", "createdAt": "2020-02-26T20:20:52Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"\n+                                    + \" dependent %s constraint\", proposedPackage, dependsBy));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {\n+                devicePackage = new PackageRegistryEntry(proposedPackage.getName(), proposedPackage.getVersion(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTczMA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjQ2OTE4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365246918", "createdAt": "2020-02-26T21:14:46Z", "commit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxNDo0NlrOFu8dPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToxNDo0NlrOFu8dPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTM0Mg==", "bodyText": "Would anyone outside package manager need to know how the registry is initialized? If not we could initialize that inline here instead of having a constructor do it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384769342", "createdAt": "2020-02-26T21:14:46Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjYyODkw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365262890", "createdAt": "2020-02-26T21:40:20Z", "commit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0MDoyMFrOFu9SRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0MDoyMFrOFu9SRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4MjkxNw==", "bodyText": "Is this modifying activePackageList? It's not very clear on this line", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384782917", "createdAt": "2020-02-26T21:40:20Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjY0ODIw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365264820", "createdAt": "2020-02-26T21:43:25Z", "commit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0MzoyNlrOFu9Ycg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0MzoyNlrOFu9Ycg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NDQ5OA==", "bodyText": "If beforePackageSet was initialized with all values in activePackageList then pendingDownloadPackages on this line will always be empty, unless activePackageList is modified inside resolveDependencies. This may be working this way but it's confusing to read", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384784498", "createdAt": "2020-02-26T21:43:26Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjkwMjYx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365290261", "createdAt": "2020-02-26T22:26:18Z", "commit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjoyNjoxOFrOFu-qXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjoyNjoxOFrOFu-qXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwNTQ2OA==", "bodyText": "This will fail even if the dependsOnBy is also updated in the new deployment.\nex\ncurrent version:\nA 1.0 depends on  C 1.0\nB 1.0 depende on  C 1.0\nnew deployment updates C 1.0 to C 2.0 and updates both A and B to use C 2.0.  The new deployment should not fail as both A and B updated the dependency on C, but as per this logic it will fail.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384805468", "createdAt": "2020-02-26T22:26:18Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;\n+    }\n+\n+    /**\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n-        return null;\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        return executorService.submit(() -> resolveDependencies(proposedPackages));\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolveDependencies(Set<PackageMetadata> proposedPackages)\n+            throws PackageVersionConflictException, PackageDownloadException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        Set<PackageRegistryEntry> downloadedPackages = downloadPackages(pendingDownloadPackages);\n+        //TODO this needs to revisit, do we want one fail all or supporting partial download\n+        if (pendingDownloadPackages.size() != downloadedPackages.size()) {\n+            throw new PackageDownloadException(\"not all the packages have been successfully downloaded\");\n+        }\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.add(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsOnBy : devicePackage.getDependsOnBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsOnBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(String.format(\"proposed package %s doesn't meet\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzAzNjEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365303613", "createdAt": "2020-02-26T22:52:11Z", "commit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjo1MjoxMVrOFu_VTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjo1NDoyNFrOFu_Ytw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNjQ2MQ==", "bodyText": "This should be @Injected.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384816461", "createdAt": "2020-02-26T22:52:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n \n-    /*\n+    private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private final PackageRegistry packageRegistry;\n+\n+    public PackageManager(PackageRegistry packageRegistry) {\n+        this.packageRegistry = packageRegistry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2OTM0Mg=="}, "originalCommit": {"oid": "52d4846befa64a44c00e3b059d4f6750ee9cad9a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNjY3NQ==", "bodyText": "Please add more comments to this section since we're all agreed that it is confusing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384816675", "createdAt": "2020-02-26T22:52:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,157 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {\n+\n+\n+    private ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\n+    private PackageRegistry packageRegistry;\n+\n+    private Set<PackageMetadata> proposedPackages;\n \n     /*\n      * Given a set of proposed package dependency trees.\n      * Return the local resolved dependency tress in the future\n      */\n-    public Future<Map<PackageMetadata, Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+    public Future<Set<Package>> resolvePackages(Set<PackageMetadata> proposedPackages) {\n+        this.proposedPackages = proposedPackages;\n+\n+        return executorService.submit((Callable<Set<Package>>) this::resolvePackages);\n+    }\n+\n+    /*\n+     * Given a set of proposed package dependency trees,\n+     * figure out new package dependencies.\n+     */\n+    private Set<Package> resolvePackages() throws\n+            PackageVersionConflictException {\n+        Map<String, PackageRegistryEntry> activePackageList = packageRegistry.findActivePackages().stream()\n+                .collect(Collectors.toMap(PackageRegistryEntry::getName, Function.identity()));\n+        Set<PackageRegistryEntry> beforePackageSet = new HashSet<>(activePackageList.values());\n+\n+        for (PackageMetadata proposedPackage : proposedPackages) {\n+            resolveDependencies(proposedPackage, activePackageList);\n+        }\n+\n+        Set<PackageRegistryEntry> pendingDownloadPackages =\n+                activePackageList.values().stream().filter(p -> !beforePackageSet.contains(p))\n+                        .collect(Collectors.toSet());\n+        downloadPackages(pendingDownloadPackages);\n+\n+        packageRegistry.updateActivePackages(new ArrayList<>(activePackageList.values()));\n+\n+        return loadPackages(proposedPackages.stream().map(PackageMetadata::getName).collect(Collectors.toSet()));\n+    }\n+\n+    void resolveDependencies(PackageMetadata packageMetadata, Map<String, PackageRegistryEntry> devicePackages)\n+            throws PackageVersionConflictException {\n+\n+        Queue<PackageMetadata> processingQueue = new LinkedList<>();\n+        processingQueue.offer(packageMetadata);\n+\n+        while (!processingQueue.isEmpty()) {\n+            PackageMetadata proposedPackage = processingQueue.poll();\n+\n+            boolean useProposedPackage = true;\n+            // first to resolve package version\n+            // check if package exists on the device\n+            PackageRegistryEntry devicePackage = devicePackages.get(proposedPackage.getName());\n+            if (devicePackage != null) {\n+                // if exists, check if meets the proposed package constraint\n+                Semver devicePackageVersion = devicePackage.getVersion();\n+                if (devicePackageVersion != null && devicePackageVersion\n+                        .satisfies(proposedPackage.getVersionConstraint())) {\n+                    // device version meets the constraint, discard proposed version\n+                    useProposedPackage = false;\n+                } else {\n+                    // device version doesn't meet constraint, need to update\n+                    // check if proposed version meets existing package dependency constraint\n+                    for (PackageRegistryEntry.Reference dependsBy : devicePackage.getDependsBy().values()) {\n+                        if (!proposedPackage.getVersion().satisfies(dependsBy.getConstraint())) {\n+                            throw new PackageVersionConflictException(\"\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // second to update its dependencies if necessary\n+            if (useProposedPackage) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzUxMQ=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNzA3MQ==", "bodyText": "Lombok works correctly. Use @Data.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384817071", "createdAt": "2020-02-26T22:53:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRegistryEntry.java", "diffHunk": "@@ -1,53 +1,46 @@\n package com.aws.iot.evergreen.packagemanager.models;\n \n import com.vdurmont.semver4j.Semver;\n-import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.EqualsAndHashCode;\n import lombok.Getter;\n+import lombok.Setter;\n import lombok.ToString;\n-import lombok.experimental.FieldDefaults;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.HashMap;\n+import java.util.Map;\n \n @Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMzI5NA=="}, "originalCommit": {"oid": "f2c81c251e6c1e29d61f3e963b9569afcfed4e6b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNzMzNQ==", "bodyText": "Remove the final. It should be open to subclassing for future expansion.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384817335", "createdAt": "2020-02-26T22:54:24Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,160 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-public class PackageManager {\n+public final class PackageManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3OTc0OA=="}, "originalCommit": {"oid": "06ceb6cfd57513f8696f4661adde488899d48782"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzE5MDg4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365319088", "createdAt": "2020-02-26T23:28:31Z", "commit": {"oid": "d9badc66ec4912f24390aa73e47b5785c7b8bc84"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoyODozMVrOFvAI-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoyODozMVrOFvAI-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyOTY4OQ==", "bodyText": "None of our other classes do this. Use our injection framework like everyone else unless there's a very good reason not to.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#discussion_r384829689", "createdAt": "2020-02-26T23:28:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/PackageManager.java", "diffHunk": "@@ -1,20 +1,168 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageDownloadException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageMetadata;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRegistryEntry;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n import java.util.Map;\n+import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n public class PackageManager {\n \n-    /*\n+    public static PackageManager createInstance() {\n+        return new PackageManager(new PackageRegistryImpl());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9badc66ec4912f24390aa73e47b5785c7b8bc84"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzM4ODIx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365338821", "createdAt": "2020-02-27T00:22:19Z", "commit": {"oid": "453600e1b226c0bd8a10024d96bf0a10f73f4c2b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzUwNzg5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/75#pullrequestreview-365350789", "createdAt": "2020-02-27T00:57:53Z", "commit": {"oid": "453600e1b226c0bd8a10024d96bf0a10f73f4c2b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "195eba59feb40d3c098dfae33fb4508e95b90406", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/195eba59feb40d3c098dfae33fb4508e95b90406", "committedDate": "2020-02-27T04:07:02Z", "message": "Merge branch 'master' into dependency_resolution"}, "afterCommit": {"oid": "453600e1b226c0bd8a10024d96bf0a10f73f4c2b", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/453600e1b226c0bd8a10024d96bf0a10f73f4c2b", "committedDate": "2020-02-27T00:13:27Z", "message": "overload constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0c624c6f9d00d0e8becdcd903a453d2940d55a3", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a0c624c6f9d00d0e8becdcd903a453d2940d55a3", "committedDate": "2020-02-27T04:23:35Z", "message": "package manager API definition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd140284a34faefafb8d0e1cb5f71e6fb1da5936", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dd140284a34faefafb8d0e1cb5f71e6fb1da5936", "committedDate": "2020-02-27T04:24:18Z", "message": "change to return set instead of map"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f252661a139957f7b7fb8b5cdec0556f1b25277", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5f252661a139957f7b7fb8b5cdec0556f1b25277", "committedDate": "2020-02-27T04:24:45Z", "message": "handle some comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bccce3f7760ab3fa837c9aca99b5f0bcae01b8f3", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bccce3f7760ab3fa837c9aca99b5f0bcae01b8f3", "committedDate": "2020-02-27T04:24:45Z", "message": "fix bugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2e7d59ec6139437b8aee30089c5014e080fb9fc", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d2e7d59ec6139437b8aee30089c5014e080fb9fc", "committedDate": "2020-02-27T04:24:58Z", "message": "checkstyle, renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9b1c2c93e9cd346528f88c551fdc188ef7ea765", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d9b1c2c93e9cd346528f88c551fdc188ef7ea765", "committedDate": "2020-02-27T04:24:58Z", "message": "handle more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09bde8200a18c4a22161925e25756240f97ad0ee", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/09bde8200a18c4a22161925e25756240f97ad0ee", "committedDate": "2020-02-27T04:24:58Z", "message": "add static factory method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "968254d5cf15b10375f13826eaa9f912fdbcd82f", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/968254d5cf15b10375f13826eaa9f912fdbcd82f", "committedDate": "2020-02-27T04:24:58Z", "message": "renaming a field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c25cd8edeee3a771b60f63df5495ff2b64d2e210", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c25cd8edeee3a771b60f63df5495ff2b64d2e210", "committedDate": "2020-02-27T04:24:58Z", "message": "overload constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "394790895652ba3b83593634758ebda453c10493", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/394790895652ba3b83593634758ebda453c10493", "committedDate": "2020-02-27T04:26:05Z", "message": "fix conflicts"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "453600e1b226c0bd8a10024d96bf0a10f73f4c2b", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/453600e1b226c0bd8a10024d96bf0a10f73f4c2b", "committedDate": "2020-02-27T00:13:27Z", "message": "overload constructor"}, "afterCommit": {"oid": "394790895652ba3b83593634758ebda453c10493", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/394790895652ba3b83593634758ebda453c10493", "committedDate": "2020-02-27T04:26:05Z", "message": "fix conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "146afc85d9f1c4c3f012797703fa719a4ae9a828", "author": {"user": null}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/146afc85d9f1c4c3f012797703fa719a4ae9a828", "committedDate": "2020-02-27T04:28:28Z", "message": "fix java doc"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2270, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}