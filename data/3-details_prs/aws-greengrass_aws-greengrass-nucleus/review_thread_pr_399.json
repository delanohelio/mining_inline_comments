{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MTAwNjc5", "number": 399, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowMTo1M1rOEd11BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo0ODo1OVrOEfq8iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzI2MDg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowMTo1M1rOHJPvzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDo0MzozM1rOHJXlMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NzIzMA==", "bodyText": "I am not sure what would happen if the ACL parameter key itself is removed, like when author deploys a new recipe and removes the parameter config altogether and then deploys. That case is skipped here, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479457230", "createdAt": "2020-08-28T18:01:53Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -72,12 +73,14 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                 false);\n \n         //Subscribe to future auth config updates\n+        //This will bubble up the entire \"accessControl\" topic containing the entire ACL JSON\n         this.kernel.getConfig().getRoot().subscribe(\n                 (why, newv) -> {\n                     if (newv == null) {\n                         return;\n                     }\n-                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                    if (!newv.childOf(PARAMETERS_CONFIG_KEY)\n+                            || !newv.getName().equals(ACCESS_CONTROL_NAMESPACE_TOPIC)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTU4NQ==", "bodyText": "refactored and added integ test for this", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585585", "createdAt": "2020-08-29T00:43:33Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -72,12 +73,14 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                 false);\n \n         //Subscribe to future auth config updates\n+        //This will bubble up the entire \"accessControl\" topic containing the entire ACL JSON\n         this.kernel.getConfig().getRoot().subscribe(\n                 (why, newv) -> {\n                     if (newv == null) {\n                         return;\n                     }\n-                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                    if (!newv.childOf(PARAMETERS_CONFIG_KEY)\n+                            || !newv.getName().equals(ACCESS_CONTROL_NAMESPACE_TOPIC)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NzIzMA=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzI2OTcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowNToxMFrOHJP1cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDo0MzoxOFrOHJXlDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1ODY3NQ==", "bodyText": "Is it a common pattern to pass logger as part of method? Isnt it usually class member?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479458675", "createdAt": "2020-08-28T18:05:10Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -88,11 +91,13 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                     }\n                     Topic updatedTopic = (Topic) newv;\n                     String componentName = findServiceForNode(updatedTopic);\n-                    //If there is a change in a node, reload that one component's ACL\n-                    List<AuthorizationPolicy> updatedComponentPolicies = policyParser\n-                            .parseAuthorizationPolicyList(componentName, updatedTopic, logger);\n-                    this.loadAuthorizationPolicies(updatedTopic.getName(), updatedComponentPolicies, true);\n-\n+                    Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = policyParser\n+                           .parseAllPoliciesForComponent(updatedTopic, componentName, logger);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTU0OA==", "bodyText": "yep, fixed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585548", "createdAt": "2020-08-29T00:43:18Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -88,11 +91,13 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                     }\n                     Topic updatedTopic = (Topic) newv;\n                     String componentName = findServiceForNode(updatedTopic);\n-                    //If there is a change in a node, reload that one component's ACL\n-                    List<AuthorizationPolicy> updatedComponentPolicies = policyParser\n-                            .parseAuthorizationPolicyList(componentName, updatedTopic, logger);\n-                    this.loadAuthorizationPolicies(updatedTopic.getName(), updatedComponentPolicies, true);\n-\n+                    Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = policyParser\n+                           .parseAllPoliciesForComponent(updatedTopic, componentName, logger);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1ODY3NQ=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzI4MzU0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowOTo1OFrOHJP9-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDo0Mzo0MVrOHJXlQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MDg1Nw==", "bodyText": "This is not a warn, and as auth we dont care about it really. lets make it info, same for below.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479460857", "createdAt": "2020-08-28T18:09:58Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTYwMw==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585603", "createdAt": "2020-08-29T00:43:41Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MDg1Nw=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzI5MjE0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoxMzowM1rOHJQDig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDo0MzozNVrOHJXlNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjI4Mg==", "bodyText": "Have you tested if \"parameters\" or \"accessControl\" node is removed? Will that fall into this if statement?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479462282", "createdAt": "2020-08-28T18:13:03Z", "author": {"login": "youtuyy"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -72,12 +73,14 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                 false);\n \n         //Subscribe to future auth config updates\n+        //This will bubble up the entire \"accessControl\" topic containing the entire ACL JSON\n         this.kernel.getConfig().getRoot().subscribe(\n                 (why, newv) -> {\n                     if (newv == null) {\n                         return;\n                     }\n-                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                    if (!newv.childOf(PARAMETERS_CONFIG_KEY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTU4OQ==", "bodyText": "added integ tests for both of these cases", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585589", "createdAt": "2020-08-29T00:43:35Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -72,12 +73,14 @@ public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n                 false);\n \n         //Subscribe to future auth config updates\n+        //This will bubble up the entire \"accessControl\" topic containing the entire ACL JSON\n         this.kernel.getConfig().getRoot().subscribe(\n                 (why, newv) -> {\n                     if (newv == null) {\n                         return;\n                     }\n-                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                    if (!newv.childOf(PARAMETERS_CONFIG_KEY)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjI4Mg=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzI5NDI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoxMzo0NlrOHJQExg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDo0Mzo0M1rOHJXlSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjU5OA==", "bodyText": "You dont need to do getOnce(), coerce does that. right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479462598", "createdAt": "2020-08-28T18:13:46Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atWarn(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName, logger);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+                    //If multiple components have policies for the same policy type\n+                    if (masterAuthorizationPolicyMap.containsKey(policyType)) {\n+                        masterAuthorizationPolicyMap.get(policyTypeList.getKey()).addAll(policyList);\n+                    } else {\n+                        masterAuthorizationPolicyMap.put(policyType, policyList);\n+                    }\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                               String componentName, Logger logger) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic.getOnce());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzg1NQ==", "bodyText": "It does", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479517855", "createdAt": "2020-08-28T20:22:55Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atWarn(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName, logger);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+                    //If multiple components have policies for the same policy type\n+                    if (masterAuthorizationPolicyMap.containsKey(policyType)) {\n+                        masterAuthorizationPolicyMap.get(policyTypeList.getKey()).addAll(policyList);\n+                    } else {\n+                        masterAuthorizationPolicyMap.put(policyType, policyList);\n+                    }\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                               String componentName, Logger logger) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic.getOnce());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjU5OA=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTYxMA==", "bodyText": "fixed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585610", "createdAt": "2020-08-29T00:43:43Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atWarn(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName, logger);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+                    //If multiple components have policies for the same policy type\n+                    if (masterAuthorizationPolicyMap.containsKey(policyType)) {\n+                        masterAuthorizationPolicyMap.get(policyTypeList.getKey()).addAll(policyList);\n+                    } else {\n+                        masterAuthorizationPolicyMap.put(policyType, policyList);\n+                    }\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                               String componentName, Logger logger) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic.getOnce());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MjU5OA=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzMwNTQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODoxNzoyN1rOHJQLkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDo0Mzo0NVrOHJXlTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2NDMzOA==", "bodyText": "Being empty is not invalid, that should not be warn.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479464338", "createdAt": "2020-08-28T18:17:27Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atWarn(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName, logger);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+                    //If multiple components have policies for the same policy type\n+                    if (masterAuthorizationPolicyMap.containsKey(policyType)) {\n+                        masterAuthorizationPolicyMap.get(policyTypeList.getKey()).addAll(policyList);\n+                    } else {\n+                        masterAuthorizationPolicyMap.put(policyType, policyList);\n+                    }\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                               String componentName, Logger logger) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic.getOnce());\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {\n+\n+            String policyType = Coerce.toString(accessControlType.getKey());\n+            Object accessControlTopicObject = accessControlType.getValue();\n+\n+            if (!(accessControlTopicObject instanceof List)\n+                    || Utils.isEmpty((List) accessControlTopicObject)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTYxNA==", "bodyText": "changed to info", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585614", "createdAt": "2020-08-29T00:43:45Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")\n public final class AuthorizationPolicyParser {\n+    private static final JsonMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atWarn(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName, logger);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+                    //If multiple components have policies for the same policy type\n+                    if (masterAuthorizationPolicyMap.containsKey(policyType)) {\n+                        masterAuthorizationPolicyMap.get(policyTypeList.getKey()).addAll(policyList);\n+                    } else {\n+                        masterAuthorizationPolicyMap.put(policyType, policyList);\n+                    }\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                               String componentName, Logger logger) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic.getOnce());\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {\n+\n+            String policyType = Coerce.toString(accessControlType.getKey());\n+            Object accessControlTopicObject = accessControlType.getValue();\n+\n+            if (!(accessControlTopicObject instanceof List)\n+                    || Utils.isEmpty((List) accessControlTopicObject)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2NDMzOA=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzY1MTQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMDoyMjo0NFrOHJTcVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDo0Njo1OFrOHJXnBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzc4MQ==", "bodyText": "why?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479517781", "createdAt": "2020-08-28T20:22:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTU0NQ==", "bodyText": "this gives the following error otherwise:\n        \n[ERROR] Unchecked/unconfirmed cast from com.fasterxml.jackson.databind.ObjectMapper to com.fasterxml.jackson.databind.json.JsonMapper of return value in com.aws.iot.evergreen.auth.AuthorizationPolicyParser.<static initializer for AuthorizationPolicyParser>() [com.aws.iot.evergreen.auth.AuthorizationPolicyParser] At AuthorizationPolicyParser.java:[line 32] BC_UNCONFIRMED_CAST_OF_RETURN_VALUE", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585545", "createdAt": "2020-08-29T00:43:16Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzc4MQ=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NjA1NA==", "bodyText": "Just make the field an objectmapper instead", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479586054", "createdAt": "2020-08-29T00:46:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,36 +23,152 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n+@SuppressFBWarnings(\"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzc4MQ=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzY1MzEzOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMDoyMzozMVrOHJTdcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDo0Mzo0OVrOHJXlWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxODA2NA==", "bodyText": "put this in a try-finally, and remove the listener in the finally", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479518064", "createdAt": "2020-08-28T20:23:31Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -158,8 +176,15 @@ public void GIVEN_invalid_pubsub_yaml_file_with_invalid_fields_WHEN_auth_parsing\n             assertNotNull(inputStream);\n             config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n \n-            //TODO: this no longer throws an exception; we need to parse the log to check the behavior\n+            logReceived = new CountDownLatch(1);\n+            logListener = m -> {\n+                if (\"load-authorization-config-unknown-policy-key\".equals(m.getEventType())) {\n+                    logReceived.countDown();\n+                }\n+            };\n+            Slf4jLogAdapter.addGlobalListener(logListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTYyNg==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r479585626", "createdAt": "2020-08-29T00:43:49Z", "author": {"login": "avipinku"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -158,8 +176,15 @@ public void GIVEN_invalid_pubsub_yaml_file_with_invalid_fields_WHEN_auth_parsing\n             assertNotNull(inputStream);\n             config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n \n-            //TODO: this no longer throws an exception; we need to parse the log to check the behavior\n+            logReceived = new CountDownLatch(1);\n+            logListener = m -> {\n+                if (\"load-authorization-config-unknown-policy-key\".equals(m.getEventType())) {\n+                    logReceived.countDown();\n+                }\n+            };\n+            Slf4jLogAdapter.addGlobalListener(logListener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxODA2NA=="}, "originalCommit": {"oid": "e635263b98f8b7855d95b8bb685b8e5cf28379f3"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzE3MjMzOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0NzoxNFrOHKCc4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNTo1NzoyMFrOHLby_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA==", "bodyText": "why are we logging the exception? It should probably only be returned to the user, maybe with a warning or info as well.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480287968", "createdAt": "2020-08-31T17:47:14Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjMxMA==", "bodyText": "I think this is part of how the PubSubImpl is implemented. We can talk about changing that and I can fix it in another PR for the SDK.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480376310", "createdAt": "2020-08-31T20:19:29Z", "author": {"login": "avipinku"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3Nzc5Nw==", "bodyText": "Nonono. That exception is correct. I'm talking about AuthorizationException", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480377797", "createdAt": "2020-08-31T20:22:29Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwOTkzMA==", "bodyText": "that exception is thrown by the  PubSubIPCService in order to set the response as PubSubResponseStatus.Unauthorized\nhttps://github.com/aws/aws-greengrass-kernel/blob/master/src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java#L133\nDo we want to handle that differently?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481309930", "createdAt": "2020-09-01T17:23:10Z", "author": {"login": "avipinku"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxNTA4Mw==", "bodyText": "Maybe log only when it isn't an auth exception, since we understand what that's about. Do log that authorization was denied, but you don't need to log out the whole exception.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481315083", "createdAt": "2020-09-01T17:32:06Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU4ODM0NQ==", "bodyText": "changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481588345", "createdAt": "2020-09-02T03:04:01Z", "author": {"login": "avipinku"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTgwNA==", "bodyText": "Since you changed it, you should be able to remove the ignore now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481751804", "createdAt": "2020-09-02T05:57:20Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4Nzk2OA=="}, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzE3MzA3OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0NzozMVrOHKCdWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoxOToyNVrOHKH10g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODA5MQ==", "bodyText": "this won't do anything; you've already ignored it on L157.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480288091", "createdAt": "2020-08-31T17:47:31Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjI3NA==", "bodyText": "whoops, removed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480376274", "createdAt": "2020-08-31T20:19:25Z", "author": {"login": "avipinku"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODA5MQ=="}, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzE3MzM5OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0NzozN1rOHKCdjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0NzozN1rOHKCdjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODE0MA==", "bodyText": "same", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480288140", "createdAt": "2020-08-31T17:47:37Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -126,6 +130,67 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n     }\n \n \n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_ACL_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        Topic acl = parameters.find(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+        if (acl != null) {\n+            acl.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8)));\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_authorized_THEN_parameters_child_removed_THEN_updates(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\",\n+                TEST_SERVICE_NAME, this.getClass());\n+        KernelIPCClientConfig config = getIPCConfigForService(TEST_SERVICE_NAME, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.subscribeToTopic(\"a\", cb.getRight()); //this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+        Topics serviceTopic = kernel.findServiceTopic(TEST_SERVICE_NAME);\n+        Topics parameters = serviceTopic.findTopics(PARAMETERS_CONFIG_KEY);\n+        if (parameters != null) {\n+            parameters.remove();\n+        }\n+        Thread.sleep(100);\n+        //Now the authorization policies should have been removed and these should fail\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzE4MTEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0OTo1M1rOHKCiZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoxOToxNVrOHKH1eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4OTM4MA==", "bodyText": "this isn't possible", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480289380", "createdAt": "2020-08-31T17:49:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,35 +24,145 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atInfo(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjE4NA==", "bodyText": "removed the check", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r480376184", "createdAt": "2020-08-31T20:19:15Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -20,35 +24,145 @@\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+\n+        //For each component\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());\n+                continue;\n+            }\n+\n+            String componentName = serviceConfig.getName();\n+            if (Utils.isEmpty(componentName)) {\n+                logger.atInfo(\"load-authorization-component-name-null\")\n+                        .log(\"Service config name is missing\");\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4OTM4MA=="}, "originalCommit": {"oid": "716078bb33eb6bdc87dc22f50e5cb6c944f7d1f7"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTkxNDg0OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/ipc/pubsub_unauthorized_publish.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxOToyNDo1N1rOHLFDCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMToxMjo0OVrOHLIcQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3OTA4Mg==", "bodyText": "Let's also remove \"unsubscribe\" while you are here. We can remove it from the list of operations we add to auth handler.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481379082", "createdAt": "2020-09-01T19:24:57Z", "author": {"login": "prateek-y"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/ipc/pubsub_unauthorized_publish.yaml", "diffHunk": "@@ -24,14 +24,7 @@ services:\n           powershell -command sleep 100\n         posix:\n           sleep 100\n-    accessControl:\n-      aws.greengrass.ipc.pubsub:\n-        - policyId1:\n-            policyDescription: \"access to pubsub topics\"\n-            operations:\n-              - \"subscribe\"\n-              - \"unsubscribe\"\n-            resources:\n-              - \"/topic/1/#\"\n-              - \"/longer/topic/example/\"\n-              - \"*\"\n+    parameters:\n+      accessControl:\n+        '{\"aws.greengrass.ipc.pubsub\":[{\"policyId1\":{\"policyDescription\":\"access to pubsub topics\",\"operations\":[\"subscribe\",\"unsubscribe\"],\"resources\":[\"/topic/1/#\",\"/longer/topic/example/\",\"*\"]}}]}'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNDY4OQ==", "bodyText": "ok; that's an SDK change I can send out", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481434689", "createdAt": "2020-09-01T21:12:49Z", "author": {"login": "avipinku"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/ipc/pubsub_unauthorized_publish.yaml", "diffHunk": "@@ -24,14 +24,7 @@ services:\n           powershell -command sleep 100\n         posix:\n           sleep 100\n-    accessControl:\n-      aws.greengrass.ipc.pubsub:\n-        - policyId1:\n-            policyDescription: \"access to pubsub topics\"\n-            operations:\n-              - \"subscribe\"\n-              - \"unsubscribe\"\n-            resources:\n-              - \"/topic/1/#\"\n-              - \"/longer/topic/example/\"\n-              - \"*\"\n+    parameters:\n+      accessControl:\n+        '{\"aws.greengrass.ipc.pubsub\":[{\"policyId1\":{\"policyDescription\":\"access to pubsub topics\",\"operations\":[\"subscribe\",\"unsubscribe\"],\"resources\":[\"/topic/1/#\",\"/longer/topic/example/\",\"*\"]}}]}'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3OTA4Mg=="}, "originalCommit": {"oid": "ba510d7bbb452a1c7ec3109feffb6ca96f6bd0a4"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjIxMTA0OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNTo1Njo1M1rOHLbxJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOToxODowNVrOHL-9Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA==", "bodyText": "can we get rid of the sleep? Random sleeps are incredibly suspect", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481751334", "createdAt": "2020-09-02T05:56:53Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -119,13 +111,72 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n \n         //Reload the kernel with the correct authorization policy\n         kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n-        Thread.sleep(500);\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MTk5OQ==", "bodyText": "There needs to be some delay here for the changes in the ACL to propagate. If this is removed, it fails.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482261999", "createdAt": "2020-09-02T17:59:46Z", "author": {"login": "avipinku"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -119,13 +111,72 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n \n         //Reload the kernel with the correct authorization policy\n         kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n-        Thread.sleep(500);\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MzYzMA==", "bodyText": "That sounds like a bug!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482263630", "createdAt": "2020-09-02T18:02:45Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -119,13 +111,72 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n \n         //Reload the kernel with the correct authorization policy\n         kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n-        Thread.sleep(500);\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDM1MA==", "bodyText": "I thought kernel config read is asynchronous?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482264350", "createdAt": "2020-09-02T18:03:38Z", "author": {"login": "prateek-y"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -119,13 +111,72 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n \n         //Reload the kernel with the correct authorization policy\n         kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n-        Thread.sleep(500);\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDk5Ng==", "bodyText": "You may need to use kernel.getContext().runOnPublishQueueAndWait(() -> {}); which will block until all the events have completed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482264996", "createdAt": "2020-09-02T18:04:48Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -119,13 +111,72 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n \n         //Reload the kernel with the correct authorization policy\n         kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n-        Thread.sleep(500);\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyNzg2Mg==", "bodyText": "fixed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482327862", "createdAt": "2020-09-02T19:18:05Z", "author": {"login": "avipinku"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -119,13 +111,72 @@ void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(Exten\n \n         //Reload the kernel with the correct authorization policy\n         kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n-        Thread.sleep(500);\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MTMzNA=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjIyMzQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNTo1ODo1OFrOHLb5tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo1OTo0OFrOHL68Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzUyNg==", "bodyText": "do not log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481753526", "createdAt": "2020-09-02T05:58:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjAxOA==", "bodyText": "removed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262018", "createdAt": "2020-09-02T17:59:48Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzUyNg=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjIyNDA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNTo1OTowNlrOHLb6Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo1OTo1NVrOHL68QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzY1NQ==", "bodyText": "do not log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481753655", "createdAt": "2020-09-02T05:59:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjA4MA==", "bodyText": "removed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262080", "createdAt": "2020-09-02T17:59:55Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1MzY1NQ=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjIyODc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNTo1OTo1MVrOHLb9Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo1OTo1MlrOHL68Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NDQwNg==", "bodyText": "use Kernel.findServiceForNode instead of getting the name like that. Just in case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481754406", "createdAt": "2020-09-02T05:59:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjA2Mw==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262063", "createdAt": "2020-09-02T17:59:52Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NDQwNg=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjIzMzY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowMDozN1rOHLcAXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODowMDowMlrOHL68nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NTIzMA==", "bodyText": "simplify to serviceConfig.find(PARAMETERS_CONFIG_KEY, ACCESS_CONTROL_NAMESPACE_TOPIC) which will return null if either is null", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481755230", "createdAt": "2020-09-02T06:00:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjE3Mg==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262172", "createdAt": "2020-09-02T18:00:02Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NTIzMA=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjI0NDI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowMjozNFrOHLcHxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODowMDoxMVrOHL689g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NzEyNA==", "bodyText": "Provide the generics: Map.Entry<String, Object>", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481757124", "createdAt": "2020-09-02T06:02:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+\n+                    //If multiple components have policies for the same policy type\n+                    masterAuthorizationPolicyMap.computeIfAbsent(policyType, k -> new ArrayList<>()).addAll(policyList);\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    private Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                                String componentName) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic);\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjI2Mg==", "bodyText": "fixed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262262", "createdAt": "2020-09-02T18:00:11Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+\n+                    //If multiple components have policies for the same policy type\n+                    masterAuthorizationPolicyMap.computeIfAbsent(policyType, k -> new ArrayList<>()).addAll(policyList);\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    private Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                                String componentName) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic);\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1NzEyNA=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjI0ODcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowMzoyMVrOHLcKtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODowMDowNlrOHL68zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1Nzg3OQ==", "bodyText": "you don't need to coerce to string, it is already a string. This will be fixed if you use the generic as I suggest above.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481757879", "createdAt": "2020-09-02T06:03:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+\n+                    //If multiple components have policies for the same policy type\n+                    masterAuthorizationPolicyMap.computeIfAbsent(policyType, k -> new ArrayList<>()).addAll(policyList);\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    private Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                                String componentName) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic);\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {\n+\n+            String policyType = Coerce.toString(accessControlType.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjIyMQ==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262221", "createdAt": "2020-09-02T18:00:06Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,175 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                logger.atInfo(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\");\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {\n+                logger.atError(\"load-authorization-component-config-retrieval-error\")\n+                        .log(\"Incorrect formatting while retrieving the config for service{}.\", service.getName());\n+                continue;\n+            }\n+\n+            Topics serviceConfig = (Topics) service;\n+            String componentName = serviceConfig.getName();\n+\n+            //Get the parameters for this component, if they exist\n+            Topics parameters = serviceConfig.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (parameters == null) {\n+                continue;\n+            }\n+            //Get the Access Control List for this component, if it exists\n+            Topic accessControlMapTopic = parameters.findLeafChild(ACCESS_CONTROL_NAMESPACE_TOPIC);\n+            if (accessControlMapTopic == null) {\n+                continue;\n+            }\n+\n+            //Retrieve all policies, mapped to each policy type\n+            Map<String, List<AuthorizationPolicy>> componentAuthorizationPolicyMap = parseAllPoliciesForComponent(\n+                    accessControlMapTopic, componentName);\n+\n+            if (componentAuthorizationPolicyMap != null) {\n+                //For each policy type (e.g. aws.greengrass.ipc.pubsub)\n+                for (Map.Entry<String, List<AuthorizationPolicy>> policyTypeList :\n+                        componentAuthorizationPolicyMap.entrySet()) {\n+\n+                    String policyType = policyTypeList.getKey();\n+                    List<AuthorizationPolicy> policyList = policyTypeList.getValue();\n+\n+                    //If multiple components have policies for the same policy type\n+                    masterAuthorizationPolicyMap.computeIfAbsent(policyType, k -> new ArrayList<>()).addAll(policyList);\n+                }\n+            }\n+        }\n+        return masterAuthorizationPolicyMap;\n+    }\n+\n+    /**\n+     * Given a accessControlMapTopic Topic, construct and return a map of AuthorizationPolicy objects that may exist\n+     * only for that component config, grouped into lists of the same policy type.\n+     * Never returns null.\n+     *\n+     * @param accessControlMapTopic Topic\n+     * @param componentName String\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     */\n+    private Map<String, List<AuthorizationPolicy>> parseAllPoliciesForComponent(Topic accessControlMapTopic,\n+                                                                                String componentName) {\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        String accessControlMapValueJson = Coerce.toString(accessControlMapTopic);\n+        if (Utils.isEmpty(accessControlMapValueJson)) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        Map<String, Object> accessControlMap;\n+        try {\n+            accessControlMap = OBJECT_MAPPER.readValue(accessControlMapValueJson,\n+                    new TypeReference<Map<String, Object>>(){});\n+        } catch (JsonProcessingException e) {\n+            logger.atError(\"load-authorization-config-deserialization-error\", e)\n+                    .log(\"Unable to deserialize access control map\");\n+            return authorizationPolicyMap;\n+        }\n+\n+        if (accessControlMap == null) {\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each policy type\n+        for (Map.Entry accessControlType : accessControlMap.entrySet()) {\n+\n+            String policyType = Coerce.toString(accessControlType.getKey());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1Nzg3OQ=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjI1NTU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowNDozM1rOHLcPbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODowMDoxNVrOHL69JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1OTA4NQ==", "bodyText": "don't bother with the cause, we know what causes authz exceptions. You can just log the exception message. (e.getmessage()I mean)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481759085", "createdAt": "2020-09-02T06:04:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -126,21 +127,30 @@ public void postInject() {\n             ApplicationMessage responseMessage = ApplicationMessage.builder().version(applicationMessage.getVersion())\n                     .payload(CBOR_MAPPER.writeValueAsBytes(pubSubGenericResponse)).build();\n             fut.complete(new Message(responseMessage.toByteArray()));\n+        } catch (AuthorizationException e) {\n+            logger.atWarn().setEventType(\"pubsub-authorization-error\").setCause(e).log(\"Unauthorized request\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjMwOA==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262308", "createdAt": "2020-09-02T18:00:15Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -126,21 +127,30 @@ public void postInject() {\n             ApplicationMessage responseMessage = ApplicationMessage.builder().version(applicationMessage.getVersion())\n                     .payload(CBOR_MAPPER.writeValueAsBytes(pubSubGenericResponse)).build();\n             fut.complete(new Message(responseMessage.toByteArray()));\n+        } catch (AuthorizationException e) {\n+            logger.atWarn().setEventType(\"pubsub-authorization-error\").setCause(e).log(\"Unauthorized request\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1OTA4NQ=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjI2MzEyOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowNTo0NlrOHLcUlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODowMDoyMlrOHL69aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MDQwNQ==", "bodyText": "try (InputStream inputStream = getClass().getResourceAsStream(filename)) { ... }", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481760405", "createdAt": "2020-09-02T06:05:46Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjM3OQ==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262379", "createdAt": "2020-09-02T18:00:22Z", "author": {"login": "avipinku"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MDQwNQ=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjI3MTkzOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowNzoyM1rOHLcajw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODowMDoyN1rOHL69kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MTkzNQ==", "bodyText": "not needed. You already do this with @Mock", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481761935", "createdAt": "2020-09-02T06:07:23Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);\n+        Topics allServices = mock(Topics.class);\n+        it = mock(Iterator.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjQxNw==", "bodyText": "removed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262417", "createdAt": "2020-09-02T18:00:27Z", "author": {"login": "avipinku"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);\n+        Topics allServices = mock(Topics.class);\n+        it = mock(Iterator.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MTkzNQ=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjI3Nzg2OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowODoyMlrOHLceew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOToxODowMFrOHL-87w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ==", "bodyText": "You have both real and mocked configs?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r481762939", "createdAt": "2020-09-02T06:08:22Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MjQ1Mg==", "bodyText": "Yes, instead of having to mock each and every function called on the Topics config/ trying to construct a mock with the parameters we want, we can just mock the iterator and use it to return real Nodes that get loaded into realConfig. We don't care about the kernel.getConfig call.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482262452", "createdAt": "2020-09-02T18:00:31Z", "author": {"login": "avipinku"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2NDcwNg==", "bodyText": "Then why have a mock at all? Why not just use the real config for everything?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482264706", "createdAt": "2020-09-02T18:04:15Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI3Mzg5MQ==", "bodyText": "Oh thats right. We can just pass the read config as part of kernel.getConfig() ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482273891", "createdAt": "2020-09-02T18:19:32Z", "author": {"login": "prateek-y"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjMyNzc5MQ==", "bodyText": "yeah, refactored to just use the real config for everything", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482327791", "createdAt": "2020-09-02T19:18:00Z", "author": {"login": "avipinku"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParserTest.java", "diffHunk": "@@ -21,145 +23,187 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n \n import static com.aws.iot.evergreen.ipc.modules.PubSubIPCService.PUB_SUB_SERVICE_NAME;\n import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.mockito.Mockito.lenient;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, EGExtension.class})\n public class AuthorizationPolicyParserTest {\n \n-    private Configuration config;\n     private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n \n     @Mock\n     private Kernel kernel;\n \n     @Mock\n-    private EvergreenService testService1;\n+    private Configuration mockConfig;\n \n     @Mock\n-    private EvergreenService testService2;\n+    Iterator it;\n+\n+    private Configuration realConfig;\n+\n+    private CountDownLatch logReceived;\n+\n+    private Consumer<EvergreenStructuredLogMessage> logListener;\n \n     protected final Logger logger = LogManager.getLogger(this.getClass());\n \n+    private void readConfig(String filename) throws IOException {\n+        realConfig = new Configuration(new Context());\n+        InputStream inputStream = null;\n+        try{\n+            inputStream = getClass().getResourceAsStream(filename);\n+            assertNotNull(inputStream);\n+            realConfig.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } finally {\n+            inputStream.close();\n+        }\n+\n+\n+    }\n+\n     @BeforeEach()\n-    void beforeEach() throws NoSuchFieldException {\n-        config = new Configuration(new Context());\n-        HashSet<EvergreenService> mockServiceSet = new HashSet<>();\n-        mockServiceSet.add(testService1);\n-        mockServiceSet.add(testService2);\n-        when(kernel.orderedDependencies()).thenReturn(mockServiceSet);\n-        //Make this lenient since some tests should throw an exception before parsing one or more of these service configs\n-        lenient().when(testService1.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"ServiceName\"));\n-        lenient().when(testService2.getConfig()).thenReturn(config.lookupTopics(\n-                SERVICES_NAMESPACE_TOPIC, \"mqtt\"));\n+    void beforeEach() {\n+        when(kernel.getConfig()).thenReturn(mockConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2MjkzOQ=="}, "originalCommit": {"oid": "3db175983ddf858190d4bf5c9bf55ee97cc04e5d"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjQ0OTM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo0ODo1OVrOHMGMUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo0ODo1OVrOHMGMUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ0NjQxNg==", "bodyText": "technically, the nullcheck is included here, so you can remove L59", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/399#discussion_r482446416", "createdAt": "2020-09-02T20:48:59Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -1,54 +1,165 @@\n package com.aws.iot.evergreen.auth;\n \n import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n-import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n import com.aws.iot.evergreen.config.Node;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.util.Coerce;\n import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.json.JsonMapper;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n import static com.aws.iot.evergreen.util.Coerce.toEnum;\n \n public final class AuthorizationPolicyParser {\n+    private static final Logger logger = LogManager.getLogger(AuthorizationPolicyParser.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            JsonMapper.builder().configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true).build();\n \n     /**\n-     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policy type.\n+     * This is used only upon kernel startup, to initialize all policies.\n      * Never returns null.\n      *\n-     * @param componentName      String\n-     * @param accessControlTopic Topic\n-     * @param logger             Logger\n-     * @return {@List} of {@AuthorizationPolicy}'s\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param kernel Kernel\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n      */\n-    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n-                                                                  Logger logger) {\n-        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel) {\n+\n+        Map<String, List<AuthorizationPolicy>> masterAuthorizationPolicyMap = new HashMap<>();\n \n-        Object accessControlTopicObject = accessControlTopic.getOnce();\n+        Topics allServices = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC);\n \n-        if (!(accessControlTopicObject instanceof List)\n-                || Utils.isEmpty((List) accessControlTopicObject)\n-                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n-            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n-                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n-            return newAuthorizationPolicyList;\n+        if (allServices == null) {\n+            logger.atInfo(\"load-authorization-all-services-component-config-retrieval-error\")\n+                    .log(\"Unable to retrieve services config\");\n+            return masterAuthorizationPolicyMap;\n         }\n \n-        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+        //For each component\n+        for (Node service : allServices) {\n+\n+            if (service == null) {\n+                continue;\n+            }\n+\n+            if (!(service instanceof Topics)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb841218b544be7d0d65ce0e6a9479742039d5dc"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 739, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}