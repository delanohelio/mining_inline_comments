{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NjM5MTg1", "number": 495, "reviewThreads": {"totalCount": 49, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMjoyMDo0OFrOEprZcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo1Njo1M1rOEwe0zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTM4MDk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMjoyMDo0OFrOHbfvXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMjoyMDo0OFrOHbfvXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU5MzYzMQ==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem: While wrapping the caught exception into a custom one, information about the caught exception is being lost, including information about the stack trace of the exception.\nFix: If the caught exception object does not contain sensitive information, consider passing it as the \"rootCause\" or inner exception parameter to the constructor of the new exception before throwing the new exception. (Note that not all exception constructors support inner exceptions. Use a wrapper exception that supports inner exceptions.)\nLearn more\nSimilar issue at line numbers 113.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r498593631", "createdAt": "2020-10-02T02:20:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDIwNTU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDo1OTo1N1rOHb7eKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDo1OTo1N1rOHb7eKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0Nzk3Nw==", "bodyText": "use Kernel.locate instead of context.get for GreengrassServices.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499047977", "createdAt": "2020-10-02T20:59:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ComponentUpdatePolicyEvents;\n+import generated.software.amazon.awssdk.iot.greengrass.model.DeferComponentUpdateRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.DeferComponentUpdateResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PostComponentUpdateEvent;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PreComponentUpdateEvent;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UpdateStateRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UpdateStateResponse;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+import software.amazon.eventstream.iot.server.ServerStreamEventPublisher;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    private final ConcurrentHashMap<String, Set<ServerStreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            Optional<GreengrassService> service = Optional.ofNullable(kernel.getContext().get(GreengrassService.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDIwOTg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowMTo0NVrOHb7g2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjo0NDozN1rOHho65w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0ODY2NA==", "bodyText": "can we still set operations after the startup? Like when CLI is a plugin will it be able to register itself after start?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499048664", "createdAt": "2020-10-02T21:01:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzNTQ5NQ==", "bodyText": "Yes we can. This is how CLI is doing right now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r505035495", "createdAt": "2020-10-14T22:44:37Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0ODY2NA=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDIxMDg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowMjoxNlrOHb7hhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjo0NTo1NlrOHho_Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0ODgzOQ==", "bodyText": "wait for ELG to close.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499048839", "createdAt": "2020-10-02T21:02:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (StringUtils.isEmpty(authToken)) {\n+            String errorMessage = \"Received empty auth token to authenticate IPC client\";\n+            logger.atError().log(errorMessage);\n+            throw new RuntimeException(errorMessage);\n+        }\n+        AuthenticationData authenticationData;\n+        try {\n+            final String serviceName = authenticationHandler.doAuthentication(authToken);\n+            authenticationData = new AuthenticationData() {\n+                @Override\n+                public String getIdentityLabel() {\n+                    return serviceName;\n+                }\n+            };\n+        } catch (UnauthenticatedException e) {\n+            throw new RuntimeException(\"Unrecognized client connecting to GGC over IPC\");\n+        }\n+        return authenticationData;\n+    }\n+\n+    @Override\n+    public void close() {\n+        ipcServer.stopServer();\n+        socketOptions.close();\n+        eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzNjU0Nw==", "bodyText": "There is some issue with ipcServer.stopServer() which blocks eventLoopGroup.close() indefinitely. Have rasied the issue with SDK team and they will look into it. For now I am triggering close and not waiting.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r505036547", "createdAt": "2020-10-14T22:45:56Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (StringUtils.isEmpty(authToken)) {\n+            String errorMessage = \"Received empty auth token to authenticate IPC client\";\n+            logger.atError().log(errorMessage);\n+            throw new RuntimeException(errorMessage);\n+        }\n+        AuthenticationData authenticationData;\n+        try {\n+            final String serviceName = authenticationHandler.doAuthentication(authToken);\n+            authenticationData = new AuthenticationData() {\n+                @Override\n+                public String getIdentityLabel() {\n+                    return serviceName;\n+                }\n+            };\n+        } catch (UnauthenticatedException e) {\n+            throw new RuntimeException(\"Unrecognized client connecting to GGC over IPC\");\n+        }\n+        return authenticationData;\n+    }\n+\n+    @Override\n+    public void close() {\n+        ipcServer.stopServer();\n+        socketOptions.close();\n+        eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0ODgzOQ=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDIxMTQ5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowMjozMVrOHb7h7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoyMDoxMVrOHc3aLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0ODk0Mw==", "bodyText": "should we use more than 1 thread?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499048943", "createdAt": "2020-10-02T21:02:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyOTk5OQ==", "bodyText": "This is for the initial connection acceptance thread, any client communication will happen in different threads. So 1 should be enough for accepting new clients.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r500029999", "createdAt": "2020-10-06T06:20:11Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0ODk0Mw=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDIxMjM3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowMjo1NFrOHb7ifw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjo0NzowNlrOHhpCMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTA4Nw==", "bodyText": "LOCALHOST", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499049087", "createdAt": "2020-10-02T21:02:54Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA1MDA0MA==", "bodyText": "Moved to domain sockets so this is no longer needed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r500050040", "createdAt": "2020-10-06T07:07:05Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTA4Nw=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMjQ2Ng==", "bodyText": "How is this going to work for containers? We can connect to servers because the network isn't isolated, but we can't use domain sockets AFAIK.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r500422466", "createdAt": "2020-10-06T16:09:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTA4Nw=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzNzM2MA==", "bodyText": "File mounting will be needed for container communication I believe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r505037360", "createdAt": "2020-10-14T22:47:06Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTA4Nw=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDIxMzIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowMzoxMVrOHb7i9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNzowNzoxMVrOHc4oog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTIwNg==", "bodyText": "use our own utils. Utils.isEmpty", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499049206", "createdAt": "2020-10-02T21:03:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (StringUtils.isEmpty(authToken)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA1MDA4Mg==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r500050082", "createdAt": "2020-10-06T07:07:11Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (StringUtils.isEmpty(authToken)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTIwNg=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDIxNDQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowMzozOFrOHb7jug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoyNDo1NlrOHc3g4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTQwMg==", "bodyText": "why are we rethrowing as unchecked?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499049402", "createdAt": "2020-10-02T21:03:38Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzMTcxNQ==", "bodyText": "ipcAuthHandler prototype does not throw exceptions so throwing it as unchecked. I am still discussing the exception handling in connect. Ideally we want an error from the protocol to be thrown here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r500031715", "createdAt": "2020-10-06T06:24:56Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.utils.StringUtils;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.DebugLoggingOperationHandler;\n+import software.amazon.eventstream.iot.server.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+\n+    public IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(operation, context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.IPv4;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, LOCAL_HOST,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0OTQwMg=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDIyMTcyOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/ipc/IPCEventStreamServiceTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMTowNjozNlrOHb7oWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjo0Nzo1MlrOHhpEcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MDU4NQ==", "bodyText": "can we setup their log to write to our own slf4j logger?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r499050585", "createdAt": "2020-10-02T21:06:36Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/ipc/IPCEventStreamServiceTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.Log;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.AuthenticationHandler;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.AuthorizationHandler;\n+\n+import java.io.IOException;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class IPCEventStreamServiceTest {\n+    private IPCEventStreamService ipcEventStreamService;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    //    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    protected static ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    static {\n+        Log.initLoggingToFile(Log.LogLevel.Trace, \"crt.log\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA1MDQzOA==", "bodyText": "I have an open item to discuss with SDK about enabling disabling logging. Can discuss this with them as well. Do you know what will be needed to set this up?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r500050438", "createdAt": "2020-10-06T07:07:55Z", "author": {"login": "abanthiy"}, "path": "src/test/java/com/aws/greengrass/ipc/IPCEventStreamServiceTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.Log;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.AuthenticationHandler;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.AuthorizationHandler;\n+\n+import java.io.IOException;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class IPCEventStreamServiceTest {\n+    private IPCEventStreamService ipcEventStreamService;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    //    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    protected static ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    static {\n+        Log.initLoggingToFile(Log.LogLevel.Trace, \"crt.log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MDU4NQ=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMzA2MA==", "bodyText": "If their logger uses slf4j, then our logger will just work. Otherwise if they can provide a method that accepts some logger interface, then we can use that too.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r500423060", "createdAt": "2020-10-06T16:10:01Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/ipc/IPCEventStreamServiceTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.Log;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.AuthenticationHandler;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.AuthorizationHandler;\n+\n+import java.io.IOException;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class IPCEventStreamServiceTest {\n+    private IPCEventStreamService ipcEventStreamService;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    //    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    protected static ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    static {\n+        Log.initLoggingToFile(Log.LogLevel.Trace, \"crt.log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MDU4NQ=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzNzkzOQ==", "bodyText": "This is low on priority.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r505037939", "createdAt": "2020-10-14T22:47:52Z", "author": {"login": "abanthiy"}, "path": "src/test/java/com/aws/greengrass/ipc/IPCEventStreamServiceTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import generated.software.amazon.awssdk.iot.greengrass.GreengrassCoreIPCService;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.crt.Log;\n+import software.amazon.eventstream.iot.server.AuthenticationData;\n+import software.amazon.eventstream.iot.server.AuthenticationHandler;\n+import software.amazon.eventstream.iot.server.Authorization;\n+import software.amazon.eventstream.iot.server.AuthorizationHandler;\n+\n+import java.io.IOException;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class IPCEventStreamServiceTest {\n+    private IPCEventStreamService ipcEventStreamService;\n+    @SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+    //    private static final String LOCAL_HOST = \"127.0.0.1\";\n+    protected static ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    static {\n+        Log.initLoggingToFile(Log.LogLevel.Trace, \"crt.log\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MDU4NQ=="}, "originalCommit": {"oid": "8989fc7439ae6bf5c867e4ef20d0e05db4028981"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTAyMzA3OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMDoxMTo0M1rOHg9uCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMzoxMzo0OFrOHhqIXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMyNzY5MQ==", "bodyText": "What's 0 here? A Timeout? Will 0 mean no timeout?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r504327691", "createdAt": "2020-10-14T00:11:43Z", "author": {"login": "philcali"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -54,26 +75,39 @@\n import static org.hamcrest.Matchers.is;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n \n @ExtendWith(GGExtension.class)\n class IPCServicesTest {\n \n-    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 2;\n+    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 20;\n+    private static int TIMEOUT_FOR_LIFECYCLE_SECONDS = 20;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n \n     @TempDir\n     static Path tempRootDir;\n \n     private static Kernel kernel;\n+    private static ClientConnection clientConnection;\n     private IPCClient client;\n \n     @BeforeAll\n-    static void beforeAll() throws InterruptedException {\n+    static void beforeAll() throws InterruptedException, IOException, ExecutionException {\n         System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n         kernel = prepareKernelFromConfigFile(\"ipc.yaml\", IPCServicesTest.class, TEST_SERVICE_NAME);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        clientConnection = IPCTestUtils.connectClientForEventStreamIpc(authToken, kernel);\n     }\n \n     @AfterAll\n     static void afterAll() throws InterruptedException {\n+        if (clientConnection != null) {\n+            clientConnection.closeConnection(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fcd63afcf364253168a29d99fe55eb10389a305"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA1NTMyNg==", "bodyText": "No its not timeout. Its an error code returned to the native. 0 indicates connection closing successfully without any error.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r505055326", "createdAt": "2020-10-14T23:13:48Z", "author": {"login": "abanthiy"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -54,26 +75,39 @@\n import static org.hamcrest.Matchers.is;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n \n @ExtendWith(GGExtension.class)\n class IPCServicesTest {\n \n-    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 2;\n+    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 20;\n+    private static int TIMEOUT_FOR_LIFECYCLE_SECONDS = 20;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n \n     @TempDir\n     static Path tempRootDir;\n \n     private static Kernel kernel;\n+    private static ClientConnection clientConnection;\n     private IPCClient client;\n \n     @BeforeAll\n-    static void beforeAll() throws InterruptedException {\n+    static void beforeAll() throws InterruptedException, IOException, ExecutionException {\n         System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n         kernel = prepareKernelFromConfigFile(\"ipc.yaml\", IPCServicesTest.class, TEST_SERVICE_NAME);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        clientConnection = IPCTestUtils.connectClientForEventStreamIpc(authToken, kernel);\n     }\n \n     @AfterAll\n     static void afterAll() throws InterruptedException {\n+        if (clientConnection != null) {\n+            clientConnection.closeConnection(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMyNzY5MQ=="}, "originalCommit": {"oid": "9fcd63afcf364253168a29d99fe55eb10389a305"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjQ4MzQ0OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTowOToyM1rOHkhv4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwMTo0MDo1MVrOHknfXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2MzcxMw==", "bodyText": "Low priority obviously, but builders or setters with builder pattern would be nice", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508063713", "createdAt": "2020-10-19T21:09:23Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -80,10 +88,18 @@\n class DeploymentConfigMergingTest extends BaseITCase {\n     private Kernel kernel;\n     private DeploymentConfigMerger deploymentConfigMerger;\n+    private static SocketOptions socketOptions;\n+\n+    @BeforeAll\n+    void initialize() {\n+        socketOptions = new SocketOptions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1Nzc4OQ==", "bodyText": "Haven't seen builder pattern in the Iot device SDKs for other services so not sure if I will be able to persuade them to add for this one. More than this I would want it for all the requests. Will add to the list of asks after re:invent", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508157789", "createdAt": "2020-10-20T01:40:51Z", "author": {"login": "abanthiy"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -80,10 +88,18 @@\n class DeploymentConfigMergingTest extends BaseITCase {\n     private Kernel kernel;\n     private DeploymentConfigMerger deploymentConfigMerger;\n+    private static SocketOptions socketOptions;\n+\n+    @BeforeAll\n+    void initialize() {\n+        socketOptions = new SocketOptions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2MzcxMw=="}, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjUwNDgxOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMToxNTo0MlrOHkh8kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMToxNTo0MlrOHkh8kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2Njk2MQ==", "bodyText": "should log this or something so that it can fail the test if some error occurs.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508066961", "createdAt": "2020-10-19T21:15:42Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -461,32 +485,48 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n-        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n-        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n-\n         AtomicInteger deferCount = new AtomicInteger(0);\n         AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n         CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n-        lifecycle.subscribeToComponentUpdate((event) -> {\n-\n-            if (event instanceof PreComponentUpdateEvent) {\n-                preComponentUpdateCount.getAndIncrement();\n-                //defer update the first time\n-                //no response the second time causes the kernel to move forward after default wait time\n-                if (deferCount.get() < 1) {\n-                    try {\n-                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n-                        deferCount.getAndIncrement();\n-                    } catch (LifecycleIPCException e) {\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"nondisruptable\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        final EventStreamRPCConnection clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions,\n+                authToken,\n+                kernel);\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToComponentUpdatesRequest subscribeToComponentUpdatesRequest = new SubscribeToComponentUpdatesRequest();\n+        greengrassCoreIPCClient.subscribeToComponentUpdates(subscribeToComponentUpdatesRequest,\n+                Optional.of(new StreamResponseHandler<ComponentUpdatePolicyEvents>() {\n+                    @Override\n+                    public void onStreamEvent(ComponentUpdatePolicyEvents streamEvent) {\n+                        if (streamEvent.getPreUpdateEvent() != null) {\n+                            preComponentUpdateCount.getAndIncrement();\n+                            if (deferCount.get() < 1) {\n+                                DeferComponentUpdateRequest deferComponentUpdateRequest = new DeferComponentUpdateRequest();\n+                                deferComponentUpdateRequest.setRecheckAfterMs(Duration.ofSeconds(5).toMillis());\n+                                deferComponentUpdateRequest.setMessage(\"Test\");\n+                                greengrassCoreIPCClient.deferComponentUpdate(deferComponentUpdateRequest,\n+                                        Optional.empty());\n+                                deferCount.getAndIncrement();\n+                            } if (streamEvent.getPostUpdateEvent() != null) {\n+                                postComponentUpdateRecieved.countDown();\n+                                clientConnection.disconnect();\n+                            }\n+                        }\n+                    }\n+\n+                    @Override\n+                    public boolean onStreamError(Throwable error) {\n+                        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjUwODA4OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMToxNjozNFrOHkh-gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwMTo0NToyNVrOHknj-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2NzQ1OQ==", "bodyText": "extract to method? This is showing up a lot", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508067459", "createdAt": "2020-10-19T21:16:34Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -58,22 +80,39 @@\n @ExtendWith(GGExtension.class)\n class IPCServicesTest {\n \n-    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 2;\n+    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 20;\n+    private static int TIMEOUT_FOR_LIFECYCLE_SECONDS = 20;\n \n     @TempDir\n     static Path tempRootDir;\n \n     private static Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n     private IPCClient client;\n+    private static SocketOptions socketOptions;\n \n     @BeforeAll\n-    static void beforeAll() throws InterruptedException {\n+    static void beforeAll() throws InterruptedException, IOException, ExecutionException {\n         System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n         kernel = prepareKernelFromConfigFile(\"ipc.yaml\", IPCServicesTest.class, TEST_SERVICE_NAME);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1ODk2OQ==", "bodyText": "Added to TestUtils for tests.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508158969", "createdAt": "2020-10-20T01:45:25Z", "author": {"login": "abanthiy"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -58,22 +80,39 @@\n @ExtendWith(GGExtension.class)\n class IPCServicesTest {\n \n-    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 2;\n+    private static int TIMEOUT_FOR_CONFIG_STORE_SECONDS = 20;\n+    private static int TIMEOUT_FOR_LIFECYCLE_SECONDS = 20;\n \n     @TempDir\n     static Path tempRootDir;\n \n     private static Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n     private IPCClient client;\n+    private static SocketOptions socketOptions;\n \n     @BeforeAll\n-    static void beforeAll() throws InterruptedException {\n+    static void beforeAll() throws InterruptedException, IOException, ExecutionException {\n         System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n         kernel = prepareKernelFromConfigFile(\"ipc.yaml\", IPCServicesTest.class, TEST_SERVICE_NAME);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2NzQ1OQ=="}, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjUxNjUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMToxOToxM1rOHkiDnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMToxOToxM1rOHkiDnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2ODc2NQ==", "bodyText": "no getOnce when using Coerce", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508068765", "createdAt": "2020-10-19T21:19:13Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                        .find(VERSION_CONFIG_KEY).getOnce()));\n+            }\n+            if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                componentDetails\n+                        .setConfiguration(service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+            }\n+            GetComponentDetailsResponse response = new GetComponentDetailsResponse();\n+            response.setComponentDetails(componentDetails);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateGetComponentDetailsRequest(GetComponentDetailsRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class ListComponentsHandler extends GeneratedAbstractListComponentsOperationHandler {\n+\n+        public ListComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListComponentsResponse handleRequest(ListComponentsRequest request) {\n+            Collection<GreengrassService> services = kernel.orderedDependencies();\n+            List<ComponentDetails> listOfComponents =\n+                    services.stream().filter(service -> !service.getName().equals(kernel.getMain().getName()))\n+                            .map(service -> {\n+                                ComponentDetails componentDetails = new ComponentDetails();\n+                                componentDetails.setComponentName(service.getName());\n+                                componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+                                if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                                    componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                                                    .find(VERSION_CONFIG_KEY).getOnce()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjUyMjc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMToyMTowNlrOHkiHWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMToyMTowNlrOHkiHWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2OTcyMg==", "bodyText": "This isn't logging. Use .log(\"text\")", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508069722", "createdAt": "2020-10-19T21:21:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,258 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo(\"Stream closed for subscribeToComponentUpdate\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjUzNzE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMToyNTo0NVrOHkiQBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwMToxODozOFrOHknH4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MTk0MA==", "bodyText": "why doesn't the SDK deserialize this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508071940", "createdAt": "2020-10-19T21:25:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String KERNEL_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_KERNEL_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MTc3Nw==", "bodyText": "The connect message payload is not part of the event-stream protocol, neither it is part of the smithy model. So we need to manually create this for Greengrass. And thus needs explicity deserialization.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508151777", "createdAt": "2020-10-20T01:18:38Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String KERNEL_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_KERNEL_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MTk0MA=="}, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjUzODE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMToyNjowNVrOHkiQpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozMDozMFrOHlW9lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MjEwMw==", "bodyText": "also wait for the elg to shutdown, like 2 seconds", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508072103", "createdAt": "2020-10-19T21:26:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String KERNEL_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_KERNEL_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().setCause(e).log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (Utils.isEmpty(authToken)) {\n+            String errorMessage = \"Received empty auth token to authenticate IPC client\";\n+            logger.atError().log(errorMessage);\n+            throw new RuntimeException(errorMessage);\n+        }\n+        AuthenticationData authenticationData;\n+        try {\n+            final String serviceName = authenticationHandler.doAuthentication(authToken);\n+            authenticationData = new AuthenticationData() {\n+                @Override\n+                public String getIdentityLabel() {\n+                    return serviceName;\n+                }\n+            };\n+        } catch (UnauthenticatedException e) {\n+            throw new RuntimeException(\"Unrecognized client connecting to GGC over IPC\");\n+        }\n+        return authenticationData;\n+    }\n+\n+    @Override\n+    public void close() {\n+        // TODO: Future does not complete, wait on them when fixed.\n+        if (ipcServer != null) {\n+            ipcServer.stopServer();\n+        }\n+        if (eventLoopGroup != null) {\n+            eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MTM5MQ==", "bodyText": "Last I checked the ipc server shutdown was not working fine so it would indefinitely block on elg close. I have a TODO to update this when this issue is fixed.\nUPDATE: Checked again, its the same behavior still.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508151391", "createdAt": "2020-10-20T01:17:21Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String KERNEL_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_KERNEL_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().setCause(e).log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (Utils.isEmpty(authToken)) {\n+            String errorMessage = \"Received empty auth token to authenticate IPC client\";\n+            logger.atError().log(errorMessage);\n+            throw new RuntimeException(errorMessage);\n+        }\n+        AuthenticationData authenticationData;\n+        try {\n+            final String serviceName = authenticationHandler.doAuthentication(authToken);\n+            authenticationData = new AuthenticationData() {\n+                @Override\n+                public String getIdentityLabel() {\n+                    return serviceName;\n+                }\n+            };\n+        } catch (UnauthenticatedException e) {\n+            throw new RuntimeException(\"Unrecognized client connecting to GGC over IPC\");\n+        }\n+        return authenticationData;\n+    }\n+\n+    @Override\n+    public void close() {\n+        // TODO: Future does not complete, wait on them when fixed.\n+        if (ipcServer != null) {\n+            ipcServer.stopServer();\n+        }\n+        if (eventLoopGroup != null) {\n+            eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MjEwMw=="}, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNTU3Mw==", "bodyText": "Timeout is fine, just log it. I added the same for mqtt and iot connection helper.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508935573", "createdAt": "2020-10-21T01:30:30Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String KERNEL_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_KERNEL_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {\n+        String authToken = null;\n+\n+        try {\n+            GGEventStreamConnectMessage connectMessage = OBJECT_MAPPER.readValue(payload,\n+                    GGEventStreamConnectMessage.class);\n+            authToken = connectMessage.getAuthToken();\n+        } catch (IOException e) {\n+            String errorMessage = \"Invalid auth token in connect message\";\n+            logger.atError().setCause(e).log(errorMessage);\n+            // TODO: Add BadRequestException to smithy model\n+            throw new RuntimeException(errorMessage);\n+        }\n+        if (Utils.isEmpty(authToken)) {\n+            String errorMessage = \"Received empty auth token to authenticate IPC client\";\n+            logger.atError().log(errorMessage);\n+            throw new RuntimeException(errorMessage);\n+        }\n+        AuthenticationData authenticationData;\n+        try {\n+            final String serviceName = authenticationHandler.doAuthentication(authToken);\n+            authenticationData = new AuthenticationData() {\n+                @Override\n+                public String getIdentityLabel() {\n+                    return serviceName;\n+                }\n+            };\n+        } catch (UnauthenticatedException e) {\n+            throw new RuntimeException(\"Unrecognized client connecting to GGC over IPC\");\n+        }\n+        return authenticationData;\n+    }\n+\n+    @Override\n+    public void close() {\n+        // TODO: Future does not complete, wait on them when fixed.\n+        if (ipcServer != null) {\n+            ipcServer.stopServer();\n+        }\n+        if (eventLoopGroup != null) {\n+            eventLoopGroup.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MjEwMw=="}, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjU2MDI5OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/testcommons/testutilities/SpawnedProcessProtector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTozMzowN1rOHkid5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwMToxMzo1M1rOHknCvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3NTQ5NQ==", "bodyText": "why is this differetn?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508075495", "createdAt": "2020-10-19T21:33:07Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/testcommons/testutilities/SpawnedProcessProtector.java", "diffHunk": "@@ -33,6 +33,17 @@ public void afterEach(ExtensionContext context) throws Exception {\n             System.err.println(\n                     \"Child PID not cleaned after test case \" + context.getDisplayName() + \". Child PIDs: \" + String\n                             .join(\", \", childPids));\n+            for (String pid : childPids) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MDQ2MQ==", "bodyText": "I was trying to debug something. Removed the code.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508150461", "createdAt": "2020-10-20T01:13:53Z", "author": {"login": "abanthiy"}, "path": "src/test/java/com/aws/greengrass/testcommons/testutilities/SpawnedProcessProtector.java", "diffHunk": "@@ -33,6 +33,17 @@ public void afterEach(ExtensionContext context) throws Exception {\n             System.err.println(\n                     \"Child PID not cleaned after test case \" + context.getDisplayName() + \". Child PIDs: \" + String\n                             .join(\", \", childPids));\n+            for (String pid : childPids) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3NTQ5NQ=="}, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MjU2NTY0OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/ipc/IPCEventStreamServiceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTozNDo1NlrOHkihKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTozNDo1NlrOHkihKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3NjMyOA==", "bodyText": "gg extension", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508076328", "createdAt": "2020-10-19T21:34:56Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/ipc/IPCEventStreamServiceTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.ipc.common.GGEventStreamConnectMessage;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.ClientConnection;\n+import software.amazon.awssdk.crt.eventstream.ClientConnectionHandler;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.eventstream.MessageType;\n+import software.amazon.awssdk.crt.io.ClientBootstrap;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.HostResolver;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthorizationHandler;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.ipc.IPCEventStreamService.DEFAULT_PORT_NUMBER;\n+import static com.aws.greengrass.ipc.IPCEventStreamService.IPC_SERVER_DOMAIN_SOCKET_FILENAME;\n+import static com.aws.greengrass.ipc.IPCEventStreamService.KERNEL_DOMAIN_SOCKET_FILEPATH;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a916125224bb8671a8c3ac0bf69aee35994f835"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODAzNzkzOnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxNzowMlrOHlWv6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxNzowMlrOHlWv6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjA3Mw==", "bodyText": "can we bump this back up?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508932073", "createdAt": "2020-10-21T01:17:02Z", "author": {"login": "MikeDombo"}, "path": "pom.xml", "diffHunk": "@@ -35,7 +36,7 @@\n         <dependency>\n             <groupId>org.mockito</groupId>\n             <artifactId>mockito-junit-jupiter</artifactId>\n-            <version>3.5.13</version>\n+            <version>3.5.6</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODAzOTQzOnYy", "diffSide": "RIGHT", "path": ".github/workflows/maven.yml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxNzo0NFrOHlWwwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzowMDo0MFrOHl2eUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjI5MA==", "bodyText": "clean shouldn't be needed because github actions uses a fresh workspace every time.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508932290", "createdAt": "2020-10-21T01:17:44Z", "author": {"login": "MikeDombo"}, "path": ".github/workflows/maven.yml", "diffHunk": "@@ -30,7 +30,7 @@ jobs:\n         shell: cmd\n         if: matrix.os == 'Windows'\n       - name: Build with Maven\n-        run: mvn -ntp -U verify\n+        run: mvn -ntp -U clean verify", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1MDc4Mw==", "bodyText": "Did not seem that way when I was testing for pulling the fresh CRT jar.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509450783", "createdAt": "2020-10-21T16:59:10Z", "author": {"login": "abanthiy"}, "path": ".github/workflows/maven.yml", "diffHunk": "@@ -30,7 +30,7 @@ jobs:\n         shell: cmd\n         if: matrix.os == 'Windows'\n       - name: Build with Maven\n-        run: mvn -ntp -U verify\n+        run: mvn -ntp -U clean verify", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjI5MA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1MTg1OQ==", "bodyText": "clean doesn't affect dependencies whatsoever", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509451859", "createdAt": "2020-10-21T17:00:40Z", "author": {"login": "MikeDombo"}, "path": ".github/workflows/maven.yml", "diffHunk": "@@ -30,7 +30,7 @@ jobs:\n         shell: cmd\n         if: matrix.os == 'Windows'\n       - name: Build with Maven\n-        run: mvn -ntp -U verify\n+        run: mvn -ntp -U clean verify", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjI5MA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA0MDE1OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxODoxNFrOHlWxLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToxNTozMlrOHmF3Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjM5Nw==", "bodyText": "this should be extracted to a common util", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508932397", "createdAt": "2020-10-21T01:18:14Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -461,32 +485,49 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n-        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n-        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n-\n         AtomicInteger deferCount = new AtomicInteger(0);\n         AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n         CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n-        lifecycle.subscribeToComponentUpdate((event) -> {\n-\n-            if (event instanceof PreComponentUpdateEvent) {\n-                preComponentUpdateCount.getAndIncrement();\n-                //defer update the first time\n-                //no response the second time causes the kernel to move forward after default wait time\n-                if (deferCount.get() < 1) {\n-                    try {\n-                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n-                        deferCount.getAndIncrement();\n-                    } catch (LifecycleIPCException e) {\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"nondisruptable\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwMzk0Mg==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509703942", "createdAt": "2020-10-21T21:15:32Z", "author": {"login": "abanthiy"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -461,32 +485,49 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n-        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n-        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n-\n         AtomicInteger deferCount = new AtomicInteger(0);\n         AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n         CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n-        lifecycle.subscribeToComponentUpdate((event) -> {\n-\n-            if (event instanceof PreComponentUpdateEvent) {\n-                preComponentUpdateCount.getAndIncrement();\n-                //defer update the first time\n-                //no response the second time causes the kernel to move forward after default wait time\n-                if (deferCount.get() < 1) {\n-                    try {\n-                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n-                        deferCount.getAndIncrement();\n-                    } catch (LifecycleIPCException e) {\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"nondisruptable\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMjM5Nw=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA0Njc5OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToyMjoxN1rOHlW1Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToxNTo0NFrOHmF3rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMzM4Mw==", "bodyText": "log?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508933383", "createdAt": "2020-10-21T01:22:17Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -869,25 +881,41 @@ void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_roll\n \n     @Test\n     @Order(8)\n+    @SuppressWarnings(\"PMD.CloseResource\")\n     void GIVEN_deployment_in_progress_WHEN_deployment_task_is_cancelled_THEN_stop_processing() throws Exception {\n         Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n                 DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n                 System.currentTimeMillis());\n         resultFuture.get(30, TimeUnit.SECONDS);\n \n-        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"NonDisruptableService\", kernel);\n-        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n-        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n-\n-        lifecycle.subscribeToComponentUpdate((event) -> {\n-            if (event instanceof PreComponentUpdateEvent) {\n-                try {\n-                    lifecycle.deferComponentUpdate(\"NonDisruptableService\", TimeUnit.SECONDS.toMillis(60));\n-                    ipcClient.disconnect();\n-                } catch (LifecycleIPCException e) {\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"NonDisruptableService\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        final EventStreamRPCConnection clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions,\n+                authToken, kernel);\n+        SubscribeToComponentUpdatesRequest subscribeToComponentUpdatesRequest = new SubscribeToComponentUpdatesRequest();\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        greengrassCoreIPCClient.subscribeToComponentUpdates(subscribeToComponentUpdatesRequest, Optional.of(new StreamResponseHandler<ComponentUpdatePolicyEvents>() {\n+            @Override\n+            public void onStreamEvent(ComponentUpdatePolicyEvents streamEvent) {\n+                if (streamEvent.getPreUpdateEvent() != null ) {\n+                    DeferComponentUpdateRequest deferComponentUpdateRequest = new DeferComponentUpdateRequest();\n+                    deferComponentUpdateRequest.setRecheckAfterMs(Duration.ofSeconds(60).toMillis());\n+                    deferComponentUpdateRequest.setMessage(\"Test\");\n+                    greengrassCoreIPCClient.deferComponentUpdate(deferComponentUpdateRequest, Optional.empty());\n                 }\n             }\n-        });\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNDExMQ==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509704111", "createdAt": "2020-10-21T21:15:44Z", "author": {"login": "abanthiy"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -869,25 +881,41 @@ void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_roll\n \n     @Test\n     @Order(8)\n+    @SuppressWarnings(\"PMD.CloseResource\")\n     void GIVEN_deployment_in_progress_WHEN_deployment_task_is_cancelled_THEN_stop_processing() throws Exception {\n         Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n                 DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n                 System.currentTimeMillis());\n         resultFuture.get(30, TimeUnit.SECONDS);\n \n-        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"NonDisruptableService\", kernel);\n-        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n-        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n-\n-        lifecycle.subscribeToComponentUpdate((event) -> {\n-            if (event instanceof PreComponentUpdateEvent) {\n-                try {\n-                    lifecycle.deferComponentUpdate(\"NonDisruptableService\", TimeUnit.SECONDS.toMillis(60));\n-                    ipcClient.disconnect();\n-                } catch (LifecycleIPCException e) {\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"NonDisruptableService\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        final EventStreamRPCConnection clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions,\n+                authToken, kernel);\n+        SubscribeToComponentUpdatesRequest subscribeToComponentUpdatesRequest = new SubscribeToComponentUpdatesRequest();\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        greengrassCoreIPCClient.subscribeToComponentUpdates(subscribeToComponentUpdatesRequest, Optional.of(new StreamResponseHandler<ComponentUpdatePolicyEvents>() {\n+            @Override\n+            public void onStreamEvent(ComponentUpdatePolicyEvents streamEvent) {\n+                if (streamEvent.getPreUpdateEvent() != null ) {\n+                    DeferComponentUpdateRequest deferComponentUpdateRequest = new DeferComponentUpdateRequest();\n+                    deferComponentUpdateRequest.setRecheckAfterMs(Duration.ofSeconds(60).toMillis());\n+                    deferComponentUpdateRequest.setMessage(\"Test\");\n+                    greengrassCoreIPCClient.deferComponentUpdate(deferComponentUpdateRequest, Optional.empty());\n                 }\n             }\n-        });\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMzM4Mw=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA0OTczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToyMzo1NFrOHlW2vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToxODowOFrOHmF_eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMzgyMQ==", "bodyText": "no getOnce when using coerce", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508933821", "createdAt": "2020-10-21T01:23:54Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNjEwNA==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509706104", "createdAt": "2020-10-21T21:18:08Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMzgyMQ=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA1MDg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToyNDozMVrOHlW3dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTo0OTozM1rOHmHcWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNDAwNg==", "bodyText": "why suppress the warning, why not just make this a static class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508934006", "createdAt": "2020-10-21T01:24:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                        .find(VERSION_CONFIG_KEY).getOnce()));\n+            }\n+            if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                componentDetails\n+                        .setConfiguration(service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+            }\n+            GetComponentDetailsResponse response = new GetComponentDetailsResponse();\n+            response.setComponentDetails(componentDetails);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateGetComponentDetailsRequest(GetComponentDetailsRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class ListComponentsHandler extends GeneratedAbstractListComponentsOperationHandler {\n+\n+        public ListComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListComponentsResponse handleRequest(ListComponentsRequest request) {\n+            Collection<GreengrassService> services = kernel.orderedDependencies();\n+            List<ComponentDetails> listOfComponents =\n+                    services.stream().filter(service -> !service.getName().equals(kernel.getMain().getName()))\n+                            .map(service -> {\n+                                ComponentDetails componentDetails = new ComponentDetails();\n+                                componentDetails.setComponentName(service.getName());\n+                                componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+                                if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                                    componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                                                    .find(VERSION_CONFIG_KEY)));\n+                                }\n+                                if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                                    componentDetails.setConfiguration(service.getServiceConfig()\n+                                            .findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+                                }\n+                                return componentDetails;\n+                            }).collect(Collectors.toList());\n+            ListComponentsResponse response = new ListComponentsResponse();\n+            response.setComponents(listOfComponents);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class RestartComponentsHandler extends GeneratedAbstractRestartComponentOperationHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyOTg4MA==", "bodyText": "need to access some non static members of CLIEventStreamAgent in this class's methods", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509729880", "createdAt": "2020-10-21T21:49:33Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                        .find(VERSION_CONFIG_KEY).getOnce()));\n+            }\n+            if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                componentDetails\n+                        .setConfiguration(service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+            }\n+            GetComponentDetailsResponse response = new GetComponentDetailsResponse();\n+            response.setComponentDetails(componentDetails);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateGetComponentDetailsRequest(GetComponentDetailsRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class ListComponentsHandler extends GeneratedAbstractListComponentsOperationHandler {\n+\n+        public ListComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListComponentsResponse handleRequest(ListComponentsRequest request) {\n+            Collection<GreengrassService> services = kernel.orderedDependencies();\n+            List<ComponentDetails> listOfComponents =\n+                    services.stream().filter(service -> !service.getName().equals(kernel.getMain().getName()))\n+                            .map(service -> {\n+                                ComponentDetails componentDetails = new ComponentDetails();\n+                                componentDetails.setComponentName(service.getName());\n+                                componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+                                if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                                    componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                                                    .find(VERSION_CONFIG_KEY)));\n+                                }\n+                                if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                                    componentDetails.setConfiguration(service.getServiceConfig()\n+                                            .findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+                                }\n+                                return componentDetails;\n+                            }).collect(Collectors.toList());\n+            ListComponentsResponse response = new ListComponentsResponse();\n+            response.setComponents(listOfComponents);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class RestartComponentsHandler extends GeneratedAbstractRestartComponentOperationHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNDAwNg=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA1MjIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToyNTowNlrOHlW4MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToyNTowNlrOHlW4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNDE5Mw==", "bodyText": "this is out of date from mainline. I have a new way of handling recipes", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508934193", "createdAt": "2020-10-21T01:25:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                        .find(VERSION_CONFIG_KEY).getOnce()));\n+            }\n+            if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                componentDetails\n+                        .setConfiguration(service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+            }\n+            GetComponentDetailsResponse response = new GetComponentDetailsResponse();\n+            response.setComponentDetails(componentDetails);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateGetComponentDetailsRequest(GetComponentDetailsRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class ListComponentsHandler extends GeneratedAbstractListComponentsOperationHandler {\n+\n+        public ListComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListComponentsResponse handleRequest(ListComponentsRequest request) {\n+            Collection<GreengrassService> services = kernel.orderedDependencies();\n+            List<ComponentDetails> listOfComponents =\n+                    services.stream().filter(service -> !service.getName().equals(kernel.getMain().getName()))\n+                            .map(service -> {\n+                                ComponentDetails componentDetails = new ComponentDetails();\n+                                componentDetails.setComponentName(service.getName());\n+                                componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+                                if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                                    componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                                                    .find(VERSION_CONFIG_KEY)));\n+                                }\n+                                if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                                    componentDetails.setConfiguration(service.getServiceConfig()\n+                                            .findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+                                }\n+                                return componentDetails;\n+                            }).collect(Collectors.toList());\n+            ListComponentsResponse response = new ListComponentsResponse();\n+            response.setComponents(listOfComponents);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class RestartComponentsHandler extends GeneratedAbstractRestartComponentOperationHandler {\n+\n+        public RestartComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public RestartComponentResponse handleRequest(RestartComponentRequest request) {\n+            validateRestartComponentRequest(request);\n+            String componentName = request.getComponentName();\n+            try {\n+                GreengrassService service = kernel.locate(componentName);\n+                // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+                // Success of this request means restart was triggered successfully\n+                service.requestRestart();\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            RestartComponentResponse response =  new RestartComponentResponse();\n+            response.setRestartStatus(RequestStatus.SUCCEEDED);\n+            return  response;\n+        }\n+\n+        private void validateRestartComponentRequest(RestartComponentRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class StopComponentHandler extends GeneratedAbstractStopComponentOperationHandler {\n+\n+        public StopComponentHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public StopComponentResponse handleRequest(StopComponentRequest request) {\n+            validateStopComponentRequest(request);\n+            String componentName = request.getComponentName();\n+            try {\n+                GreengrassService service = kernel.locate(componentName);\n+                // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+                // Success of this request means stop was triggered successfully\n+                service.requestStop();\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            StopComponentResponse response = new StopComponentResponse();\n+            response.setStopStatus(RequestStatus.SUCCEEDED);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateStopComponentRequest(StopComponentRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    class UpdateRecipesAndArtifactsHandler extends GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler {\n+\n+        public UpdateRecipesAndArtifactsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateRecipesAndArtifactsResponse handleRequest(UpdateRecipesAndArtifactsRequest request) {\n+            validateUpdateRecipesAndArtifactsRequest(request);\n+            Path kernelPackageStorePath = kernel.getNucleusPaths().componentStorePath();\n+            if (!Utils.isEmpty(request.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+                Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(ComponentStore.RECIPE_DIRECTORY);\n+                try {\n+                    if (recipeDirectoryPath.equals(kernelPackageStorePath)) {\n+                        logger.atWarn().log(\"Requested recipe directory path is same as kernel recipe \"\n+                                + \"directory path. Nothing to do\");\n+                    } else {\n+                        Utils.copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA1NTM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToyNzowM1rOHlW6Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToyNzowM1rOHlW6Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNDY2Nw==", "bodyText": "formatting", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508934667", "createdAt": "2020-10-21T01:27:03Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,593 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Coerce;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+import org.apache.commons.lang3.StringUtils;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractCreateLocalDeploymentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetComponentDetailsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetLocalDeploymentStatusOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListComponentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractListLocalDeploymentsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractRestartComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractStopComponentOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidRecipeDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.LocalDeployment;\n+import software.amazon.awssdk.aws.greengrass.model.RequestStatus;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.LOCAL_DEPLOYMENT_RESOURCE;\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_ID_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_TYPE_KEY_NAME;\n+import static com.aws.greengrass.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+\n+public class CLIEventStreamAgent {\n+\n+    private static Logger logger = LogManager.getLogger(CLIEventStreamAgent.class);\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private DeploymentQueue deploymentQueue;\n+\n+    public GetComponentDetailsHandler getGetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+        return new GetComponentDetailsHandler(context);\n+    }\n+\n+    public ListComponentsHandler getListComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new ListComponentsHandler(context);\n+    }\n+\n+    public RestartComponentsHandler getRestartComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new RestartComponentsHandler(context);\n+    }\n+\n+    public StopComponentHandler getStopComponentsHandler(OperationContinuationHandlerContext context) {\n+        return new StopComponentHandler(context);\n+    }\n+\n+    public UpdateRecipesAndArtifactsHandler getUpdateRecipesAndArtifactsHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateRecipesAndArtifactsHandler(context);\n+    }\n+\n+    public CreateLocalDeploymentHandler getCreateLocalDeploymentHandler(OperationContinuationHandlerContext context,\n+                                                                        Topics cliServiceConfig) {\n+        return new CreateLocalDeploymentHandler(context, cliServiceConfig);\n+    }\n+\n+    public GetLocalDeploymentStatusHandler getGetLocalDeploymentStatusHandler(\n+            OperationContinuationHandlerContext context,\n+            Topics cliServiceConfig) {\n+        return new GetLocalDeploymentStatusHandler(context, cliServiceConfig);\n+    }\n+\n+    public ListLocalDeploymentsHandler getListLocalDeploymentsHandler(OperationContinuationHandlerContext context,\n+                                                                      Topics cliServiceConfig) {\n+        return new ListLocalDeploymentsHandler(context, cliServiceConfig);\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     *\n+     * @param serviceConfig     CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(DEPLOYMENT_ID_KEY_NAME);\n+        Topics localDeploymentDetails = localDeployments.lookupTopics(deploymentId);\n+        localDeploymentDetails.replaceAndWait(deploymentDetails);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class GetComponentDetailsHandler extends GeneratedAbstractGetComponentDetailsOperationHandler {\n+\n+        public GetComponentDetailsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public GetComponentDetailsResponse handleRequest(GetComponentDetailsRequest request) {\n+            validateGetComponentDetailsRequest(request);\n+            String componentName = request.getComponentName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(componentName);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            ComponentDetails componentDetails = new ComponentDetails();\n+            componentDetails.setComponentName(service.getName());\n+            componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+            if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                        .find(VERSION_CONFIG_KEY).getOnce()));\n+            }\n+            if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                componentDetails\n+                        .setConfiguration(service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+            }\n+            GetComponentDetailsResponse response = new GetComponentDetailsResponse();\n+            response.setComponentDetails(componentDetails);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateGetComponentDetailsRequest(GetComponentDetailsRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class ListComponentsHandler extends GeneratedAbstractListComponentsOperationHandler {\n+\n+        public ListComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListComponentsResponse handleRequest(ListComponentsRequest request) {\n+            Collection<GreengrassService> services = kernel.orderedDependencies();\n+            List<ComponentDetails> listOfComponents =\n+                    services.stream().filter(service -> !service.getName().equals(kernel.getMain().getName()))\n+                            .map(service -> {\n+                                ComponentDetails componentDetails = new ComponentDetails();\n+                                componentDetails.setComponentName(service.getName());\n+                                componentDetails.setState(LifecycleState.valueOf(service.getState().toString()));\n+\n+                                if (service.getServiceConfig().find(VERSION_CONFIG_KEY) != null) {\n+                                    componentDetails.setVersion(Coerce.toString(service.getServiceConfig()\n+                                                    .find(VERSION_CONFIG_KEY)));\n+                                }\n+                                if (service.getServiceConfig().findInteriorChild(PARAMETERS_CONFIG_KEY) != null) {\n+                                    componentDetails.setConfiguration(service.getServiceConfig()\n+                                            .findInteriorChild(PARAMETERS_CONFIG_KEY).toPOJO());\n+                                }\n+                                return componentDetails;\n+                            }).collect(Collectors.toList());\n+            ListComponentsResponse response = new ListComponentsResponse();\n+            response.setComponents(listOfComponents);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class RestartComponentsHandler extends GeneratedAbstractRestartComponentOperationHandler {\n+\n+        public RestartComponentsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public RestartComponentResponse handleRequest(RestartComponentRequest request) {\n+            validateRestartComponentRequest(request);\n+            String componentName = request.getComponentName();\n+            try {\n+                GreengrassService service = kernel.locate(componentName);\n+                // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+                // Success of this request means restart was triggered successfully\n+                service.requestRestart();\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            RestartComponentResponse response =  new RestartComponentResponse();\n+            response.setRestartStatus(RequestStatus.SUCCEEDED);\n+            return  response;\n+        }\n+\n+        private void validateRestartComponentRequest(RestartComponentRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"SIC_INNER_SHOULD_BE_STATIC\")\n+    class StopComponentHandler extends GeneratedAbstractStopComponentOperationHandler {\n+\n+        public StopComponentHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public StopComponentResponse handleRequest(StopComponentRequest request) {\n+            validateStopComponentRequest(request);\n+            String componentName = request.getComponentName();\n+            try {\n+                GreengrassService service = kernel.locate(componentName);\n+                // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+                // Success of this request means stop was triggered successfully\n+                service.requestStop();\n+            } catch (ServiceLoadException e) {\n+                logger.atError().kv(\"ComponentName\", componentName).setCause(e)\n+                        .log(\"Did not find the component with the given name in Greengrass\");\n+                throw new ResourceNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+            }\n+            StopComponentResponse response = new StopComponentResponse();\n+            response.setStopStatus(RequestStatus.SUCCEEDED);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateStopComponentRequest(StopComponentRequest request) {\n+            validateComponentName(request.getComponentName());\n+        }\n+    }\n+\n+    class UpdateRecipesAndArtifactsHandler extends GeneratedAbstractUpdateRecipesAndArtifactsOperationHandler {\n+\n+        public UpdateRecipesAndArtifactsHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateRecipesAndArtifactsResponse handleRequest(UpdateRecipesAndArtifactsRequest request) {\n+            validateUpdateRecipesAndArtifactsRequest(request);\n+            Path kernelPackageStorePath = kernel.getNucleusPaths().componentStorePath();\n+            if (!Utils.isEmpty(request.getRecipeDirectoryPath())) {\n+                Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+                Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(ComponentStore.RECIPE_DIRECTORY);\n+                try {\n+                    if (recipeDirectoryPath.equals(kernelPackageStorePath)) {\n+                        logger.atWarn().log(\"Requested recipe directory path is same as kernel recipe \"\n+                                + \"directory path. Nothing to do\");\n+                    } else {\n+                        Utils.copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath,\n+                                StandardCopyOption.REPLACE_EXISTING);\n+                    }\n+                } catch (IOException e) {\n+                    logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                            .log(\"Caught exception while updating the recipes\");\n+                    throw new InvalidRecipeDirectoryPathError(e.getMessage());\n+                }\n+            }\n+            if (!Utils.isEmpty(request.getArtifactsDirectoryPath())) {\n+                Path artifactsDirectoryPath = Paths.get(request.getArtifactsDirectoryPath());\n+                Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(ComponentStore.ARTIFACT_DIRECTORY);\n+                try {\n+                    if (artifactsDirectoryPath.equals(kernelArtifactsDirectoryPath)) {\n+                        logger.atWarn().log(\"Requested artifacts directory path is same as kernel artifacts \"\n+                                + \"directory path. Nothing to do\");\n+                    } else {\n+                        Utils.copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath,\n+                                StandardCopyOption.REPLACE_EXISTING);\n+                    }\n+                } catch (IOException e) {\n+                    logger.atError().setCause(e).kv(\"Artifact Directory path\", artifactsDirectoryPath)\n+                            .log(\"Caught exception while updating the recipes\");\n+                    throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+                }\n+            }\n+            return new UpdateRecipesAndArtifactsResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void validateUpdateRecipesAndArtifactsRequest(UpdateRecipesAndArtifactsRequest request) {\n+            String recipeDirectoryPath = request.getRecipeDirectoryPath();\n+            String artifactsDirectoryPath = request.getArtifactsDirectoryPath();\n+            if (StringUtils.isEmpty(recipeDirectoryPath) && StringUtils.isEmpty(artifactsDirectoryPath)) {\n+                throw new InvalidArgumentsError(\"Need to provide at least one of the directory paths to update\");\n+            }\n+        }\n+    }\n+\n+    class CreateLocalDeploymentHandler extends GeneratedAbstractCreateLocalDeploymentOperationHandler {\n+\n+        private final Topics cliServiceConfig;\n+\n+        public CreateLocalDeploymentHandler(OperationContinuationHandlerContext context, Topics cliServiceConfig) {\n+            super(context);\n+            this.cliServiceConfig = cliServiceConfig;\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public CreateLocalDeploymentResponse handleRequest(CreateLocalDeploymentRequest request) {\n+            //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with\n+            // new recipes set using the updateRecipesAndArtifacts API.\n+            String deploymentId = UUID.randomUUID().toString();\n+\n+            LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                    .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                    .componentsToRemove(request.getRootComponentsToRemove())\n+                    .requestTimestamp(System.currentTimeMillis())\n+                    .groupName(request.getGroupName() == null || request.getGroupName().isEmpty() ? DEFAULT_GROUP_NAME\n+                            : request.getGroupName())\n+                    .componentNameToConfig(request.getComponentToConfiguration()).build();\n+            String deploymentDocument;\n+            try {\n+                deploymentDocument = OBJECT_MAPPER.writeValueAsString(localOverrideRequest);\n+            } catch (JsonProcessingException e) {\n+                logger.atError().setCause(e).log(\"Caught exception while parsing local deployment request\");\n+                throw new ServiceError(e.getMessage());\n+            }\n+            Deployment deployment = new Deployment(deploymentDocument, Deployment.DeploymentType.LOCAL, deploymentId);\n+            if (deploymentQueue == null) {\n+                logger.atError().log(\"Deployments queue not initialized\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+            } else {\n+                // save the deployment status as queued\n+                LocalDeploymentDetails localDeploymentDetails = new LocalDeploymentDetails();\n+                localDeploymentDetails.setDeploymentId(deploymentId);\n+                localDeploymentDetails.setDeploymentType(Deployment.DeploymentType.LOCAL);\n+                localDeploymentDetails.setStatus(DeploymentStatus.QUEUED);\n+                persistLocalDeployment(cliServiceConfig, localDeploymentDetails.convertToMapOfObject());\n+                if (deploymentQueue.offer(deployment)) {\n+                    logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                    CreateLocalDeploymentResponse createLocalDeploymentResponse = new CreateLocalDeploymentResponse();\n+                    createLocalDeploymentResponse.setDeploymentId(deploymentId);\n+                    return createLocalDeploymentResponse;\n+                } else {\n+                    logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                            .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                    throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+            //NA\n+        }\n+    }\n+\n+    class GetLocalDeploymentStatusHandler extends GeneratedAbstractGetLocalDeploymentStatusOperationHandler {\n+\n+        private final Topics cliServiceConfig;\n+\n+        public GetLocalDeploymentStatusHandler(OperationContinuationHandlerContext context, Topics cliServiceConfig) {\n+            super(context);\n+            this.cliServiceConfig = cliServiceConfig;\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public GetLocalDeploymentStatusResponse handleRequest(GetLocalDeploymentStatusRequest request) {\n+            validateGetLocalDeploymentStatusRequest(request);\n+            Topics localDeployments = cliServiceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+            if (localDeployments == null || localDeployments.findTopics(request.getDeploymentId()) == null) {\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Cannot find deployment\");\n+                rnf.setResourceType(LOCAL_DEPLOYMENT_RESOURCE);\n+                rnf.setResourceName(request.getDeploymentId());\n+                throw rnf;\n+            } else {\n+                Topics deployment = localDeployments.findTopics(request.getDeploymentId());\n+                DeploymentStatus status =\n+                        deploymentStatusFromString(Coerce.toString(deployment.find(DEPLOYMENT_STATUS_KEY_NAME)));\n+                GetLocalDeploymentStatusResponse response = new GetLocalDeploymentStatusResponse();\n+                LocalDeployment localDeployment = new LocalDeployment();\n+                localDeployment.setDeploymentId(request.getDeploymentId());\n+                localDeployment.setStatus(status);\n+                response.setDeployment(localDeployment);\n+                return response;\n+            }\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        private void validateGetLocalDeploymentStatusRequest(GetLocalDeploymentStatusRequest request) {\n+            try {\n+                UUID.fromString(request.getDeploymentId());\n+            } catch (IllegalArgumentException e) {\n+                throw new InvalidArgumentsError(\"Invalid deploymentId format received. DeploymentId is a UUID\");\n+            }\n+        }\n+    }\n+\n+    class ListLocalDeploymentsHandler extends GeneratedAbstractListLocalDeploymentsOperationHandler {\n+\n+        private final Topics cliServiceConfig;\n+\n+        public ListLocalDeploymentsHandler(OperationContinuationHandlerContext context, Topics cliServiceConfig) {\n+            super(context);\n+            this.cliServiceConfig = cliServiceConfig;\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public ListLocalDeploymentsResponse handleRequest(ListLocalDeploymentsRequest request) {\n+            List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+            Topics localDeployments = cliServiceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+            localDeployments.forEach(topic -> {\n+                Topics topics = (Topics) topic;\n+                LocalDeployment localDeployment = new LocalDeployment();\n+                localDeployment.setDeploymentId(topics.getName());\n+                localDeployment.setStatus(deploymentStatusFromString(Coerce.toString(\n+                        topics.find(DEPLOYMENT_STATUS_KEY_NAME))));\n+                persistedDeployments.add(localDeployment);\n+            });\n+            ListLocalDeploymentsResponse response = new ListLocalDeploymentsResponse();\n+            response.setLocalDeployments(persistedDeployments);\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    private void validateComponentName(String componentName) {\n+        if (Utils.isEmpty(componentName)) {\n+            throw new InvalidArgumentsError(\"Component name cannot be empty\");\n+        }\n+    }\n+\n+    private DeploymentStatus deploymentStatusFromString(String status) {\n+        for (DeploymentStatus ds: DeploymentStatus.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 561}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA1NzY5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToyODoyM1rOHlW7XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToyODoyM1rOHlW7XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNTAwNQ==", "bodyText": "I'm a bit worried about all these changes. I'm sure you thought it through, but most of the interface is in the \"service\" and not the agent. It should be possible to mostly change the service and then the agent logic could remain mostly the same", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508935005", "createdAt": "2020-10-21T01:28:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA3MzQ3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozNzowM1rOHlXEeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozNzowM1rOHlXEeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzMzOA==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937338", "createdAt": "2020-10-21T01:37:03Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA3MzcxOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozNzoxMVrOHlXEnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozNzoxMVrOHlXEnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzM3NQ==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937375", "createdAt": "2020-10-21T01:37:11Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA3NTE1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozNzo1NVrOHlXFcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozNzo1NVrOHlXFcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzU4NA==", "bodyText": "use assert throws. It returns the exception so you can validate the message", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937584", "createdAt": "2020-10-21T01:37:55Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(mockMainService.getName()).thenReturn(\"main\");\n+        when(kernel.getMain()).thenReturn(mockMainService);\n+        when(kernel.orderedDependencies()).thenReturn(Arrays.asList(mockTestService, mockMainService));\n+        ListComponentsResponse response =\n+                cliEventStreamAgent.getListComponentsHandler(mockContext).handleRequest(request);\n+        assertEquals(1, response.getComponents().size());\n+        ComponentDetails componentDetails = response.getComponents().get(0);\n+        assertEquals(TEST_SERVICE, componentDetails.getComponentName());\n+        assertEquals(mockParameterConfig, componentDetails.getConfiguration());\n+        assertEquals(\"1.0.0\", componentDetails.getVersion());\n+    }\n+\n+    @Test\n+    public void testRestartComponent_emptyComponentName() {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_restart() throws ServiceLoadException {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest);\n+        verify(mockTestService).requestRestart();\n+    }\n+\n+    @Test\n+    public void testStopComponent_emptyComponentName() {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_restart() throws ServiceLoadException {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest);\n+        verify(mockTestService).requestStop();\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_empty_paths() {\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_invalid_paths(ExtensionContext context) {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        request.setArtifactsDirectoryPath(\"/InvalidPath\");\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        assertThrows(InvalidArtifactsDirectoryPathError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_successful_update(ExtensionContext context) throws IOException {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        Path mockArtifactsDirectoryPath = Files.createTempDirectory(\"mockArtifactsDirectoryPath\");\n+        request.setArtifactsDirectoryPath(mockArtifactsDirectoryPath.toString());\n+        Path mockRecipesDirectoryPath = Files.createTempDirectory(\"mockRecipesDirectoryPath\");\n+        request.setRecipeDirectoryPath(mockRecipesDirectoryPath.toString());\n+        Path componentPath = Files.createDirectories(mockRecipesDirectoryPath.resolve(\"SampleComponent-1.0.0\"));\n+        Files.createFile(componentPath.resolve(\"sampleRecipe.xml\"));\n+        Files.createFile(mockArtifactsDirectoryPath.resolve(\"artifact.zip\"));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY));\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request);\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY)\n+                .resolve(\"SampleComponent-1.0.0\").resolve(\"sampleRecipe.xml\")));\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY).resolve(\"artifact.zip\")));\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_deployments_Q_not_initialized() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+       try {\n+            cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA3NTY4OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozODoxNFrOHlXFyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozODoxNFrOHlXFyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzY3NQ==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937675", "createdAt": "2020-10-21T01:38:14Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(mockMainService.getName()).thenReturn(\"main\");\n+        when(kernel.getMain()).thenReturn(mockMainService);\n+        when(kernel.orderedDependencies()).thenReturn(Arrays.asList(mockTestService, mockMainService));\n+        ListComponentsResponse response =\n+                cliEventStreamAgent.getListComponentsHandler(mockContext).handleRequest(request);\n+        assertEquals(1, response.getComponents().size());\n+        ComponentDetails componentDetails = response.getComponents().get(0);\n+        assertEquals(TEST_SERVICE, componentDetails.getComponentName());\n+        assertEquals(mockParameterConfig, componentDetails.getConfiguration());\n+        assertEquals(\"1.0.0\", componentDetails.getVersion());\n+    }\n+\n+    @Test\n+    public void testRestartComponent_emptyComponentName() {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_restart() throws ServiceLoadException {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest);\n+        verify(mockTestService).requestRestart();\n+    }\n+\n+    @Test\n+    public void testStopComponent_emptyComponentName() {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_restart() throws ServiceLoadException {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest);\n+        verify(mockTestService).requestStop();\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_empty_paths() {\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_invalid_paths(ExtensionContext context) {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        request.setArtifactsDirectoryPath(\"/InvalidPath\");\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        assertThrows(InvalidArtifactsDirectoryPathError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_successful_update(ExtensionContext context) throws IOException {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        Path mockArtifactsDirectoryPath = Files.createTempDirectory(\"mockArtifactsDirectoryPath\");\n+        request.setArtifactsDirectoryPath(mockArtifactsDirectoryPath.toString());\n+        Path mockRecipesDirectoryPath = Files.createTempDirectory(\"mockRecipesDirectoryPath\");\n+        request.setRecipeDirectoryPath(mockRecipesDirectoryPath.toString());\n+        Path componentPath = Files.createDirectories(mockRecipesDirectoryPath.resolve(\"SampleComponent-1.0.0\"));\n+        Files.createFile(componentPath.resolve(\"sampleRecipe.xml\"));\n+        Files.createFile(mockArtifactsDirectoryPath.resolve(\"artifact.zip\"));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY));\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request);\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY)\n+                .resolve(\"SampleComponent-1.0.0\").resolve(\"sampleRecipe.xml\")));\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY).resolve(\"artifact.zip\")));\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_deployments_Q_not_initialized() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+       try {\n+            cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        } catch (ServiceError e) {\n+           assertEquals(DEPLOYMENTS_QUEUE_NOT_INITIALIZED, e.getMessage());\n+           return;\n+       }\n+       fail();\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_successfull() throws JsonProcessingException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Topics localDeployments = mock(Topics.class);\n+        Topics localDeploymentDetailsTopics = mock(Topics.class);\n+        when(localDeployments.lookupTopics(any())).thenReturn(localDeploymentDetailsTopics);\n+        when(mockCliConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(deploymentQueue.offer(any())).thenReturn(true);\n+        cliEventStreamAgent.setDeploymentQueue(deploymentQueue);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+        request.setGroupName(MOCK_GROUP);\n+        request.setRootComponentVersionsToAdd(ImmutableMap.of(TEST_SERVICE, \"1.0.0\"));\n+        request.setRootComponentsToRemove(Arrays.asList(\"SomeService\"));\n+        Map<String, Map<String, Object>> componentToConfig = new HashMap<>();\n+        componentToConfig.put(TEST_SERVICE, ImmutableMap.of(\"param1\", \"value1\"));\n+        request.setComponentToConfiguration(componentToConfig);\n+        cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        ArgumentCaptor<Deployment> deploymentCaptor = ArgumentCaptor.forClass(Deployment.class);\n+        verify(deploymentQueue).offer(deploymentCaptor.capture());\n+        String deploymentDoc = deploymentCaptor.getValue().getDeploymentDocument();\n+        LocalOverrideRequest localOverrideRequest = OBJECT_MAPPER.readValue(deploymentDoc, LocalOverrideRequest.class);\n+        assertEquals(MOCK_GROUP, localOverrideRequest.getGroupName());\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsKey(TEST_SERVICE));\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsValue(\"1.0.0\"));\n+        assertTrue(localOverrideRequest.getComponentsToRemove().contains(\"SomeService\"));\n+        assertNotNull(localOverrideRequest.getComponentNameToConfig().get(TEST_SERVICE));\n+        assertEquals(\"value1\", localOverrideRequest.getComponentNameToConfig()\n+                .get(TEST_SERVICE).get(\"param1\"));\n+\n+\n+        verify(localDeployments).lookupTopics(localOverrideRequest.getRequestId());\n+        ArgumentCaptor<Map> deploymentDetailsCaptor = ArgumentCaptor.forClass(Map.class);\n+        verify(localDeploymentDetailsTopics).replaceAndWait(deploymentDetailsCaptor.capture());\n+        CLIEventStreamAgent.LocalDeploymentDetails localDeploymentDetails =\n+                OBJECT_MAPPER.convertValue((Map<String, Object>)deploymentDetailsCaptor.getValue(),\n+                CLIEventStreamAgent.LocalDeploymentDetails.class);\n+        assertEquals(Deployment.DeploymentType.LOCAL, localDeploymentDetails.getDeploymentType());\n+        assertEquals(DeploymentStatus.QUEUED, localDeploymentDetails.getStatus());\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_invalidDeploymentId() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(\"InvalidId\");\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+            mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_deploymentId_not_exist() {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        String deploymentId = UUID.randomUUID().toString();\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(null);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testGetLocalDeploymentStatus_successful() throws IOException {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 349}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA3NTkyOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozODoyMVrOHlXF7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozODoyMVrOHlXF7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzcxMQ==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937711", "createdAt": "2020-10-21T01:38:21Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(mockMainService.getName()).thenReturn(\"main\");\n+        when(kernel.getMain()).thenReturn(mockMainService);\n+        when(kernel.orderedDependencies()).thenReturn(Arrays.asList(mockTestService, mockMainService));\n+        ListComponentsResponse response =\n+                cliEventStreamAgent.getListComponentsHandler(mockContext).handleRequest(request);\n+        assertEquals(1, response.getComponents().size());\n+        ComponentDetails componentDetails = response.getComponents().get(0);\n+        assertEquals(TEST_SERVICE, componentDetails.getComponentName());\n+        assertEquals(mockParameterConfig, componentDetails.getConfiguration());\n+        assertEquals(\"1.0.0\", componentDetails.getVersion());\n+    }\n+\n+    @Test\n+    public void testRestartComponent_emptyComponentName() {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_restart() throws ServiceLoadException {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest);\n+        verify(mockTestService).requestRestart();\n+    }\n+\n+    @Test\n+    public void testStopComponent_emptyComponentName() {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_restart() throws ServiceLoadException {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest);\n+        verify(mockTestService).requestStop();\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_empty_paths() {\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_invalid_paths(ExtensionContext context) {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        request.setArtifactsDirectoryPath(\"/InvalidPath\");\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        assertThrows(InvalidArtifactsDirectoryPathError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_successful_update(ExtensionContext context) throws IOException {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        Path mockArtifactsDirectoryPath = Files.createTempDirectory(\"mockArtifactsDirectoryPath\");\n+        request.setArtifactsDirectoryPath(mockArtifactsDirectoryPath.toString());\n+        Path mockRecipesDirectoryPath = Files.createTempDirectory(\"mockRecipesDirectoryPath\");\n+        request.setRecipeDirectoryPath(mockRecipesDirectoryPath.toString());\n+        Path componentPath = Files.createDirectories(mockRecipesDirectoryPath.resolve(\"SampleComponent-1.0.0\"));\n+        Files.createFile(componentPath.resolve(\"sampleRecipe.xml\"));\n+        Files.createFile(mockArtifactsDirectoryPath.resolve(\"artifact.zip\"));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY));\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request);\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY)\n+                .resolve(\"SampleComponent-1.0.0\").resolve(\"sampleRecipe.xml\")));\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY).resolve(\"artifact.zip\")));\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_deployments_Q_not_initialized() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+       try {\n+            cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        } catch (ServiceError e) {\n+           assertEquals(DEPLOYMENTS_QUEUE_NOT_INITIALIZED, e.getMessage());\n+           return;\n+       }\n+       fail();\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_successfull() throws JsonProcessingException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Topics localDeployments = mock(Topics.class);\n+        Topics localDeploymentDetailsTopics = mock(Topics.class);\n+        when(localDeployments.lookupTopics(any())).thenReturn(localDeploymentDetailsTopics);\n+        when(mockCliConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(deploymentQueue.offer(any())).thenReturn(true);\n+        cliEventStreamAgent.setDeploymentQueue(deploymentQueue);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+        request.setGroupName(MOCK_GROUP);\n+        request.setRootComponentVersionsToAdd(ImmutableMap.of(TEST_SERVICE, \"1.0.0\"));\n+        request.setRootComponentsToRemove(Arrays.asList(\"SomeService\"));\n+        Map<String, Map<String, Object>> componentToConfig = new HashMap<>();\n+        componentToConfig.put(TEST_SERVICE, ImmutableMap.of(\"param1\", \"value1\"));\n+        request.setComponentToConfiguration(componentToConfig);\n+        cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        ArgumentCaptor<Deployment> deploymentCaptor = ArgumentCaptor.forClass(Deployment.class);\n+        verify(deploymentQueue).offer(deploymentCaptor.capture());\n+        String deploymentDoc = deploymentCaptor.getValue().getDeploymentDocument();\n+        LocalOverrideRequest localOverrideRequest = OBJECT_MAPPER.readValue(deploymentDoc, LocalOverrideRequest.class);\n+        assertEquals(MOCK_GROUP, localOverrideRequest.getGroupName());\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsKey(TEST_SERVICE));\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsValue(\"1.0.0\"));\n+        assertTrue(localOverrideRequest.getComponentsToRemove().contains(\"SomeService\"));\n+        assertNotNull(localOverrideRequest.getComponentNameToConfig().get(TEST_SERVICE));\n+        assertEquals(\"value1\", localOverrideRequest.getComponentNameToConfig()\n+                .get(TEST_SERVICE).get(\"param1\"));\n+\n+\n+        verify(localDeployments).lookupTopics(localOverrideRequest.getRequestId());\n+        ArgumentCaptor<Map> deploymentDetailsCaptor = ArgumentCaptor.forClass(Map.class);\n+        verify(localDeploymentDetailsTopics).replaceAndWait(deploymentDetailsCaptor.capture());\n+        CLIEventStreamAgent.LocalDeploymentDetails localDeploymentDetails =\n+                OBJECT_MAPPER.convertValue((Map<String, Object>)deploymentDetailsCaptor.getValue(),\n+                CLIEventStreamAgent.LocalDeploymentDetails.class);\n+        assertEquals(Deployment.DeploymentType.LOCAL, localDeploymentDetails.getDeploymentType());\n+        assertEquals(DeploymentStatus.QUEUED, localDeploymentDetails.getStatus());\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_invalidDeploymentId() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(\"InvalidId\");\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+            mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_deploymentId_not_exist() {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        String deploymentId = UUID.randomUUID().toString();\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(null);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testGetLocalDeploymentStatus_successful() throws IOException {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();\n+        String deploymentId = UUID.randomUUID().toString();\n+        Topics mockLocalDeployment = Topics.of(context, deploymentId, null);\n+        mockLocalDeployment.lookup(DEPLOYMENT_STATUS_KEY_NAME).withValue(DeploymentStatus.IN_PROGRESS.toString());\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(mockLocalDeployment);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        GetLocalDeploymentStatusResponse response = cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request);\n+        assertEquals(deploymentId, response.getDeployment().getDeploymentId());\n+        assertEquals(DeploymentStatus.IN_PROGRESS, response.getDeployment().getStatus());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testListLocalDeployment_no_local_deployments() throws IOException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 368}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA3NjE1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozODoyN1rOHlXGDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTozODoyN1rOHlXGDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNzc0MQ==", "bodyText": "try with resources", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r508937741", "createdAt": "2020-10-21T01:38:27Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/cli/CLIEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,407 @@\n+package com.aws.greengrass.builtin.services.cli;\n+\n+import com.aws.greengrass.componentmanager.ComponentStore;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.deployment.DeploymentQueue;\n+import com.aws.greengrass.deployment.model.Deployment;\n+import com.aws.greengrass.deployment.model.LocalOverrideRequest;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.util.NucleusPaths;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentDetails;\n+import software.amazon.awssdk.aws.greengrass.model.CreateLocalDeploymentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeploymentStatus;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetComponentDetailsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetLocalDeploymentStatusResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentsError;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArtifactsDirectoryPathError;\n+import software.amazon.awssdk.aws.greengrass.model.LifecycleState;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListComponentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ListLocalDeploymentsResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.RestartComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.StopComponentRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateRecipesAndArtifactsRequest;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.utils.ImmutableMap;\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import static com.aws.greengrass.builtin.services.cli.CLIServiceAgent.PERSISTENT_LOCAL_DEPLOYMENTS;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.greengrass.deployment.DeploymentStatusKeeper.DEPLOYMENT_STATUS_KEY_NAME;\n+import static com.aws.greengrass.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+public class CLIEventStreamAgentTest {\n+\n+    private CLIEventStreamAgent cliEventStreamAgent;\n+\n+    private static final String TEST_SERVICE = \"TestService\";\n+    private static final String MOCK_GROUP = \"mockGroup\";\n+    private static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    @Mock\n+    Kernel kernel;\n+\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+\n+    @TempDir\n+    Path mockPath;\n+\n+    @Mock\n+    DeploymentQueue deploymentQueue;\n+\n+    @BeforeEach\n+    public void setup() {\n+        when(mockContext.getContinuation()).thenReturn(mock(ServerConnectionContinuation.class));\n+        cliEventStreamAgent = new CLIEventStreamAgent();\n+        cliEventStreamAgent.setKernel(kernel);\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_empty_component_name() {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        assertThrows(InvalidArgumentsError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void test_GetComponentDetails_component_does_not_exist(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        when(kernel.locate(TEST_SERVICE)).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class, () ->\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetComponentDetails_successful() throws ServiceLoadException, IOException {\n+        GetComponentDetailsRequest request = new GetComponentDetailsRequest();\n+        request.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        GetComponentDetailsResponse response =\n+                cliEventStreamAgent.getGetComponentDetailsHandler(mockContext).handleRequest(request);\n+        assertEquals(TEST_SERVICE, response.getComponentDetails().getComponentName());\n+        assertEquals(LifecycleState.RUNNING, response.getComponentDetails().getState());\n+        assertEquals(\"1.0.0\", response.getComponentDetails().getVersion());\n+        assertEquals(mockParameterConfig, response.getComponentDetails().getConfiguration());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void test_GetListComponent_success() {\n+        ListComponentsRequest request = new ListComponentsRequest();\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        GreengrassService mockMainService = mock(GreengrassService.class);\n+        when(mockTestService.getName()).thenReturn(TEST_SERVICE);\n+        when(mockTestService.getState()).thenReturn(State.RUNNING);\n+        Context context = new Context();\n+        Topics mockServiceConfig = Topics.of(context, TEST_SERVICE, null);\n+        mockServiceConfig.lookup(VERSION_CONFIG_KEY).withValue(\"1.0.0\");\n+        Map<String, Object> mockParameterConfig = ImmutableMap.of(\"param1\", \"value1\");\n+        mockServiceConfig.lookupTopics(PARAMETERS_CONFIG_KEY).replaceAndWait(mockParameterConfig);\n+        when(mockTestService.getServiceConfig()).thenReturn(mockServiceConfig);\n+        when(mockMainService.getName()).thenReturn(\"main\");\n+        when(kernel.getMain()).thenReturn(mockMainService);\n+        when(kernel.orderedDependencies()).thenReturn(Arrays.asList(mockTestService, mockMainService));\n+        ListComponentsResponse response =\n+                cliEventStreamAgent.getListComponentsHandler(mockContext).handleRequest(request);\n+        assertEquals(1, response.getComponents().size());\n+        ComponentDetails componentDetails = response.getComponents().get(0);\n+        assertEquals(TEST_SERVICE, componentDetails.getComponentName());\n+        assertEquals(mockParameterConfig, componentDetails.getConfiguration());\n+        assertEquals(\"1.0.0\", componentDetails.getVersion());\n+    }\n+\n+    @Test\n+    public void testRestartComponent_emptyComponentName() {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest));\n+    }\n+\n+    @Test\n+    public void testRestartComponent_component_restart() throws ServiceLoadException {\n+        RestartComponentRequest restartComponentRequest = new RestartComponentRequest();\n+        restartComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getRestartComponentsHandler(mockContext).handleRequest(restartComponentRequest);\n+        verify(mockTestService).requestRestart();\n+    }\n+\n+    @Test\n+    public void testStopComponent_emptyComponentName() {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_not_found(ExtensionContext context) throws ServiceLoadException {\n+        ignoreExceptionOfType(context, ServiceLoadException.class);\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(\"INVALID_COMPONENT\");\n+        when(kernel.locate(\"INVALID_COMPONENT\")).thenThrow(new ServiceLoadException(\"error\"));\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest));\n+    }\n+\n+    @Test\n+    public void testStopComponent_component_restart() throws ServiceLoadException {\n+        StopComponentRequest stopComponentRequest = new StopComponentRequest();\n+        stopComponentRequest.setComponentName(TEST_SERVICE);\n+        GreengrassService mockTestService = mock(GreengrassService.class);\n+        when(kernel.locate(TEST_SERVICE)).thenReturn(mockTestService);\n+        cliEventStreamAgent.getStopComponentsHandler(mockContext).handleRequest(stopComponentRequest);\n+        verify(mockTestService).requestStop();\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_empty_paths() {\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_invalid_paths(ExtensionContext context) {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        request.setArtifactsDirectoryPath(\"/InvalidPath\");\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        assertThrows(InvalidArtifactsDirectoryPathError.class,\n+                () -> cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testUpdateRecipesAndArtifacts_successful_update(ExtensionContext context) throws IOException {\n+        ignoreExceptionOfType(context, NoSuchFileException.class);\n+        UpdateRecipesAndArtifactsRequest request = new UpdateRecipesAndArtifactsRequest();\n+        Path mockArtifactsDirectoryPath = Files.createTempDirectory(\"mockArtifactsDirectoryPath\");\n+        request.setArtifactsDirectoryPath(mockArtifactsDirectoryPath.toString());\n+        Path mockRecipesDirectoryPath = Files.createTempDirectory(\"mockRecipesDirectoryPath\");\n+        request.setRecipeDirectoryPath(mockRecipesDirectoryPath.toString());\n+        Path componentPath = Files.createDirectories(mockRecipesDirectoryPath.resolve(\"SampleComponent-1.0.0\"));\n+        Files.createFile(componentPath.resolve(\"sampleRecipe.xml\"));\n+        Files.createFile(mockArtifactsDirectoryPath.resolve(\"artifact.zip\"));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY));\n+        Files.createDirectories(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY));\n+        NucleusPaths nucleusPaths = mock(NucleusPaths.class);\n+        when(kernel.getNucleusPaths()).thenReturn(nucleusPaths);\n+        when(nucleusPaths.componentStorePath()).thenReturn(mockPath);\n+        cliEventStreamAgent.getUpdateRecipesAndArtifactsHandler(mockContext).handleRequest(request);\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.RECIPE_DIRECTORY)\n+                .resolve(\"SampleComponent-1.0.0\").resolve(\"sampleRecipe.xml\")));\n+        assertTrue(Files.exists(mockPath.resolve(ComponentStore.ARTIFACT_DIRECTORY).resolve(\"artifact.zip\")));\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_deployments_Q_not_initialized() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+       try {\n+            cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        } catch (ServiceError e) {\n+           assertEquals(DEPLOYMENTS_QUEUE_NOT_INITIALIZED, e.getMessage());\n+           return;\n+       }\n+       fail();\n+    }\n+\n+    @Test\n+    public void testCreateLocalDeployment_successfull() throws JsonProcessingException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Topics localDeployments = mock(Topics.class);\n+        Topics localDeploymentDetailsTopics = mock(Topics.class);\n+        when(localDeployments.lookupTopics(any())).thenReturn(localDeploymentDetailsTopics);\n+        when(mockCliConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(deploymentQueue.offer(any())).thenReturn(true);\n+        cliEventStreamAgent.setDeploymentQueue(deploymentQueue);\n+        CreateLocalDeploymentRequest request = new CreateLocalDeploymentRequest();\n+        request.setGroupName(MOCK_GROUP);\n+        request.setRootComponentVersionsToAdd(ImmutableMap.of(TEST_SERVICE, \"1.0.0\"));\n+        request.setRootComponentsToRemove(Arrays.asList(\"SomeService\"));\n+        Map<String, Map<String, Object>> componentToConfig = new HashMap<>();\n+        componentToConfig.put(TEST_SERVICE, ImmutableMap.of(\"param1\", \"value1\"));\n+        request.setComponentToConfiguration(componentToConfig);\n+        cliEventStreamAgent.getCreateLocalDeploymentHandler(mockContext, mockCliConfig).handleRequest(request);\n+        ArgumentCaptor<Deployment> deploymentCaptor = ArgumentCaptor.forClass(Deployment.class);\n+        verify(deploymentQueue).offer(deploymentCaptor.capture());\n+        String deploymentDoc = deploymentCaptor.getValue().getDeploymentDocument();\n+        LocalOverrideRequest localOverrideRequest = OBJECT_MAPPER.readValue(deploymentDoc, LocalOverrideRequest.class);\n+        assertEquals(MOCK_GROUP, localOverrideRequest.getGroupName());\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsKey(TEST_SERVICE));\n+        assertTrue(localOverrideRequest.getComponentsToMerge().containsValue(\"1.0.0\"));\n+        assertTrue(localOverrideRequest.getComponentsToRemove().contains(\"SomeService\"));\n+        assertNotNull(localOverrideRequest.getComponentNameToConfig().get(TEST_SERVICE));\n+        assertEquals(\"value1\", localOverrideRequest.getComponentNameToConfig()\n+                .get(TEST_SERVICE).get(\"param1\"));\n+\n+\n+        verify(localDeployments).lookupTopics(localOverrideRequest.getRequestId());\n+        ArgumentCaptor<Map> deploymentDetailsCaptor = ArgumentCaptor.forClass(Map.class);\n+        verify(localDeploymentDetailsTopics).replaceAndWait(deploymentDetailsCaptor.capture());\n+        CLIEventStreamAgent.LocalDeploymentDetails localDeploymentDetails =\n+                OBJECT_MAPPER.convertValue((Map<String, Object>)deploymentDetailsCaptor.getValue(),\n+                CLIEventStreamAgent.LocalDeploymentDetails.class);\n+        assertEquals(Deployment.DeploymentType.LOCAL, localDeploymentDetails.getDeploymentType());\n+        assertEquals(DeploymentStatus.QUEUED, localDeploymentDetails.getStatus());\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_invalidDeploymentId() {\n+        Topics mockCliConfig = mock(Topics.class);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(\"InvalidId\");\n+        assertThrows(InvalidArgumentsError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+            mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    public void testGetLocalDeploymentStatus_deploymentId_not_exist() {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        String deploymentId = UUID.randomUUID().toString();\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(null);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        assertThrows(ResourceNotFoundError.class,\n+                () -> cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testGetLocalDeploymentStatus_successful() throws IOException {\n+        Topics localDeployments = mock(Topics.class);\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();\n+        String deploymentId = UUID.randomUUID().toString();\n+        Topics mockLocalDeployment = Topics.of(context, deploymentId, null);\n+        mockLocalDeployment.lookup(DEPLOYMENT_STATUS_KEY_NAME).withValue(DeploymentStatus.IN_PROGRESS.toString());\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        when(localDeployments.findTopics(deploymentId)).thenReturn(mockLocalDeployment);\n+        GetLocalDeploymentStatusRequest request = new GetLocalDeploymentStatusRequest();\n+        request.setDeploymentId(deploymentId);\n+        GetLocalDeploymentStatusResponse response = cliEventStreamAgent.getGetLocalDeploymentStatusHandler(mockContext,\n+                        mockCliConfig).handleRequest(request);\n+        assertEquals(deploymentId, response.getDeployment().getDeploymentId());\n+        assertEquals(DeploymentStatus.IN_PROGRESS, response.getDeployment().getStatus());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testListLocalDeployment_no_local_deployments() throws IOException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();\n+        Topics localDeployments = Topics.of(context, \"localDeployments\", null);\n+        when(mockCliConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS)).thenReturn(localDeployments);\n+        ListLocalDeploymentsRequest request = new ListLocalDeploymentsRequest();\n+        ListLocalDeploymentsResponse response = cliEventStreamAgent.getListLocalDeploymentsHandler(mockContext,\n+                mockCliConfig).handleRequest(request);\n+        assertEquals(0, response.getLocalDeployments().size());\n+        context.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void testListLocalDeployment_successful() throws IOException {\n+        Topics mockCliConfig = mock(Topics.class);\n+        Context context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 382}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIyMjYyOnYy", "diffSide": "RIGHT", "path": "codestyle/findbugs-exclude.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozMjo0MFrOHl1UKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToyMToxOVrOHmGJ7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMjg3Mg==", "bodyText": "hmmm...why are they excluded?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509432872", "createdAt": "2020-10-21T16:32:40Z", "author": {"login": "fengwang666"}, "path": "codestyle/findbugs-exclude.xml", "diffHunk": "@@ -17,4 +17,12 @@\n             <Bug pattern=\"EI_EXPOSE_REP2\"/>\n         </Or>\n     </Match>\n+    <Match>\n+        <Or>\n+            <Package name=\"software.amazon.awssdk.aws.greengrass\"/>\n+            <Package name=\"software.amazon.awssdk.aws.greengrass.model\"/>\n+            <Package name=\"software.amazon.awssdk.eventstreamrpc\"/>\n+            <Package name=\"software.amazon.awssdk.eventstreamrpc.model\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwODc4MQ==", "bodyText": "This code is copied from SDK teams package. Part of this code will eventually come from IotDeviceSdk. For the rest if the bugs are not resolved in the source package (owned by SDK team) they will creep in again when we update code in GG nucleus. So excluding them for now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509708781", "createdAt": "2020-10-21T21:21:19Z", "author": {"login": "abanthiy"}, "path": "codestyle/findbugs-exclude.xml", "diffHunk": "@@ -17,4 +17,12 @@\n             <Bug pattern=\"EI_EXPOSE_REP2\"/>\n         </Or>\n     </Match>\n+    <Match>\n+        <Or>\n+            <Package name=\"software.amazon.awssdk.aws.greengrass\"/>\n+            <Package name=\"software.amazon.awssdk.aws.greengrass.model\"/>\n+            <Package name=\"software.amazon.awssdk.eventstreamrpc\"/>\n+            <Package name=\"software.amazon.awssdk.eventstreamrpc.model\"/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMjg3Mg=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTYwMDU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzo0NTo1OVrOHl5Jsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMjo0ODowMVrOHmOnnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ5NTczMQ==", "bodyText": "What's this DEFAULT_PORT_NUMBER for? Why are we hardcoding it? Can we use random port similar to what we do in IPCService?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509495731", "createdAt": "2020-10-21T17:45:59Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwOTQ1NQ==", "bodyText": "Port number is irrelevant when using domain sockets, but the server does not accept a null value for port number, it just ignores it when using LOCAL socket type.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509709455", "createdAt": "2020-10-21T21:22:08Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ5NTczMQ=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcxMTEyNA==", "bodyText": "How are we going to support lambdas? Lambdas work very easily with regular ports, but a domain socket may be difficult", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509711124", "createdAt": "2020-10-21T21:24:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ5NTczMQ=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1MDE4MQ==", "bodyText": "Can you add a comment regarding the port and hostname? It will be super weird for anyone new reading this code (think about the outside readers once this code is open-source).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509750181", "createdAt": "2020-10-21T22:18:00Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ5NTczMQ=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NTU5NA==", "bodyText": "@MikeDombo what difficulty do you foresee for lambda?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509845594", "createdAt": "2020-10-22T02:40:44Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ5NTczMQ=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NjQwNg==", "bodyText": "Well at the very least we'd need to mount it into the container at some location and then pass that along to the customer lambda. Depending on the permissions of the socket, there could be some permissions difficulties. @rbattle any comments, or is this an easy thing for us to handle correctly?\nIf it just runs a server, then we don't need to do anything at all because the container can already connect to our old IPC, the v1-style IPC, and TES.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509846406", "createdAt": "2020-10-22T02:44:09Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ5NTczMQ=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NzQ1NQ==", "bodyText": "Added comment to explain the Ipc server parameters for domain sockets.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509847455", "createdAt": "2020-10-22T02:48:01Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ5NTczMQ=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTY0MTcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzo1MDoxMVrOHl5nAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMjo0NzozN1rOHmOnPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUwMzIzNA==", "bodyText": "I'm a bit confused here. We're passing ipcServerSocketPath to the hostname parameter of the IpcServer class constructor. Is this intentional?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509503234", "createdAt": "2020-10-21T17:50:11Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcxMDY2NA==", "bodyText": "It is not the most intutive code. But thats how the library accepts. We may request improvements to server library in future. IpcServer is part of server library.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509710664", "createdAt": "2020-10-21T21:23:51Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUwMzIzNA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1MDUxNw==", "bodyText": "Definitely add a comment to explain the weirdness.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509750517", "createdAt": "2020-10-21T22:18:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUwMzIzNA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NzM1OQ==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509847359", "createdAt": "2020-10-22T02:47:37Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUwMzIzNA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTY4MDQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzo1MzowMVrOHl6BsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToyNToyOFrOHmGV6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUxMDA2NA==", "bodyText": "Is it safe to hardcode this? Will customer ever need to adjust it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509510064", "createdAt": "2020-10-21T17:53:01Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcxMTg0OQ==", "bodyText": "I am not sure if they would need to or not. We can always add it to system settings if we want it configurable. This seems like a standard default", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509711849", "createdAt": "2020-10-21T21:25:28Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUxMDA2NA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTcxNjUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzo1NTo0NFrOHl6bgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToyODowM1rOHmGeyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUxNjY3NA==", "bodyText": "I don't quite get this part. Why are we deleting the socket file? Who is responsible to create it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509516674", "createdAt": "2020-10-21T17:55:44Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcxNDEyMA==", "bodyText": "It gets created when we start the server on the specified socket path. In order to use the same path again we need to delete the old socket path file and then create the new IpcServer. So before starting the server, we check if the file exists at the socket path and if so we delete it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509714120", "createdAt": "2020-10-21T21:28:03Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUxNjY3NA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTczNjM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzo1NzoyM1rOHl6ptA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoyNToyMlrOHmJE2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUyMDMwOA==", "bodyText": "headers is not used. Can we remove it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509520308", "createdAt": "2020-10-21T17:57:23Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1NjYzMw==", "bodyText": "Yes. Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509756633", "createdAt": "2020-10-21T22:25:22Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/ipc/IPCEventStreamService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+package com.aws.greengrass.ipc;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.ipc.exceptions.UnauthenticatedException;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.NoArgsConstructor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCService;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCServiceModel;\n+import software.amazon.awssdk.crt.eventstream.Header;\n+import software.amazon.awssdk.crt.io.EventLoopGroup;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.Authorization;\n+import software.amazon.awssdk.eventstreamrpc.DebugLoggingOperationHandler;\n+import software.amazon.awssdk.eventstreamrpc.GreengrassEventStreamConnectMessage;\n+import software.amazon.awssdk.eventstreamrpc.IpcServer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SETENV_CONFIG_NAMESPACE;\n+\n+@NoArgsConstructor\n+public class IPCEventStreamService implements Startable, Closeable {\n+    public static final int DEFAULT_PORT_NUMBER = 8033;\n+    private static final ObjectMapper OBJECT_MAPPER =\n+                new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+    public static final String IPC_SERVER_DOMAIN_SOCKET_FILENAME = \"ipcEventStreamServer\";\n+    public static final String NUCLEUS_DOMAIN_SOCKET_FILEPATH = \"AWS_GG_NUCLEUS_DOMAIN_SOCKET_FILEPATH\";\n+\n+    private static Logger logger = LogManager.getLogger(IPCEventStreamService.class);\n+\n+    private IpcServer ipcServer;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private GreengrassCoreIPCService greengrassCoreIPCService;\n+\n+    @Inject\n+    private AuthenticationHandler authenticationHandler;\n+\n+    @Inject\n+    private Configuration config;\n+\n+    private SocketOptions socketOptions;\n+    private EventLoopGroup eventLoopGroup;\n+    private String ipcServerSocketPath;\n+\n+    IPCEventStreamService(Kernel kernel,\n+                                 GreengrassCoreIPCService greengrassCoreIPCService,\n+                                 Configuration config) {\n+        this.kernel = kernel;\n+        this.greengrassCoreIPCService = greengrassCoreIPCService;\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public void startup() {\n+        greengrassCoreIPCService.getAllOperations().forEach(operation -> {\n+            greengrassCoreIPCService.setOperationHandler(operation,\n+                    (context) -> new DebugLoggingOperationHandler(GreengrassCoreIPCServiceModel.getInstance()\n+                            .getOperationModelContext(operation), context));\n+        });\n+        greengrassCoreIPCService.setAuthenticationHandler(\n+                (List<Header> headers, byte[] bytes) -> ipcAuthenticationHandler(headers, bytes));\n+        greengrassCoreIPCService.setAuthorizationHandler(\n+                authenticationData -> ipcAuthorizationHandler(authenticationData));\n+\n+        socketOptions = new SocketOptions();\n+        socketOptions.connectTimeoutMs = 3000;\n+        socketOptions.domain = SocketOptions.SocketDomain.LOCAL;\n+        socketOptions.type = SocketOptions.SocketType.STREAM;\n+        eventLoopGroup = new EventLoopGroup(1);\n+        ipcServerSocketPath = kernel.getNucleusPaths().rootPath()\n+                .resolve(IPC_SERVER_DOMAIN_SOCKET_FILENAME).toString();\n+        if (Files.exists(Paths.get(ipcServerSocketPath))) {\n+            try {\n+                logger.atDebug().log(\"Deleting the ipc server socket descriptor file\");\n+                Files.delete(Paths.get(ipcServerSocketPath));\n+            } catch (IOException e) {\n+                logger.atError().setCause(e).log(\"Failed to delete the ipc server socket descriptor file\");\n+            }\n+        }\n+        Topic kernelUri = config.getRoot().lookup(SETENV_CONFIG_NAMESPACE, NUCLEUS_DOMAIN_SOCKET_FILEPATH);\n+        kernelUri.withValue(ipcServerSocketPath);\n+        ipcServer = new IpcServer(eventLoopGroup, socketOptions, null, ipcServerSocketPath,\n+                DEFAULT_PORT_NUMBER, greengrassCoreIPCService);\n+        ipcServer.runServer();\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private Authorization ipcAuthorizationHandler(AuthenticationData authenticationData) {\n+        // No authorization on service level exist for whole IPC right now so returning ACCEPT for all authenticated\n+        // clients\n+        return Authorization.ACCEPT;\n+    }\n+\n+    @SuppressWarnings({\"PMD.UnusedFormalParameter\", \"PMD.PreserveStackTrace\"})\n+    private AuthenticationData ipcAuthenticationHandler(List<Header> headers, byte[] payload) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUyMDMwOA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTkyODgxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODoyODozOFrOHl8s0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoyNzoxM1rOHmJLcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1Mzg3NA==", "bodyText": "What's this for? When do we need to implement this method?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509553874", "createdAt": "2020-10-21T18:28:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1ODMyMQ==", "bodyText": "This is for bi-directional streaming, say if client was sending some streaming data to the server. So if any streaming data comes from client on this stream it will need to be handled here. For now we do not have such a use case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509758321", "createdAt": "2020-10-21T22:27:13Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1Mzg3NA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTk2MjQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozMzozN1rOHl9Eng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoyNzo1M1rOHmJONQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1OTk2Ng==", "bodyText": "Is Info the right level? I would remove it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509559966", "createdAt": "2020-10-21T18:33:37Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1OTAyOQ==", "bodyText": "Yes left from debugging, removing it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509759029", "createdAt": "2020-10-21T22:27:53Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1OTk2Ng=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTk2OTEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozNDo0NlrOHl9JNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoyODowMFrOHmJOew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2MTE0Mw==", "bodyText": "Same here. pretty useless log imo.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509561143", "createdAt": "2020-10-21T18:34:46Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1OTA5OQ==", "bodyText": "agree", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509759099", "createdAt": "2020-10-21T22:28:00Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2MTE0Mw=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjU4OTMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyNzoyNlrOHmDp0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjoyOTowOVrOHmJRwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2Nzc5NQ==", "bodyText": "Is this at the right level?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509667795", "createdAt": "2020-10-21T20:27:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending preComponentUpdate event\");\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                componentUpdatePolicyEvents.setPreUpdateEvent(preComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+                CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+                deferUpdateFutures.add(deferUpdateFuture);\n+                // If there are multiple pre component events sent to same service, we will store the latest future\n+                // As the update should be waiting for the latest one to complete.\n+                deferUpdateFuturesMap.put(serviceName, deferUpdateFuture);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending postComponentUpdate event\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc1OTkzOA==", "bodyText": "Changed it to debug", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509759938", "createdAt": "2020-10-21T22:29:09Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending preComponentUpdate event\");\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                componentUpdatePolicyEvents.setPreUpdateEvent(preComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+                CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+                deferUpdateFutures.add(deferUpdateFuture);\n+                // If there are multiple pre component events sent to same service, we will store the latest future\n+                // As the update should be waiting for the latest one to complete.\n+                deferUpdateFuturesMap.put(serviceName, deferUpdateFuture);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending postComponentUpdate event\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2Nzc5NQ=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjYzMzYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDozODozNFrOHmEGxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo1NDo1MVrOHmLwGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NTIwNg==", "bodyText": "I cannot understand this error message by reading this code. The code tells me the future doesn't exist in the map. I have no idea what it means by Time limit to respond to PreComponentUpdateEvent exceeded. To me it show the code be written in a better way.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509675206", "createdAt": "2020-10-21T20:38:34Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc2MDIzMg==", "bodyText": "Requested @fahadmohammed01  to help with the LifecycleIPCEventStreamAgent comments", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509760232", "createdAt": "2020-10-21T22:29:52Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NTIwNg=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3NjgzMA==", "bodyText": "When the UpdateSystemSafelyService waits for X seconds and did not receive a deferUpdate request from any component. UpdateSystemSafelyService moves forward with the update. Before doing so it clears the futures list. LifeCycleIPCEventsStreamAgent receives a defer update request and there is no future, LifeCycleIPCEventsStreamAgent assumes that the UpdateSystemSafelyService has moved on with the update and the component is responding late.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509776830", "createdAt": "2020-10-21T22:49:31Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NTIwNg=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4ODY0Mg==", "bodyText": "So there is no way to understand this error message without reading through multiple classes. Why not just simply say \"The deferCompnentUpdateRequest future doesn't exist any more\"? I'm not sure what benefit this error message provides.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509788642", "createdAt": "2020-10-21T23:16:30Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NTIwNg=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwMDQ3NQ==", "bodyText": "This error message goes to the client. So the current message is more customer friendly than saying the future does not exist.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509800475", "createdAt": "2020-10-21T23:54:51Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NTIwNg=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjY0NzYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo0MTowMlrOHmEP8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo1OTo1NVrOHmL2TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NzU1Mw==", "bodyText": "Do you need to have get and remove two operations?\nWhy not just remove, check, close?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509677553", "createdAt": "2020-10-21T20:41:02Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjcwMg==", "bodyText": "Remove, check and close works!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509782702", "createdAt": "2020-10-21T22:58:50Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NzU1Mw=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwMjA2MA==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509802060", "createdAt": "2020-10-21T23:59:55Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NzU1Mw=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjY1MTk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo0MTo1M1rOHmES-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NTozMlrOHmKmFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3ODMyOA==", "bodyText": "Why discard all of them?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509678328", "createdAt": "2020-10-21T20:41:53Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MTUyNw==", "bodyText": "Both has the same outcome, instead of checking if a future already exists and add a new one if there is not. The current approach discard all the current futures and adds new ones.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509781527", "createdAt": "2020-10-21T22:55:32Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3ODMyOA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjY2MDM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo0MzoyNFrOHmEYnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMDowMzoxM1rOHmL6BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3OTc3Mg==", "bodyText": "Instead of passing in a list, why not just return a list? It's not conventional in Java to use parameters for output.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509679772", "createdAt": "2020-10-21T20:43:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjA5OA==", "bodyText": "Agree, the previous version was returning something so it got implemented this way. Then that changed but the change to move the list as a return value was not made.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509782098", "createdAt": "2020-10-21T22:57:10Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3OTc3Mg=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwMzAxMw==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509803013", "createdAt": "2020-10-22T00:03:13Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3OTc3Mg=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjcyMTQyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo1Njo1M1rOHmFBbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMDowOTowM1rOHmMCfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5MDIyMA==", "bodyText": "Why does this need to be a public method? It seems an anti-pattern to me that the class expose a public method to allow others to mutate its internal state (e.g. deferUpdateFuturesMap). If at 216, the map is always cleared when sendPreComponentUpdateEvent is called(), why would UpdateSystemSafelyService still need to call this method again?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509690220", "createdAt": "2020-10-21T20:56:53Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending preComponentUpdate event\");\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                componentUpdatePolicyEvents.setPreUpdateEvent(preComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+                CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+                deferUpdateFutures.add(deferUpdateFuture);\n+                // If there are multiple pre component events sent to same service, we will store the latest future\n+                // As the update should be waiting for the latest one to complete.\n+                deferUpdateFuturesMap.put(serviceName, deferUpdateFuture);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending postComponentUpdate event\");\n+                componentUpdatePolicyEvents.setPostUpdateEvent(postComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NDEyNQ==", "bodyText": "This is used by UpdateSystemSafelyService to let the LifeCycleIPCEventStreamAgent know that any response to PrecomponentUpdateEvent is now invalid as UpdateSystemSafelyService is moving on with the update", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509784125", "createdAt": "2020-10-21T23:02:49Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending preComponentUpdate event\");\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                componentUpdatePolicyEvents.setPreUpdateEvent(preComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+                CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+                deferUpdateFutures.add(deferUpdateFuture);\n+                // If there are multiple pre component events sent to same service, we will store the latest future\n+                // As the update should be waiting for the latest one to complete.\n+                deferUpdateFuturesMap.put(serviceName, deferUpdateFuture);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending postComponentUpdate event\");\n+                componentUpdatePolicyEvents.setPostUpdateEvent(postComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5MDIyMA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4Njg4MA==", "bodyText": "Does it matter though? What's the impact if the map is left there?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509786880", "createdAt": "2020-10-21T23:11:05Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending preComponentUpdate event\");\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                componentUpdatePolicyEvents.setPreUpdateEvent(preComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+                CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+                deferUpdateFutures.add(deferUpdateFuture);\n+                // If there are multiple pre component events sent to same service, we will store the latest future\n+                // As the update should be waiting for the latest one to complete.\n+                deferUpdateFuturesMap.put(serviceName, deferUpdateFuture);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending postComponentUpdate event\");\n+                componentUpdatePolicyEvents.setPostUpdateEvent(postComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5MDIyMA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNDE1Mw==", "bodyText": "The response to the client for a deferUpdateRequest depends on the the contents of the map. If the future is not present it responds back with error message \"Time limit to respond to PreComponentUpdateEvent exceeded\". If a future exists it responds back success.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509804153", "createdAt": "2020-10-22T00:07:06Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending preComponentUpdate event\");\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                componentUpdatePolicyEvents.setPreUpdateEvent(preComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+                CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+                deferUpdateFutures.add(deferUpdateFuture);\n+                // If there are multiple pre component events sent to same service, we will store the latest future\n+                // As the update should be waiting for the latest one to complete.\n+                deferUpdateFuturesMap.put(serviceName, deferUpdateFuture);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending postComponentUpdate event\");\n+                componentUpdatePolicyEvents.setPostUpdateEvent(postComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5MDIyMA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNTE4MA==", "bodyText": "Functionality wise it should be fine. There will be lingering data consuming unnecessary main memory. Especially when services which are no longer part of Greengrass but their entry will still be part of this map here, as long as the LifecycleService is not restarted. The cleanup needs to be triggered somewhere.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/495#discussion_r509805180", "createdAt": "2020-10-22T00:09:03Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/greengrass/builtin/services/lifecycle/LifecycleIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package com.aws.greengrass.builtin.services.lifecycle;\n+\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.GreengrassService;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.lifecyclemanager.exceptions.ServiceLoadException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractDeferComponentUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToComponentUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateStateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ComponentUpdatePolicyEvents;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.DeferComponentUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.PostComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.PreComponentUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToComponentUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateStateResponse;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+public class LifecycleIPCEventStreamAgent {\n+\n+    @Getter (AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>>\n+            componentUpdateListeners = new ConcurrentHashMap<>();\n+\n+    // When a PreComponentUpdateEvent is pushed to components, a future is created for each component. When the\n+    // component responds with DeferComponentUpdateRequest the future is marked as complete. The caller of\n+    // sendPreComponentUpdateEvent will have reference to the set of futures.\n+    // deferUpdateFuturesMap maps the context of a component to the future created for the component.\n+    // This map is from service name to the Futures. Only one (latest) Future per service is maintained.\n+    //TODO: Remove the DeferUpdateRequest when we remove the LifecycleIPCAgent. Keeping it right now so both old and new\n+    // IPC can work.\n+    @Getter (AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<DeferUpdateRequest>> deferUpdateFuturesMap =\n+            new ConcurrentHashMap<>();\n+\n+    private static Logger log = LogManager.getLogger(LifecycleIPCEventStreamAgent.class);\n+\n+    @Inject\n+    @Setter (AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public UpdateStateOperationHandler getUpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+        return new UpdateStateOperationHandler(context);\n+    }\n+\n+    public SubscribeToComponentUpdateOperationHandler getSubscribeToComponentUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToComponentUpdateOperationHandler(context);\n+    }\n+\n+    public DeferComponentUpdateHandler getDeferComponentHandler(OperationContinuationHandlerContext context) {\n+        return new DeferComponentUpdateHandler(context);\n+    }\n+\n+    class UpdateStateOperationHandler extends GeneratedAbstractUpdateStateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public UpdateStateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public UpdateStateResponse handleRequest(UpdateStateRequest request) {\n+            log.atInfo().log(\"Got update state request for service \" + serviceName);\n+            State s = State.valueOf(request.getState().toString());\n+            String serviceN = request.getServiceName() == null ? serviceName : request.getServiceName();\n+            GreengrassService service;\n+            try {\n+                service = kernel.locate(serviceN);\n+                log.atInfo().log(\"Located the service\");\n+                service.reportState(s);\n+                log.atInfo().log(\"Reported the state\");\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", request.getServiceName()).log(\"Service not present\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(request.getServiceName());\n+                throw rnf;\n+            }\n+\n+            return new UpdateStateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+\n+    class SubscribeToComponentUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToComponentUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        public SubscribeToComponentUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            log.atInfo().log(\"Stream closed for subscribeToComponentUpdate\");\n+            componentUpdateListeners.get(serviceName).remove(this);\n+            if (componentUpdateListeners.get(serviceName).isEmpty()) {\n+                componentUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        public SubscribeToComponentUpdatesResponse handleRequest(SubscribeToComponentUpdatesRequest request) {\n+            try {\n+                kernel.locate(serviceName);\n+            } catch (ServiceLoadException e) {\n+                log.atWarn().kv(\"service name\", serviceName).setCause(e)\n+                        .log(\"Got subscribe to component update request from a \"\n+                        + \"service that is not found in Greengrass\");\n+                ResourceNotFoundError rnf = new ResourceNotFoundError();\n+                rnf.setMessage(\"Service with given name not found currently in Greengrass\");\n+                rnf.setResourceType(\"Service/Component\");\n+                rnf.setResourceName(serviceName);\n+                throw rnf;\n+            }\n+            componentUpdateListeners.putIfAbsent(serviceName, new HashSet<>());\n+            componentUpdateListeners.get(serviceName).add(this);\n+            log.atInfo().log(\"{} subscribed to component update\", serviceName);\n+            return new SubscribeToComponentUpdatesResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+    }\n+\n+    class DeferComponentUpdateHandler extends GeneratedAbstractDeferComponentUpdateOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected DeferComponentUpdateHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public DeferComponentUpdateResponse handleRequest(DeferComponentUpdateRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+\n+            if (!componentUpdateListeners.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Component is not subscribed to component update events\");\n+            }\n+\n+            CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =\n+                    deferUpdateFuturesMap.get(serviceName);\n+            if (deferComponentUpdateRequestFuture == null) {\n+                throw new ServiceError(\"Time limit to respond to PreComponentUpdateEvent exceeded\");\n+            }\n+            deferComponentUpdateRequestFuture.complete(new DeferUpdateRequest(serviceName,\n+                    request.getMessage(), request.getRecheckAfterMs()));\n+            deferUpdateFuturesMap.remove(serviceName);\n+            return new DeferComponentUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending preComponentUpdate event\");\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                componentUpdatePolicyEvents.setPreUpdateEvent(preComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+                CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+                deferUpdateFutures.add(deferUpdateFuture);\n+                // If there are multiple pre component events sent to same service, we will store the latest future\n+                // As the update should be waiting for the latest one to complete.\n+                deferUpdateFuturesMap.put(serviceName, deferUpdateFuture);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        for (Map.Entry<String, Set<StreamEventPublisher<ComponentUpdatePolicyEvents>>> entry\n+                : componentUpdateListeners.entrySet()) {\n+            String serviceName = entry.getKey();\n+            entry.getValue().forEach(subscribeHandler -> {\n+                ComponentUpdatePolicyEvents componentUpdatePolicyEvents = new ComponentUpdatePolicyEvents();\n+                log.atInfo().kv(\"serviceName\", serviceName).log(\"Sending postComponentUpdate event\");\n+                componentUpdatePolicyEvents.setPostUpdateEvent(postComponentUpdateEvent);\n+                subscribeHandler.sendStreamEvent(componentUpdatePolicyEvents);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5MDIyMA=="}, "originalCommit": {"oid": "84d6f0f557cd1e15a7e83ba3d72c79221eb19cb9"}, "originalPosition": 256}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 600, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}