{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMjU0NzA5", "number": 511, "reviewThreads": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoxOVrOEr1eMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMToxNzoyNFrOExYIqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NDAwMzA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoxOVrOHe0zcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoxOVrOHe0zcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ2Ng==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 118 and 140. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084466", "createdAt": "2020-10-08T23:54:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60675cc71de913ea700b2df5e2b8eacece26b93a"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NDAwMzA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoxOVrOHe0zdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoxOVrOHe0zdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ2OA==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 184 and 188. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084468", "createdAt": "2020-10-08T23:54:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"service\", serviceName).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }\n+    }\n+\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (!subscribeCallbacks.containsKey(serviceName)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).log(\"No IoT core topics subscribed by service\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+            if (!subscribeCallbacks.get(serviceName).containsKey(topic)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60675cc71de913ea700b2df5e2b8eacece26b93a"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NDAwMzA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoxOVrOHe0zdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoxOVrOHe0zdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ2OQ==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 184 and 193. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084469", "createdAt": "2020-10-08T23:54:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"service\", serviceName).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }\n+    }\n+\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (!subscribeCallbacks.containsKey(serviceName)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).log(\"No IoT core topics subscribed by service\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+            if (!subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).kv(\"topic\", topic).log(\"IoT core topic not subscribed\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = subscribeCallbacks.get(serviceName).get(topic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60675cc71de913ea700b2df5e2b8eacece26b93a"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NDAwMzEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoyMFrOHe0zdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoyMFrOHe0zdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ3MQ==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 184 and 202. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084471", "createdAt": "2020-10-08T23:54:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"service\", serviceName).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }\n+    }\n+\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (!subscribeCallbacks.containsKey(serviceName)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).log(\"No IoT core topics subscribed by service\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+            if (!subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).kv(\"topic\", topic).log(\"IoT core topic not subscribed\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = subscribeCallbacks.get(serviceName).get(topic);\n+            UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(cb).topic(topic).build();\n+\n+            try {\n+                mqttClient.unsubscribe(unsubscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error unsubscribing from IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.get(serviceName).remove(topic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60675cc71de913ea700b2df5e2b8eacece26b93a"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NDAwMzExOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoyMFrOHe0zeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMzo1NDoyMFrOHe0zeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NDQ3Mw==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 184 and 203. In between the check and the get() another thread can remove the key and the get() will return null. The remove that can remove the key is at line: 204.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502084473", "createdAt": "2020-10-08T23:54:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (subscribeCallbacks.containsKey(serviceName) && subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"topic\", topic).log(\"IoT core topic already subscribed\");\n+                return new SubscribeToIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+            SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(topic);\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.putIfAbsent(serviceName, new ConcurrentHashMap<>());\n+            subscribeCallbacks.get(serviceName).put(topic, cb);\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"service\", serviceName).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }\n+    }\n+\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+            if (!subscribeCallbacks.containsKey(serviceName)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).log(\"No IoT core topics subscribed by service\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+            if (!subscribeCallbacks.get(serviceName).containsKey(topic)) {\n+                LOGGER.atDebug().kv(\"service\", serviceName).kv(\"topic\", topic).log(\"IoT core topic not subscribed\");\n+                return new UnsubscribeFromIoTCoreResponse();\n+            }\n+\n+            Consumer<MqttMessage> cb = subscribeCallbacks.get(serviceName).get(topic);\n+            UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(cb).topic(topic).build();\n+\n+            try {\n+                mqttClient.unsubscribe(unsubscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                throw new ServiceError(\"Error unsubscribing from IoT core topic\");\n+            }\n+\n+            subscribeCallbacks.get(serviceName).remove(topic);\n+            if (subscribeCallbacks.get(serviceName).isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60675cc71de913ea700b2df5e2b8eacece26b93a"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzAyOTc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo0MzoyOVrOHfRUug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo0MzoyOVrOHfRUug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1MTczOA==", "bodyText": "Ditch the if statements, just call the builder method directly, regardless of value", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502551738", "createdAt": "2020-10-09T16:43:29Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47fd59b886ad99d06110cc3710d7ebc77a89752f"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzA0ODk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo0OToxMVrOHfRgiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo0OToxMVrOHfRgiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NDc2Mw==", "bodyText": "I don't think we can wait for the future to complete. If the network is doing it's going to limit throughput to 2 TPS.\nI'll likely add a new API that returns whether or not the message was successfully queued, and that can be used to construct an appropriate response (success if queued, else failure)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502554763", "createdAt": "2020-10-09T16:49:11Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47fd59b886ad99d06110cc3710d7ebc77a89752f"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzA2NTAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo1NDoyMVrOHfRqrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxOToxODo0MVrOHgKYZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NzM1OQ==", "bodyText": "Are these response objects empty? If they are then we need to change that...", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502557359", "createdAt": "2020-10-09T16:54:21Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47fd59b886ad99d06110cc3710d7ebc77a89752f"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyODc0MA==", "bodyText": "yeah, currently these responses have no fields. But I don't think we can add anything to these manually because they are the generated models", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502628740", "createdAt": "2020-10-09T19:21:45Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NzM1OQ=="}, "originalCommit": {"oid": "47fd59b886ad99d06110cc3710d7ebc77a89752f"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NjU2Ng==", "bodyText": "I took another look at the model, and it looks like errors are modeled separately. What you have here looks good - though I think we could probably pull the error out of the exception instead of hardcoding a generic error. It's helpful for the customer to know it failed because the spool is full", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r503486566", "createdAt": "2020-10-12T19:18:41Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NzM1OQ=="}, "originalCommit": {"oid": "47fd59b886ad99d06110cc3710d7ebc77a89752f"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzA4MjU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo1OToyNVrOHfR1Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxOToxODowNVrOHfV7Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MDAzNA==", "bodyText": "I'm assuming this still needs some work. How do you plan to route this to the correct subscriber? Also, we can't wait on any futures here. It will block the mqtt client thread", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502560034", "createdAt": "2020-10-09T16:59:25Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final ConcurrentHashMap<String, Consumer<MqttMessage>> serviceSubscribeCallbacks;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            String serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeCallbacks = subscribeCallbacks.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            //TODO: remove callbacks\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            Consumer<MqttMessage> callback = serviceSubscribeCallbacks.computeIfAbsent(topic, t -> {\n+                Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(t);\n+\n+                if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                    subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+                } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                    subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+                }\n+\n+                SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+                try {\n+                    mqttClient.subscribe(subscribeRequest);\n+                } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                    return null;\n+                }\n+\n+                return cb;\n+            });\n+\n+            if (callback == null) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47fd59b886ad99d06110cc3710d7ebc77a89752f"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNzE2Mw==", "bodyText": "this.sendStreamEvent(iotCoreMessage) will automatically route it to the correct subscriber because this handler instance represents the specific subscribe request. And yeah, we should remove the future wait here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r502627163", "createdAt": "2020-10-09T19:18:05Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.PublishRequest.PublishRequestBuilder;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest.SubscribeRequestBuilder;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.QOS;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain());\n+\n+            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+            }\n+\n+            PublishRequest publishRequest = publishRequestBuilder.build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final ConcurrentHashMap<String, Consumer<MqttMessage>> serviceSubscribeCallbacks;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            String serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeCallbacks = subscribeCallbacks.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            //TODO: remove callbacks\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            Consumer<MqttMessage> callback = serviceSubscribeCallbacks.computeIfAbsent(topic, t -> {\n+                Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                SubscribeRequestBuilder subscribeRequestBuilder = SubscribeRequest.builder().callback(cb).topic(t);\n+\n+                if (request.getQos() == QOS.AT_LEAST_ONCE) {\n+                    subscribeRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n+                } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n+                    subscribeRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n+                }\n+\n+                SubscribeRequest subscribeRequest = subscribeRequestBuilder.build();\n+                try {\n+                    mqttClient.subscribe(subscribeRequest);\n+                } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                    return null;\n+                }\n+\n+                return cb;\n+            });\n+\n+            if (callback == null) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            CompletableFuture<Void> future = this.sendStreamEvent(iotCoreMessage);\n+\n+            try {\n+                future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(\"topic\", message.getTopic())\n+                        .log(\"Error sending message to subscriber\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2MDAzNA=="}, "originalCommit": {"oid": "47fd59b886ad99d06110cc3710d7ebc77a89752f"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzU4NTg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxOToxNjoxOFrOHgKUsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QyMjoxOTozNFrOHg7f6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NTYxNg==", "bodyText": "Need qos(request.getQos())", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r503485616", "createdAt": "2020-10-12T19:16:18Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -72,23 +71,15 @@ protected void onStreamClosed() {\n \n         @Override\n         public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n-            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n-                    .topic(request.getTopicName()).retain(request.isRetain());\n-\n-            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n-                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n-            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n-                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n-            }\n-\n-            PublishRequest publishRequest = publishRequestBuilder.build();\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d923c4172b968c260c4af08f54e18ae5c60f6b5"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4MDA4Nw==", "bodyText": "qos() takes in QualityOfService and request.getQos() return QOS, so added a method to convert QOS to QualityOfService", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r503580087", "createdAt": "2020-10-12T23:15:40Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -72,23 +71,15 @@ protected void onStreamClosed() {\n \n         @Override\n         public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n-            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n-                    .topic(request.getTopicName()).retain(request.isRetain());\n-\n-            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n-                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n-            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n-                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n-            }\n-\n-            PublishRequest publishRequest = publishRequestBuilder.build();\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain()).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NTYxNg=="}, "originalCommit": {"oid": "7d923c4172b968c260c4af08f54e18ae5c60f6b5"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5MTMwNA==", "bodyText": "Oh my bad, that's why you had the if statement originally. Didn't see the type difference", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r504291304", "createdAt": "2020-10-13T22:19:34Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -72,23 +71,15 @@ protected void onStreamClosed() {\n \n         @Override\n         public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n-            PublishRequestBuilder publishRequestBuilder = PublishRequest.builder().payload(request.getPayload())\n-                    .topic(request.getTopicName()).retain(request.isRetain());\n-\n-            if (request.getQos() == QOS.AT_LEAST_ONCE) {\n-                publishRequestBuilder.qos(QualityOfService.AT_LEAST_ONCE);\n-            } else if (request.getQos() == QOS.AT_MOST_ONCE) {\n-                publishRequestBuilder.qos(QualityOfService.AT_MOST_ONCE);\n-            }\n-\n-            PublishRequest publishRequest = publishRequestBuilder.build();\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain()).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NTYxNg=="}, "originalCommit": {"oid": "7d923c4172b968c260c4af08f54e18ae5c60f6b5"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzY1NzQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxOTo0MzowNlrOHgK_hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxOTo0MzowNlrOHgK_hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NjU4MQ==", "bodyText": "What's the scope of this object? Per client or per request? I'm assuming the former, in which case, what happens if the client makes multiple calls to subscribe to multiple topics?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r503496581", "createdAt": "2020-10-12T19:43:06Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,211 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.IoTCoreMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.MQTTMessage;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.PublishToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ServiceError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToIoTCoreResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Consumer<MqttMessage>>> subscribeCallbacks\n+            = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload())\n+                    .topic(request.getTopicName()).retain(request.isRetain()).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            if (future.isCompletedExceptionally()) {\n+                throw new ServiceError(\"Error publishing message to IoT core\");\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamableJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final ConcurrentHashMap<String, Consumer<MqttMessage>> serviceSubscribeCallbacks;\n+\n+        private String subscribedTopic;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d923c4172b968c260c4af08f54e18ae5c60f6b5"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIwOTIyOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjoyOToyOFrOHl1LzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMToyNjoyOFrOHmNT1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMDczMg==", "bodyText": "e2e tests are slow, not sure I'd recommend a e2e test. Integ is sufficient given the other coverage that mqtt has.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509430732", "createdAt": "2020-10-21T16:29:28Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.greengrass.integrationtests.ipc.IPCTestUtils;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(GGExtension.class)\n+@Tag(\"E2E\")\n+public class MqttProxyIPCTest extends BaseE2ETestCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNjAwNw==", "bodyText": "removed this and added integ tests", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509826007", "createdAt": "2020-10-22T01:26:28Z", "author": {"login": "popanmol"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.greengrass.integrationtests.ipc.IPCTestUtils;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(GGExtension.class)\n+@Tag(\"E2E\")\n+public class MqttProxyIPCTest extends BaseE2ETestCase {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMDczMg=="}, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIxMTQ5OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjoyOTo1N1rOHl1NKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjoyOTo1N1rOHl1NKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMTA4Mw==", "bodyText": "log error", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509431083", "createdAt": "2020-10-21T16:29:57Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.greengrass.integrationtests.ipc.IPCTestUtils;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(GGExtension.class)\n+@Tag(\"E2E\")\n+public class MqttProxyIPCTest extends BaseE2ETestCase {\n+    private Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    protected MqttProxyIPCTest() throws Exception {\n+        super();\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        try {\n+            if (clientConnection != null) {\n+                clientConnection.disconnect();\n+            }\n+            if (socketOptions != null) {\n+                socketOptions.close();\n+            }\n+            kernel.shutdown();\n+        } finally {\n+            cleanup();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_subscribe_and_publish_THEN_message_received() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+        kernel = prepareKernelFromConfigFile(\"mqttproxy.yaml\", MqttProxyIPCTest.class, TEST_SERVICE_NAME);\n+        deviceProvisioningHelper.updateKernelConfigWithIotConfiguration(kernel, thingInfo, GAMMA_REGION.toString());\n+\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = TestUtils.getSocketOptionsForIPC();\n+        clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions,\n+                authToken, kernel);\n+\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        String topic = \"A/B/C\";\n+        byte[] payload = \"Hello world\".getBytes(StandardCharsets.UTF_8);\n+\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToIoTCoreRequest subscribeToIoTCoreRequest = new SubscribeToIoTCoreRequest();\n+        subscribeToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        subscribeToIoTCoreRequest.setTopicName(topic);\n+\n+        StreamResponseHandler<IoTCoreMessage> streamResponseHandler = new StreamResponseHandler<IoTCoreMessage>() {\n+            @Override\n+            public void onStreamEvent(IoTCoreMessage streamEvent) {\n+                if (Arrays.equals(streamEvent.getMessage().getPayload(), payload)\n+                        && streamEvent.getMessage().getTopicName().equals(topic)) {\n+                    cdl.countDown();\n+                }\n+            }\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIyMTMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozMjoyMFrOHl1TWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMToyNTo1OFrOHmNTUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMjY2Nw==", "bodyText": "You never remove the subscription. If someone unsubscribe, they need to be removed from this map", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509432667", "createdAt": "2020-10-21T16:32:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNTg3NQ==", "bodyText": "subscription will be removed by returning null from lambda\nhttps://github.com/aws/aws-greengrass-nucleus/blob/mqtt-proxy/src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java#L259", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509825875", "createdAt": "2020-10-22T01:25:58Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMjY2Nw=="}, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIyMzUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozMjo1MlrOHl1Usw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMzozNDozOVrOHmPXDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzAxMQ==", "bodyText": "log exception and return an error to the customer", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509433011", "createdAt": "2020-10-21T16:32:52Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNTAyOA==", "bodyText": "logged exception here and error is returned later\nif (listener == null) {\nthrow new ServiceError(\"Error subscribing to topic \" + topic);\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509825028", "createdAt": "2020-10-22T01:23:00Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzAxMQ=="}, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyODM5OQ==", "bodyText": "But they have no idea why it failed. We should be helpful to the customer.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509828399", "createdAt": "2020-10-22T01:35:49Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzAxMQ=="}, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg1OTU5OQ==", "bodyText": "Added the exception and its message to the thrown error", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509859599", "createdAt": "2020-10-22T03:34:39Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzAxMQ=="}, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIyNTIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozMzoyMlrOHl1V4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozMzoyMlrOHl1V4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzMxMg==", "bodyText": "this is unsubscribing, what do you need these fields for?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509433312", "createdAt": "2020-10-21T16:33:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;\n+                        }\n+\n+                        subscribedTopic = t;\n+                        subscriptionCallback = cb;\n+                        return this;\n+                    });\n+\n+            if (listener == null) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            this.sendStreamEvent(iotCoreMessage);\n+        }\n+    }\n+\n+    @SuppressFBWarnings(value = \"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS\", justification = \"Should not be static\")\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI1NjAzOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0MDo0MVrOHl1owg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMToyMDoyM1rOHmNNbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzODE0Ng==", "bodyText": "Is calling both required?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509438146", "createdAt": "2020-10-21T16:40:41Z", "author": {"login": "philcali"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.greengrass.integrationtests.ipc.IPCTestUtils;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(GGExtension.class)\n+@Tag(\"E2E\")\n+public class MqttProxyIPCTest extends BaseE2ETestCase {\n+    private Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    protected MqttProxyIPCTest() throws Exception {\n+        super();\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        try {\n+            if (clientConnection != null) {\n+                clientConnection.disconnect();\n+            }\n+            if (socketOptions != null) {\n+                socketOptions.close();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNDM2NQ==", "bodyText": "yeah I believe both these resources need to be closed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509824365", "createdAt": "2020-10-22T01:20:23Z", "author": {"login": "popanmol"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.greengrass.integrationtests.ipc.IPCTestUtils;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(GGExtension.class)\n+@Tag(\"E2E\")\n+public class MqttProxyIPCTest extends BaseE2ETestCase {\n+    private Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    protected MqttProxyIPCTest() throws Exception {\n+        super();\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        try {\n+            if (clientConnection != null) {\n+                clientConnection.disconnect();\n+            }\n+            if (socketOptions != null) {\n+                socketOptions.close();\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzODE0Ng=="}, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI1NjY1OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0MDo1MFrOHl1pKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0MDo1MFrOHl1pKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzODI0OA==", "bodyText": "Add license header", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509438248", "createdAt": "2020-10-21T16:40:50Z", "author": {"login": "philcali"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/e2e/mqttclient/MqttProxyIPCTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.aws.greengrass.integrationtests.e2e.mqttclient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI1ODU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0MToxOFrOHl1qdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0MToxOFrOHl1qdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzODU4MA==", "bodyText": "Add license header", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509438580", "createdAt": "2020-10-21T16:41:18Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI3NjIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/modules/MqttProxyIPCService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NToyNVrOHl11Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NToyNVrOHl11Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MTM2Ng==", "bodyText": "Add license header", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509441366", "createdAt": "2020-10-21T16:45:25Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/ipc/modules/MqttProxyIPCService.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.aws.greengrass.ipc.modules;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI3NzM3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgentTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NTo0MVrOHl12Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0NTo0MVrOHl12Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MTUzOQ==", "bodyText": "Add license header", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509441539", "createdAt": "2020-10-21T16:45:41Z", "author": {"login": "philcali"}, "path": "src/test/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgentTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI5Mzk1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo0OTo1NVrOHl2Aig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMToxOTo1MFrOHmNM7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0NDIzNA==", "bodyText": "Does this throw a meaningful error?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509444234", "createdAt": "2020-10-21T16:49:55Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;\n+                        }\n+\n+                        subscribedTopic = t;\n+                        subscriptionCallback = cb;\n+                        return this;\n+                    });\n+\n+            if (listener == null) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            this.sendStreamEvent(iotCoreMessage);\n+        }\n+    }\n+\n+    @SuppressFBWarnings(value = \"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS\", justification = \"Should not be static\")\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.get(topic);\n+            if (listener != null) {\n+                listener.closeStream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNDIzNw==", "bodyText": "this returns a future, so not sure if we should wait for an error to be thrown or just closeStream() and return?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509824237", "createdAt": "2020-10-22T01:19:50Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>>>\n+            subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to IoT core failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                            .topic(t).build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().kv(\"topic\", t).log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.computeIfAbsent(\n+                    topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            return null;\n+                        }\n+\n+                        subscribedTopic = t;\n+                        subscriptionCallback = cb;\n+                        return this;\n+                    });\n+\n+            if (listener == null) {\n+                throw new ServiceError(\"Error subscribing to IoT core topic\");\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            this.sendStreamEvent(iotCoreMessage);\n+        }\n+    }\n+\n+    @SuppressFBWarnings(value = \"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS\", justification = \"Should not be static\")\n+    class UnsubscribeFromIoTCoreOperationHandler extends GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, StreamEventPublisher<IoTCoreMessage>> serviceSubscribeListeners;\n+\n+        protected UnsubscribeFromIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public UnsubscribeFromIoTCoreResponse handleRequest(UnsubscribeFromIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            StreamEventPublisher<IoTCoreMessage> listener = serviceSubscribeListeners.get(topic);\n+            if (listener != null) {\n+                listener.closeStream();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0NDIzNA=="}, "originalCommit": {"oid": "eb22768f065db47fd24882b2e06912bf6added59"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzU1ODg3OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCMqttProxyTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozMTowOVrOHmNYdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozMTowOVrOHmNYdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzE4OQ==", "bodyText": "log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509827189", "createdAt": "2020-10-22T01:31:09Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCMqttProxyTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.integrationtests.ipc;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+import software.amazon.awssdk.eventstreamrpc.UnmappedDataException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(GGExtension.class)\n+public class IPCMqttProxyTest {\n+    private static final Logger logger = LogManager.getLogger(IPCMqttProxyTest.class);\n+    private static final int TIMEOUT_FOR_MQTTPROXY_SECONDS = 20;\n+    private static final String TEST_TOPIC = \"A/B/C\";\n+    private static final byte[] TEST_PAYLOAD = \"TestPayload\".getBytes(StandardCharsets.UTF_8);\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static MqttClient mqttClient;\n+    private static Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        mqttClient = mock(MqttClient.class);\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCMqttProxyTest.class.getResource(\"mqttproxy.yaml\").toString());\n+        CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(TEST_SERVICE_NAME) && newState.equals(State.RUNNING)) {\n+                awaitIpcServiceLatch.countDown();\n+            }\n+        });\n+        kernel.getContext().put(MqttClient.class, mqttClient);\n+        kernel.launch();\n+        assertTrue(awaitIpcServiceLatch.await(10, TimeUnit.SECONDS));\n+\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = TestUtils.getSocketOptionsForIPC();\n+        clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel);\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (clientConnection != null) {\n+            clientConnection.disconnect();\n+        }\n+        if (socketOptions != null) {\n+            socketOptions.close();\n+        }\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_publish_THEN_message_published() throws Exception {\n+        CompletableFuture<Integer> completableFuture = new CompletableFuture<>();\n+        when(mqttClient.publish(any())).thenReturn(completableFuture);\n+\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        PublishToIoTCoreRequest publishToIoTCoreRequest = new PublishToIoTCoreRequest();\n+        publishToIoTCoreRequest.setPayload(TEST_PAYLOAD);\n+        publishToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        publishToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+        publishToIoTCoreRequest.setRetain(false);\n+        greengrassCoreIPCClient.publishToIoTCore(publishToIoTCoreRequest, Optional.empty()).getResponse()\n+                .get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<PublishRequest> publishRequestArgumentCaptor = ArgumentCaptor.forClass(PublishRequest.class);\n+        verify(mqttClient).publish(publishRequestArgumentCaptor.capture());\n+        PublishRequest capturedPublishRequest = publishRequestArgumentCaptor.getValue();\n+        assertThat(capturedPublishRequest.getPayload(), is(TEST_PAYLOAD));\n+        assertThat(capturedPublishRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedPublishRequest.isRetain(), is(false));\n+        assertThat(capturedPublishRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_subscribe_THEN_subscribed_and_message_received()\n+            throws Exception {\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToIoTCoreRequest subscribeToIoTCoreRequest = new SubscribeToIoTCoreRequest();\n+        subscribeToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        subscribeToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+\n+        StreamResponseHandler<IoTCoreMessage> streamResponseHandler = new StreamResponseHandler<IoTCoreMessage>() {\n+            @Override\n+            public void onStreamEvent(IoTCoreMessage streamEvent) {\n+                if (Arrays.equals(streamEvent.getMessage().getPayload(), TEST_PAYLOAD)\n+                        && streamEvent.getMessage().getTopicName().equals(TEST_TOPIC)) {\n+                    cdl.countDown();\n+                }\n+            }\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                logger.atError().cause(error).log(\"Subscribe stream errored\");\n+                return false;\n+            }\n+\n+            @Override\n+            public void onStreamClosed() {\n+\n+            }\n+        };\n+\n+        greengrassCoreIPCClient.subscribeToIoTCore(subscribeToIoTCoreRequest, Optional.of(streamResponseHandler))\n+                .getResponse().get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<SubscribeRequest> subscribeRequestArgumentCaptor\n+                = ArgumentCaptor.forClass(SubscribeRequest.class);\n+        verify(mqttClient).subscribe(subscribeRequestArgumentCaptor.capture());\n+        SubscribeRequest capturedSubscribeRequest = subscribeRequestArgumentCaptor.getValue();\n+        assertThat(capturedSubscribeRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedSubscribeRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+\n+        Consumer<MqttMessage> callback = capturedSubscribeRequest.getCallback();\n+        MqttMessage message = new MqttMessage(TEST_TOPIC, TEST_PAYLOAD);\n+        callback.accept(message);\n+        assertTrue(cdl.await(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS));\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_unsubscribe_THEN_unsubscribed(ExtensionContext context)\n+            throws Exception {\n+        ignoreExceptionOfType(context, UnmappedDataException.class);\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToIoTCoreRequest subscribeToIoTCoreRequest = new SubscribeToIoTCoreRequest();\n+        subscribeToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        subscribeToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+\n+        StreamResponseHandler<IoTCoreMessage> streamResponseHandler = new StreamResponseHandler<IoTCoreMessage>() {\n+            @Override\n+            public void onStreamEvent(IoTCoreMessage streamEvent) {\n+\n+            }\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzU1OTkwOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/resources/com/aws/greengrass/integrationtests/ipc/mqttproxy.yaml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozMTozN1rOHmNZBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozMTozN1rOHmNZBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzMzMg==", "bodyText": "remove lifecycle.\nJust do ServiceName: {}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509827332", "createdAt": "2020-10-22T01:31:37Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/resources/com/aws/greengrass/integrationtests/ipc/mqttproxy.yaml", "diffHunk": "@@ -0,0 +1,30 @@\n+---\n+services:\n+  main:\n+    dependencies:\n+      - ServiceName\n+  ServiceName:\n+    lifecycle:\n+      run:\n+        windows:\n+          powershell -command sleep 1\n+        posix:\n+          sleep 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzU2MDkzOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/resources/com/aws/greengrass/integrationtests/ipc/mqttproxy.yaml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozMjoyNlrOHmNZrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTo0ODozNlrOHmNp2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzUwMw==", "bodyText": "did this format change? Why is there a prefix or aws.greengrass#? Why isn't the operation just \"PublishToIoTCore\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509827503", "createdAt": "2020-10-22T01:32:26Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/resources/com/aws/greengrass/integrationtests/ipc/mqttproxy.yaml", "diffHunk": "@@ -0,0 +1,30 @@\n+---\n+services:\n+  main:\n+    dependencies:\n+      - ServiceName\n+  ServiceName:\n+    lifecycle:\n+      run:\n+        windows:\n+          powershell -command sleep 1\n+        posix:\n+          sleep 1\n+    parameters:\n+      accessControl:\n+        '{\n+          \"aws.greengrass.ipc.mqttproxy\":[\n+          {\n+            \"policyId1\":{\n+              \"policyDescription\":\"access to IoT topics for mqtt\",\n+              \"operations\":[\n+                \"aws.greengrass#PublishToIoTCore\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzMTY0MQ==", "bodyText": "all operation names have the prefix aws.greengrass https://github.com/aws/aws-greengrass-nucleus/blob/ipcIntegration/src/main/java/software/amazon/awssdk/aws/greengrass/GreengrassCoreIPCService.java\nand calling getOperationName() on the handler returns this name", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509831641", "createdAt": "2020-10-22T01:48:36Z", "author": {"login": "popanmol"}, "path": "src/integrationtests/resources/com/aws/greengrass/integrationtests/ipc/mqttproxy.yaml", "diffHunk": "@@ -0,0 +1,30 @@\n+---\n+services:\n+  main:\n+    dependencies:\n+      - ServiceName\n+  ServiceName:\n+    lifecycle:\n+      run:\n+        windows:\n+          powershell -command sleep 1\n+        posix:\n+          sleep 1\n+    parameters:\n+      accessControl:\n+        '{\n+          \"aws.greengrass.ipc.mqttproxy\":[\n+          {\n+            \"policyId1\":{\n+              \"policyDescription\":\"access to IoT topics for mqtt\",\n+              \"operations\":[\n+                \"aws.greengrass#PublishToIoTCore\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzUwMw=="}, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzU2MzA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozMzozNVrOHmNa5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMzo0MjowNFrOHmPd_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ==", "bodyText": "Why are you calling getNow that doesn't give it any time to complete the future.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509827815", "createdAt": "2020-10-22T01:33:35Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzMjQwMg==", "bodyText": "This is temporary. This will be replaced by insertion in spooler queue and error will be thrown if insertion fails. Can I just remove this for now and only call mqttclient.publish()? Or wait for the future to complete?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509832402", "createdAt": "2020-10-22T01:51:28Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ=="}, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzMjk5MQ==", "bodyText": "This is not temporary. The API will not change with spooler.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509832991", "createdAt": "2020-10-22T01:53:47Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ=="}, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgzMzM0Ng==", "bodyText": "https://github.com/aws/aws-greengrass-nucleus/blob/02b9467d04e752529521141049301ef26626a214/src/main/java/com/aws/greengrass/mqttclient/MqttClient.java#L263\nMaybe make the getTimeout method public and move it into the MqttClient", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509833346", "createdAt": "2020-10-22T01:55:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ=="}, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg2MTM3NQ==", "bodyText": "Added getTimeout() to MqttClient. I haven't removed it from AwsIotMqttClient because it also uses it and if removed, it would need an instance of MqttClient to access it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509861375", "createdAt": "2020-10-22T03:42:04Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzgxNQ=="}, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzU2NDI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozNDoxN1rOHmNbjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMzozOToxNlrOHmPbbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzk4Mw==", "bodyText": "This is not correct. You need to pull the message out of the exception (e.getCause().getMessage()). This should also get logged with the cause.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509827983", "createdAt": "2020-10-22T01:34:17Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to topic \" + topic + \" failed with error \" + e.getCause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg2MDcxOQ==", "bodyText": "logged the exception and thrown ServiceError with error and message", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509860719", "createdAt": "2020-10-22T03:39:16Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to topic \" + topic + \" failed with error \" + e.getCause());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyNzk4Mw=="}, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzU2NjA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozNToxM1rOHmNclA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMzozNTo1OVrOHmPYcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyODI0NA==", "bodyText": "do we have any logging for failed auth attempts?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509828244", "createdAt": "2020-10-22T01:35:13Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to topic \" + topic + \" failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>, Consumer<MqttMessage>>>\n+                serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(l.getRight()).topic(t)\n+                            .build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().cause(e).kv(\"topic\", t).kv(\"service\", serviceName)\n+                                .log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+\n+            subscribeListeners.computeIfPresent(serviceName, (s, listeners) -> {\n+                if (listeners.isEmpty()) {\n+                    return null;\n+                } else {\n+                    return listeners;\n+                }\n+            });\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg1OTk1Mw==", "bodyText": "AuthorizationHandler doesn't log failed auth attempts, it just throws the exception with message.\nI'm adding log with that message here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509859953", "createdAt": "2020-10-22T03:35:59Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to topic \" + topic + \" failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>, Consumer<MqttMessage>>>\n+                serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(l.getRight()).topic(t)\n+                            .build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().cause(e).kv(\"topic\", t).kv(\"service\", serviceName)\n+                                .log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+\n+            subscribeListeners.computeIfPresent(serviceName, (s, listeners) -> {\n+                if (listeners.isEmpty()) {\n+                    return null;\n+                } else {\n+                    return listeners;\n+                }\n+            });\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyODI0NA=="}, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzU3MjM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozOTowMFrOHmNgSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMTozOTowMFrOHmNgSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyOTE5NA==", "bodyText": "Would it make sense to just unsubscribe when the subscription stream has ended? Not sure we actually need a separate event. @abanthiy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r509829194", "createdAt": "2020-10-22T01:39:00Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.getNow(0);\n+            } catch (CompletionException e) {\n+                throw new ServiceError(\"Publish to topic \" + topic + \" failed with error \" + e.getCause());\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private final ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>, Consumer<MqttMessage>>>\n+                serviceSubscribeListeners;\n+\n+        private String subscribedTopic;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+            serviceSubscribeListeners = subscribeListeners.computeIfAbsent(serviceName, k -> new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                serviceSubscribeListeners.computeIfPresent(subscribedTopic, (t, l) -> {\n+                    UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(l.getRight()).topic(t)\n+                            .build();\n+                    try {\n+                        mqttClient.unsubscribe(unsubscribeRequest);\n+                    } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                        LOGGER.atError().cause(e).kv(\"topic\", t).kv(\"service\", serviceName)\n+                                .log(\"Stream closed but unable to unsubscribe from topic\");\n+                        return l;\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+\n+            subscribeListeners.computeIfPresent(serviceName, (s, listeners) -> {\n+                if (listeners.isEmpty()) {\n+                    return null;\n+                } else {\n+                    return listeners;\n+                }\n+            });\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                throw new UnauthorizedError(e.getMessage());\n+            }\n+\n+            Pair<StreamEventPublisher<IoTCoreMessage>, Consumer<MqttMessage>> listener = serviceSubscribeListeners\n+                    .computeIfAbsent(topic, t -> {\n+                        Consumer<MqttMessage> cb = this::forwardToSubscriber;\n+                        SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(cb).topic(t)\n+                                .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+                        try {\n+                            mqttClient.subscribe(subscribeRequest);\n+                        } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                            LOGGER.atError().cause(e).kv(\"topic\", t).kv(\"service\", serviceName)\n+                                    .log(\"Unable to subscribe to topic\");\n+                            return null;\n+                        }\n+\n+                        subscribedTopic = t;\n+                        return new Pair<>(this, cb);\n+                    });\n+\n+            if (listener == null) {\n+                throw new ServiceError(\"Error subscribing to topic \" + topic);\n+            }\n+\n+            return new SubscribeToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+\n+        private void forwardToSubscriber(MqttMessage message) {\n+            MQTTMessage mqttMessage = new MQTTMessage();\n+            mqttMessage.setTopicName(message.getTopic());\n+            mqttMessage.setPayload(message.getPayload());\n+\n+            IoTCoreMessage iotCoreMessage = new IoTCoreMessage();\n+            iotCoreMessage.setMessage(mqttMessage);\n+            this.sendStreamEvent(iotCoreMessage);\n+        }\n+    }\n+\n+    @SuppressFBWarnings(value = \"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS\", justification = \"Should not be static\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b178164f001d2816f0601d32c7578aaf70d3e84c"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Njc5ODI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNzoyNjo0OFrOHmsX4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNzoyNjo0OFrOHmsX4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMzNDk0Nw==", "bodyText": "don't log the message and the cause. Just call log()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510334947", "createdAt": "2020-10-22T17:26:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Pair;\n+import com.aws.greengrass.util.Utils;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUnsubscribeFromIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UnsubscribeFromIoTCoreResponse;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, ConcurrentHashMap<String, Pair<StreamEventPublisher<IoTCoreMessage>,\n+            Consumer<MqttMessage>>>> subscribeListeners = new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    public UnsubscribeFromIoTCoreOperationHandler getUnsubscribeFromIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UnsubscribeFromIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49bef4755248d477edfe87d36070ac94f5dddd6c"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE5MTc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0ODowNlrOHm5grg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0ODowNlrOHm5grg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDE5MA==", "bodyText": "This doesn't make sense. You're formatting e and e.getMessage() only use e.getMessage()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510550190", "createdAt": "2020-10-23T01:48:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.get(mqttClient.getTimeout(), TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(TOPIC_KEY, topic).kv(SERVICE_KEY, serviceName)\n+                        .log(\"Unable to publish to topic\");\n+                throw new ServiceError(String.format(\"Publish to topic %s failed with error %s:%s\", topic, e,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9576b4c5ebd8fd3dc13b139e0c2b28b837997258"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE5MjA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0ODoyMlrOHm5g4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0ODoyMlrOHm5g4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDI0MQ==", "bodyText": "same as below", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510550241", "createdAt": "2020-10-23T01:48:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9576b4c5ebd8fd3dc13b139e0c2b28b837997258"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE5MjU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0ODo0MFrOHm5hKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0ODo0MFrOHm5hKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDMxNQ==", "bodyText": "Same", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510550315", "createdAt": "2020-10-23T01:48:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.get(mqttClient.getTimeout(), TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(TOPIC_KEY, topic).kv(SERVICE_KEY, serviceName)\n+                        .log(\"Unable to publish to topic\");\n+                throw new ServiceError(String.format(\"Publish to topic %s failed with error %s:%s\", topic, e,\n+                        e.getMessage()));\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                        .topic(subscribedTopic).build();\n+\n+                try {\n+                    mqttClient.unsubscribe(unsubscribeRequest);\n+                } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                    LOGGER.atError().cause(e).kv(TOPIC_KEY, subscribedTopic).kv(SERVICE_KEY, serviceName)\n+                            .log(\"Stream closed but unable to unsubscribe from topic\");\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9576b4c5ebd8fd3dc13b139e0c2b28b837997258"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5ODE5MjY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0ODo0NFrOHm5hNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo0ODo0NFrOHm5hNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MDMyNw==", "bodyText": "Same", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r510550327", "createdAt": "2020-10-23T01:48:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue\n+            try {\n+                future.get(mqttClient.getTimeout(), TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(TOPIC_KEY, topic).kv(SERVICE_KEY, serviceName)\n+                        .log(\"Unable to publish to topic\");\n+                throw new ServiceError(String.format(\"Publish to topic %s failed with error %s:%s\", topic, e,\n+                        e.getMessage()));\n+            }\n+\n+            return new PublishToIoTCoreResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class SubscribeToIoTCoreOperationHandler extends GeneratedAbstractSubscribeToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        private String subscribedTopic;\n+\n+        private Consumer<MqttMessage> subscriptionCallback;\n+\n+        protected SubscribeToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            if (!Utils.isEmpty(subscribedTopic)) {\n+                UnsubscribeRequest unsubscribeRequest = UnsubscribeRequest.builder().callback(subscriptionCallback)\n+                        .topic(subscribedTopic).build();\n+\n+                try {\n+                    mqttClient.unsubscribe(unsubscribeRequest);\n+                } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                    LOGGER.atError().cause(e).kv(TOPIC_KEY, subscribedTopic).kv(SERVICE_KEY, serviceName)\n+                            .log(\"Stream closed but unable to unsubscribe from topic\");\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public SubscribeToIoTCoreResponse handleRequest(SubscribeToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s:%s\", e, e.getMessage()));\n+            }\n+\n+            Consumer<MqttMessage> callback = this::forwardToSubscriber;\n+            SubscribeRequest subscribeRequest = SubscribeRequest.builder().callback(callback).topic(topic)\n+                    .qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+\n+            try {\n+                mqttClient.subscribe(subscribeRequest);\n+            } catch (ExecutionException | InterruptedException | TimeoutException e) {\n+                LOGGER.atError().cause(e).kv(TOPIC_KEY, topic).kv(SERVICE_KEY, serviceName)\n+                        .log(\"Unable to subscribe to topic\");\n+                throw new ServiceError(String.format(\"Subscribe to topic %s failed with error %s:%s\", topic, e,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9576b4c5ebd8fd3dc13b139e0c2b28b837997258"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTcyMjI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOToyMjoxMlrOHnbJ_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOToyMjoxMlrOHnbJ_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEwMTQzNg==", "bodyText": "As discussed offline, this is going to need to change. Need to sign off with Jamie, but current thinking is that we need a separate stream for message delivery events so that we can scalably receive publish requests while offline (i.e. we can't pile up streams, threads, objects, etc -- the spool itself should be the limiting factor).\nWe can address this separately.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r511101436", "createdAt": "2020-10-23T19:22:12Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/builtin/services/mqttproxy/MqttProxyIPCAgent.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.mqttproxy;\n+\n+import com.aws.greengrass.authorization.AuthorizationHandler;\n+import com.aws.greengrass.authorization.Permission;\n+import com.aws.greengrass.authorization.exceptions.AuthorizationException;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractPublishToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToIoTCoreOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.MQTTMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.ServiceError;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UnauthorizedError;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.ipc.modules.MqttProxyIPCService.MQTT_PROXY_SERVICE_NAME;\n+\n+public class MqttProxyIPCAgent {\n+    private static final Logger LOGGER = LogManager.getLogger(MqttProxyIPCAgent.class);\n+    private static final String SERVICE_KEY = \"service\";\n+    private static final String TOPIC_KEY = \"topic\";\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private MqttClient mqttClient;\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private AuthorizationHandler authorizationHandler;\n+\n+    public PublishToIoTCoreOperationHandler getPublishToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new PublishToIoTCoreOperationHandler(context);\n+    }\n+\n+    public SubscribeToIoTCoreOperationHandler getSubscribeToIoTCoreOperationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SubscribeToIoTCoreOperationHandler(context);\n+    }\n+\n+    class PublishToIoTCoreOperationHandler extends GeneratedAbstractPublishToIoTCoreOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected PublishToIoTCoreOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public PublishToIoTCoreResponse handleRequest(PublishToIoTCoreRequest request) {\n+            String topic = request.getTopicName();\n+\n+            try {\n+                doAuthorization(this.getOperationModelContext().getOperationName(), serviceName, topic);\n+            } catch (AuthorizationException e) {\n+                LOGGER.atError().cause(e).log();\n+                throw new UnauthorizedError(String.format(\"Authorization failed with error %s\", e.getMessage()));\n+            }\n+\n+            PublishRequest publishRequest = PublishRequest.builder().payload(request.getPayload()).topic(topic)\n+                    .retain(request.isRetain()).qos(getQualityOfServiceFromQOS(request.getQos())).build();\n+            CompletableFuture<Integer> future = mqttClient.publish(publishRequest);\n+\n+            //TODO: replace this with a check that message is inserted in spooler queue", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "833359ba64c045d7274b0e73d65b07b9dbfcd02a"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjA3MzYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTowMTozOFrOHneWCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTowMTozOFrOHneWCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MzY3NA==", "bodyText": "Can be backed out after we make the publish changes", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r511153674", "createdAt": "2020-10-23T21:01:38Z", "author": {"login": "jbutler"}, "path": "src/main/java/com/aws/greengrass/mqttclient/MqttClient.java", "diffHunk": "@@ -438,4 +438,8 @@ public synchronized void close() {\n     public void addToCallbackEvents(MqttClientConnectionEvents callbacks) {\n         callbackEventManager.addToCallbackEvents(callbacks);\n     }\n+\n+    public int getTimeout() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "833359ba64c045d7274b0e73d65b07b9dbfcd02a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMjExMTEzOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCMqttProxyTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMToxNzoyNFrOHneshQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMjowNzowOVrOHnftlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1OTQyOQ==", "bodyText": "Is closeStream() async? Sleeping problem isn't the most robust way to handle this", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r511159429", "createdAt": "2020-10-23T21:17:24Z", "author": {"login": "jbutler"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCMqttProxyTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.integrationtests.ipc;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.SubscribeToIoTCoreResponseHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(GGExtension.class)\n+public class IPCMqttProxyTest {\n+    private static final Logger logger = LogManager.getLogger(IPCMqttProxyTest.class);\n+    private static final int TIMEOUT_FOR_MQTTPROXY_SECONDS = 20;\n+    private static final String TEST_TOPIC = \"A/B/C\";\n+    private static final byte[] TEST_PAYLOAD = \"TestPayload\".getBytes(StandardCharsets.UTF_8);\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static MqttClient mqttClient;\n+    private static Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    @BeforeEach\n+    void beforeEach() throws Exception {\n+        mqttClient = mock(MqttClient.class);\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCMqttProxyTest.class.getResource(\"mqttproxy.yaml\").toString());\n+        CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(TEST_SERVICE_NAME) && newState.equals(State.FINISHED)) {\n+                awaitIpcServiceLatch.countDown();\n+            }\n+        });\n+        kernel.getContext().put(MqttClient.class, mqttClient);\n+        kernel.launch();\n+        assertTrue(awaitIpcServiceLatch.await(10, TimeUnit.SECONDS));\n+\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = TestUtils.getSocketOptionsForIPC();\n+        clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel);\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (clientConnection != null) {\n+            clientConnection.disconnect();\n+        }\n+        if (socketOptions != null) {\n+            socketOptions.close();\n+        }\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_publish_THEN_message_published() throws Exception {\n+        CompletableFuture<Integer> completableFuture = new CompletableFuture<>();\n+        completableFuture.complete(0);\n+        when(mqttClient.publish(any())).thenReturn(completableFuture);\n+        when(mqttClient.getTimeout()).thenReturn(1000);\n+\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        PublishToIoTCoreRequest publishToIoTCoreRequest = new PublishToIoTCoreRequest();\n+        publishToIoTCoreRequest.setPayload(TEST_PAYLOAD);\n+        publishToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        publishToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+        publishToIoTCoreRequest.setRetain(false);\n+        greengrassCoreIPCClient.publishToIoTCore(publishToIoTCoreRequest, Optional.empty()).getResponse()\n+                .get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<PublishRequest> publishRequestArgumentCaptor = ArgumentCaptor.forClass(PublishRequest.class);\n+        verify(mqttClient).publish(publishRequestArgumentCaptor.capture());\n+        PublishRequest capturedPublishRequest = publishRequestArgumentCaptor.getValue();\n+        assertThat(capturedPublishRequest.getPayload(), is(TEST_PAYLOAD));\n+        assertThat(capturedPublishRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedPublishRequest.isRetain(), is(false));\n+        assertThat(capturedPublishRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_subscribe_THEN_subscribed_and_message_received()\n+            throws Exception {\n+        CountDownLatch messageLatch = new CountDownLatch(1);\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToIoTCoreRequest subscribeToIoTCoreRequest = new SubscribeToIoTCoreRequest();\n+        subscribeToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        subscribeToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+\n+        StreamResponseHandler<IoTCoreMessage> streamResponseHandler = new StreamResponseHandler<IoTCoreMessage>() {\n+            @Override\n+            public void onStreamEvent(IoTCoreMessage streamEvent) {\n+                if (Arrays.equals(streamEvent.getMessage().getPayload(), TEST_PAYLOAD)\n+                        && streamEvent.getMessage().getTopicName().equals(TEST_TOPIC)) {\n+                    messageLatch.countDown();\n+                }\n+            }\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                logger.atError().cause(error).log(\"Subscribe stream errored\");\n+                return false;\n+            }\n+\n+            @Override\n+            public void onStreamClosed() {\n+\n+            }\n+        };\n+\n+        SubscribeToIoTCoreResponseHandler responseHandler = greengrassCoreIPCClient.subscribeToIoTCore(\n+                subscribeToIoTCoreRequest, Optional.of(streamResponseHandler));\n+        responseHandler.getResponse().get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<SubscribeRequest> subscribeRequestArgumentCaptor\n+                = ArgumentCaptor.forClass(SubscribeRequest.class);\n+        verify(mqttClient).subscribe(subscribeRequestArgumentCaptor.capture());\n+        SubscribeRequest capturedSubscribeRequest = subscribeRequestArgumentCaptor.getValue();\n+        assertThat(capturedSubscribeRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedSubscribeRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+\n+        Consumer<MqttMessage> callback = capturedSubscribeRequest.getCallback();\n+        MqttMessage message = new MqttMessage(TEST_TOPIC, TEST_PAYLOAD);\n+        callback.accept(message);\n+        assertTrue(messageLatch.await(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS));\n+\n+        //close stream -> unsubscribe\n+        responseHandler.closeStream();\n+        Thread.sleep(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "833359ba64c045d7274b0e73d65b07b9dbfcd02a"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3NjA4NA==", "bodyText": "closeStream() returns a future but waiting for the future to complete didn't trigger mqttclient.unsubscribe(), until I added the 5 ms sleep. I think that's probably because completion of closeStream() on client side doesn't necessarily mean onStreamClosed() has been completed on the server side.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/511#discussion_r511176084", "createdAt": "2020-10-23T22:07:09Z", "author": {"login": "popanmol"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCMqttProxyTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.integrationtests.ipc;\n+\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.State;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.mqttclient.MqttClient;\n+import com.aws.greengrass.mqttclient.PublishRequest;\n+import com.aws.greengrass.mqttclient.SubscribeRequest;\n+import com.aws.greengrass.mqttclient.UnsubscribeRequest;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import com.aws.greengrass.testcommons.testutilities.TestUtils;\n+import com.aws.greengrass.util.Coerce;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.ArgumentCaptor;\n+import software.amazon.awssdk.aws.greengrass.GreengrassCoreIPCClient;\n+import software.amazon.awssdk.aws.greengrass.SubscribeToIoTCoreResponseHandler;\n+import software.amazon.awssdk.aws.greengrass.model.IoTCoreMessage;\n+import software.amazon.awssdk.aws.greengrass.model.PublishToIoTCoreRequest;\n+import software.amazon.awssdk.aws.greengrass.model.QOS;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToIoTCoreRequest;\n+import software.amazon.awssdk.crt.io.SocketOptions;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.eventstreamrpc.EventStreamRPCConnection;\n+import software.amazon.awssdk.eventstreamrpc.StreamResponseHandler;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.greengrass.integrationtests.ipc.IPCTestUtils.TEST_SERVICE_NAME;\n+import static com.aws.greengrass.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.PRIVATE_STORE_NAMESPACE_TOPIC;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(GGExtension.class)\n+public class IPCMqttProxyTest {\n+    private static final Logger logger = LogManager.getLogger(IPCMqttProxyTest.class);\n+    private static final int TIMEOUT_FOR_MQTTPROXY_SECONDS = 20;\n+    private static final String TEST_TOPIC = \"A/B/C\";\n+    private static final byte[] TEST_PAYLOAD = \"TestPayload\".getBytes(StandardCharsets.UTF_8);\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static MqttClient mqttClient;\n+    private static Kernel kernel;\n+    private static EventStreamRPCConnection clientConnection;\n+    private static SocketOptions socketOptions;\n+\n+    @BeforeEach\n+    void beforeEach() throws Exception {\n+        mqttClient = mock(MqttClient.class);\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+\n+        kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCMqttProxyTest.class.getResource(\"mqttproxy.yaml\").toString());\n+        CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(TEST_SERVICE_NAME) && newState.equals(State.FINISHED)) {\n+                awaitIpcServiceLatch.countDown();\n+            }\n+        });\n+        kernel.getContext().put(MqttClient.class, mqttClient);\n+        kernel.launch();\n+        assertTrue(awaitIpcServiceLatch.await(10, TimeUnit.SECONDS));\n+\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, TEST_SERVICE_NAME,\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        socketOptions = TestUtils.getSocketOptionsForIPC();\n+        clientConnection = IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel);\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (clientConnection != null) {\n+            clientConnection.disconnect();\n+        }\n+        if (socketOptions != null) {\n+            socketOptions.close();\n+        }\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_publish_THEN_message_published() throws Exception {\n+        CompletableFuture<Integer> completableFuture = new CompletableFuture<>();\n+        completableFuture.complete(0);\n+        when(mqttClient.publish(any())).thenReturn(completableFuture);\n+        when(mqttClient.getTimeout()).thenReturn(1000);\n+\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        PublishToIoTCoreRequest publishToIoTCoreRequest = new PublishToIoTCoreRequest();\n+        publishToIoTCoreRequest.setPayload(TEST_PAYLOAD);\n+        publishToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        publishToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+        publishToIoTCoreRequest.setRetain(false);\n+        greengrassCoreIPCClient.publishToIoTCore(publishToIoTCoreRequest, Optional.empty()).getResponse()\n+                .get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<PublishRequest> publishRequestArgumentCaptor = ArgumentCaptor.forClass(PublishRequest.class);\n+        verify(mqttClient).publish(publishRequestArgumentCaptor.capture());\n+        PublishRequest capturedPublishRequest = publishRequestArgumentCaptor.getValue();\n+        assertThat(capturedPublishRequest.getPayload(), is(TEST_PAYLOAD));\n+        assertThat(capturedPublishRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedPublishRequest.isRetain(), is(false));\n+        assertThat(capturedPublishRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+    }\n+\n+    @Test\n+    void GIVEN_MqttProxyEventStreamClient_WHEN_called_subscribe_THEN_subscribed_and_message_received()\n+            throws Exception {\n+        CountDownLatch messageLatch = new CountDownLatch(1);\n+        GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+        SubscribeToIoTCoreRequest subscribeToIoTCoreRequest = new SubscribeToIoTCoreRequest();\n+        subscribeToIoTCoreRequest.setQos(QOS.AT_LEAST_ONCE);\n+        subscribeToIoTCoreRequest.setTopicName(TEST_TOPIC);\n+\n+        StreamResponseHandler<IoTCoreMessage> streamResponseHandler = new StreamResponseHandler<IoTCoreMessage>() {\n+            @Override\n+            public void onStreamEvent(IoTCoreMessage streamEvent) {\n+                if (Arrays.equals(streamEvent.getMessage().getPayload(), TEST_PAYLOAD)\n+                        && streamEvent.getMessage().getTopicName().equals(TEST_TOPIC)) {\n+                    messageLatch.countDown();\n+                }\n+            }\n+\n+            @Override\n+            public boolean onStreamError(Throwable error) {\n+                logger.atError().cause(error).log(\"Subscribe stream errored\");\n+                return false;\n+            }\n+\n+            @Override\n+            public void onStreamClosed() {\n+\n+            }\n+        };\n+\n+        SubscribeToIoTCoreResponseHandler responseHandler = greengrassCoreIPCClient.subscribeToIoTCore(\n+                subscribeToIoTCoreRequest, Optional.of(streamResponseHandler));\n+        responseHandler.getResponse().get(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS);\n+\n+        ArgumentCaptor<SubscribeRequest> subscribeRequestArgumentCaptor\n+                = ArgumentCaptor.forClass(SubscribeRequest.class);\n+        verify(mqttClient).subscribe(subscribeRequestArgumentCaptor.capture());\n+        SubscribeRequest capturedSubscribeRequest = subscribeRequestArgumentCaptor.getValue();\n+        assertThat(capturedSubscribeRequest.getTopic(), is(TEST_TOPIC));\n+        assertThat(capturedSubscribeRequest.getQos(), is(QualityOfService.AT_LEAST_ONCE));\n+\n+        Consumer<MqttMessage> callback = capturedSubscribeRequest.getCallback();\n+        MqttMessage message = new MqttMessage(TEST_TOPIC, TEST_PAYLOAD);\n+        callback.accept(message);\n+        assertTrue(messageLatch.await(TIMEOUT_FOR_MQTTPROXY_SECONDS, TimeUnit.SECONDS));\n+\n+        //close stream -> unsubscribe\n+        responseHandler.closeStream();\n+        Thread.sleep(5);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1OTQyOQ=="}, "originalCommit": {"oid": "833359ba64c045d7274b0e73d65b07b9dbfcd02a"}, "originalPosition": 182}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 631, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}