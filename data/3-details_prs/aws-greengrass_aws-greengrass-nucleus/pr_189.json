{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0ODQ5MjUy", "number": 189, "title": "consolidate break/continue in lifecycle whileLoop", "bodyText": "Issue #, if available:\nTo improve readability of current Lifecycle\nDescription of changes:\n\nconsolidate break/continue in lifecycle whileLoop . Move the logic of updateStateAndBroadcast() to the end of while loop , and handleStateTransitionX() doesn't update state directly.\nmove timeout logic to each handleStateTransitionX() method.\nadd asyncFinishActionCheck to lifecycle whileLoop , so that async handleStateTransitionX() can have a finish action when a state event is received.\nAdd unit test of lifecycle test\n\nWhy is this change necessary:\nHow was this change tested:\nmvn verify\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-04-16T23:59:47Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189", "merged": true, "mergeCommit": {"oid": "3224af065ddd0302db2762859de40b9c15a88134"}, "closed": true, "closedAt": "2020-05-05T17:26:05Z", "author": {"login": "ShirleyZheng92"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYWDKlAFqTM5NTA4MjgxNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABceWtMSgFqTQwNTk1Nzk1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MDgyODE3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-395082817", "createdAt": "2020-04-17T00:16:59Z", "commit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMDoxNjo1OVrOGG7mLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMDoyMDo0MlrOGG7qQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMTA3MQ==", "bodyText": "This can just be a lambda, can't it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409921071", "createdAt": "2020-04-17T00:16:59Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -509,6 +527,33 @@ private void serviceTerminatedMoveToDesiredState(@Nonnull State desiredState) {\n         }\n     }\n \n+    private TimerTask timeoutTask;\n+    private Timer timer = new Timer();\n+\n+    private void setTimeoutAction(Runnable timeoutAction, long timeout) {\n+        synchronized (timer) {\n+            if (timeoutTask != null) {\n+                timeoutTask.cancel();\n+            }\n+\n+            timeoutTask = new TimerTask() {\n+                @Override\n+                public void run() {\n+                    timeoutAction.run();\n+                }\n+            };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 480}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMTgzNg==", "bodyText": "should be final.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409921836", "createdAt": "2020-04-17T00:19:35Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -509,6 +527,33 @@ private void serviceTerminatedMoveToDesiredState(@Nonnull State desiredState) {\n         }\n     }\n \n+    private TimerTask timeoutTask;\n+    private Timer timer = new Timer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 467}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMjExMw==", "bodyText": "instead of null, can we we use an AtomicReference<Predicate>? Which we get() and set()?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409922113", "createdAt": "2020-04-17T00:20:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -213,57 +203,76 @@ void startStateTransition() throws InterruptedException {\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n+            // A state event can either be a report state transition event or a desired state updated event.\n+            Object stateEvent = stateEventQueue.poll();\n+\n+            // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+            // drain them until a \"State\" event is encountered.\n+            while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                stateEvent = stateEventQueue.poll();\n             }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+\n+            // if there are no events in the queue, block until one is available.\n+            if (stateEvent == null) {\n+                stateEvent = stateEventQueue.take();\n             }\n+\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    // ignore same state reported twice\n+                    if (newState != current) {\n+                        canFinish = true;\n+                        logger.atInfo(\"service-set-state\").kv(\"newState\", newState).log();\n+                        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n+                        // across different services.\n+                        synchronized (State.class) {\n+                            prevState = current;\n+                            stateTopic.withValue(newState);\n+                            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                        }\n+                    }\n+                }\n+                if (asyncFinishActionCheck == null || asyncFinishActionCheck.test(stateEvent)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 167}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MTM2MjY1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-395136265", "createdAt": "2020-04-17T03:22:50Z", "commit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMzoyMjo1MFrOGG-mJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMzoyMjo1MFrOGG-mJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk3MDIxNQ==", "bodyText": "I'd really really prefer if we only have 1 place in this thread that we block.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409970215", "createdAt": "2020-04-17T03:22:50Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -213,57 +203,76 @@ void startStateTransition() throws InterruptedException {\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n+            // A state event can either be a report state transition event or a desired state updated event.\n+            Object stateEvent = stateEventQueue.poll();\n+\n+            // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+            // drain them until a \"State\" event is encountered.\n+            while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                stateEvent = stateEventQueue.poll();\n             }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+\n+            // if there are no events in the queue, block until one is available.\n+            if (stateEvent == null) {\n+                stateEvent = stateEventQueue.take();\n             }\n+\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    // ignore same state reported twice\n+                    if (newState != current) {\n+                        canFinish = true;\n+                        logger.atInfo(\"service-set-state\").kv(\"newState\", newState).log();\n+                        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n+                        // across different services.\n+                        synchronized (State.class) {\n+                            prevState = current;\n+                            stateTopic.withValue(newState);\n+                            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                        }\n+                    }\n+                }\n+                if (asyncFinishActionCheck == null || asyncFinishActionCheck.test(stateEvent)) {\n+                    canFinish = true;\n+                }\n+\n+                if (canFinish) {\n+                    break;\n+                } else {\n+                    stateEvent = stateEventQueue.take();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MTY0NDA5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-395164409", "createdAt": "2020-04-17T05:09:01Z", "commit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNTowOTowMVrOGHAIoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1OTo0OFrOGHV5jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NTQyNA==", "bodyText": "Probably log at debug level.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409995424", "createdAt": "2020-04-17T05:09:01Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -86,37 +88,25 @@ public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger)\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n-            return;\n+    synchronized void reportState(State newState) {\n+         logger.atInfo(\"service-report-state\").kv(\"newState\", newState).log();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NTc0Ng==", "bodyText": "Probably logging at warn level is more appropriate. Error should be reserved for something with negative impact. I'm not sure if that's the case here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409995746", "createdAt": "2020-04-17T05:10:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -86,37 +88,25 @@ public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger)\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n-            return;\n+    synchronized void reportState(State newState) {\n+         logger.atInfo(\"service-report-state\").kv(\"newState\", newState).log();\n+        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n+            logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"newState\", newState).log(\"Invalid reported state\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NTk5Ng==", "bodyText": "synchronized is not needed here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409995996", "createdAt": "2020-04-17T05:11:30Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -86,37 +88,25 @@ public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger)\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n-            return;\n+    synchronized void reportState(State newState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NjMyMQ==", "bodyText": "Move this above together with other instance variables.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r409996321", "createdAt": "2020-04-17T05:12:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -86,37 +88,25 @@ public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger)\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n-            return;\n+    synchronized void reportState(State newState) {\n+         logger.atInfo(\"service-report-state\").kv(\"newState\", newState).log();\n+        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n+            logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"newState\", newState).log(\"Invalid reported state\");\n         }\n+        // TODO: Add more validations\n \n-        // TODO: Add validation\n-\n-        logger.atInfo(\"service-set-state\").kv(\"newState\", newState).log();\n-        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n-        // across different services.\n-        synchronized (State.class) {\n-            prevState = currentState;\n-            stateTopic.withValue(newState);\n-            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n-        }\n+        internalReportState(newState);\n     }\n \n+    private AtomicBoolean errorReported = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAwNjAwOQ==", "bodyText": "Not sure if this is better than the previous way. Personally I find it more difficult to read. setTimeoutAction() also takes an extra thread.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410006009", "createdAt": "2020-04-17T05:52:27Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -369,43 +380,50 @@ private void handleStateTransitionInstalledToRunning(AtomicReference<Future> tri\n                     Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n                             : (Integer) timeOutTopic.getOnce();\n \n-\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                if (!State.RUNNING.equals(evergreenService.getState())) {\n-                                    logger.atWarn(\"service-startup-timed-out\")\n-                                            .kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n+                    setTimeoutAction(() -> {\n+                        logger.error(\"Timeout starting service\");\n+                        reportState(State.ERRORED);\n+                    }, timeout * 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0OTg0OQ==", "bodyText": "What does canFinish mean?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410349849", "createdAt": "2020-04-17T16:55:49Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -213,57 +203,76 @@ void startStateTransition() throws InterruptedException {\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n+            // A state event can either be a report state transition event or a desired state updated event.\n+            Object stateEvent = stateEventQueue.poll();\n+\n+            // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+            // drain them until a \"State\" event is encountered.\n+            while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                stateEvent = stateEventQueue.poll();\n             }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+\n+            // if there are no events in the queue, block until one is available.\n+            if (stateEvent == null) {\n+                stateEvent = stateEventQueue.take();\n             }\n+\n+            boolean canFinish = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjAxMw==", "bodyText": "Agree", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r410352013", "createdAt": "2020-04-17T16:59:48Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -213,57 +203,76 @@ void startStateTransition() throws InterruptedException {\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n+            // A state event can either be a report state transition event or a desired state updated event.\n+            Object stateEvent = stateEventQueue.poll();\n+\n+            // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+            // drain them until a \"State\" event is encountered.\n+            while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                stateEvent = stateEventQueue.poll();\n             }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+\n+            // if there are no events in the queue, block until one is available.\n+            if (stateEvent == null) {\n+                stateEvent = stateEventQueue.take();\n             }\n+\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    // ignore same state reported twice\n+                    if (newState != current) {\n+                        canFinish = true;\n+                        logger.atInfo(\"service-set-state\").kv(\"newState\", newState).log();\n+                        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n+                        // across different services.\n+                        synchronized (State.class) {\n+                            prevState = current;\n+                            stateTopic.withValue(newState);\n+                            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                        }\n+                    }\n+                }\n+                if (asyncFinishActionCheck == null || asyncFinishActionCheck.test(stateEvent)) {\n+                    canFinish = true;\n+                }\n+\n+                if (canFinish) {\n+                    break;\n+                } else {\n+                    stateEvent = stateEventQueue.take();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk3MDIxNQ=="}, "originalCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809"}, "originalPosition": 174}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8cfea8ae3f852dc6e1b9035db1afaf9085389809", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8cfea8ae3f852dc6e1b9035db1afaf9085389809", "committedDate": "2020-04-16T23:41:43Z", "message": "[Draft]consolidate break/continue in lifecycle whileLoop"}, "afterCommit": {"oid": "eba133a1c621966c07f8c8b2ea11c1db2f9021e3", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eba133a1c621966c07f8c8b2ea11c1db2f9021e3", "committedDate": "2020-04-24T19:28:48Z", "message": "address comments and add unit test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eba133a1c621966c07f8c8b2ea11c1db2f9021e3", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/eba133a1c621966c07f8c8b2ea11c1db2f9021e3", "committedDate": "2020-04-24T19:28:48Z", "message": "address comments and add unit test"}, "afterCommit": {"oid": "dab78db3c13a8923f952e9180ae4e2a8a8ac6799", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dab78db3c13a8923f952e9180ae4e2a8a8ac6799", "committedDate": "2020-04-27T20:36:49Z", "message": "address comments and add unit test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dab78db3c13a8923f952e9180ae4e2a8a8ac6799", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dab78db3c13a8923f952e9180ae4e2a8a8ac6799", "committedDate": "2020-04-27T20:36:49Z", "message": "address comments and add unit test"}, "afterCommit": {"oid": "b87348bb1d19f3c2b81bfba8f5bd900e949c8c18", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b87348bb1d19f3c2b81bfba8f5bd900e949c8c18", "committedDate": "2020-04-27T20:37:57Z", "message": "[Draft]consolidate break/continue in lifecycle whileLoop"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b87348bb1d19f3c2b81bfba8f5bd900e949c8c18", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b87348bb1d19f3c2b81bfba8f5bd900e949c8c18", "committedDate": "2020-04-27T20:37:57Z", "message": "[Draft]consolidate break/continue in lifecycle whileLoop"}, "afterCommit": {"oid": "3d7e68c8fbae52f509179949629ab754b5a300e5", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3d7e68c8fbae52f509179949629ab754b5a300e5", "committedDate": "2020-04-27T22:47:09Z", "message": "Consolidate break/continue in lifecycle whileLoop"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d7e68c8fbae52f509179949629ab754b5a300e5", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3d7e68c8fbae52f509179949629ab754b5a300e5", "committedDate": "2020-04-27T22:47:09Z", "message": "Consolidate break/continue in lifecycle whileLoop"}, "afterCommit": {"oid": "08d296e59cb004d47039856aeb0fb6bae49ef24c", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/08d296e59cb004d47039856aeb0fb6bae49ef24c", "committedDate": "2020-04-27T23:23:34Z", "message": "Consolidate break/continue in lifecycle whileLoop"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "08d296e59cb004d47039856aeb0fb6bae49ef24c", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/08d296e59cb004d47039856aeb0fb6bae49ef24c", "committedDate": "2020-04-27T23:23:34Z", "message": "Consolidate break/continue in lifecycle whileLoop"}, "afterCommit": {"oid": "2cf8530442fb914c220e41659ee8e3a79c2d3fd2", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2cf8530442fb914c220e41659ee8e3a79c2d3fd2", "committedDate": "2020-04-28T00:35:43Z", "message": "Consolidate break/continue in lifecycle whileLoop"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "568ea32935bbd02b1d63efdfbcfa25e7aae09c0c", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/568ea32935bbd02b1d63efdfbcfa25e7aae09c0c", "committedDate": "2020-04-28T02:41:25Z", "message": "AddressComments"}, "afterCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4e07375c85dca0fcd65f3432d199de680de390a4", "committedDate": "2020-04-28T20:49:21Z", "message": "Add Starting state"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjExMTUz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-402211153", "createdAt": "2020-04-28T21:05:24Z", "commit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTowNToyNFrOGNm5MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToxNDozMlrOGNnNXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMTkwNA==", "bodyText": "not needed, the default is console.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416921904", "createdAt": "2020-04-28T21:05:24Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMjA2OA==", "bodyText": "context needs to be closed in the after and the executors need to be shutdown too, otherwise you're leaking a lot of threads.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416922068", "createdAt": "2020-04-28T21:05:42Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMjc2Mw==", "bodyText": "this isn't needed, you can just let this method throw.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416922763", "createdAt": "2020-04-28T21:06:48Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDIwMw==", "bodyText": "no sleeping, just use verify(<x>, timeout(<some time>)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416924203", "createdAt": "2020-04-28T21:09:24Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDY5MQ==", "bodyText": "switch the order here, it should be expected, actual.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416924691", "createdAt": "2020-04-28T21:10:17Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        Mockito.verify(evergreenService).install();\n+        Mockito.verify(evergreenService).startup();\n+        assertEquals(lifecycle.getState(), State.STARTING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDk2Mw==", "bodyText": "please no sleeping", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416924963", "createdAt": "2020-04-28T21:10:50Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        Mockito.verify(evergreenService).install();\n+        Mockito.verify(evergreenService).startup();\n+        assertEquals(lifecycle.getState(), State.STARTING);\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_install_timeout_THEN_service_errored() throws InterruptedException {\n+        //GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        AtomicBoolean installInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTIyNw==", "bodyText": "these are unit tests, 10 seconds is far too long for a unit test. Each one should take a couple milliseconds.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416925227", "createdAt": "2020-04-28T21:11:18Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        Mockito.verify(evergreenService).install();\n+        Mockito.verify(evergreenService).startup();\n+        assertEquals(lifecycle.getState(), State.STARTING);\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_install_timeout_THEN_service_errored() throws InterruptedException {\n+        //GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        AtomicBoolean installInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                installInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).install();\n+\n+        CountDownLatch errorHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            errorHandleLatch.countDown();\n+            return null;\n+        }).when(evergreenService).handleError();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+        boolean errorHandled = errorHandleLatch.await(10, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTkzNA==", "bodyText": "Understand what you're doing, but why?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416925934", "createdAt": "2020-04-28T21:12:30Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        Mockito.verify(evergreenService).install();\n+        Mockito.verify(evergreenService).startup();\n+        assertEquals(lifecycle.getState(), State.STARTING);\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_install_timeout_THEN_service_errored() throws InterruptedException {\n+        //GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        AtomicBoolean installInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                installInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).install();\n+\n+        CountDownLatch errorHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            errorHandleLatch.countDown();\n+            return null;\n+        }).when(evergreenService).handleError();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+        boolean errorHandled = errorHandleLatch.await(10, TimeUnit.SECONDS);\n+\n+        // THEN\n+        assertTrue(errorHandled);\n+        // sleep to let error handle finished\n+        Thread.sleep(100);\n+        assertTrue(installInterrupted.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_state_installed_WHEN_startup_timeout_THEN_service_errored() throws InterruptedException {\n+        // GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.INSTALLED);\n+\n+        AtomicBoolean startupInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                startupInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).startup();\n+\n+        CountDownLatch errorHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            errorHandleLatch.countDown();\n+            return null;\n+        }).when(evergreenService).handleError();\n+\n+        CountDownLatch shutdownHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            if (errorHandleLatch.getCount() == 0) {\n+                shutdownHandleLatch.countDown();\n+            }\n+            return null;\n+        }).when(evergreenService).shutdown();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+        boolean shutdownCalled = shutdownHandleLatch.await(10, TimeUnit.SECONDS);\n+\n+        // THEN\n+        assertTrue(shutdownCalled);\n+        // sleep to let shutdown finished\n+        Thread.sleep(100);\n+        assertTrue(startupInterrupted.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_state_running_WHEN_requestStop_THEN_shutdown_called() throws InterruptedException {\n+        // GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.INSTALLED);\n+\n+        AtomicBoolean startupInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            lifecycle.reportState(State.RUNNING);\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                startupInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).startup();\n+\n+\n+        CountDownLatch shutdownCalledLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            shutdownCalledLatch.countDown();\n+            return null;\n+        }).when(evergreenService).shutdown();\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        assertEquals(State.RUNNING, lifecycle.getState());\n+\n+        // WHEN\n+        lifecycle.requestStop();\n+        shutdownCalledLatch.await(1, TimeUnit.SECONDS);\n+\n+        // THEN\n+        Mockito.verify(evergreenService).startup();\n+        Mockito.verify(evergreenService).shutdown();\n+        Thread.sleep(100);\n+        assertTrue(startupInterrupted.get());\n+        assertEquals(State.FINISHED, lifecycle.getState());\n+    }\n+\n+    @Test\n+    public void GIVEN_state_install_WHEN_requestStop_THEN_shutdown_called() throws InterruptedException {\n+        // GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.INSTALLED);\n+\n+        AtomicBoolean startupInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            // not report RUNNING here\n+            lifecycle.requestStop();\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                startupInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).startup();\n+\n+        CountDownLatch shutdownCalledLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            shutdownCalledLatch.countDown();\n+            return null;\n+        }).when(evergreenService).shutdown();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        // THEN\n+        shutdownCalledLatch.await(1, TimeUnit.SECONDS);\n+        Mockito.verify(evergreenService).startup();\n+        Mockito.verify(evergreenService).shutdown();\n+\n+        Thread.sleep(100);\n+        assertTrue(startupInterrupted.get());\n+        assertEquals(State.FINISHED, lifecycle.getState());\n+    }\n+\n+    @Test\n+    void GIVEN_a_service_WHEN_reportState_THEN_all_state_changes_are_notified() throws InterruptedException {\n+        // set lifecycle thread with min priority", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjE3MQ==", "bodyText": "Also, this executor will need to be shutdown.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416926171", "createdAt": "2020-04-28T21:12:51Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/LifecycleTest.java", "diffHunk": "@@ -0,0 +1,328 @@\n+package com.aws.iot.evergreen.kernel;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class LifecycleTest {\n+\n+    @Mock\n+    protected EvergreenService evergreenService;\n+\n+    private static final String BLANK_CONFIG_YAML_WITH_TIMEOUT =\n+            \"---\\n\"\n+            + \"lifecycle:\\n\"\n+            + \"  install:\\n\"\n+            + \"    timeout: 2\\n\"\n+            + \"  startup:\\n\"\n+            + \"    timeout: 3\\n\"\n+            + \"  shutdown:\\n\"\n+            + \"    timeout: 5\\n\";\n+\n+    private final Logger logger = LogManager.getLogger(\"test\");\n+    private Context context;\n+    private Topics config;\n+    private Lifecycle lifecycle;\n+\n+    @BeforeAll\n+    static void setupProperty() {\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+    }\n+\n+    @BeforeEach\n+    void setupContext() {\n+        context = new Context();\n+        ScheduledThreadPoolExecutor ses = new ScheduledThreadPoolExecutor(4);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        context.put(ScheduledThreadPoolExecutor.class, ses);\n+        context.put(ScheduledExecutorService.class, ses);\n+        context.put(Executor.class, executorService);\n+        context.put(ExecutorService.class, executorService);\n+        context.put(ThreadPoolExecutor.class, ses);\n+\n+        config = new Topics(context, \"MockService\", null);\n+        try (InputStream inputStream = new ByteArrayInputStream(BLANK_CONFIG_YAML_WITH_TIMEOUT.getBytes())) {\n+            config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+        } catch (IOException e) {\n+            fail(e);\n+        }\n+\n+        Mockito.when(evergreenService.getConfig()).thenReturn(config);\n+        Mockito.when(evergreenService.getContext()).thenReturn(context);\n+    }\n+\n+    @AfterEach\n+    void stop() {\n+        if (lifecycle != null) {\n+            lifecycle.setClosed(true);\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_requestStart_called_THEN_install_invoked() throws InterruptedException {\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        Mockito.verify(evergreenService).install();\n+        Mockito.verify(evergreenService).startup();\n+        assertEquals(lifecycle.getState(), State.STARTING);\n+    }\n+\n+    @Test\n+    public void GIVEN_state_new_WHEN_install_timeout_THEN_service_errored() throws InterruptedException {\n+        //GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.NEW);\n+\n+        AtomicBoolean installInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                installInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).install();\n+\n+        CountDownLatch errorHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            errorHandleLatch.countDown();\n+            return null;\n+        }).when(evergreenService).handleError();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+        boolean errorHandled = errorHandleLatch.await(10, TimeUnit.SECONDS);\n+\n+        // THEN\n+        assertTrue(errorHandled);\n+        // sleep to let error handle finished\n+        Thread.sleep(100);\n+        assertTrue(installInterrupted.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_state_installed_WHEN_startup_timeout_THEN_service_errored() throws InterruptedException {\n+        // GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.INSTALLED);\n+\n+        AtomicBoolean startupInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                startupInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).startup();\n+\n+        CountDownLatch errorHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            errorHandleLatch.countDown();\n+            return null;\n+        }).when(evergreenService).handleError();\n+\n+        CountDownLatch shutdownHandleLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            if (errorHandleLatch.getCount() == 0) {\n+                shutdownHandleLatch.countDown();\n+            }\n+            return null;\n+        }).when(evergreenService).shutdown();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+        boolean shutdownCalled = shutdownHandleLatch.await(10, TimeUnit.SECONDS);\n+\n+        // THEN\n+        assertTrue(shutdownCalled);\n+        // sleep to let shutdown finished\n+        Thread.sleep(100);\n+        assertTrue(startupInterrupted.get());\n+    }\n+\n+    @Test\n+    public void GIVEN_state_running_WHEN_requestStop_THEN_shutdown_called() throws InterruptedException {\n+        // GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.INSTALLED);\n+\n+        AtomicBoolean startupInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            lifecycle.reportState(State.RUNNING);\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                startupInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).startup();\n+\n+\n+        CountDownLatch shutdownCalledLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            shutdownCalledLatch.countDown();\n+            return null;\n+        }).when(evergreenService).shutdown();\n+\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        Thread.sleep(100);\n+        assertEquals(State.RUNNING, lifecycle.getState());\n+\n+        // WHEN\n+        lifecycle.requestStop();\n+        shutdownCalledLatch.await(1, TimeUnit.SECONDS);\n+\n+        // THEN\n+        Mockito.verify(evergreenService).startup();\n+        Mockito.verify(evergreenService).shutdown();\n+        Thread.sleep(100);\n+        assertTrue(startupInterrupted.get());\n+        assertEquals(State.FINISHED, lifecycle.getState());\n+    }\n+\n+    @Test\n+    public void GIVEN_state_install_WHEN_requestStop_THEN_shutdown_called() throws InterruptedException {\n+        // GIVEN\n+        lifecycle = new Lifecycle(evergreenService, logger);\n+        initLifecycleState(lifecycle, State.INSTALLED);\n+\n+        AtomicBoolean startupInterrupted = new AtomicBoolean(false);\n+        Mockito.doAnswer((mock) -> {\n+            // not report RUNNING here\n+            lifecycle.requestStop();\n+            try {\n+                Thread.sleep(20_000);\n+            } catch (InterruptedException e) {\n+                startupInterrupted.set(true);\n+            }\n+            return null;\n+        }).when(evergreenService).startup();\n+\n+        CountDownLatch shutdownCalledLatch = new CountDownLatch(1);\n+        Mockito.doAnswer((mock) -> {\n+            shutdownCalledLatch.countDown();\n+            return null;\n+        }).when(evergreenService).shutdown();\n+\n+        // WHEN\n+        lifecycle.initLifecycleThread();\n+        lifecycle.requestStart();\n+\n+        // THEN\n+        shutdownCalledLatch.await(1, TimeUnit.SECONDS);\n+        Mockito.verify(evergreenService).startup();\n+        Mockito.verify(evergreenService).shutdown();\n+\n+        Thread.sleep(100);\n+        assertTrue(startupInterrupted.get());\n+        assertEquals(State.FINISHED, lifecycle.getState());\n+    }\n+\n+    @Test\n+    void GIVEN_a_service_WHEN_reportState_THEN_all_state_changes_are_notified() throws InterruptedException {\n+        // set lifecycle thread with min priority", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTkzNA=="}, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzA3MQ==", "bodyText": "Why do these need getters? If they need getters, can we keep them private or package-private?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416927071", "createdAt": "2020-04-28T21:14:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -36,17 +36,18 @@\n import static com.aws.iot.evergreen.util.Utils.getUltimateCause;\n \n public class EvergreenService implements InjectionActions {\n-    public static final String STATE_TOPIC_NAME = \"_State\";\n     public static final String SERVICES_NAMESPACE_TOPIC = \"services\";\n     public static final String SERVICE_LIFECYCLE_NAMESPACE_TOPIC = \"lifecycle\";\n     public static final String SERVICE_NAME_KEY = \"serviceName\";\n \n     private static final String CURRENT_STATE_METRIC_NAME = \"currentState\";\n \n+    @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjIwNzkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-402220791", "createdAt": "2020-04-28T21:20:51Z", "commit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMToyMDo1MVrOGNnZ1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo0MDo1N1rOGNoDow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDI2Mg==", "bodyText": "This seems very specific, can this be generalized more, ie apply it to all the reported-current state pairs that don't make sense.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416930262", "createdAt": "2020-04-28T21:20:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -89,44 +97,36 @@\n     // We only need to track the ERROR for the state transition starting from NEW, INSTALLED and RUNNING because\n     // these states impact whether the service can function as expected.\n     private static final Set<State> STATES_TO_ERRORED =\n-            new HashSet<>(Arrays.asList(State.NEW, State.INSTALLED, State.RUNNING));\n-    private Pair<State, State> currentStateTransition = null;\n+            new HashSet<>(Arrays.asList(State.NEW, State.STARTING, State.RUNNING));\n \n     /**\n      * Constructor for lifecycle.\n      *\n      * @param evergreenService service that this is the lifecycle for\n-     * @param state            service's state topic\n      * @param logger           service's logger\n      */\n-    public Lifecycle(EvergreenService evergreenService, Topic state, Logger logger) {\n+    public Lifecycle(EvergreenService evergreenService, Logger logger) {\n         this.evergreenService = evergreenService;\n         this.prevState = State.NEW;\n-        this.stateTopic = state;\n+        this.stateTopic = initStateTopic(evergreenService.getConfig());\n         this.logger = logger;\n     }\n \n-    private void updateStateAndBroadcast(State newState) {\n-        final State currentState = evergreenService.getState();\n-\n-        if (newState.equals(currentState)) {\n+    void reportState(State newState) {\n+        logger.atInfo(\"service-report-state\").kv(NEW_STATE_METRIC_NAME, newState).log();\n+        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n+            logger.atWarn(INVALID_STATE_ERROR_EVENT).kv(NEW_STATE_METRIC_NAME, newState).log(\"Invalid reported state\");\n             return;\n         }\n \n-        // TODO: Add validation\n-\n-        logger.atInfo(\"service-set-state\").kv(\"newState\", newState).log();\n-        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n-        // across different services.\n-        synchronized (State.class) {\n-            currentStateTransition = null; //NOPMD\n-            if (State.INSTALLED.equals(newState)) {\n-                stateGeneration.incrementAndGet();\n-            }\n-            prevState = currentState;\n-            stateTopic.withValue(newState);\n-            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+        if (newState.equals(State.RUNNING) && !currentOrReportedStateIs(State.STARTING)) {\n+            logger.atWarn(INVALID_STATE_ERROR_EVENT).kv(NEW_STATE_METRIC_NAME, newState)\n+                    .log(\"Service cannot report running when in the process of shutdown\");\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTUwNQ==", "bodyText": "The last reported state also needs to be reset once the reported state has been processed because after that point, it is invalid.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416931505", "createdAt": "2020-04-28T21:23:08Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -164,30 +160,51 @@ synchronized void reportState(State newState) {\n         }\n     }\n \n-    private Optional<State> getReportState() {\n-        Object top = stateEventQueue.poll();\n-        while (top != null && !(top instanceof State)) {\n-            top = stateEventQueue.poll();\n+    /**\n+     * Returns true if either the current or the very last reported state (if any)\n+     * is equal to the provided state.\n+     *\n+     * @param state state to check against\n+     */\n+    public boolean currentOrReportedStateIs(State state) {\n+        if (state.equals(getState())) {\n+            return true;\n         }\n+        return state.equals(lastReportedState.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMzkyNA==", "bodyText": "is current at this point accurate? Can't the handleX methods change what state it is in?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416933924", "createdAt": "2020-04-28T21:27:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +245,111 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();\n+                }\n+\n+                // if there are no events in the queue, block until one is available.\n+                if (stateEvent == null) {\n+                    stateEvent = stateEventQueue.take();\n+                }\n+\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    if (newState == current) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNTI3MA==", "bodyText": "this needs logging now since it is called directly in the lifecycle thread.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416935270", "createdAt": "2020-04-28T21:29:56Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -135,19 +135,15 @@ private void updateStateAndBroadcast(State newState) {\n      * @param newState reported state from the service which should eventually be set as the service's\n      *                 actual state\n      */\n-    synchronized void reportState(State newState) {\n-        logger.atInfo(\"service-report-state\").kv(\"newState\", newState).log();\n-        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n-            logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"newState\", newState).log(\"Invalid reported state\");\n-        }\n-        // TODO: Add more validations\n+    private synchronized void internalReportState(State newState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNjg5OA==", "bodyText": "Let's check the generation here too.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416936898", "createdAt": "2020-04-28T21:32:55Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +245,111 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();\n+                }\n+\n+                // if there are no events in the queue, block until one is available.\n+                if (stateEvent == null) {\n+                    stateEvent = stateEventQueue.take();\n+                }\n+\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    if (newState == current) {\n+                        continue;\n+                    }\n+\n+                    canFinish = true;\n+                    logger.atInfo(\"service-set-state\").kv(NEW_STATE_METRIC_NAME, newState).log();\n+                    // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged\n+                    // are consistent across different services.\n+                    synchronized (State.class) {\n+                        prevState = current;\n+                        stateTopic.withValue(newState);\n+                        evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                    }\n+                }\n+                if (asyncFinishAction.get().test(stateEvent)) {\n+                    canFinish = true;\n+                }\n             }\n+            asyncFinishAction.set((stateEvent) -> true);\n         }\n     }\n \n-    private boolean handleCurrentStateBroken(Optional<State> desiredState) {\n+    private void handleCurrentStateBroken(Optional<State> desiredState) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n         // Having State.NEW as the desired state indicates the service is requested to reinstall, so here\n         // we'll transition out of BROKEN state to give it a new chance.\n         if (State.NEW.equals(desiredState.get())) {\n-            updateStateAndBroadcast(State.NEW);\n+            internalReportState(State.NEW);\n         } else {\n             logger.atError(\"service-broken\").log(\"service is broken. Deployment is needed\");\n-            return true;\n         }\n-        return false;\n     }\n \n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private boolean handleCurrentStateNew(Optional<State> desiredState) throws InterruptedException {\n+    private void handleCurrentStateNew(Optional<State> desiredState) throws InterruptedException {\n         // if no desired state is set, don't do anything.\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        CountDownLatch installLatch = new CountDownLatch(1);\n         setBackingTask(() -> {\n-            if (!State.NEW.equals(evergreenService.getState())) {\n+            if (!State.NEW.equals(getState())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 380}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNzYxMg==", "bodyText": "Let's use serviceErrored since that provides a standardized way of logging errors which result in the service moving to errored.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416937612", "createdAt": "2020-04-28T21:34:24Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -328,101 +360,90 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (Throwable t) {\n                 reportState(State.ERRORED);\n                 logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            logger.error(\"error in install\", ee);\n+            internalReportState(State.ERRORED);\n+        } catch (TimeoutException te) {\n+            logger.error(\"Timeout in install\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzODc4MQ==", "bodyText": "use current or reported?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416938781", "createdAt": "2020-04-28T21:36:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -328,101 +360,90 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (Throwable t) {\n                 reportState(State.ERRORED);\n                 logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 411}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDE4NQ==", "bodyText": "use current or last?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416940185", "createdAt": "2020-04-28T21:39:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -455,37 +493,36 @@ private void handleCurrentStateStopping() throws InterruptedException {\n             } catch (Throwable t) {\n                 reportState(State.ERRORED);\n                 logger.atError(\"service-shutdown-error\", t).log();\n-            } finally {\n-                stopping.countDown();\n             }\n         });\n \n-        boolean stopSucceed = stopping.await(15, TimeUnit.SECONDS);\n-\n-        stopBackingTask();\n-        if (State.ERRORED.equals(getReportState().orElse(null)) || !stopSucceed) {\n-            if (!stopSucceed) {\n-                logger.atError(\"service-shutdown-error\").log(\"Service stop timed out\");\n-            }\n-            updateStateAndBroadcast(State.ERRORED);\n-            // If the thread is still running, then kill it\n-            if (!shutdownFuture.isDone()) {\n-                shutdownFuture.cancel(true);\n+        try {\n+            Integer timeout = getTimeoutConfigValue(\n+                        LIFECYCLE_SHUTDOWN_NAMESPACE_TOPIC, DEFAULT_SHUTDOWN_STAGE_TIMEOUT_IN_SEC);\n+            shutdownFuture.get(timeout, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 618}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDk2Mw==", "bodyText": "these lines do the same thing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r416940963", "createdAt": "2020-04-28T21:40:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -589,13 +634,17 @@ void initLifecycleThread() {\n                             .log(\"Service lifecycle thread interrupted. Thread will exit now\");\n                     return;\n                 } catch (Throwable e) {\n-                    logger.atError(\"service-state-transition-error\", e).log();\n+                    logger.atError(\"service-state-transition-error\").setCause(e).log();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4"}, "originalPosition": 744}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e07375c85dca0fcd65f3432d199de680de390a4", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4e07375c85dca0fcd65f3432d199de680de390a4", "committedDate": "2020-04-28T20:49:21Z", "message": "Add Starting state"}, "afterCommit": {"oid": "94b8051a1139e717722215eb9dd4aba8152b85b5", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/94b8051a1139e717722215eb9dd4aba8152b85b5", "committedDate": "2020-04-28T21:30:07Z", "message": "Add Starting state"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzOTA5MDk0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-403909094", "createdAt": "2020-04-30T22:03:53Z", "commit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjowMzo1M1rOGO77Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMzoxMzowM1rOGO9c4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNTAzMQ==", "bodyText": "Is it ok to discard \"DesiredStateUpdated\"? If yes, why do we even add those to the queue?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418315031", "createdAt": "2020-04-30T22:03:53Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +255,112 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNDM5Mg==", "bodyText": "nit: update the comments", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418324392", "createdAt": "2020-04-30T22:27:12Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -80,53 +89,53 @@\n     // Eg. Start a service will need DesiredStateList to be <RUNNING>\n     // ReInstall a service will set DesiredStateList to <FINISHED->NEW->RUNNING>\n     private final List<State> desiredStateList = new CopyOnWriteArrayList<>();\n-    private static final Set<State> ALLOWED_STATES_FOR_REPORTING =\n-            new HashSet<>(Arrays.asList(State.RUNNING, State.ERRORED, State.FINISHED));\n     private final AtomicBoolean isClosed = new AtomicBoolean(false);\n+\n+    private static final Map<State, Collection<State>> ALLOWED_STATE_TRANSITION_FOR_REPORTING = new HashMap<>();\n     // The number of continual occurrences from a state to ERRORED.\n     // This is not thread safe and should only be used inside reportState().\n     private final Map<State, Integer> stateToErroredCount = new HashMap<>();\n     // We only need to track the ERROR for the state transition starting from NEW, INSTALLED and RUNNING because", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyODc0Mw==", "bodyText": "Not sure if I understand. Is asyncFinishAction used to block until the backing task inhandleXAsync actually finishes? The default value (stateEvent) -> true (in both init ln259 and reset below ln337) is only needed so that the loop exists properly for handleX sync methods?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418328743", "createdAt": "2020-04-30T22:39:02Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +255,112 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();\n+                }\n+\n+                // if there are no events in the queue, block until one is available.\n+                if (stateEvent == null) {\n+                    stateEvent = stateEventQueue.take();\n+                }\n+\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    if (newState == current) {\n+                        continue;\n+                    }\n+\n+                    canFinish = true;\n+                    logger.atInfo(\"service-set-state\").kv(NEW_STATE_METRIC_NAME, newState).log();\n+                    // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged\n+                    // are consistent across different services.\n+                    synchronized (State.class) {\n+                        prevState = current;\n+                        stateTopic.withValue(newState);\n+                        evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                    }\n+                }\n+                if (asyncFinishAction.get().test(stateEvent)) {\n+                    canFinish = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyOTgyNw==", "bodyText": "Update comments about what stateGeneration is intended for?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418329827", "createdAt": "2020-04-30T22:42:16Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -66,12 +74,13 @@\n     @Getter(AccessLevel.PACKAGE)\n     private final AtomicLong stateGeneration = new AtomicLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzNTI3OQ==", "bodyText": "Is it implicit that backingTask won't be changed again after setBackingTask, since handleX is actually executed synchronously? nit but in this case, we don't need atomic reference of backingTask?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418335279", "createdAt": "2020-04-30T22:58:21Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzODUxNw==", "bodyText": "Why stopBackingTask here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418338517", "createdAt": "2020-04-30T23:08:17Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzOTA3MA==", "bodyText": "Why do we have another way to timeout different from install timeout?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418339070", "createdAt": "2020-04-30T23:10:01Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 536}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0MDA2Ng==", "bodyText": "What are the possible current tasks?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418340066", "createdAt": "2020-04-30T23:13:03Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 515}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0Mzg3NzE5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-404387719", "createdAt": "2020-05-01T20:37:03Z", "commit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDozNzowM1rOGPVEFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDozNzowM1rOGPVEFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyNjkzNQ==", "bodyText": "This is the only case that the async action returns false. Why is this the only case?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418726935", "createdAt": "2020-05-01T20:37:03Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {\n             try {\n-                Topics startupTopics = evergreenService.config\n-                        .findTopics(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                                LIFECYCLE_STARTUP_NAMESPACE_TOPIC);\n-                // only schedule task to report error for services with startup stage\n-                // timeout for run stage is handled in generic external service\n-                if (startupTopics != null) {\n-                    Topic timeOutTopic = startupTopics.findLeafChild(TIMEOUT_NAMESPACE_TOPIC);\n-                    // default time out is 120 seconds\n-                    Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n-                            : (Integer) timeOutTopic.getOnce();\n-\n-                    long initialStateGeneration = stateGeneration.get();\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                // If the current state is still INSTALLED, then we failed to install\n-                                // within the timeout and should move to ERRORED\n-                                if (State.INSTALLED.equals(evergreenService.getState())\n-                                        && initialStateGeneration == stateGeneration.get()) {\n-                                    logger.atWarn(\"service-startup-timed-out\").kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n-                }\n-                // TODO: rename to initiateStartup. Service need to report state to RUNNING.\n                 evergreenService.startup();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-run-interrupted\").log(\"Service interrupted while running startup\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-runtime-error\", t).log();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"start\");\n+\n+        asyncFinishAction.set((Object stateEvent) -> {\n+            // if a state is reported\n+            if (stateEvent instanceof State) {\n+                schedule.cancel(true);\n+                return true;\n+            }\n+\n+            // else if desiredState is updated\n+            Optional<State> nextDesiredState = peekOrRemoveFirstDesiredState(State.INSTALLED);\n+            // Don't finish the state handling if the new desiredState is still RUNNING\n+            if (nextDesiredState.isPresent() && nextDesiredState.get().equals(State.RUNNING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 586}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NDA2MTI1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-404406125", "createdAt": "2020-05-01T21:18:11Z", "commit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMToxODoxMVrOGPV_fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMToyNjoyNVrOGPWK2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MjE0MA==", "bodyText": "make this a long instead of Long.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418742140", "createdAt": "2020-05-01T21:18:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -228,96 +255,112 @@ private void enqueueStateEvent(Object event) {\n         }\n     }\n \n-    void startStateTransition() throws InterruptedException {\n-        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+    private void startStateTransition() throws InterruptedException {\n+        AtomicReference<Predicate<Object>> asyncFinishAction = new AtomicReference<>((stateEvent) -> true);\n+        while (!(isClosed.get() && getState().isClosable())) {\n             Optional<State> desiredState;\n-            State current = evergreenService.getState();\n+            State current = getState();\n             logger.atDebug(\"service-state-transition-start\").log();\n \n             // if already in desired state, remove the head of desired state list.\n             desiredState = peekOrRemoveFirstDesiredState(current);\n             while (desiredState.isPresent() && desiredState.get().equals(current)) {\n                 desiredState = peekOrRemoveFirstDesiredState(current);\n             }\n-            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+\n             switch (current) {\n                 case BROKEN:\n-                    if (handleCurrentStateBroken(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateBroken(desiredState);\n+                    break;\n                 case NEW:\n-                    if (handleCurrentStateNew(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateNew(desiredState);\n+                    break;\n                 case INSTALLED:\n-                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateInstalledAsync(desiredState, asyncFinishAction);\n+                    break;\n+                case STARTING:\n+                    handleCurrentStateStartingAsync(desiredState, asyncFinishAction);\n+                    break;\n                 case RUNNING:\n-                    if (handleCurrentStateRunning(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateRunning(desiredState);\n+                    break;\n                 case STOPPING:\n                     handleCurrentStateStopping();\n-                    continue;\n+                    break;\n                 case FINISHED:\n-                    if (handleCurrentStateFinished(desiredState)) {\n-                        break;\n-                    }\n-                    continue;\n+                    handleCurrentStateFinished(desiredState);\n+                    break;\n                 case ERRORED:\n                     handleCurrentStateErrored(desiredState);\n-                    continue;\n+                    break;\n                 default:\n                     logger.atError(INVALID_STATE_ERROR_EVENT).log(\"Unrecognized current state\");\n                     break;\n             }\n \n-            // blocking on event queue.\n-            // The state event can either be a report state transition event or a desired state updated event.\n-            // TODO: check if it's possible to move this blocking logic to the beginning of while loop.\n-            Object stateEvent = stateEventQueue.take();\n-            if (stateEvent instanceof State) {\n-                State toState = (State) stateEvent;\n-                updateStateAndBroadcast(toState);\n-            }\n-            // service transitioning to another state, cancelling task monitoring the timeout for startup\n-            Future triggerTimeOutFuture = triggerTimeOutReference.get();\n-            if (triggerTimeOutFuture != null) {\n-                triggerTimeOutFuture.cancel(true);\n+            boolean canFinish = false;\n+            while (!canFinish) {\n+                // A state event can either be a report state transition event or a desired state updated event.\n+                Object stateEvent = stateEventQueue.poll();\n+\n+                // If there are accumulated \"DesiredStateUpdated\" in the queue,\n+                // drain them until a \"State\" event is encountered.\n+                while (!(stateEvent instanceof State) && !stateEventQueue.isEmpty()) {\n+                    stateEvent = stateEventQueue.poll();\n+                }\n+\n+                // if there are no events in the queue, block until one is available.\n+                if (stateEvent == null) {\n+                    stateEvent = stateEventQueue.take();\n+                }\n+\n+                if (stateEvent instanceof State) {\n+                    State newState = (State) stateEvent;\n+                    if (newState == current) {\n+                        continue;\n+                    }\n+\n+                    canFinish = true;\n+                    logger.atInfo(\"service-set-state\").kv(NEW_STATE_METRIC_NAME, newState).log();\n+                    // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged\n+                    // are consistent across different services.\n+                    synchronized (State.class) {\n+                        prevState = current;\n+                        stateTopic.withValue(newState);\n+                        evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+                    }\n+                }\n+                if (asyncFinishAction.get().test(stateEvent)) {\n+                    canFinish = true;\n+                }\n             }\n+            asyncFinishAction.set((stateEvent) -> true);\n         }\n     }\n \n-    private boolean handleCurrentStateBroken(Optional<State> desiredState) {\n+    private void handleCurrentStateBroken(Optional<State> desiredState) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n         // Having State.NEW as the desired state indicates the service is requested to reinstall, so here\n         // we'll transition out of BROKEN state to give it a new chance.\n         if (State.NEW.equals(desiredState.get())) {\n-            updateStateAndBroadcast(State.NEW);\n+            internalReportState(State.NEW);\n         } else {\n             logger.atError(\"service-broken\").log(\"service is broken. Deployment is needed\");\n-            return true;\n         }\n-        return false;\n     }\n \n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private boolean handleCurrentStateNew(Optional<State> desiredState) throws InterruptedException {\n+    private void handleCurrentStateNew(Optional<State> desiredState) throws InterruptedException {\n         // if no desired state is set, don't do anything.\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        CountDownLatch installLatch = new CountDownLatch(1);\n+        Long currentStateGeneration = stateGeneration.incrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 399}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MzY3Mw==", "bodyText": "Report stopping doesn't seem right. Shouldn't we request a stop here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418743673", "createdAt": "2020-05-01T21:22:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 517}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0NDAzNA==", "bodyText": "Shouldn't this re-check that the dependencies are ready, since this is happening async to when we last know that the dependencies were ready?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418744034", "createdAt": "2020-05-01T21:23:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 538}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0NTA1MA==", "bodyText": "This log should be redundant, right? We already log in internalReportState.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r418745050", "createdAt": "2020-05-01T21:26:25Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {\n             try {\n-                Topics startupTopics = evergreenService.config\n-                        .findTopics(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                                LIFECYCLE_STARTUP_NAMESPACE_TOPIC);\n-                // only schedule task to report error for services with startup stage\n-                // timeout for run stage is handled in generic external service\n-                if (startupTopics != null) {\n-                    Topic timeOutTopic = startupTopics.findLeafChild(TIMEOUT_NAMESPACE_TOPIC);\n-                    // default time out is 120 seconds\n-                    Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n-                            : (Integer) timeOutTopic.getOnce();\n-\n-                    long initialStateGeneration = stateGeneration.get();\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                // If the current state is still INSTALLED, then we failed to install\n-                                // within the timeout and should move to ERRORED\n-                                if (State.INSTALLED.equals(evergreenService.getState())\n-                                        && initialStateGeneration == stateGeneration.get()) {\n-                                    logger.atWarn(\"service-startup-timed-out\").kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n-                }\n-                // TODO: rename to initiateStartup. Service need to report state to RUNNING.\n                 evergreenService.startup();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-run-interrupted\").log(\"Service interrupted while running startup\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-runtime-error\", t).log();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"start\");\n+\n+        asyncFinishAction.set((Object stateEvent) -> {\n+            // if a state is reported\n+            if (stateEvent instanceof State) {\n+                schedule.cancel(true);\n+                return true;\n+            }\n+\n+            // else if desiredState is updated\n+            Optional<State> nextDesiredState = peekOrRemoveFirstDesiredState(State.INSTALLED);\n+            // Don't finish the state handling if the new desiredState is still RUNNING\n+            if (nextDesiredState.isPresent() && nextDesiredState.get().equals(State.RUNNING)) {\n+                return false;\n+            }\n+\n+            schedule.cancel(true);\n+            return true;\n+        });\n     }\n \n-    private boolean handleCurrentStateRunning(Optional<State> desiredState) {\n+\n+    private void handleCurrentStateRunning(Optional<State> desiredState) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n         // desired state is different, let's transition to stopping state first.\n-        updateStateAndBroadcast(State.STOPPING);\n-        return false;\n+        internalReportState(State.STOPPING);\n     }\n \n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n     private void handleCurrentStateStopping() throws InterruptedException {\n         // does not handle desiredState in STOPPING because we must stop first.\n         // does not use setBackingTask because it will cancel the existing task.\n-        CountDownLatch stopping = new CountDownLatch(1);\n         Future<?> shutdownFuture = evergreenService.getContext().get(ExecutorService.class).submit(() -> {\n             try {\n                 evergreenService.shutdown();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-shutdown-interrupted\").log(\"Service interrupted while running shutdown\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-shutdown-error\", t).log();\n-            } finally {\n-                stopping.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         });\n \n-        boolean stopSucceed = stopping.await(15, TimeUnit.SECONDS);\n-\n-        stopBackingTask();\n-        if (State.ERRORED.equals(getReportState().orElse(null)) || !stopSucceed) {\n-            if (!stopSucceed) {\n-                logger.atError(\"service-shutdown-error\").log(\"Service stop timed out\");\n-            }\n-            updateStateAndBroadcast(State.ERRORED);\n-            // If the thread is still running, then kill it\n-            if (!shutdownFuture.isDone()) {\n-                shutdownFuture.cancel(true);\n+        try {\n+            Integer timeout = getTimeoutConfigValue(\n+                        LIFECYCLE_SHUTDOWN_NAMESPACE_TOPIC, DEFAULT_SHUTDOWN_STAGE_TIMEOUT_IN_SEC);\n+            shutdownFuture.get(timeout, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                Optional<State> desiredState = peekOrRemoveFirstDesiredState(State.FINISHED);\n+                serviceTerminatedMoveToDesiredState(desiredState.orElse(State.FINISHED));\n             }\n-        } else {\n-            Optional<State> desiredState = peekOrRemoveFirstDesiredState(State.FINISHED);\n-            serviceTerminatedMoveToDesiredState(desiredState.orElse(State.FINISHED));\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            shutdownFuture.cancel(true);\n+            evergreenService.serviceErrored(\"Timeout shutdown\");\n+        } finally {\n+            stopBackingTask();\n         }\n     }\n \n-    private boolean handleCurrentStateFinished(Optional<State> desiredState) {\n+    private void handleCurrentStateFinished(Optional<State> desiredState) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n         logger.atInfo(\"service-state-transition\").kv(\"desiredState\", desiredState).log();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 666}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/24e6f6e415ae3e6a805fa37904b4ad943bf1a98b", "committedDate": "2020-04-30T21:13:27Z", "message": "Merge branch 'master' into experimentImprovingStateMachine"}, "afterCommit": {"oid": "49ca8da27510405a163eaa0840f4599fd9d05d64", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/49ca8da27510405a163eaa0840f4599fd9d05d64", "committedDate": "2020-05-04T21:13:29Z", "message": "AddressComments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MzA4Mjkw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-405308290", "createdAt": "2020-05-04T20:07:31Z", "commit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDoxMjozNVrOGQQZjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDoxNjowOFrOGQQhOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY5OTA4Nw==", "bodyText": "Do we need to check if this state is RUNNING?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419699087", "createdAt": "2020-05-04T20:12:35Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {\n             try {\n-                Topics startupTopics = evergreenService.config\n-                        .findTopics(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                                LIFECYCLE_STARTUP_NAMESPACE_TOPIC);\n-                // only schedule task to report error for services with startup stage\n-                // timeout for run stage is handled in generic external service\n-                if (startupTopics != null) {\n-                    Topic timeOutTopic = startupTopics.findLeafChild(TIMEOUT_NAMESPACE_TOPIC);\n-                    // default time out is 120 seconds\n-                    Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n-                            : (Integer) timeOutTopic.getOnce();\n-\n-                    long initialStateGeneration = stateGeneration.get();\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                // If the current state is still INSTALLED, then we failed to install\n-                                // within the timeout and should move to ERRORED\n-                                if (State.INSTALLED.equals(evergreenService.getState())\n-                                        && initialStateGeneration == stateGeneration.get()) {\n-                                    logger.atWarn(\"service-startup-timed-out\").kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n-                }\n-                // TODO: rename to initiateStartup. Service need to report state to RUNNING.\n                 evergreenService.startup();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-run-interrupted\").log(\"Service interrupted while running startup\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-runtime-error\", t).log();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"start\");\n+\n+        asyncFinishAction.set((Object stateEvent) -> {\n+            // if a state is reported\n+            if (stateEvent instanceof State) {\n+                schedule.cancel(true);\n+                return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 580}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcwMTA0OA==", "bodyText": "Why do we pass in INSTALLED here? The side effect seems to be removing INSTALLED from desired list if exists. Does this mean if reinstall is called during the starting->running transition, we will drop it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419701048", "createdAt": "2020-05-04T20:16:08Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -326,166 +369,161 @@ private boolean handleCurrentStateNew(Optional<State> desiredState) throws Inter\n             } catch (InterruptedException t) {\n                 logger.atWarn(\"service-install-interrupted\").log(\"Service interrupted while running install\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-install-error\", t).log();\n-            } finally {\n-                installLatch.countDown();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"install\");\n \n-        Topic installTimeOutTopic = evergreenService.config\n-                .find(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC, LIFECYCLE_INSTALL_NAMESPACE_TOPIC,\n-                        TIMEOUT_NAMESPACE_TOPIC);\n-        Integer installTimeOut = installTimeOutTopic == null ? DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC\n-                : (Integer) installTimeOutTopic.getOnce();\n-        boolean ok = installLatch.await(installTimeOut, TimeUnit.SECONDS);\n-        State reportState = getReportState().orElse(null);\n-        if (State.ERRORED.equals(reportState) || !ok) {\n-            updateStateAndBroadcast(State.ERRORED);\n-        } else if (State.BROKEN.equals(reportState)) {\n-            updateStateAndBroadcast(State.BROKEN);\n-        } else {\n-            updateStateAndBroadcast(State.INSTALLED);\n+        Integer installTimeOut = getTimeoutConfigValue(\n+                LIFECYCLE_INSTALL_NAMESPACE_TOPIC, DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC);\n+\n+        try {\n+            backingTask.get().get(installTimeOut, TimeUnit.SECONDS);\n+            if (!State.ERRORED.equals(lastReportedState.get())) {\n+                internalReportState(State.INSTALLED);\n+            }\n+        } catch (ExecutionException ee) {\n+            evergreenService.serviceErrored(ee);\n+        } catch (TimeoutException te) {\n+            evergreenService.serviceErrored(\"Timeout in install\");\n+        } finally {\n+            stopBackingTask();\n         }\n-        return false;\n     }\n \n-    private boolean handleCurrentStateInstalled(Optional<State> desiredState,\n-                                                AtomicReference<Future> triggerTimeOutReference) {\n+\n+    private void handleCurrentStateInstalledAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n         if (!desiredState.isPresent()) {\n-            return true;\n+            return;\n         }\n \n-        switch (desiredState.get()) {\n-            // For new or finished, make sure to stop first because we may be\n-            // currently transitioning from installed to running\n-            case NEW:\n-            case FINISHED:\n-                updateStateAndBroadcast(State.STOPPING);\n-                return false;\n-            case RUNNING:\n-                // If we are already handling the installed to running transition, then don't do anything\n-                if (!INSTALLED_TO_RUNNING.equals(currentStateTransition)) {\n-                    stopBackingTask();\n-                    currentStateTransition = INSTALLED_TO_RUNNING;\n-                    handleStateTransitionInstalledToRunning(triggerTimeOutReference);\n-                }\n-                break;\n-            default:\n-                // not allowed for STOPPING, ERRORED, BROKEN\n-                logger.atError(INVALID_STATE_ERROR_EVENT).kv(\"desiredState\", desiredState)\n-                        .log(\"Unexpected desired state\");\n-                break;\n+        if (!desiredState.get().equals(State.RUNNING)) {\n+            serviceTerminatedMoveToDesiredState(desiredState.get());\n+            return;\n         }\n-        return true;\n-    }\n \n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    private void handleStateTransitionInstalledToRunning(AtomicReference<Future> triggerTimeOutReference) {\n         setBackingTask(() -> {\n             try {\n                 logger.atInfo(\"service-awaiting-start\").log(\"waiting for dependencies to start\");\n                 evergreenService.waitForDependencyReady();\n                 logger.atInfo(\"service-starting\").log();\n+                internalReportState(State.STARTING);\n             } catch (InterruptedException e) {\n                 logger.atWarn(\"service-dependency-error\").log(\"Got interrupted while waiting for dependency ready\");\n-                return;\n             }\n+        }, \"waiting for dependency ready\");\n \n-            if (!State.INSTALLED.equals(evergreenService.getState())) {\n-                // Bail out if we're not in the expected state after waiting for dependencies\n-                return;\n-            }\n+        asyncFinishAction.set((stateEvent) -> {\n+            stopBackingTask();\n+            return true;\n+        });\n+    }\n+\n+    private void handleCurrentStateStartingAsync(Optional<State> desiredState,\n+                                                  AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        if (!desiredState.isPresent()) {\n+            return;\n+        }\n+        Future currentTask = backingTask.get();\n+        if (currentTask != null && !currentTask.isDone()) {\n+            internalReportState(State.STOPPING);\n+            return;\n+        }\n+\n+        if (desiredState.get().equals(State.RUNNING)) {\n+            handleStateTransitionStartingToRunningAsync(asyncFinishAction);\n+        } else {\n+            internalReportState(State.STOPPING);\n+        }\n+    }\n+\n+    @SuppressWarnings({\"PMD.AvoidCatchingThrowable\", \"PMD.AvoidGettingFutureWithoutTimeout\"})\n+    private void handleStateTransitionStartingToRunningAsync(AtomicReference<Predicate<Object>> asyncFinishAction) {\n+        stateGeneration.incrementAndGet();\n+        Integer timeout = getTimeoutConfigValue(\n+                LIFECYCLE_STARTUP_NAMESPACE_TOPIC, DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC);\n+        Future<?> schedule =\n+            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n+                evergreenService.serviceErrored(\"startup timeout\");\n+            }, timeout, TimeUnit.SECONDS);\n+\n+        setBackingTask(() -> {\n             try {\n-                Topics startupTopics = evergreenService.config\n-                        .findTopics(EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC,\n-                                LIFECYCLE_STARTUP_NAMESPACE_TOPIC);\n-                // only schedule task to report error for services with startup stage\n-                // timeout for run stage is handled in generic external service\n-                if (startupTopics != null) {\n-                    Topic timeOutTopic = startupTopics.findLeafChild(TIMEOUT_NAMESPACE_TOPIC);\n-                    // default time out is 120 seconds\n-                    Integer timeout = timeOutTopic == null ? DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC\n-                            : (Integer) timeOutTopic.getOnce();\n-\n-                    long initialStateGeneration = stateGeneration.get();\n-                    Future<?> schedule =\n-                            evergreenService.getContext().get(ScheduledExecutorService.class).schedule(() -> {\n-                                // If the current state is still INSTALLED, then we failed to install\n-                                // within the timeout and should move to ERRORED\n-                                if (State.INSTALLED.equals(evergreenService.getState())\n-                                        && initialStateGeneration == stateGeneration.get()) {\n-                                    logger.atWarn(\"service-startup-timed-out\").kv(TIMEOUT_NAMESPACE_TOPIC, timeout)\n-                                            .log(\"Service failed to startup within timeout\");\n-                                    reportState(State.ERRORED);\n-                                }\n-                            }, timeout, TimeUnit.SECONDS);\n-                    triggerTimeOutReference.set(schedule);\n-                }\n-                // TODO: rename to initiateStartup. Service need to report state to RUNNING.\n                 evergreenService.startup();\n             } catch (InterruptedException i) {\n                 logger.atWarn(\"service-run-interrupted\").log(\"Service interrupted while running startup\");\n             } catch (Throwable t) {\n-                reportState(State.ERRORED);\n-                logger.atError(\"service-runtime-error\", t).log();\n+                evergreenService.serviceErrored(t);\n             }\n         }, \"start\");\n+\n+        asyncFinishAction.set((Object stateEvent) -> {\n+            // if a state is reported\n+            if (stateEvent instanceof State) {\n+                schedule.cancel(true);\n+                return true;\n+            }\n+\n+            // else if desiredState is updated\n+            Optional<State> nextDesiredState = peekOrRemoveFirstDesiredState(State.INSTALLED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24e6f6e415ae3e6a805fa37904b4ad943bf1a98b"}, "originalPosition": 584}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "49ca8da27510405a163eaa0840f4599fd9d05d64", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/49ca8da27510405a163eaa0840f4599fd9d05d64", "committedDate": "2020-05-04T21:13:29Z", "message": "AddressComments"}, "afterCommit": {"oid": "d29330f245d6e62b33d2c0758cabd50a83a805a7", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d29330f245d6e62b33d2c0758cabd50a83a805a7", "committedDate": "2020-05-04T21:20:36Z", "message": "AddressComments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MzYzMTE3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-405363117", "createdAt": "2020-05-04T21:31:44Z", "commit": {"oid": "d29330f245d6e62b33d2c0758cabd50a83a805a7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTozMTo0NFrOGQS_Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTozMTo1OFrOGQS_vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MTUyNg==", "bodyText": "Add some comments about when to use lastReportedState, prevState and stateEventQueue?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419741526", "createdAt": "2020-05-04T21:31:44Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -66,67 +74,68 @@\n     @Getter(AccessLevel.PACKAGE)\n     private final AtomicLong stateGeneration = new AtomicLong();\n     private final EvergreenService evergreenService;\n+    private final AtomicReference<State> lastReportedState = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d29330f245d6e62b33d2c0758cabd50a83a805a7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc0MTYyOQ==", "bodyText": "Add comments?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#discussion_r419741629", "createdAt": "2020-05-04T21:31:58Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/dependency/State.java", "diffHunk": "@@ -25,6 +25,7 @@\n      */\n     INSTALLED(true, false, false),\n \n+    STARTING(true, false, false),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d29330f245d6e62b33d2c0758cabd50a83a805a7"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c29da1e7afb3e45b915383bd08d8f0c06ba3ca77", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c29da1e7afb3e45b915383bd08d8f0c06ba3ca77", "committedDate": "2020-05-04T23:26:11Z", "message": "Consolidate break/continue in lifecycle whileLoop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "172b8ee8dafd3adbc2511cca2f8ecd8ccc564aa9", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/172b8ee8dafd3adbc2511cca2f8ecd8ccc564aa9", "committedDate": "2020-05-04T23:26:13Z", "message": "AddressComments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10295e1c460ccb0583fd6f5d15ab2ab1795d71c5", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/10295e1c460ccb0583fd6f5d15ab2ab1795d71c5", "committedDate": "2020-05-04T23:26:13Z", "message": "Add Starting state"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d29330f245d6e62b33d2c0758cabd50a83a805a7", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d29330f245d6e62b33d2c0758cabd50a83a805a7", "committedDate": "2020-05-04T21:20:36Z", "message": "AddressComments"}, "afterCommit": {"oid": "594451043077c64d3708687d1d3f0c7c5c1d670b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/594451043077c64d3708687d1d3f0c7c5c1d670b", "committedDate": "2020-05-04T23:57:23Z", "message": "AddressComments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "594451043077c64d3708687d1d3f0c7c5c1d670b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/594451043077c64d3708687d1d3f0c7c5c1d670b", "committedDate": "2020-05-04T23:57:23Z", "message": "AddressComments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0934c19c3e3d1ac49847ffe3fec981e956082bd3", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0934c19c3e3d1ac49847ffe3fec981e956082bd3", "committedDate": "2020-05-05T00:35:20Z", "message": "Fix IotJobsHelper for empty job execution"}, "afterCommit": {"oid": "594451043077c64d3708687d1d3f0c7c5c1d670b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/594451043077c64d3708687d1d3f0c7c5c1d670b", "committedDate": "2020-05-04T23:57:23Z", "message": "AddressComments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDQ3MjMx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-405447231", "createdAt": "2020-05-05T01:20:33Z", "commit": {"oid": "594451043077c64d3708687d1d3f0c7c5c1d670b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1OTU3OTU2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/189#pullrequestreview-405957956", "createdAt": "2020-05-05T16:31:05Z", "commit": {"oid": "594451043077c64d3708687d1d3f0c7c5c1d670b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2130, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}