{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4Njg4ODMy", "number": 502, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzozNDo0NFrOEq2XJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzowOTozNVrOEuF8Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzY2MzA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzozNDo0NFrOHdSr3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxODo1NDo0MFrOHdVp8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Njg5NA==", "bodyText": "this blocks the publish queue, doesn't it need to be unblocked to actually process the deployment?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500476894", "createdAt": "2020-10-06T17:34:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -79,41 +79,50 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n         // wait until topic listeners finished processing mergeMap changes.\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+            try {\n+                kernel.getContext().get(ExecutorService.class).submit(() -> {\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        // Restart any services that may have been broken before this deployment\n+                        // This is added to allow deployments to fix broken services\n+                        servicesChangeManager.reinstallBrokenServices();\n+                    } catch (ServiceLoadException e) {\n+                        handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture, e);\n                     }\n-                }\n-            });\n+                }).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3NzgyNw==", "bodyText": "Also, it blocks and can't be unblocked by cancellation which doesn't seem right", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500477827", "createdAt": "2020-10-06T17:36:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -79,41 +79,50 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n         // wait until topic listeners finished processing mergeMap changes.\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+            try {\n+                kernel.getContext().get(ExecutorService.class).submit(() -> {\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        // Restart any services that may have been broken before this deployment\n+                        // This is added to allow deployments to fix broken services\n+                        servicesChangeManager.reinstallBrokenServices();\n+                    } catch (ServiceLoadException e) {\n+                        handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture, e);\n                     }\n-                }\n-            });\n+                }).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Njg5NA=="}, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4NDM4Nw==", "bodyText": "This is only requesting starts/reinstalls for services which should be quick and the individual lifecycle threads can run their state changes on the publish queue right after. And that will be monitored by the wait logic below. I don't see why it would block in a way that deployment cannot be processed?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500484387", "createdAt": "2020-10-06T17:47:39Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -79,41 +79,50 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n         // wait until topic listeners finished processing mergeMap changes.\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+            try {\n+                kernel.getContext().get(ExecutorService.class).submit(() -> {\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        // Restart any services that may have been broken before this deployment\n+                        // This is added to allow deployments to fix broken services\n+                        servicesChangeManager.reinstallBrokenServices();\n+                    } catch (ServiceLoadException e) {\n+                        handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture, e);\n                     }\n-                }\n-            });\n+                }).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Njg5NA=="}, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4NTA0Mg==", "bodyText": "Or you mean for failure cases it will stop services from making any changes before trying to handle the failure first ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500485042", "createdAt": "2020-10-06T17:48:43Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -79,41 +79,50 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n         // wait until topic listeners finished processing mergeMap changes.\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+            try {\n+                kernel.getContext().get(ExecutorService.class).submit(() -> {\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        // Restart any services that may have been broken before this deployment\n+                        // This is added to allow deployments to fix broken services\n+                        servicesChangeManager.reinstallBrokenServices();\n+                    } catch (ServiceLoadException e) {\n+                        handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture, e);\n                     }\n-                }\n-            });\n+                }).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Njg5NA=="}, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4NjUzOA==", "bodyText": "If you're only starting and reinstalling, does it need to be in a separate thread at all? Those aren't blocking methods AFAIK.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500486538", "createdAt": "2020-10-06T17:51:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -79,41 +79,50 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n         // wait until topic listeners finished processing mergeMap changes.\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+            try {\n+                kernel.getContext().get(ExecutorService.class).submit(() -> {\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        // Restart any services that may have been broken before this deployment\n+                        // This is added to allow deployments to fix broken services\n+                        servicesChangeManager.reinstallBrokenServices();\n+                    } catch (ServiceLoadException e) {\n+                        handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture, e);\n                     }\n-                }\n-            });\n+                }).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Njg5NA=="}, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4OTk4MQ==", "bodyText": "Maybe not, it was just there since everything including waiting was combined and waiting had to happen without blocking the queue. let me see if it can be changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500489981", "createdAt": "2020-10-06T17:56:40Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -79,41 +79,50 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n         // wait until topic listeners finished processing mergeMap changes.\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+            try {\n+                kernel.getContext().get(ExecutorService.class).submit(() -> {\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        // Restart any services that may have been broken before this deployment\n+                        // This is added to allow deployments to fix broken services\n+                        servicesChangeManager.reinstallBrokenServices();\n+                    } catch (ServiceLoadException e) {\n+                        handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture, e);\n                     }\n-                }\n-            });\n+                }).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Njg5NA=="}, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MTUxNQ==", "bodyText": "If you don't want to block the queue, then you shouldn't be calling .get(), since that's blocking it anyway", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500491515", "createdAt": "2020-10-06T17:59:08Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -79,41 +79,50 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n         // wait until topic listeners finished processing mergeMap changes.\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+            try {\n+                kernel.getContext().get(ExecutorService.class).submit(() -> {\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        // Restart any services that may have been broken before this deployment\n+                        // This is added to allow deployments to fix broken services\n+                        servicesChangeManager.reinstallBrokenServices();\n+                    } catch (ServiceLoadException e) {\n+                        handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture, e);\n                     }\n-                }\n-            });\n+                }).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Njg5NA=="}, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMzE1NQ==", "bodyText": "I'm blocking until service starts/reinstalls have been requested so that the desired state is set for all services before the waiting logic starts monitoring if services reached those desired states or not", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500523155", "createdAt": "2020-10-06T18:50:22Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -79,41 +79,50 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n         // wait until topic listeners finished processing mergeMap changes.\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+            try {\n+                kernel.getContext().get(ExecutorService.class).submit(() -> {\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        // Restart any services that may have been broken before this deployment\n+                        // This is added to allow deployments to fix broken services\n+                        servicesChangeManager.reinstallBrokenServices();\n+                    } catch (ServiceLoadException e) {\n+                        handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture, e);\n                     }\n-                }\n-            });\n+                }).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Njg5NA=="}, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNTU1NA==", "bodyText": "So, since the queue is blocked anyway, you may as well just run those requests in the queue thread", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500525554", "createdAt": "2020-10-06T18:54:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -79,41 +79,50 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n         // wait until topic listeners finished processing mergeMap changes.\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+            try {\n+                kernel.getContext().get(ExecutorService.class).submit(() -> {\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        // Restart any services that may have been broken before this deployment\n+                        // This is added to allow deployments to fix broken services\n+                        servicesChangeManager.reinstallBrokenServices();\n+                    } catch (ServiceLoadException e) {\n+                        handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture, e);\n                     }\n-                }\n-            });\n+                }).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Njg5NA=="}, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzczMjA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/lifecyclemanager/UpdateSystemSafelyService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzo1MzozNlrOHdTXYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzo1MzozNlrOHdTXYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4ODAzNQ==", "bodyText": "why change this? How is it any different from before?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r500488035", "createdAt": "2020-10-06T17:53:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/lifecyclemanager/UpdateSystemSafelyService.java", "diffHunk": "@@ -159,12 +155,17 @@ protected void startup() throws InterruptedException {\n                 try {\n                     context.get(ExecutorService.class).submit(() -> {\n                         logger.atInfo().setEventType(\"service-update-start\").log();\n+                        runningUpdateActions.set(true);\n+\n                         runUpdateActions();\n+                        pendingActions.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0316163a2bcd2e369fb1c87907c6b038dff16227"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTM0MjEzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMzoxODoxNVrOHeIyLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMzoxODoxNVrOHeIyLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM2MzI0Nw==", "bodyText": "Nice! this simplifies the threading model a lot", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r501363247", "createdAt": "2020-10-07T23:18:15Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -128,35 +140,47 @@ void rollback(DeploymentDocument deploymentDocument, CompletableFuture<Deploymen\n             return;\n         }\n         // wait until topic listeners finished processing read changes.\n+        AtomicBoolean setDesiredStatesFailed = new AtomicBoolean();\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                // TODO: Add timeout\n-                try {\n-                    rollbackManager.startNewServices();\n-                    rollbackManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrackForRollback = rollbackManager.servicesToTrack();\n-\n-                    waitForServicesToStart(servicesToTrackForRollback, mergeTime);\n-\n-                    rollbackManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services rolled back\");\n-\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n-                } catch (InterruptedException | ServiceUpdateException | ExecutionException\n-                        | ServiceLoadException e) {\n-                    // Rollback execution failed\n-                    logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n-                            .log(\"Failed to rollback deployment\");\n-                    // TODO : Run user provided script to reach user defined safe state and\n-                    //  set deployment status based on the success of the script run\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n-                }\n-            });\n+            try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e80d1afe49a03c392a973a5c573c3e853101e3e"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTExNjQ5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMTowNDowNVrOHg-kag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNTo1OToyOFrOHhaM2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MTYxMA==", "bodyText": "Are services stopped before the updated config is applied?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504341610", "createdAt": "2020-10-14T01:04:05Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -77,43 +78,56 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n                 kernel.getConfig().updateMap(deploymentDocument.getTimestamp(), newConfig, DEPLOYMENT_MERGE_BEHAVIOR));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NDMzMQ==", "bodyText": "No, the listeners triggered by updateMap handle the stop and restart as part of the service lifecycle threads. For any services that become obsolete after the update, there's a remove step at the end of the workflow", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504794331", "createdAt": "2020-10-14T15:59:28Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -77,43 +78,56 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n                 kernel.getConfig().updateMap(deploymentDocument.getTimestamp(), newConfig, DEPLOYMENT_MERGE_BEHAVIOR));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MTYxMA=="}, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTEyMjA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMTowNjo1N1rOHg-ngg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNTo1OTo0N1rOHhaNuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MjQwMg==", "bodyText": "Isn't the presence of a Throwable evidence that setDesiredStatesFailed? Why have both?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504342402", "createdAt": "2020-10-14T01:06:57Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -77,43 +78,56 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n                 kernel.getConfig().updateMap(deploymentDocument.getTimestamp(), newConfig, DEPLOYMENT_MERGE_BEHAVIOR));\n \n         // wait until topic listeners finished processing mergeMap changes.\n+        kernel.getContext().runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicBoolean setDesiredStatesFailed = new AtomicBoolean();\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NDU1NQ==", "bodyText": "Right, removed it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504794555", "createdAt": "2020-10-14T15:59:47Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -77,43 +78,56 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n                 kernel.getConfig().updateMap(deploymentDocument.getTimestamp(), newConfig, DEPLOYMENT_MERGE_BEHAVIOR));\n \n         // wait until topic listeners finished processing mergeMap changes.\n+        kernel.getContext().runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicBoolean setDesiredStatesFailed = new AtomicBoolean();\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MjQwMg=="}, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTEyNzc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMToxMDoxMVrOHg-qrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjowMjo1OVrOHhaWUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MzIxMg==", "bodyText": "There was a add timeout comment above... is that still relevant?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504343212", "createdAt": "2020-10-14T01:10:11Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -77,43 +78,56 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n                 kernel.getConfig().updateMap(deploymentDocument.getTimestamp(), newConfig, DEPLOYMENT_MERGE_BEHAVIOR));\n \n         // wait until topic listeners finished processing mergeMap changes.\n+        kernel.getContext().runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicBoolean setDesiredStatesFailed = new AtomicBoolean();\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n-                    }\n-                }\n-            });\n+            try {\n+                servicesChangeManager.startNewServices();\n+                // Restart any services that may have been broken before this deployment\n+                // This is added to allow deployments to fix broken services\n+                servicesChangeManager.reinstallBrokenServices();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Njc1Mw==", "bodyText": "That was a really old comment that became irrelevant because deployment workflow really can't have a timeout since it can wait for an unknown time for a safe time to update, there are other guardrails like individual service lifecycle step timeouts and cancellation that ensure deployment doesn't turn the device into a brick", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504796753", "createdAt": "2020-10-14T16:02:59Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -77,43 +78,56 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n                 kernel.getConfig().updateMap(deploymentDocument.getTimestamp(), newConfig, DEPLOYMENT_MERGE_BEHAVIOR));\n \n         // wait until topic listeners finished processing mergeMap changes.\n+        kernel.getContext().runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicBoolean setDesiredStatesFailed = new AtomicBoolean();\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n-                    }\n-                }\n-            });\n+            try {\n+                servicesChangeManager.startNewServices();\n+                // Restart any services that may have been broken before this deployment\n+                // This is added to allow deployments to fix broken services\n+                servicesChangeManager.reinstallBrokenServices();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MzIxMg=="}, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTEyOTI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMToxMDo0OVrOHg-rdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjowMDowMlrOHhaOjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MzQxNA==", "bodyText": "Should these be logged?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504343414", "createdAt": "2020-10-14T01:10:49Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -128,35 +142,47 @@ void rollback(DeploymentDocument deploymentDocument, CompletableFuture<Deploymen\n             return;\n         }\n         // wait until topic listeners finished processing read changes.\n+        AtomicBoolean setDesiredStatesFailed = new AtomicBoolean();\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                // TODO: Add timeout\n-                try {\n-                    rollbackManager.startNewServices();\n-                    rollbackManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrackForRollback = rollbackManager.servicesToTrack();\n-\n-                    waitForServicesToStart(servicesToTrackForRollback, mergeTime);\n-\n-                    rollbackManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services rolled back\");\n-\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n-                } catch (InterruptedException | ServiceUpdateException | ExecutionException\n-                        | ServiceLoadException e) {\n-                    // Rollback execution failed\n-                    logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n-                            .log(\"Failed to rollback deployment\");\n-                    // TODO : Run user provided script to reach user defined safe state and\n-                    //  set deployment status based on the success of the script run\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n-                }\n-            });\n+            try {\n+                rollbackManager.startNewServices();\n+                rollbackManager.reinstallBrokenServices();\n+            } catch (ServiceLoadException e) {\n+                setDesiredStatesFailed.set(true);\n+                setDesiredStateFailureCause.set(e);\n+            }\n         });\n+        // Do not block the publish queue to handle failure in setting desired states for services\n+        if (setDesiredStatesFailed.get()) {\n+            handleFailureRollback(totallyCompleteFuture, failureCause, setDesiredStateFailureCause.get());\n+        }\n+\n+        try {\n+            Set<GreengrassService> servicesToTrackForRollback = rollbackManager.servicesToTrack();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5NDc2Ng==", "bodyText": "Added a debug log similar to the rollforward action", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504794766", "createdAt": "2020-10-14T16:00:02Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -128,35 +142,47 @@ void rollback(DeploymentDocument deploymentDocument, CompletableFuture<Deploymen\n             return;\n         }\n         // wait until topic listeners finished processing read changes.\n+        AtomicBoolean setDesiredStatesFailed = new AtomicBoolean();\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                // TODO: Add timeout\n-                try {\n-                    rollbackManager.startNewServices();\n-                    rollbackManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrackForRollback = rollbackManager.servicesToTrack();\n-\n-                    waitForServicesToStart(servicesToTrackForRollback, mergeTime);\n-\n-                    rollbackManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services rolled back\");\n-\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n-                } catch (InterruptedException | ServiceUpdateException | ExecutionException\n-                        | ServiceLoadException e) {\n-                    // Rollback execution failed\n-                    logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n-                            .log(\"Failed to rollback deployment\");\n-                    // TODO : Run user provided script to reach user defined safe state and\n-                    //  set deployment status based on the success of the script run\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n-                }\n-            });\n+            try {\n+                rollbackManager.startNewServices();\n+                rollbackManager.reinstallBrokenServices();\n+            } catch (ServiceLoadException e) {\n+                setDesiredStatesFailed.set(true);\n+                setDesiredStateFailureCause.set(e);\n+            }\n         });\n+        // Do not block the publish queue to handle failure in setting desired states for services\n+        if (setDesiredStatesFailed.get()) {\n+            handleFailureRollback(totallyCompleteFuture, failureCause, setDesiredStateFailureCause.get());\n+        }\n+\n+        try {\n+            Set<GreengrassService> servicesToTrackForRollback = rollbackManager.servicesToTrack();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0MzQxNA=="}, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1OTEzMzQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/lifecyclemanager/UpdateSystemSafelyService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMToxMzoyMFrOHg-t2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjowNToyNlrOHhacwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0NDAyNA==", "bodyText": "This log does not seem relevant anymore.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504344024", "createdAt": "2020-10-14T01:13:20Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/lifecyclemanager/UpdateSystemSafelyService.java", "diffHunk": "@@ -156,16 +155,10 @@ protected void startup() throws InterruptedException {\n             } else {\n                 lifecycleIPCAgent.discardDeferComponentUpdateFutures();\n                 logger.atDebug().setEventType(\"service-update-scheduled\").log();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5ODQwMg==", "bodyText": "I had to revet the changes to this class because it was failing in cases when deployment causes kernel restart and kernel shutdown has to stop this service, but since this startup thread would be running the deployment action it would fail to close gracefully", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r504798402", "createdAt": "2020-10-14T16:05:26Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/lifecyclemanager/UpdateSystemSafelyService.java", "diffHunk": "@@ -156,16 +155,10 @@ protected void startup() throws InterruptedException {\n             } else {\n                 lifecycleIPCAgent.discardDeferComponentUpdateFutures();\n                 logger.atDebug().setEventType(\"service-update-scheduled\").log();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM0NDAyNA=="}, "originalCommit": {"oid": "d81768f0e46854468f0a36105120ee1131a2998a"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDExNTEyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMjozNzoxNFrOHhupOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMjozNzoxNFrOHhupOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTEyOTI3Mg==", "bodyText": "don't you need to wait for the lambda to run? This will always be null because it hasn't executed yet, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r505129272", "createdAt": "2020-10-15T02:37:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -77,43 +77,54 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n                 kernel.getConfig().updateMap(deploymentDocument.getTimestamp(), newConfig, DEPLOYMENT_MERGE_BEHAVIOR));\n \n         // wait until topic listeners finished processing mergeMap changes.\n+        kernel.getContext().runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n-                    }\n-                }\n-            });\n+            try {\n+                servicesChangeManager.startNewServices();\n+                // Restart any services that may have been broken before this deployment\n+                // This is added to allow deployments to fix broken services\n+                servicesChangeManager.reinstallBrokenServices();\n+            } catch (ServiceLoadException e) {\n+                setDesiredStateFailureCause.set(e);\n+            }\n         });\n+        // Do not block the publish queue to handle failure in setting desired states for services\n+        if (setDesiredStateFailureCause.get() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f10aa4872cfb3d1e37ba5128933e2b59421f3d2b"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDExNjc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMjozODowM1rOHhuqGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMjozODowM1rOHhuqGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTEyOTQ5OQ==", "bodyText": "use run and wait which returns you the exception (if any)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r505129499", "createdAt": "2020-10-15T02:38:03Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -77,43 +77,54 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n                 kernel.getConfig().updateMap(deploymentDocument.getTimestamp(), newConfig, DEPLOYMENT_MERGE_BEHAVIOR));\n \n         // wait until topic listeners finished processing mergeMap changes.\n+        kernel.getContext().runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();\n         kernel.getContext().runOnPublishQueue(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f10aa4872cfb3d1e37ba5128933e2b59421f3d2b"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDExOTI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMjozOToxM1rOHhurcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMjozOToxM1rOHhurcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTEyOTg0MA==", "bodyText": "same here. This will always be null because you aren't waiting for the error to maybe happen.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r505129840", "createdAt": "2020-10-15T02:39:13Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -128,35 +139,49 @@ void rollback(DeploymentDocument deploymentDocument, CompletableFuture<Deploymen\n             return;\n         }\n         // wait until topic listeners finished processing read changes.\n+        kernel.getContext().runOnPublishQueueAndWait(() -> {});\n+\n+        AtomicReference<Throwable> setDesiredStateFailureCause = new AtomicReference<>();\n         kernel.getContext().runOnPublishQueue(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                // TODO: Add timeout\n-                try {\n-                    rollbackManager.startNewServices();\n-                    rollbackManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrackForRollback = rollbackManager.servicesToTrack();\n-\n-                    waitForServicesToStart(servicesToTrackForRollback, mergeTime);\n-\n-                    rollbackManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services rolled back\");\n-\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n-                } catch (InterruptedException | ServiceUpdateException | ExecutionException\n-                        | ServiceLoadException e) {\n-                    // Rollback execution failed\n-                    logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n-                            .log(\"Failed to rollback deployment\");\n-                    // TODO : Run user provided script to reach user defined safe state and\n-                    //  set deployment status based on the success of the script run\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n-                }\n-            });\n+            try {\n+                rollbackManager.startNewServices();\n+                rollbackManager.reinstallBrokenServices();\n+            } catch (ServiceLoadException e) {\n+                setDesiredStateFailureCause.set(e);\n+            }\n         });\n+        // Do not block the publish queue to handle failure in setting desired states for services\n+        if (setDesiredStateFailureCause.get() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f10aa4872cfb3d1e37ba5128933e2b59421f3d2b"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzU4NjM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNjo0ODowM1rOHiQ9nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNjo0ODowM1rOHiQ9nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5MTU1MQ==", "bodyText": "after handling failure, shouldn't we quit?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r505691551", "createdAt": "2020-10-15T16:48:03Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -77,43 +76,46 @@ public void activate(Map<String, Object> newConfig, Deployment deployment,\n                 kernel.getConfig().updateMap(deploymentDocument.getTimestamp(), newConfig, DEPLOYMENT_MERGE_BEHAVIOR));\n \n         // wait until topic listeners finished processing mergeMap changes.\n-        kernel.getContext().runOnPublishQueue(() -> {\n+        Throwable setDesiredStateFailureCause = kernel.getContext().runOnPublishQueueAndWait(() -> {\n             // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                //TODO: Add timeout\n-                try {\n-                    servicesChangeManager.startNewServices();\n-\n-                    // Restart any services that may have been broken before this deployment\n-                    // This is added to allow deployments to fix broken services\n-                    servicesChangeManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrack = servicesChangeManager.servicesToTrack();\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"Applied new service config. Waiting for services to complete update\");\n-\n-                    waitForServicesToStart(servicesToTrack, mergeTime);\n-                    logger.atDebug(MERGE_CONFIG_EVENT_KEY).log(\"new/updated services are running, will now remove\"\n-                            + \" old services\");\n-                    servicesChangeManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services updated\");\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.SUCCESSFUL, null));\n-                } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n-                        | ExecutionException e) {\n-                    logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n-                            .log(\"Deployment failed\");\n-                    if (isAutoRollbackRequested(deploymentDocument)) {\n-                        rollback(deploymentDocument, totallyCompleteFuture, e,\n-                                servicesChangeManager.createRollbackManager());\n-                    } else {\n-                        totallyCompleteFuture.complete(new DeploymentResult(\n-                                DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n-                    }\n-                }\n-            });\n+            servicesChangeManager.startNewServices();\n+            // Restart any services that may have been broken before this deployment\n+            // This is added to allow deployments to fix broken services\n+            servicesChangeManager.reinstallBrokenServices();\n         });\n+        if (setDesiredStateFailureCause != null) {\n+            handleFailure(servicesChangeManager, deploymentDocument, totallyCompleteFuture,\n+                    setDesiredStateFailureCause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "920704f30aede09201ffa970b0d986e8c63870d3"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzU4OTc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNjo0ODo1NFrOHiQ_ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNjo0ODo1NFrOHiQ_ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5MjA2Nw==", "bodyText": "likewise", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r505692067", "createdAt": "2020-10-15T16:48:54Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -128,35 +130,40 @@ void rollback(DeploymentDocument deploymentDocument, CompletableFuture<Deploymen\n             return;\n         }\n         // wait until topic listeners finished processing read changes.\n-        kernel.getContext().runOnPublishQueue(() -> {\n-            // polling to wait for all services to be started.\n-            kernel.getContext().get(ExecutorService.class).execute(() -> {\n-                // TODO: Add timeout\n-                try {\n-                    rollbackManager.startNewServices();\n-                    rollbackManager.reinstallBrokenServices();\n-\n-                    Set<GreengrassService> servicesToTrackForRollback = rollbackManager.servicesToTrack();\n-\n-                    waitForServicesToStart(servicesToTrackForRollback, mergeTime);\n-\n-                    rollbackManager.removeObsoleteServices();\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                            .log(\"All services rolled back\");\n-\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n-                } catch (InterruptedException | ServiceUpdateException | ExecutionException\n-                        | ServiceLoadException e) {\n-                    // Rollback execution failed\n-                    logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n-                            .log(\"Failed to rollback deployment\");\n-                    // TODO : Run user provided script to reach user defined safe state and\n-                    //  set deployment status based on the success of the script run\n-                    totallyCompleteFuture.complete(new DeploymentResult(\n-                            DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n-                }\n-            });\n+        Throwable setDesiredStateFailureCause = kernel.getContext().runOnPublishQueueAndWait(() -> {\n+                rollbackManager.startNewServices();\n+                rollbackManager.reinstallBrokenServices();\n         });\n+        if (setDesiredStateFailureCause != null) {\n+            handleFailureRollback(totallyCompleteFuture, failureCause, setDesiredStateFailureCause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "920704f30aede09201ffa970b0d986e8c63870d3"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NzY3MjM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzowOTozNVrOHiRzMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyMjo0OFrOHiSRpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNTI2Ng==", "bodyText": "instead of suppressing it would be better to fix it, or mark the variable as final which also resolves it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r505705266", "createdAt": "2020-10-15T17:09:35Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -43,6 +42,7 @@ public DefaultActivator(Kernel kernel, DynamicComponentConfigurationValidator va\n     }\n \n     @Override\n+    @SuppressWarnings(\"PMD.PrematureDeclaration\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "272a5df8cf88b8b44bfa98d90e142c8b69c19f58"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMzA2MQ==", "bodyText": "I fixed one for deploymentId, the other is for mergTime at line 69 which has to be initialized at the time it is because we need to record it before changing config but we reference it much later in the wait phase. Making it final isn't helping", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/502#discussion_r505713061", "createdAt": "2020-10-15T17:22:48Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/greengrass/deployment/activator/DefaultActivator.java", "diffHunk": "@@ -43,6 +42,7 @@ public DefaultActivator(Kernel kernel, DynamicComponentConfigurationValidator va\n     }\n \n     @Override\n+    @SuppressWarnings(\"PMD.PrematureDeclaration\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNTI2Ng=="}, "originalCommit": {"oid": "272a5df8cf88b8b44bfa98d90e142c8b69c19f58"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 606, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}